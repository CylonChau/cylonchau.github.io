<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>memcached从入门到精通 | Cylon&#39;s Collection</title>
<meta name="keywords" content="memcache, memcache概论">
<meta name="description" content="memcached从入门到精通 - Cylon&#39;s Collection">
<meta name="author" content="cylon">
<link rel="canonical" href="https://www.oomkill.com/2016/09/memcached/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.41a8706089174fae1769fc26da4d1d354fa88083db604a95688ff58852dd9006.css" integrity="sha256-QahwYIkXT64Xafwm2k0dNU&#43;ogIPbYEqVaI/1iFLdkAY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.oomkill.com/favicon.ico">
<link rel="apple-touch-icon" href="https://www.oomkill.com/apple-touch-icon.png">

<meta name="twitter:title" content="memcached从入门到精通 | Cylon&#39;s Collection" />
<meta name="twitter:description" content="" />
<meta property="og:title" content="memcached从入门到精通 | Cylon&#39;s Collection" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.oomkill.com/2016/09/memcached/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2016-09-28T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2024-05-28T21:27:14&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.oomkill.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "memcached从入门到精通",
      "item": "https://www.oomkill.com/2016/09/memcached/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "memcached从入门到精通 | Cylon's Collection",
  "name": "memcached从入门到精通",
  "description": "",
  "keywords": [
    "memcache", "memcache概论"
  ],
  "wordCount" : "13621",
  "inLanguage": "zh",
  "datePublished": "2016-09-28T00:00:00Z",
  "dateModified": "2024-05-28T21:27:14+08:00",
  "author":{
    "@type": "Person",
    "name": "cylon"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.oomkill.com/2016/09/memcached/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cylon's Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.oomkill.com/favicon.ico"
    }
  }
}
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.oomkill.com" accesskey="h" title="Cylon&#39;s Collection (Alt + H)">Cylon&#39;s Collection</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.oomkill.com/archives/" title="归档"
                >归档
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/tags/" title="标签"
                >标签
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/search/" title="搜索 (Alt &#43; /)"data-no-instant accesskey=/
                >搜索
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/about/" title="关于"
                >关于
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header"><h1 class="post-title">memcached从入门到精通</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2016-09-28</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>Edited on 2024-05-28</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://www.oomkill.com/tags/databases/">databases</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>28 分钟</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-memcached%e4%bb%8b%e7%bb%8d%e5%8f%8a%e5%b8%b8%e8%a7%81%e5%90%8c%e7%b1%bb%e8%bd%af%e4%bb%b6%e5%af%b9%e6%af%94" aria-label="1 Memcached介绍及常见同类软件对比">1 Memcached介绍及常见同类软件对比</a><ul>
                        
                <li>
                    <a href="#11-memcached%e6%98%af%e4%bb%80%e4%b9%88" aria-label="1.1 Memcached是什么？">1.1 Memcached是什么？</a></li>
                <li>
                    <a href="#12-memcached%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="1.2 Memcached的作用">1.2 Memcached的作用</a></li>
                <li>
                    <a href="#13-%e4%ba%92%e8%81%94%e7%bd%91%e5%b8%b8%e8%a7%81%e5%86%85%e5%ad%98%e6%9c%8d%e5%8a%a1%e8%bd%af%e4%bb%b6" aria-label="1.3 互联网常见内存服务软件">1.3 互联网常见内存服务软件</a></li></ul>
                </li>
                <li>
                    <a href="#2-memcached%e5%b8%b8%e8%a7%81%e7%94%a8%e9%80%94%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="2 Memcached常见用途工作流程">2 Memcached常见用途工作流程</a><ul>
                        
                <li>
                    <a href="#21-%e7%bd%91%e7%ab%99%e8%af%bb%e5%8f%96memcached%e6%95%b0%e6%8d%ae%e6%97%b6%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="2.1 网站读取Memcached数据时的工作流程">2.1 网站读取Memcached数据时的工作流程</a></li>
                <li>
                    <a href="#22-%e7%bd%91%e7%ab%99%e6%9b%b4%e6%96%b0memcached%e6%95%b0%e6%8d%ae%e6%97%b6%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="2.2 网站更新Memcached数据时工作流程">2.2 网站更新Memcached数据时工作流程</a></li></ul>
                </li>
                <li>
                    <a href="#3-memcached%e5%9c%a8%e4%bc%81%e4%b8%9a%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="3 Memcached在企业中的应用场景">3 Memcached在企业中的应用场景</a><ul>
                        
                <li>
                    <a href="#31-%e4%bd%9c%e4%b8%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae%e7%bc%93%e5%ad%98" aria-label="3.1 作为数据库查询数据缓存">3.1 作为数据库查询数据缓存</a><ul>
                        
                <li>
                    <a href="#311-%e5%ae%8c%e6%95%b4%e6%95%b0%e6%8d%ae%e7%bc%93%e5%ad%98" aria-label="3.1.1 完整数据缓存">3.1.1 完整数据缓存</a></li>
                <li>
                    <a href="#312-%e7%83%ad%e7%82%b9%e6%95%b0%e6%8d%ae%e7%bc%93%e5%ad%98" aria-label="3.1.2 热点数据缓存">3.1.2 热点数据缓存</a></li></ul>
                </li>
                <li>
                    <a href="#32-%e4%bd%9c%e4%b8%ba%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e7%9a%84session%e4%bc%9a%e8%af%9d%e5%ad%98%e5%82%a8" aria-label="3.2 作为集群节点的session会话存储">3.2 作为集群节点的session会话存储</a></li>
                <li>
                    <a href="#33-memcached%e6%9c%8d%e5%8a%a1%e5%9c%a8%e4%bc%81%e4%b8%9a%e9%9b%86%e7%be%a4%e6%9e%b6%e6%9e%84%e4%b8%ad%e7%9a%84%e4%bd%8d%e7%bd%ae" aria-label="3.3 Memcached服务在企业集群架构中的位置">3.3 Memcached服务在企业集群架构中的位置</a></li>
                <li>
                    <a href="#34-%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9%e6%95%88%e5%ba%94" aria-label="3.4 缓存雪崩效应">3.4 缓存雪崩效应</a></li></ul>
                </li>
                <li>
                    <a href="#4-memcached%e7%9a%84%e7%89%b9%e7%82%b9%e4%b8%8e%e5%b7%a5%e4%bd%9c%e6%9c%ba%e5%88%b6" aria-label="4 Memcached的特点与工作机制">4 Memcached的特点与工作机制</a><ul>
                        
                <li>
                    <a href="#41-memcache%e7%9a%84%e7%89%b9%e5%be%81" aria-label="4.1 Memcache的特征">4.1 Memcache的特征</a><ul>
                        
                <li>
                    <a href="#411-%e5%8d%8f%e8%ae%ae%e7%ae%80%e5%8d%95" aria-label="4.1.1 协议简单">4.1.1 协议简单</a></li>
                <li>
                    <a href="#412-%e6%94%af%e6%8c%81epollkqueue%e5%bc%82%e6%ad%a5io%e6%a8%a1%e5%9e%8b%e4%bd%bf%e7%94%a8libevent%e4%bd%9c%e4%b8%ba%e4%ba%8b%e4%bb%b6%e5%a4%84%e7%90%86%e9%80%9a%e7%9f%a5%e6%9c%ba%e5%88%b6" aria-label="4.1.2 支持epoll/kqueue异步I/O模型，使用libevent作为事件处理通知机制。">4.1.2 支持epoll/kqueue异步I/O模型，使用libevent作为事件处理通知机制。</a></li>
                <li>
                    <a href="#413-keyvalue%e9%94%ae%e5%80%bc%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="4.1.3 key/value键值数据类型">4.1.3 key/value键值数据类型</a></li>
                <li>
                    <a href="#414-%e5%85%a8%e5%86%85%e5%ad%98%e7%bc%93%e5%ad%98%e6%95%88%e7%8e%87%e9%ab%98" aria-label="4.1.4 全内存缓存，效率高">4.1.4 全内存缓存，效率高</a></li>
                <li>
                    <a href="#415-%e5%8f%af%e6%94%af%e6%8c%81%e5%88%86%e5%b8%83%e5%bc%8f%e9%9b%86%e7%be%a4" aria-label="4.1.5 可支持分布式集群">4.1.5 可支持分布式集群</a></li></ul>
                </li>
                <li>
                    <a href="#42-memcached%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e4%b8%8e%e6%9c%ba%e5%88%b6" aria-label="4.2 Memcached工作原理与机制">4.2 Memcached工作原理与机制</a><ul>
                        
                <li>
                    <a href="#421-memcached%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="4.2.1 Memcached工作原理">4.2.1 Memcached工作原理</a></li>
                <li>
                    <a href="#422-socket%e6%97%b6%e9%97%b4%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6" aria-label="4.2.2 Socket时间处理机制">4.2.2 Socket时间处理机制</a></li>
                <li>
                    <a href="#423-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e6%9c%ba%e5%88%b6" aria-label="4.2.3 数据存储机制">4.2.3 数据存储机制</a></li>
                <li>
                    <a href="#424-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6" aria-label="4.2.4 内存管理机制">4.2.4 内存管理机制</a></li>
                <li>
                    <a href="#425-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86%e6%9c%ba%e5%88%b6" aria-label="4.2.5 多线程处理机制">4.2.5 多线程处理机制</a></li></ul>
                </li>
                <li>
                    <a href="#43-memcached%e9%a2%84%e7%83%ad%e7%90%86%e5%bf%b5%e5%8f%8a%e9%9b%86%e7%be%a4%e8%8a%82%e7%82%b9%e7%9a%84%e6%ad%a3%e7%a1%ae%e9%87%8d%e5%90%af%e6%96%b9%e6%b3%95" aria-label="4.3 Memcached预热理念及集群节点的正确重启方法">4.3 Memcached预热理念及集群节点的正确重启方法</a><ul>
                        
                <li>
                    <a href="#431-memcached%e9%a2%84%e7%83%ad%e7%90%86%e5%bf%b5" aria-label="4.3.1 Memcached预热理念">4.3.1 Memcached预热理念</a></li>
                <li>
                    <a href="#432-%e5%a6%82%e4%bd%95%e6%ad%a3%e7%a1%ae%e5%bc%80%e5%90%af%e7%bd%91%e7%ab%99%e9%9b%86%e7%be%a4%e6%9c%8d%e5%8a%a1%e5%99%a8" aria-label="4.3.2 如何正确开启网站集群服务器">4.3.2 如何正确开启网站集群服务器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#5-memcached%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="5 Memcached内存管理">5 Memcached内存管理</a><ul>
                        
                <li>
                    <a href="#51-memcached%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6%e6%b7%b1%e5%85%a5%e5%89%96%e6%9e%90" aria-label="5.1 Memcached内存管理机制深入剖析">5.1 Memcached内存管理机制深入剖析</a><ul>
                        
                <li>
                    <a href="#511-malloc%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6" aria-label="5.1.1 Malloc内存管理机制">5.1.1 Malloc内存管理机制</a></li>
                <li>
                    <a href="#512-slab%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6" aria-label="5.1.2 Slab内存管理机制">5.1.2 Slab内存管理机制</a></li></ul>
                </li>
                <li>
                    <a href="#52-memcached-slab-allocator%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e6%9c%ba%e5%88%b6%e7%9a%84%e7%bc%ba%e7%82%b9" aria-label="5.2 Memcached Slab Allocator内存管理机制的缺点">5.2 Memcached Slab Allocator内存管理机制的缺点</a></li>
                <li>
                    <a href="#53-memcached%e7%9a%84%e6%a3%80%e6%b5%8b%e8%bf%87%e6%9c%9f%e4%b8%8e%e5%88%a0%e9%99%a4%e6%9c%ba%e5%88%b6" aria-label="5.3 Memcached的检测过期与删除机制">5.3 Memcached的检测过期与删除机制</a><ul>
                        
                <li>
                    <a href="#531-memcached%e6%87%92%e6%83%b0%e6%a3%80%e6%b5%8b%e5%af%b9%e8%b1%a1%e7%9a%84%e8%bf%87%e6%9c%9f%e6%9c%ba%e5%88%b6" aria-label="5.3.1 Memcached懒惰检测对象的过期机制">5.3.1 Memcached懒惰检测对象的过期机制</a></li>
                <li>
                    <a href="#532-memcached%e6%83%b0%e6%80%a7%e5%88%a0%e9%99%a4%e5%af%b9%e8%b1%a1%e6%9c%ba%e5%88%b6" aria-label="5.3.2 Memcached惰性删除对象机制">5.3.2 Memcached惰性删除对象机制</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#6-memcache%e6%9c%8d%e5%8a%a1%e5%ae%89%e8%a3%85" aria-label="6 Memcache服务安装">6 Memcache服务安装</a><ul>
                        
                <li>
                    <a href="#61-memcached-%e5%ae%89%e8%a3%85" aria-label="6.1 Memcached 安装">6.1 Memcached 安装</a><ul>
                        
                <li>
                    <a href="#611-%e5%ae%89%e8%a3%85libevent%e5%8f%8a%e8%bf%9e%e6%8e%a5memcached%e5%b7%a5%e5%85%b7nc" aria-label="6.1.1 安装libevent及连接Memcached工具nc">6.1.1 安装libevent及连接Memcached工具nc</a></li>
                <li>
                    <a href="#612-%e7%bc%96%e8%af%91%e5%ae%89%e8%a3%85memcached" aria-label="6.1.2 编译安装Memcached">6.1.2 编译安装Memcached</a></li></ul>
                </li>
                <li>
                    <a href="#62-%e5%ae%89%e8%a3%85memcached%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="6.2 安装Memcached客户端">6.2 安装Memcached客户端</a></li>
                <li>
                    <a href="#621-php%e6%89%a9%e5%b1%95%e6%8f%92%e4%bb%b6memcache%e4%b8%8ememcached" aria-label="6.2.1 PHP扩展插件Memcache与Memcached">6.2.1 PHP扩展插件Memcache与Memcached</a></li>
                <li>
                    <a href="#622-php-memcache%e6%89%a9%e5%b1%95%e5%ae%89%e8%a3%85" aria-label="6.2.2 PHP Memcache扩展安装">6.2.2 PHP Memcache扩展安装</a><ul>
                        
                <li>
                    <a href="#622-%e9%83%a8%e7%bd%b2memcached" aria-label="6.2.2 部署memcached">6.2.2 部署memcached</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#7-memcached%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ae%a1%e7%90%86" aria-label="7 Memcached服务的基本管理">7 Memcached服务的基本管理</a><ul>
                        
                <li>
                    <a href="#71-%e5%90%af%e5%8a%a8memcached" aria-label="7.1 启动Memcached">7.1 启动Memcached</a></li>
                <li>
                    <a href="#72-memcached%e5%90%af%e5%8a%a8%e7%9b%b8%e5%85%b3%e5%8f%82%e6%95%b0%e8%af%b4%e6%98%8e" aria-label="7.2 Memcached启动相关参数说明">7.2 Memcached启动相关参数说明</a></li>
                <li>
                    <a href="#73-%e5%90%91memcached%e4%b8%ad%e5%86%99%e5%85%a5%e6%95%b0%e6%8d%ae%e5%b9%b6%e6%a3%80%e6%9f%a5" aria-label="7.3 向Memcached中写入数据。并检查">7.3 向Memcached中写入数据。并检查</a><ul>
                        
                <li>
                    <a href="#731-memcached%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e5%bd%a2%e5%bc%8f%e5%8f%8a%e4%b8%8emysql%e7%9b%b8%e5%85%b3%e8%af%ad%e5%8f%a5%e5%af%b9%e6%af%94" aria-label="7.3.1 Memcached中的数据形式及与MySQL相关语句对比">7.3.1 Memcached中的数据形式及与MySQL相关语句对比</a></li>
                <li>
                    <a href="#732-%e5%90%91memcached%e4%b8%ad%e5%86%99%e5%85%a5%e6%95%b0%e6%8d%ae%e5%ae%9e%e8%b7%b5" aria-label="7.3.2 向Memcached中写入数据实践">7.3.2 向Memcached中写入数据实践</a></li>
                <li>
                    <a href="#733-%e6%93%8d%e4%bd%9cmemcached%e7%9b%b8%e5%85%b3%e5%91%bd%e4%bb%a4%e7%9a%84%e8%af%ad%e6%b3%95" aria-label="7.3.3 操作Memcached相关命令的语法">7.3.3 操作Memcached相关命令的语法</a></li>
                <li>
                    <a href="#734-%e5%85%b3%e9%97%admemcached" aria-label="7.3.4 关闭Memcached">7.3.4 关闭Memcached</a></li>
                <li>
                    <a href="#735-%e4%bc%81%e4%b8%9a%e5%b7%a5%e4%bd%9c%e5%9c%ba%e6%99%af%e4%b8%ad%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%aememcached" aria-label="7.3.5 企业工作场景中如何配置Memcached">7.3.5 企业工作场景中如何配置Memcached</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content">
    





<div class="copyrightTopBlock">
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <div class="articleSuffix-bg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
</div>
<br><h2 id="1-memcached介绍及常见同类软件对比">1 Memcached介绍及常见同类软件对比<a hidden class="anchor" aria-hidden="true" href="#1-memcached介绍及常见同类软件对比">¶</a></h2>
<h3 id="11-memcached是什么">1.1 Memcached是什么？<a hidden class="anchor" aria-hidden="true" href="#11-memcached是什么">¶</a></h3>
<p>Memcached是一个开源的、支持高性能、高并发的分布式缓存系统，由C语言编写，总共2000多行代码。从软件名称上看，前3个字符的单词Mem就是内存的意思，接下来的后面5个字符的单词Cache就是缓存的意思，最后一个字符d是daemon的意思，代表是服务端守护进程模式服务。</p>
<p>Memcached服务分为服务端和客户端两部分，其中，<font style="background:#ffc104;" size=2>服务端</font>软件的名字形如 <code>Memcached-1.4.24.tat.gz</code>，<font style="background:#ffc104;" size=2>客户端</font>软件的名字形如 <code>Memcache-2.25.tar.gz</code></p>
<p>Memcached软件诞生于2003年，最初由LiveJournal的BradFitzpatrick开发完成。Memcached是整个项目的名称，而Memcached是服务器端的主程序名，因其协议简单，使用部署方便、且支持高并发而被互联网企业广泛使用，知道现在仍然被广泛应用。官方网址：http://memcached.org</p>
<h3 id="12-memcached的作用">1.2 Memcached的作用<a hidden class="anchor" aria-hidden="true" href="#12-memcached的作用">¶</a></h3>
<p>传统场景，多数Web应用都将数据保存到关系型数据库中（例如MySQL），Web服务器从中读取数据并在浏览器中显示。但随着数据量的增大、访问的集中，关系型数据库的负担就会加重、响应缓慢、导致网站打开延迟等问题，影响用户体验。</p>
<p>这时就需要Memcached软件出马了。使用Memcached的主要目的是，通过在自身内存中缓存关系型数据库的查询结果，减少数据库自身被访问的次数，以提高动态web应用的速度、提高网站架构的并发能力和可扩展性。</p>
<p>Memcached服务的运行原理是通过在实现规划好的系统内存空间中临时缓存数据库的各类数据，以达到减少前端业务服务对数据库的直接高并发访问，从而达到提升大规模网站急群众动态服务的并发访问能力。</p>
<p>生产场景的Memcached服务一般被用来保存网站中经常被读取的对象或数据，就像我们的客户端浏览器也会把经常访问的网页缓存起来一样，通过内存缓存来存取对象或数据要比磁盘存取快很多，因为磁盘是机械的，因此，在当今的IT企业中，Memcached的应用范围很广泛</p>
<h3 id="13-互联网常见内存服务软件">1.3 互联网常见内存服务软件<a hidden class="anchor" aria-hidden="true" href="#13-互联网常见内存服务软件">¶</a></h3>
<p>下表为互联网企业场景常见内存缓存服务软件相关对比信息：</p>
<table>
<thead>
<tr>
<th>软件</th>
<th>类型</th>
<th>主要作用</th>
<th>缓存的数据</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memcached</td>
<td>纯内存型</td>
<td>常用于缓存网站后端的各类数据，例如数据库中的数据</td>
<td>主要缓存用户重复请求的动态内容，</br>blog的博文</br>BBS的帖子等内容</br>用户的Session会话信息</td>
</tr>
<tr>
<td>Redis/Mongodb/memcachedb</td>
<td>可持久化存储，即使用内存也会使用磁盘存储</td>
<td>1. 缓存后端数据库的查询数据<br>2.作为关系数据库的重要补充</td>
<td>1.作为缓存：主要缓存用户重复请求的动态内容：例如BLOG的博文、BBS的帖子等内容。</br>2.作为数据库的有效补充：例如：好友关注、粉丝统计、业务统计等功能可以用持久化存储。</td>
</tr>
<tr>
<td>Squid/Nginx</td>
<td>内存或内存加磁盘缓存</td>
<td>主要用于缓存web前端的服务内容</td>
<td>主要用于静态数据缓存，例如：图片，附件（压缩包），js,css,html等，</br>此部分功能大多数企业会选择专业的CDN公司如：蓝讯、网宿。</td>
</tr>
</tbody>
</table>
<h2 id="2-memcached常见用途工作流程">2 Memcached常见用途工作流程<a hidden class="anchor" aria-hidden="true" href="#2-memcached常见用途工作流程">¶</a></h2>
<p>Memcached是一种内存缓存软件，在工作中经常用来缓存数据库的查询数据，数据被缓存在事先预分配的Memcached管理的内存中，可以通过API或命令的方式存取内存中缓存的这些数据，Memcached服务内存中缓存的数据就像一张巨大的HASH表，每条数据都是以key-value对的形式存在。</p>
<h3 id="21-网站读取memcached数据时的工作流程">2.1 网站读取Memcached数据时的工作流程<a hidden class="anchor" aria-hidden="true" href="#21-网站读取memcached数据时的工作流程">¶</a></h3>
<p>Memcached用来缓存查询到的数据库中的数据，逻辑上，当程序访问后端数据库获取数据时会先优先访问Memcached缓存，如果缓存中有数据就直接返回给客户端用户，如果没有数据（没有命中）程序再去读取后端的数据库的数据，读取到需要的数据后，把数据返回给客户端，同时还会把读取到的数据库缓存到Memcached内存中，这样客户端用户再请求相同数据就会直接读取Memcached缓存的数据，这样就大大减轻了后端数据库的压力，并提高了整个网站的响应速断，提升了用户体验。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025002621702.png" alt="image-20221025002621702" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图2-1展示了Memcached缓存系统和后端数据库系统的协作流程</center>
<blockquote>
<p><strong>上图，使用Memcached缓存查询数据来减少数据库压力的具体工作流程如下</strong>：</p>
</blockquote>
<ol>
<li>
<p>web程序首先检查客户端请求的数据是否在Memcached缓存中存在，如果存在，直接把请求的数据返回给客户端，此时不在请求后端数据库。</p>
</li>
<li>
<p>如果请求的数据在Memcached缓存中不存在，则程序会请求数据库服务，把数据库中取到的数据返回给客户端，此时不再请求后端数据库。</p>
</li>
</ol>
<h3 id="22-网站更新memcached数据时工作流程">2.2 网站更新Memcached数据时工作流程<a hidden class="anchor" aria-hidden="true" href="#22-网站更新memcached数据时工作流程">¶</a></h3>
<ol>
<li>当程序更新或者删除数据时，会首先处理后端数据库中的数据。</li>
<li>程序处理后端数据库中的数据的同时，也会通知Memcached中的对应旧数据失效，从而保证Memcached中缓存的数据始终和数据库中的户数一直，这个数据一致性非常重要，也是大型网站分布式缓存集群的最头痛的问题所在。</li>
<li>如果是在高并发读写场合，除了要程序通知Memcached过期的缓存失效外，还可能会通过相关机制，例如在数据库上部署相关程序（例如：在数据库中设置触发器使用UDFs），实现当数据库有更新就会把数据更新到Memcached服务中，使得客户端在访问新数据前，预先把更新过的数据库数据复制到Memcached中缓存起来，这样可以减少第一次查询数据库带来的访问压力，提升Memcached中缓存的命中率，甚至sina门户还会把持久化存储redis做成MySQL数据库的从库，实现真正的主从复制。</li>
</ol>
<center>Memcached网站作为缓存应用更新数据流程图见下图1-2</center>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024234831970.png" alt="image-20221024234831970" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>Memcached服务作为缓存应用通过相关软件更新数据见图2-2</center>
<h2 id="3-memcached在企业中的应用场景">3 Memcached在企业中的应用场景<a hidden class="anchor" aria-hidden="true" href="#3-memcached在企业中的应用场景">¶</a></h2>
<h3 id="31-作为数据库查询数据缓存">3.1 作为数据库查询数据缓存<a hidden class="anchor" aria-hidden="true" href="#31-作为数据库查询数据缓存">¶</a></h3>
<h4 id="311-完整数据缓存">3.1.1 完整数据缓存<a hidden class="anchor" aria-hidden="true" href="#311-完整数据缓存">¶</a></h4>
<p>例如电商的商品分类功能不会经常变动，就可以实现放到Memcached里，然后再对外提供数据访问。这个过程被称之为“数据预热”。</p>
<p>此时秩序读取缓存无需读取数据库就能读到Memcached缓存里的所有商品分类数据了，所以数据库的访问压力就会大大降低了。</p>
<blockquote>
<p><strong>为什么商品分类数据可以实现放在缓存里呢？</strong></p>
</blockquote>
<p>因为，商品分类几乎都是由内部人员管理的，如果需要更新数据，更新数据库后，就可以把数据同时更新到Memcached里。</p>
<p>如果把商品分类数据做成静态化文件，然后通过在前段WEB缓存或者使用CDN加速效果更好。</p>
<h4 id="312-热点数据缓存">3.1.2 热点数据缓存<a hidden class="anchor" aria-hidden="true" href="#312-热点数据缓存">¶</a></h4>
<p>热点数据缓存一般是用于由用户更新的商品，例如淘宝的卖家，当卖家新增商品后，网站程序就会把商品写入后端数据库，同时把这部分数据，放入Memcached内存中，下一次访问这个商品的请求就直接从Memcached内存中取走了。这种方法用来缓存网站热点的数据，即利用Memcached缓存经常被访问的数据。</p>
<p>特别提示：这个过程可以通过程序实现，也可以在数据库上安装软件进行设置，直接由数据库把内容更新到Memcached中，相当于Memcached是MySQL的丛库一样。</p>
<blockquote>
<p><strong>淘宝、京东、小米等电商双11秒杀抢购场景</strong>：</p>
</blockquote>
<p>如果碰到电商双11秒杀高并发的业务场景，必须要实现预热各种缓存，包括前端的web缓存和后端的数据缓存。</p>
<p>先把数据放入内存预热，然后在逐步动态更新。先读取缓存，如果缓存里没有对应的数据，再去读取数据库，然后把读到的数据放入缓存。如果数据库里的数据更细，需要同时触发缓存更细，防止给用户过期的数据，当然对于百万级别并发还有很多其它的工作要做。</p>
<hr>
<p><strong><font color="#0215cd" size=2> <font color="#f8070d" size=2>⚠</font> 提示：这个过程可以通过程序实现，也可以在数据库上安装相关软件进行设置，直接由数据库把内容更新到Memcached中，就相当于Memcached是MySQL的从库一样</font></strong></p>
<hr>
<p>如果碰到双十一、秒杀高并发的业务场景，必须要事先预热各种缓存，包括前段的Web缓存和后端的数据缓存。</p>
<p>也就是说事先把数据放入内存预热，然后逐步动态更新。此时，会先读取缓存，如果缓存里没有对应的数据，再去读取数据库，然后把读到的数据放入缓存。如果数据库里的数据更新，需要同时触发缓存更新，防止给用户过期的数据，当然对于百万级别并发还有很多其他的工作要做。</p>
<p>绝大多数的网站动态数据都是保存在数据库当中的，每次频繁地存取数据库，会导致数据库性能急剧下降，无法同时服务更多的用户（比如MySQL特别频繁的表锁就会存在此问题），那么，就可以让Memcached来分担数据库的压力。增加Memcached服务的好处除了可以分担数据库的压力以外，还包括无须改动整个网站架构，只需简单修改下程序逻辑，让程序先读取Memcached缓存查询数据即可。更新数据时也要更新Memcached缓存。</p>
<blockquote>
<p><strong>【分布式应用1】</strong></p>
</blockquote>
<p>Memcached支持分布式，我们在应用服务程序上改造，就可以更好的支持。例如：可以根据key适当进行有规律的封装，比如以用户位置的网站来说，每个用户都有UID。那么可以按照固定的ID来进行提取和存取，比如1开头的用户保存在第一台Memcached服务器上，以2开头的用户的数据保存在第二天Memcached服务器上，存取数据都先按照UID来进行的转换和存取。</p>
<blockquote>
<p><strong>【分布式应用2】</strong></p>
</blockquote>
<p>在应用服务器上通过程序及URL_HASH，抑制性哈希算法区访问Memcache服务，所有Memcached服务器的地址池可以简单的配在程序的配置文件里。</p>
<blockquote>
<p><strong>【分布式应用3】</strong></p>
</blockquote>
<p>门户网站如百度，会通过一个中间件代理负责请求后端的Cache服务。</p>
<blockquote>
<p><strong>【分布式应用4】</strong></p>
</blockquote>
<p>可以用常见的LVS haproxy做Cache的负载均衡，和普通应用服务相比，这里的重点是轮训算法，一般会选择url_hash，及consistent hash算法。</p>
<p>算法重要性图解</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024234919688.png" alt="image-20221024234919688" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="32-作为集群节点的session会话存储">3.2 作为集群节点的session会话存储<a hidden class="anchor" aria-hidden="true" href="#32-作为集群节点的session会话存储">¶</a></h3>
<p>即把客户端用户请求多个前端应用服务集群产生的session会话信息，统一存储到一个Memcached缓存中。由于session会话数据是存储在内存中的，所以速度很快。</p>
<p>图3-2为Memcached服务在企业集群架构中常见的工作位置。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024234934265.png" alt="image-20221024234934265" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="33-memcached服务在企业集群架构中的位置">3.3 Memcached服务在企业集群架构中的位置<a hidden class="anchor" aria-hidden="true" href="#33-memcached服务在企业集群架构中的位置">¶</a></h3>
<p>下图为Memcached服务在企业集群架构中常见的工作位置。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235014658.png" alt="image-20221024235014658" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="34-缓存雪崩效应">3.4 缓存雪崩效应<a hidden class="anchor" aria-hidden="true" href="#34-缓存雪崩效应">¶</a></h3>
<p>一般是由于某个节点生效，导致其他节点的缓存命中率下降，缓存中缺失的数据去数据可查询。短时间内造成数据库服务器崩溃。或，由于缓存周期性的输小，如：6小时失效一次，那么每6小时，将有一个请求&quot;峰值&quot;，严重情况下会导致数据库宕机。</p>
<h2 id="4-memcached的特点与工作机制">4 Memcached的特点与工作机制<a hidden class="anchor" aria-hidden="true" href="#4-memcached的特点与工作机制">¶</a></h2>
<h3 id="41-memcache的特征">4.1 Memcache的特征<a hidden class="anchor" aria-hidden="true" href="#41-memcache的特征">¶</a></h3>
<p>Memcached作为高并发、高性能的缓存服务，具有如下特征：</p>
<h4 id="411-协议简单">4.1.1 协议简单<a hidden class="anchor" aria-hidden="true" href="#411-协议简单">¶</a></h4>
<p>Memcached的协议实现简单，采用基于文本行的协议，能通过telnet/nc等命令直接操作Memcached服务读取数据。</p>
<h4 id="412-支持epollkqueue异步io模型使用libevent作为事件处理通知机制">4.1.2 支持epoll/kqueue异步I/O模型，使用libevent作为事件处理通知机制。<a hidden class="anchor" aria-hidden="true" href="#412-支持epollkqueue异步io模型使用libevent作为事件处理通知机制">¶</a></h4>
<p>简单的说libevent是一套利用C开发的程序库，他将BSD系统的kqueue，Linux系统的epoll等事件处理功能封装成一个接口，确保即使服务器端的连接数量增加也能发挥很好的性能。Memcached就是利用这个libevent库进行异步事件处理。</p>
<h4 id="413-keyvalue键值数据类型">4.1.3 key/value键值数据类型<a hidden class="anchor" aria-hidden="true" href="#413-keyvalue键值数据类型">¶</a></h4>
<p>被缓存的数据以key/value键形式存在的，例如：</p>
<pre><code>zhangsan=&gt;23 key=zhangsan value=23
通过zhangsan key可以获取到23
</code></pre>
<h4 id="414-全内存缓存效率高">4.1.4 全内存缓存，效率高<a hidden class="anchor" aria-hidden="true" href="#414-全内存缓存效率高">¶</a></h4>
<p>Memcached管理内存的方式非常搞笑，即全部的数据都存放于Memcached服务实现分配好的内存中，无持久化存储的设计，和系统的物理内存一样，当重启系统或Memcached服务时，Memcached内存中的数据即会丢失。</p>
<p>如果希望重启后，数据依然能保存，那么就可以采用redis这样的持久性内存缓存系统的缓存数据。也可以在存放数据时，对存储的数据设置过期时间，这样过期后数据就自动被清除，Memcached服务本身不会监控数据过期，而是在访问的时候查看key的时间戳判断是否过期。</p>
<h4 id="415-可支持分布式集群">4.1.5 可支持分布式集群<a hidden class="anchor" aria-hidden="true" href="#415-可支持分布式集群">¶</a></h4>
<p>Memcached没有像MySQL那样的主从复制方式，分布式Memcached集群的不同服务器之间是互不通讯的，每一个节点都独立存取数据，并且数据内容也不一样。通过对Web应用端的程序设计或者通过支持hash算法的负载均衡软件，可以让Memcached支持大规模海量分布式缓存集群应用。</p>
<h3 id="42-memcached工作原理与机制">4.2 Memcached工作原理与机制<a hidden class="anchor" aria-hidden="true" href="#42-memcached工作原理与机制">¶</a></h3>
<h4 id="421-memcached工作原理">4.2.1 Memcached工作原理<a hidden class="anchor" aria-hidden="true" href="#421-memcached工作原理">¶</a></h4>
<p>Memcached是一套类似C/S模式的架构软件，在服务器端启动Memcached服务守护进程，可以指定监听本地的IP地址、端口号、并发访问连接数，以及分配了多少内存来处理客户端请求。</p>
<h4 id="422-socket时间处理机制">4.2.2 Socket时间处理机制<a hidden class="anchor" aria-hidden="true" href="#422-socket时间处理机制">¶</a></h4>
<p>Memcached软件是由C语言来实现的，全部代码仅有2000多行，采用的是异步epoll/kqueue非阻塞I/O网络模型，其实现方式是基于异步的libevent时间单进程、单线程模式。使用libevent作为事件通知机制，应用程序端通过指定服务器的IP地址及端口，就可以连接Memcached服务进程通讯。</p>
<h4 id="423-数据存储机制">4.2.3 数据存储机制<a hidden class="anchor" aria-hidden="true" href="#423-数据存储机制">¶</a></h4>
<p>需要被缓存的数据以key/value键值对的形式保存在服务器端预分配的内存区中，每个被缓存的数据都有唯一的标识key，操作Memcached中的数据就是通过这个唯一标识的key进行的。缓存到Memcached中的数据仅放置在Memcached服务预分配的内存中，而非存储在Memcached服务器所在的磁盘上，因此存取速度非常快。</p>
<p>由于Memcached服务自身没有对缓存的数据进行持久化存储的设计，因此，在服务端的Memcached服务进程重启之后，存储在内存中的这些数据都会丢失。且当内存中缓存的数据容量达到启动时设定的内存值时，也会自动使用LRU算法删除过期的数据。</p>
<p>开发Memcached的初衷仅是通过内存缓存提示访问效率，并没有过多考虑数据的永久存储问题。因此，如果使用Memcached作为缓存数据服务，要考虑数据丢失后带来的问题，例如：是否可以重新生成数据，还有，在高并发场合下缓存宕机或重启会不会导致大量请求直接到数据库，导致数据库无法承受，最终导致网站架构雪崩等。</p>
<h4 id="424-内存管理机制">4.2.4 内存管理机制<a hidden class="anchor" aria-hidden="true" href="#424-内存管理机制">¶</a></h4>
<ul>
<li>Memcached采用了如下机制：</li>
<li>采用slab内存分配机制。</li>
<li>采用LRU对象清除机制。</li>
<li>采用hash机制快速检索item。</li>
</ul>
<h4 id="425-多线程处理机制">4.2.5 多线程处理机制<a hidden class="anchor" aria-hidden="true" href="#425-多线程处理机制">¶</a></h4>
<ul>
<li>多线程处理时采用的是pthread（POSIX）线程模式。</li>
<li>若要激活多线程，可在编译时指定：<font color="#f8070d" size=2><code>./configure --enable-threads</code></font> 。</li>
<li>锁机制不够完善。</li>
<li>负载过重时，可以开启多线程（-t线程数为CPU核数）。</li>
</ul>
<h3 id="43-memcached预热理念及集群节点的正确重启方法">4.3 Memcached预热理念及集群节点的正确重启方法<a hidden class="anchor" aria-hidden="true" href="#43-memcached预热理念及集群节点的正确重启方法">¶</a></h3>
<h4 id="431-memcached预热理念">4.3.1 Memcached预热理念<a hidden class="anchor" aria-hidden="true" href="#431-memcached预热理念">¶</a></h4>
<p>当需要大面积重启Memcached时，首先要在前端控制网站入口的访问流量，然后重启Memcached集群并进行数据预热，所有数据都预热完毕之后，在逐步开放前端网站入口的流量。</p>
<p>为了满足Memcached服务可以持久化存储的需求，在较早时期，新浪网基于Memcached服务开发了一款NoSQL软件，名字为MemcacheDB，实现了在缓存的基础上增加了之久存储的特性，不过目前逐步被更优秀的redis mongodb取代了。</p>
<h4 id="432-如何正确开启网站集群服务器">4.3.2 如何正确开启网站集群服务器<a hidden class="anchor" aria-hidden="true" href="#432-如何正确开启网站集群服务器">¶</a></h4>
<p>如果由于机房断电或者搬迁服务器集群到新机房，那么启动集群服务器时，一定要从网站集群的后端**==依次往前端开启==**，特别是开启Memcached缓存服务器时要提前预热。</p>
<h2 id="5-memcached内存管理">5 Memcached内存管理<a hidden class="anchor" aria-hidden="true" href="#5-memcached内存管理">¶</a></h2>
<h3 id="51-memcached内存管理机制深入剖析">5.1 Memcached内存管理机制深入剖析<a hidden class="anchor" aria-hidden="true" href="#51-memcached内存管理机制深入剖析">¶</a></h3>
<h4 id="511-malloc内存管理机制">5.1.1 Malloc内存管理机制<a hidden class="anchor" aria-hidden="true" href="#511-malloc内存管理机制">¶</a></h4>
<p>在讲解Memcached内存管理机制前，先来了解malloc。</p>
<p>malloc的全称是memory allocation，中文名称动态内存分配，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态分配内存。</p>
<p>早期的Memcached内存管理是通过malloc分配的内存实现的，使用完后通过free来回收内存。这种方式容易产生内存碎片并降低操作系统对内存的管理效率。因此，也会加重操作系统内存管理器的负担，最坏的情况下，会导致操作系统比Memcached进程本身还慢，为了解决上述问题，Slab Allocator内存分配机制就诞生了。</p>
<h4 id="512-slab内存管理机制">5.1.2 Slab内存管理机制<a hidden class="anchor" aria-hidden="true" href="#512-slab内存管理机制">¶</a></h4>
<p>现在的Memcached是利用Slab Allocation机制来分配和管理内存的，过程如下。</p>
<ol>
<li>提前将大内存分配大小为1MB的若干个slab，然后针对每个slab在进行小对象填充，这个小对象成为chunk，避免大量重复的初始化和清理，减轻了内存管理器的负担。</li>
<li>Slab Allocation内存分配的原理是按照预先规定的大小，将分配给Memcached服务的内存预先分割成特定长度的内存块(chunk)分成组(chunks slab class)，这些内存块不会释放，可以重复利用。</li>
</ol>
<p>新增数据对象存储时。因Memcached服务器中保存这slab内空闲chunk的列表，他会根据该列表选择chunk，然后将数据缓存于其中。当有数据存入时，Memcached根据接收到的数据大小，选择最适合数据大小的slab分配一个能存下这个数据的最小内存块(chunk)。例如：有100字节的一个数据，就会分配存入下面112字节的内存块中，会有这样12字节被浪费，这部分空间就不能被使用了，这也是SlabAllocator机制的一个缺点。</p>
<p>Slab Allocator还可以重复使用已分配的内存，即分配道德内存不书房，而是重复利用。</p>
<blockquote>
<p><strong>Slab Allocation的主要术语</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>Slab Allocation主要术语</th>
<th>注解说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>slab class</td>
<td>内存区类别（48bytes-1MB）</td>
</tr>
<tr>
<td>slab</td>
<td>动态创建的实际内存区，即分配给Slab的内存空间，默认是1MB。分配给Slab之后根据slab的大小切分成chunk。slab默认大小为1048576byte(1MB)，大于1MB的数据会忽略。</td>
</tr>
<tr>
<td>slab classid</td>
<td>slab class的ID</td>
</tr>
<tr>
<td>chunk</td>
<td>数据区块，固定大小，chunk初始大小，1.4版本中是48bytes</td>
</tr>
<tr>
<td>item</td>
<td>实际存储在chunk中的数据项。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Slab内存管理机制特点</strong></p>
</blockquote>
<ul>
<li>提前分配大量内存Slab 1Mb，再进行小对象填充chunk。</li>
<li>避免大量重复的初始化和清理，减轻内存管理器的负担。</li>
<li>避免频繁malloc/free内存分配导致的碎片。</li>
</ul>
<blockquote>
<p><strong>下面对Mc内存管理机制进行一个小结</strong></p>
</blockquote>
<ul>
<li>mc的早期内存管理机制为malloc（动态分配内存）。</li>
<li>malloc（动态内存分配）产生内存碎片，导致操作系统性能急剧下降。</li>
<li>Slab内存分配机制可以解决内存碎片的问题</li>
<li>Memcached服务的内存预先分割成特定长度的内存块，成为chunk，用于缓存数据的内存空间或内存块，相当于磁盘的block，只不过磁盘的每一个block都是相等的，而chunk只有在同一个Slab Class内才是相等的。</li>
<li>Slab Class指特定大小（1MB）的包含多个chunk的集合或组，一个Memcached包含多个Slab Class，每个Slab Class包含多个相同大小的chunk。</li>
<li>Slab机制也有缺点，例如，Chunk的空间会有浪费等。</li>
</ul>
<h3 id="52-memcached-slab-allocator内存管理机制的缺点">5.2 Memcached Slab Allocator内存管理机制的缺点<a hidden class="anchor" aria-hidden="true" href="#52-memcached-slab-allocator内存管理机制的缺点">¶</a></h3>
<p>chunk存储item浪费空间</p>
<p>Slab Allocator解决了当初的内存碎片问题，但新的机制也给Memcached带来了新的问题。这个问题就是，由于分配的是特定长度的内存，因此无法有效利用分配的内存。例如：将100字节的数据缓存到128字节的chunk中，剩余的28字节就浪费了</p>
<p>避免浪费内存的方法是，预先计算出应用存入的数据大小，或把同一业务类型的数据存入一个Memcached服务器中，确保存入的数据大小相对均匀，这样就可以较少内存的浪费。</p>
<p>还有一种方法是，在启动时，指定-f参数，能在某种程度上控制内存组之间的大小差异。在应用中使用Memcached时，通常可以不重新设置这个参数，即默认值1.25进行部署即可。如果想优化Memcached对内存的使用，可以考虑重新计算数据的预期品均长度，调整这个参数来获得合适的设置值。</p>
<h3 id="53-memcached的检测过期与删除机制">5.3 Memcached的检测过期与删除机制<a hidden class="anchor" aria-hidden="true" href="#53-memcached的检测过期与删除机制">¶</a></h3>
<h4 id="531-memcached懒惰检测对象的过期机制">5.3.1 Memcached懒惰检测对象的过期机制<a hidden class="anchor" aria-hidden="true" href="#531-memcached懒惰检测对象的过期机制">¶</a></h4>
<p>首先要知道，Memcached不会主动检测item对象是否过期，而是在进行get操作时检查item对象是否过期自己是否应该删除！</p>
<p>因为不会主动检测item对象是否过期，自然也就不会释放已分配给对象的内存空间了，除非为添加的数据设定过期时间或内存缓存满了，在数据过期后，客户端不能通过key取他的值，起存储空前被重新利用。</p>
<p>Memcached使用的这种策略为懒惰检测对象过期策略，即自己不监控存入的key/value对是否过期，而是在获取key值时查看记录时间戳(set key flag exptime bytes)，从而检查key/value对空间是否过期。这种策略不会在过期检测上浪费CPU资源</p>
<h4 id="532-memcached惰性删除对象机制">5.3.2 Memcached惰性删除对象机制<a hidden class="anchor" aria-hidden="true" href="#532-memcached惰性删除对象机制">¶</a></h4>
<p>当删除item对象时，一般不会释放内存空间，而是做删除标记，将指针放入slot回收插槽，下次分配的时候直接使用。</p>
<p>Memcached在分配空间时，会优先使用已经过期的key/value对空间；若分配的内存空间占满，Memcached就会使用LRU算法来分配空间，删除最近最少使用的key/value对，从而将其空间分配给新的key/value对。在某些情况下（完整缓存），如果不想使用LRU算法，那么可以通过“-M”参数来启动Memcached，这样Memcached在内存耗尽时，会返回一本报错信息，如下：</p>
<pre><code class="language-sh">-M   return error on memory exhausted (rather than removing items)
</code></pre>
<blockquote>
<p><strong>Memcache删除机制小结</strong>：</p>
</blockquote>
<p>不主动检测item对象是否过期，而是在get时才会检查item对象是否过期以及是否应该删除。</p>
<p>当删除item对象时，一般不释放内存空间，而是做删除标记，将指针放入slot回收插槽，下次分配的时候直接使用。</p>
<p>当内存空间满的时候，将会根据LRU算法把最近最少使用的item对象删除。</p>
<p>数据存入可以设定过期时间，但是数据过期后不会被立即删除，而是在get时检查item对象是否过期以及是否应该删除。</p>
<p>如果不希望系统使用LRU算法清楚数据，可以使用-M参数。</p>
<pre><code class="language-sh">stats 
STAT curr_items 3
STAT total_items 10	#←删除前的item对象
STAT evictions 0
END
flush_all
OK
stats
STAT pid 1532
...
STAT curr_items 3		#←由于memcached删除机制的原理，数据并未释放而是做了标记
STAT total_items 10	#←在下次访问过
STAT evictions 0
END
flush_all 
OK
STAT curr_items 2
STAT total_items 6
STAT evictions 0
END
get a
END
stats
...
STAT bytes 67
STAT curr_items 1
STAT total_items 6
STAT evictions 0
END
# 数据过期与上述基本相同
set key 0 10 2
23
STORED
stats
..
STAT curr_items 1
STAT total_items 2
STAT evictions 0
END
get ket   
END
stats
...
STAT curr_items 1
STAT total_items 2
STAT evictions 0
END
get key
END
stats
...
STAT curr_items 0
STAT total_items 2
STAT evictions 0
END
</code></pre>
<p><a href="http://www.cnblogs.com/UnGeek/p/5136410.html" target="_blank"
   rel="noopener nofollow noreferrer" >memcached-slab内存管理</a></p>
<h2 id="6-memcache服务安装">6 Memcache服务安装<a hidden class="anchor" aria-hidden="true" href="#6-memcache服务安装">¶</a></h2>
<h3 id="61-memcached-安装">6.1 Memcached 安装<a hidden class="anchor" aria-hidden="true" href="#61-memcached-安装">¶</a></h3>
<p>Memcached的安装比较简单，支持Memcached的平台常见的有Linux、FreeBSD、Solaris、windows。这里以CentOS 7为例进行讲解。</p>
<h4 id="611-安装libevent及连接memcached工具nc">6.1.1 安装libevent及连接Memcached工具nc<a hidden class="anchor" aria-hidden="true" href="#611-安装libevent及连接memcached工具nc">¶</a></h4>
<p>系统安装环境如下</p>
<pre><code class="language-sh">$ cat /etc/redhat-release 
CentOS Linux release 7.1.1503 (Core) 
$ uname -r
3.10.0-229.el7.x86_64
$ uname -m
x86_64
</code></pre>
<p>安装Memcached前，需要先安装libevent，此处用yum安装libevent。</p>
<pre><code class="language-sh">yum install libevent libevent-devel nc -y
# centos7 nc变更为nmap-ncat
</code></pre>
<h4 id="612-编译安装memcached">6.1.2 编译安装Memcached<a hidden class="anchor" aria-hidden="true" href="#612-编译安装memcached">¶</a></h4>
<pre><code class="language-sh">./configure --prefix=/app/memcached
make &amp;&amp; make install
</code></pre>
<p>yum安装的Memcached版本略低，但是不影响使用。</p>
<pre><code class="language-sh"># CentOS 6
$ yum list nc memcached
Loaded plugins: fastestmirror, security
Loading mirror speeds from cached hostfile
Available Packages
memcached.x86_64                	1.4.4-3.el6_8.1                 		 updates
nc.x86_64                        	1.84-24.el6                          base   

# CentOS 7
$ yum list memcached|grep memcached
memcached.x86_64                  1.4.15-10.el7_3.1                    updates
</code></pre>
<h3 id="62-安装memcached客户端">6.2 安装Memcached客户端<a hidden class="anchor" aria-hidden="true" href="#62-安装memcached客户端">¶</a></h3>
<blockquote>
<p><strong>LAMP PHP环境准备</strong></p>
</blockquote>
<p>这里以PHP虚拟机程序为例，首先要在LAMP环境下能出来phpinfo信息页面，只有这样才能继续操作。具体如图：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235122992.png" alt="image-20221024235122992" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="621-php扩展插件memcache与memcached">6.2.1 PHP扩展插件Memcache与Memcached<a hidden class="anchor" aria-hidden="true" href="#621-php扩展插件memcache与memcached">¶</a></h3>
<p>PHP的Memcached扩展分为两个版本：</p>
<ol>
<li>
<p>memcache 是 pecl 扩展库版本，原生支持php，出现于2004年。</p>
</li>
<li>
<p>memcached 是 libmemcached 版本，出现较后，是新一代，因此也更加完善，推荐使用。</p>
</li>
</ol>
<p>在安装memcache扩展的时候并不要求安装其他依赖，但是在安装memcached的时候会要求你安装libmemcached，问题来了，libmemcached是memcache的C客户端，它具有的优点是低内存，线程安全等特点。比如新浪微博之前就全面将php的memcache替换成php的memcached，在高并发下，稳定性果断提高。差别比较大的一点是，memcached 支持 Binary Protocol，而 memcache 不支持，意味着 memcached 会有更高的性能。不过，还需要注意的是，memcached 目前还不支持长连接。</p>
<p>参考网址：http://blog.wpjam.com/m/memcache-vs-memcached/</p>
<h3 id="622-php-memcache扩展安装">6.2.2 PHP Memcache扩展安装<a hidden class="anchor" aria-hidden="true" href="#622-php-memcache扩展安装">¶</a></h3>
<p>php的Memcache的扩展插件下载地址为：http://pecl.php.net/package/memcache</p>
<p>PHP的Memcache客户端扩展插件安装命令如下：</p>
<pre><code class="language-bash">/app/php/bin/phpize
./configure --enable-memcache --with-php-config=/app/php/bin/php-config
make &amp;&amp; make install
</code></pre>
<p>配置Memcache客户端，使其生效</p>
<p>修改PHP的配置文件php.ini，加入Memcache客户端的配置</p>
<pre><code class="language-sh">extension=/app/php-5.5/lib/php/extensions/no-debug-non-zts-20121212/memcache.so
</code></pre>
<p>重启php fpm服务使php的配置修改生效</p>
<pre><code class="language-sh">/app/php/sbin/php-fpm -t
</code></pre>
<p>打开浏览器访问phpinfo页面，出现下图表示Memcache客户端安装成功。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235143724.png" alt="image-20221024235143724" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="622-部署memcached">6.2.2 部署memcached<a hidden class="anchor" aria-hidden="true" href="#622-部署memcached">¶</a></h4>
<p>PHP Memcached 扩展基于 libmemcached 开发的，使用 libmemcached 库提供的 API 与 Memcached 服务进行交互。顾安装php memcached扩展需要先安装libmemcached</p>
<p>libmemcached下载地址:https://launchpad.net/libmemcached</p>
<blockquote>
<p><strong>安装libmemcached依赖包</strong></p>
</blockquote>
<pre><code class="language-sh">yum install cyrus-sasl-devel -y
</code></pre>
<p>遇到如下错误：</p>
<pre><code class="language-sh">configure: error: no, sasl.h is not available. Run configure with 
--disable-memcached-sasl to disable this check
</code></pre>
<p>解决：需先安装后在编译libmemcached</p>
<pre><code class="language-sh">yum install cyrus-sasl-devel -y
</code></pre>
<p>编译libmemcached：</p>
<pre><code class="language-sh">./configure \
--with-memcached=/usr/local/memcached \
--prefix=/usr/local/libmemcached
</code></pre>
<blockquote>
<p><strong>安装PHP Memcached组件</strong></p>
</blockquote>
<p>下载和解压这步，我们要区分是PHP7还是之前的版本：</p>
<p>下载网址：http://pecl.php.net/package，这里写名3.0版本之后，支持PHP版本为7.0或以上</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235218253.png" alt="image-20221024235218253" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>编译参数</p>
<pre><code class="language-sh">/app/php/bin/phpize
./configure \
--enable-memcached \
--with-php-config=/app/php-5.5/bin/php-config \
--with-libmemcached-dir=/app/libmem-1.0.18/
</code></pre>
<p>配置Memcache客户端，使其生效</p>
<p>修改PHP的配置文件php.ini，加入Memcache客户端的配置</p>
<pre><code class="language-conf">extension=/app/php-5.5/lib/php/extensions/no-debug-non-zts-20121212/memcached.so
</code></pre>
<p>打开浏览器访问phpinfo页面，出现下图表示Memcached组件安装成功。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235234830.png" alt="image-20221024235234830" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p><strong>测试Memcache扩展与Memcached扩展</strong></p>
</blockquote>
<ol>
<li><strong>测试Memcache扩展是否成功</strong></li>
</ol>
<pre><code class="language-php">$m = new Memcache();
$m-&gt;connect('127.0.0.1',11211) or die('Could not connect');
$m-&gt;set('key2321','zhangsan');
echo $m-&gt;get('key2321');
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235252036.png" alt="image-20221024235252036" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<ol start="2">
<li><strong>测试Memcached扩展是否成功</strong></li>
</ol>
<pre><code class="language-php">$m = new Memcached();
$m-&gt;addServer('127.0.0.1',11211,40);
$m-&gt;set('ke1','zhangsan2');
echo $m-&gt;get('ke1');
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221024235304685.png" alt="image-20221024235304685" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p><strong>用telnet查询</strong></p>
</blockquote>
<pre><code class="language-sh">$ telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
get key2321
VALUE key2321 0 8
zhangsan
END

get ke1
VALUE ke1 0 9
zhangsan2
END
</code></pre>
<p>参考网址：http://www.bcty365.com/content-103-3516-1.html</p>
<h2 id="7-memcached服务的基本管理">7 Memcached服务的基本管理<a hidden class="anchor" aria-hidden="true" href="#7-memcached服务的基本管理">¶</a></h2>
<h3 id="71-启动memcached">7.1 启动Memcached<a hidden class="anchor" aria-hidden="true" href="#71-启动memcached">¶</a></h3>
<p>启动Memcached的命令如下：</p>
<pre><code class="language-sh">$ /home/memcached/bin/memcached -m 16m -p 11211 -d -u root -c 8192
</code></pre>
<p>查看启动状态</p>
<pre><code class="language-sh">$ lsof -i:11211
COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
memcached 16729 root   26u  IPv4 139948      0t0  TCP *:memcache (LISTEN)
memcached 16729 root   27u  IPv6 139949      0t0  TCP *:memcache (LISTEN)
memcached 16729 root   28u  IPv4 139952      0t0  UDP *:memcache 
memcached 16729 root   29u  IPv4 139952      0t0  UDP *:memcache 
memcached 16729 root   30u  IPv4 139952      0t0  UDP *:memcache 
memcached 16729 root   31u  IPv4 139952      0t0  UDP *:memcache 
memcached 16729 root   32u  IPv6 139953      0t0  UDP *:memcache 
memcached 16729 root   33u  IPv6 139953      0t0  UDP *:memcache 
memcached 16729 root   34u  IPv6 139953      0t0  UDP *:memcache 
memcached 16729 root   35u  IPv6 139953      0t0  UDP *:memcache    
</code></pre>
<p>配置ld.so.conf路径防止启动Memcached时报错</p>
<pre><code class="language-sh">echo '/usr/local/lib' &gt;&gt;/etc/ld.so.conf
ldconfig
</code></pre>
<p>启动多个实例</p>
<pre><code class="language-sh">memcached -m 16m -p 11212 -d -uroot -c 8192
</code></pre>
<p>查看结构</p>
<pre><code class="language-sh">$ netstat -lntup
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address    Foreign Address     State       PID/Program name    
tcp        0      0  0.0.0.0:11211     0.0.0.0:*         LISTEN      16729/memcached           
tcp        0      0 0.0.0.0:11212      0.0.0.0:*         LISTEN      16741/memcached                
tcp6       0      0 :::11211           :::*              LISTEN      16729/memcached     
tcp6       0      0 :::11212           :::*              LISTEN      16741/memcached              
udp        0      0 0.0.0.0:11211      0.0.0.0:*                     16729/memcached     
udp        0      0 0.0.0.0:11212      0.0.0.0:*                     16741/memcached     
udp6       0      0 :::11211           :::*                          16729/memcached     
udp6       0      0 :::11212           :::*                          16741/memcached 
</code></pre>
<h3 id="72-memcached启动相关参数说明">7.2 Memcached启动相关参数说明<a hidden class="anchor" aria-hidden="true" href="#72-memcached启动相关参数说明">¶</a></h3>
<p>表7-1为Memcached启动命令相关参数说明</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td><strong>进程与连接参数</strong></td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td>以守护进程（daemon）方式运行服务</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td>指定运行Memcached的用户，如果当前用户为root，需要使用此参数指定用户</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td>指定Memcached进程监听的服务器IP地址，可以不设置此参数。</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td>指定Memcached服务监听TCP端口号。默认为11211</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td>设置Memcached的PID文件（$$），保存PID到指定文件</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><strong>内存相关设置</strong></td>
</tr>
<tr>
<td style="text-align:center">-m</td>
<td>指定Memcached服务可以缓存数据的最大内存，默认为64M</td>
</tr>
<tr>
<td style="text-align:center">-M</td>
<td>Memcached服务内存不够时禁止LRU，如果内存满了会报错</td>
</tr>
<tr>
<td style="text-align:center">-n</td>
<td>为key+value+flags分配的最小内存空间，默认为48节</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td>chunk size增长因子，默认为1.25</td>
</tr>
<tr>
<td style="text-align:center">-L</td>
<td>启用大内存页，可以降低内存浪费，改进性能。</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><strong>并发连接设置</strong></td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td>最大的并发连接数，默认是1024</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td>线程数，默认4,。由于Memcached采用的是NIO，所以太多线程作用不大</td>
</tr>
<tr>
<td style="text-align:center">-R</td>
<td>每个event的最大请求，默认是20</td>
</tr>
<tr>
<td style="text-align:center">-C</td>
<td>禁用CAS（可以禁止版本计数，减少开销）</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td><strong>调试参数</strong></td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td>打印较少的errors/warings</td>
</tr>
<tr>
<td style="text-align:center">-vv</td>
<td>打印非常多调试信息和错误输出到控制台，也打印客户端命令及相应</td>
</tr>
<tr>
<td style="text-align:center">-vvv</td>
<td>打印极多的调试信息和错误输出，也打印内部状态转变</td>
</tr>
</tbody>
</table>
<p>更多参数 <strong><code>memcached -h</code></strong></p>
<h3 id="73-向memcached中写入数据并检查">7.3 向Memcached中写入数据。并检查<a hidden class="anchor" aria-hidden="true" href="#73-向memcached中写入数据并检查">¶</a></h3>
<h4 id="731-memcached中的数据形式及与mysql相关语句对比">7.3.1 Memcached中的数据形式及与MySQL相关语句对比<a hidden class="anchor" aria-hidden="true" href="#731-memcached中的数据形式及与mysql相关语句对比">¶</a></h4>
<p>向Memcached中添加数据时，注意添加的数据一般为键值对的形式，例如：<font color="#f8070d" size=3><code>key1-value1 key2-value2</code></font></p>
<p>这里把Memcached添加、查询、删除等的命令和MySQL数据库做了一个基本类比。见表7-2</p>
<table>
<thead>
<tr>
<th>MySQL数据库管理</th>
<th>Memcached管理</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL的insert语句</td>
<td>Memcached的set命令</td>
</tr>
<tr>
<td>MySQL的select语句</td>
<td>Memcached的get命令</td>
</tr>
<tr>
<td>MySQL的delete语句</td>
<td>Memcached的delete命令</td>
</tr>
</tbody>
</table>
<p>管理MySQL和Memcached的常见命令类比</p>
<h4 id="732-向memcached中写入数据实践">7.3.2 向Memcached中写入数据实践<a hidden class="anchor" aria-hidden="true" href="#732-向memcached中写入数据实践">¶</a></h4>
<p>通过printf配合nc想Memcached中写入数据</p>
<pre><code class="language-bash">$ printf &quot;set key1 0 0 6\r\nzhang\r\n&quot;|nc 127.0.0.1 11211 
$ 
</code></pre>
<p>如果set命令的字节是6就要6个字符（字节）。否则插入数据就不会成功</p>
<pre><code class="language-bash">$ printf &quot;set key1 0 0 6\r\nzhangs\r\n&quot;|nc 127.0.0.1 11211
STORED
</code></pre>
<p>通过printf配合nc从Memcached中读取数据，命令如下：</p>
<pre><code class="language-sh">$ printf &quot;get key1\r\n&quot;|nc 127.0.0.1 11211
VALUE key1 0 6
zhangs # 这就是读到的key1对应额值
END
</code></pre>
<p>通过printf配合nc从Memcached中删除数据</p>
<pre><code class="language-sh">$ printf &quot;delete key1\r\n&quot;|nc 127.0.0.1 11211  
DELETED   #←出现DELETED表示成功删除key1及对应的数据
$ printf &quot;get key1\r\n&quot;|nc 127.0.0.1 11211   
END
</code></pre>
<hr>
<p><strong><font color="#0215cd" size=2> <font color="#f8070d" size=2>⚠</font> 提示：推荐使用上述方法测试操作Memcached
</font></strong></p>
<hr>
<p>通过telnet命令写入数据时，具体步骤如下。</p>
<blockquote>
<p><strong>通过telnet向Memcached写入数据</strong></p>
</blockquote>
<pre><code class="language-sh">$ telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
add id 0 0 5	
12345		#← 写入数据
STORED
add id 0 0 3	
123
NOT_STORED	#← 若key存在则报如下错误
set name 0 0 6 	#← 写入数据，如果key不存在则创建key，如果存在则更改key的value值
张三	#← 中文，每个字占3个bytes
STORED
get name
VALUE name 0 6
张三
END
get id
VALUE id 0 5
12345
END
set id 0 0 1	#← 写入数据，如果key不存在则创建key，如果存在则更改key的value值
2
STORED
get id
VALUE id 0 1
2
END
</code></pre>
<blockquote>
<p><strong>incr/decr</strong></p>
</blockquote>
<pre><code class="language-sh">set key 0 0 1
9
STORED
get key
VALUE key 0 1
9
END
incr key 1
10		
get key   
VALUE key 0 2	  #← 对整型增加后对应的bytes也增加
10		
END
get key
VALUE key 0 1
1
END
decr key 1
0
decr key 1
0
</code></pre>
<hr>
<p><strong><font color="#0215cd" size=2> <font color="#f8070d" size=2>⚠</font> 提示：telnet连接后如果输入字符错了，可以通过Ctrl+Backspace删除
</font></strong></p>
<hr>
<h4 id="733-操作memcached相关命令的语法">7.3.3 操作Memcached相关命令的语法<a hidden class="anchor" aria-hidden="true" href="#733-操作memcached相关命令的语法">¶</a></h4>
<p>以下为操作Memcached的相关命令基础语法</p>
<pre><code class="language-sh">set			   key1	  0 	   0		 6
[command name]  [key]  [flags]  [exptime]  [bytes]
[datablock]\r\n
[status]\r\n
</code></pre>
<p>表7-3 Memcached相关命令详细说明</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>command name</td>
<td>set：无论如何都进行写入数据，会覆盖老数据<br>add：只有对应数据不存在时才添加数据<br>repalce：只有数据存在时进行替换数据<br>delete [second] 加秒数之后，被删除的key N秒内不能再用，作用：让网站的页面也代谢完毕<br>append往后追加：prepend[key]datablock[status]?<br>prepend往前追加：prepend[key]datablock[status]<br>cas按版本号更换<br>incr key num  增加一个值的大小。<br>decr key num  减少一个值的大小。<br>incr decr操作将值进行32位无符号计算  0-232-1范围内<br>应用场景，限时秒杀中库存量，先给抢中者分发订单号，数据低谷期将数据写入数据库</td>
</tr>
<tr>
<td>key</td>
<td>普通字符串，要求小于250个字符，不包含空格和控制字符</td>
</tr>
<tr>
<td>flags</td>
<td>客户端用来标识数据格式和数值，如json、xml、压缩、数组等</td>
</tr>
<tr>
<td>exptime</td>
<td>存活时间s，<br/>0为永久有效：编译时默认为30天。<br/>小于30天，60x60x24x30为秒数，<br/>大于30天为unix timestamp 如：团购网站，某团到中午12:00失效。</td>
</tr>
<tr>
<td>bytes</td>
<td>byte字节数，不包含\r\n，根据长度截取存/取的字符串，可以是0，即存空串</td>
</tr>
<tr>
<td>datablock</td>
<td>文本行，以\r\n结尾，当然可以包含\r或\n</td>
</tr>
<tr>
<td>status</td>
<td>STORED/NOT_STORED/EXISTS/NOT_FOUND<br/>ERROR/CLIENT_ERROR/SERVER_ERROR服务器端会关闭连接以修复。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>事例1：向memcached中插入数据</strong></p>
</blockquote>
<pre><code class="language-sh">add id 0 0 5
12345
STORED
set name 0 0 6
张三
STORED
get name
VALUE name 0 6
张三
END
get id
VALUE id 0 5
12345
END
set id 0 0 1
2
STORED
get id
VALUE id 0 1
2
END
</code></pre>
<h4 id="734-关闭memcached">7.3.4 关闭Memcached<a hidden class="anchor" aria-hidden="true" href="#734-关闭memcached">¶</a></h4>
<blockquote>
<p><strong>单实例关闭Memcached的方法如下</strong>：</p>
</blockquote>
<pre><code class="language-sh">killall memcached 或 pkill
</code></pre>
<p>若启动了多个实例Memcached，使用killall或pkill方式就会同时关闭这些实例！因此最好在启动时增加-P参数指定固定的pid文件，这样便于管理不同的实例。实例如下</p>
<pre><code class="language-sh">memcached -m 16m -p 11211 -d -u root -c 8192 -P /var/run/memcached/11211.pid
memcached -m 16m -p 11211 -d -u root -c 8192 -P /var/run/memcached/11212.pid
</code></pre>
<p>此时，即可以通过kill命令关闭Memcached</p>
<pre><code class="language-sh">kill `cat /var/run/memcached/11211.pid`
</code></pre>
<blockquote>
<p><strong>关闭Memcached的方法小结如下</strong>：</p>
</blockquote>
<pre><code class="language-sh">ps -ef|grep memcached|grep -v grep|awk '{print $2}'|xargs kill
kill `cat /var/run/memcached/11211.pid`
pkill memcached
killall memcached
</code></pre>
<h4 id="735-企业工作场景中如何配置memcached">7.3.5 企业工作场景中如何配置Memcached<a hidden class="anchor" aria-hidden="true" href="#735-企业工作场景中如何配置memcached">¶</a></h4>
<p>在企业实际工作中，一般是开发人员提出需求，说要不熟一个Memcached数据缓存。运维人员在接到这个不确定的需求后，需要和开发人员深入沟通，进而确定要将内存指定为多大，或者和开发人员商量如何根据具体业务来指定内存缓存的大小。此外，还要确定业务的重要性，进而决定是否采取负载均衡、分布式缓存集群等架构，最后确定使用多大的并发连接数等。</p>
<p>对于运维人员，部署Memcached一般就是安装Memcached服务端，把服务启动起来，最好监控，配好开机自启动，基本上就OK了，客户端的PHP程序环境一般在安装LNMP环境时都会提前安装Memcached客户端插件，Java程序环境下，开发人员会用第三方的JAR包直接连接Memcached服务。</p>


    
    


<div class="copyrightBlock" >
    <div class="articleSuffix-bg"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <p>链接：<a href="https://www.oomkill.com/2016/09/memcached/" target="_blank">https://www.oomkill.com/2016/09/memcached/</a></p>
    <p style="margin-bottom: 0px;">版权：本作品采用<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">「署名-非商业性使用-相同方式共享 4.0 国际」</a> 许可协议进行许可。</p>
    </div>
</div>
  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://www.oomkill.com/2016/10/install-troubleshooting/">
    <span class="title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline>
      </polyline></svg>&nbsp; </span>
    
    <span>PHP安装错误记录</span>
  </a>
  <a class="next" href="https://www.oomkill.com/2016/09/vsftp-network-filesystem/" >
    <span class="title"> </span>
    
    <span>网络共享 - centos7安装vsftpd&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg></span>
  </a>
</nav>

  </footer>

  
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
  </div>
  
  
  
  
    <div class="comments-separator"></div>
    

<h3 class="relatedContentTitle" >相关阅读</h3>
<ul class="relatedContent">
	
	<li><a href="/2016/09/consistent-hash/"><span>一致性hash在memcache中的应用</span></a></li>
	
</ul>

  

  
    
      <div class="comments-separator"></div>
<div class="comments">
    <script>
    function loadComment() {
        let theme = localStorage.getItem('pref-theme') === 'dark' ? 'dark' : 'light';
        let s = document.createElement('script');
        s.src = 'https://giscus.app/client.js';
        s.setAttribute('data-repo', 'cylonchau\/cylonchau.github.io');
        s.setAttribute('data-repo-id', 'R_kgDOIRlNSQ');
        s.setAttribute('data-category', 'Announcements');
        s.setAttribute('data-category-id', 'DIC_kwDOIRlNSc4CXy1U');
        s.setAttribute('data-mapping', 'title');
        s.setAttribute('data-reactions-enabled', '1');
        s.setAttribute('data-emit-metadata', '1');
        s.setAttribute('data-input-position', 'top');
        s.setAttribute('data-lang', 'zh-TW');
        s.setAttribute('data-theme', theme);
        s.setAttribute('crossorigin', 'anonymous');
        s.setAttribute('async', '');
        document.querySelector('div.comments').innerHTML = '';
        document.querySelector('div.comments').appendChild(s);
    }
    loadComment();
    </script>
</div>
</article>
    </main>
    
<footer class="footer">
  <p>
  Copyright
  <span>&copy; 2024 <a href="https://www.oomkill.com">Cylon&#39;s Collection</a></span></p>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> on github-page & Theme
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '1' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>

<script>
  document.addEventListener('scroll', function (e) {
      const readProgress = document.getElementById("read_progress");
      const scrollHeight = document.documentElement.scrollHeight;
      const clientHeight = document.documentElement.clientHeight;
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
  })
</script>

<script>
  var menu = document.getElementById('menu')
  if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
  }

  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                  behavior: "smooth"
              });
          } else {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
          }
          if (id === "top") {
              history.replaceState(null, null, " ");
          } else {
              history.pushState(null, null, `#${id}`);
          }
      });
  });
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
      if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
      } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
      }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

<script src="/js/instantclick.min.js" data-no-instant
></script>
<script data-no-instant>
  
  
  
  
  
  
  InstantClick.init();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.6.0/mermaid.min.js" crossorigin="anonymous"></script>
<script>
    mermaid.init(undefined, '.language-mermaid');
</script>
</body>

</html>
