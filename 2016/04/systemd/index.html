<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux服务管理 - systemd | Cylon's Collection</title><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NP3JNCPR" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta name=keywords content="systemd"><meta name=description content="关于Linux服务管理 Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。 SysV init UpStart systemd主要是解决服务引导管理的问题。
CentOS 5：SysV init CentOS 6：Upstart CentOS 7：Systemd http://www.linuxidc.com/Linux/2015-04/115937.htm 1.1 SysV init的优缺点 SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。
SysV init方案的优点：
1.原理简单，易于理解； 2.依靠shell脚本控制，编写服务脚本门槛比较低。 缺点是：
1.服务顺序启动，启动过程比较慢。 2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。 1.2 UpStart的改进 为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。
1.3 systemd的诞生 SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。
但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。
systemd的设计思路是：
尽可能的快速启动服务。 尽可能的减少系统资源占用。 1.4 为什么systemd能做到启动很快 systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。
使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。
systemd的特性 systemd解决了那些问题？
按需启动服务，减少系统资源消耗； 尽可能并行启动进程，减少系统启动等待时间； 提供一个一致的配置环境，不光是服务配置； 提供服务状态快照，可以恢复特定点的服务状态。 CentOS 7的systemd特性 3.1 套接字服务保持激活功能 在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。
3.2 进程间通讯保持激活功能 当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。
3.3 设备保持激活功能 当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。
3.4 文件路径保持激活功能 当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。
3.5 系统状态快照 systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。
3.6 挂载和自动挂载点管理 systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。"><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2016/04/systemd/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2016/04/systemd/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-H94HZ5S19Y"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-H94HZ5S19Y")</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="Linux服务管理 - systemd"><meta property="og:description" content="关于Linux服务管理 Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。 SysV init UpStart systemd主要是解决服务引导管理的问题。
CentOS 5：SysV init CentOS 6：Upstart CentOS 7：Systemd http://www.linuxidc.com/Linux/2015-04/115937.htm 1.1 SysV init的优缺点 SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。
SysV init方案的优点：
1.原理简单，易于理解； 2.依靠shell脚本控制，编写服务脚本门槛比较低。 缺点是：
1.服务顺序启动，启动过程比较慢。 2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。 1.2 UpStart的改进 为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。
1.3 systemd的诞生 SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。
但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。
systemd的设计思路是：
尽可能的快速启动服务。 尽可能的减少系统资源占用。 1.4 为什么systemd能做到启动很快 systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。
使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。
systemd的特性 systemd解决了那些问题？
按需启动服务，减少系统资源消耗； 尽可能并行启动进程，减少系统启动等待时间； 提供一个一致的配置环境，不光是服务配置； 提供服务状态快照，可以恢复特定点的服务状态。 CentOS 7的systemd特性 3.1 套接字服务保持激活功能 在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。
3.2 进程间通讯保持激活功能 当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。
3.3 设备保持激活功能 当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。
3.4 文件路径保持激活功能 当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。
3.5 系统状态快照 systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。
3.6 挂载和自动挂载点管理 systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2016/04/systemd/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-22T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux服务管理 - systemd"><meta name=twitter:description content="关于Linux服务管理 Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。 SysV init UpStart systemd主要是解决服务引导管理的问题。
CentOS 5：SysV init CentOS 6：Upstart CentOS 7：Systemd http://www.linuxidc.com/Linux/2015-04/115937.htm 1.1 SysV init的优缺点 SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。
SysV init方案的优点：
1.原理简单，易于理解； 2.依靠shell脚本控制，编写服务脚本门槛比较低。 缺点是：
1.服务顺序启动，启动过程比较慢。 2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。 1.2 UpStart的改进 为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。
1.3 systemd的诞生 SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。
但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。
systemd的设计思路是：
尽可能的快速启动服务。 尽可能的减少系统资源占用。 1.4 为什么systemd能做到启动很快 systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。
使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。
systemd的特性 systemd解决了那些问题？
按需启动服务，减少系统资源消耗； 尽可能并行启动进程，减少系统启动等待时间； 提供一个一致的配置环境，不光是服务配置； 提供服务状态快照，可以恢复特定点的服务状态。 CentOS 7的systemd特性 3.1 套接字服务保持激活功能 在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。
3.2 进程间通讯保持激活功能 当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。
3.3 设备保持激活功能 当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。
3.4 文件路径保持激活功能 当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。
3.5 系统状态快照 systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。
3.6 挂载和自动挂载点管理 systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"Linux服务管理 - systemd","item":"https://www.oomkill.com/2016/04/systemd/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux服务管理 - systemd","name":"Linux服务管理 - systemd","description":"关于Linux服务管理 Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。 SysV init UpStart systemd主要是解决服务引导管理的问题。\nCentOS 5：SysV init CentOS 6：Upstart CentOS 7：Systemd http://www.linuxidc.com/Linux/2015-04/115937.htm 1.1 SysV init的优缺点 SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。\nSysV init方案的优点：\n1.原理简单，易于理解； 2.依靠shell脚本控制，编写服务脚本门槛比较低。 缺点是：\n1.服务顺序启动，启动过程比较慢。 2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。 1.2 UpStart的改进 为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。\n1.3 systemd的诞生 SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。\n但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。\nsystemd的设计思路是：\n尽可能的快速启动服务。 尽可能的减少系统资源占用。 1.4 为什么systemd能做到启动很快 systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。\n使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。\nsystemd的特性 systemd解决了那些问题？\n按需启动服务，减少系统资源消耗； 尽可能并行启动进程，减少系统启动等待时间； 提供一个一致的配置环境，不光是服务配置； 提供服务状态快照，可以恢复特定点的服务状态。 CentOS 7的systemd特性 3.1 套接字服务保持激活功能 在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。\n3.2 进程间通讯保持激活功能 当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。\n3.3 设备保持激活功能 当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。\n3.4 文件路径保持激活功能 当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。\n3.5 系统状态快照 systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。\n3.6 挂载和自动挂载点管理 systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。","keywords":["systemd"],"articleBody":"关于Linux服务管理 Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。 SysV init UpStart systemd主要是解决服务引导管理的问题。\nCentOS 5：SysV init CentOS 6：Upstart CentOS 7：Systemd http://www.linuxidc.com/Linux/2015-04/115937.htm 1.1 SysV init的优缺点 SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。\nSysV init方案的优点：\n1.原理简单，易于理解； 2.依靠shell脚本控制，编写服务脚本门槛比较低。 缺点是：\n1.服务顺序启动，启动过程比较慢。 2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。 1.2 UpStart的改进 为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。\n1.3 systemd的诞生 SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。\n但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。\nsystemd的设计思路是：\n尽可能的快速启动服务。 尽可能的减少系统资源占用。 1.4 为什么systemd能做到启动很快 systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。\n使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。\nsystemd的特性 systemd解决了那些问题？\n按需启动服务，减少系统资源消耗； 尽可能并行启动进程，减少系统启动等待时间； 提供一个一致的配置环境，不光是服务配置； 提供服务状态快照，可以恢复特定点的服务状态。 CentOS 7的systemd特性 3.1 套接字服务保持激活功能 在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。\n3.2 进程间通讯保持激活功能 当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。\n3.3 设备保持激活功能 当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。\n3.4 文件路径保持激活功能 当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。\n3.5 系统状态快照 systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。\n3.6 挂载和自动挂载点管理 systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。\n3.7 闪电并行启动 因为使用套接字保持激活功能，systemd可以并行的启动所以套接字监听服务，大大减少系统启动时间。\n3.8 单元逻辑模拟检查 当激活或者关闭一个单元，systemd会计算依赖行，产生一个临时的模拟检查，并且校验一直性。如果不一致，systemd会尝试自动修正，并且移除报错的不重要的任务。\n3.9 和SysV init向后兼容 systemd完全支持SysV init Linux标准的基础核心规范脚本，这样的脚本易于升级到systemd服务单元。\n核心概念:unit 4.1 什么是单元 在RHEL7之前，服务管理是分布式的被SysV init或UpStart通过 /etc/rc.d/init.d 下的脚本管理。这些脚本是经典的Bash脚本，允许管理员控制服务的状态。在RHEL7中，这些脚本被服务单元文件替换。\n在systemd中，服务、挂载等资源统一被称为单元，所以systemd中有许多单元类型，服务单元文件的扩展名是.service，同脚本的功能相似。例如有查看、启动、停止、重启、启用或者禁止服务的参数。\n配置文件进行标识和配置：文件中主要包含了系统服务、监听socket、保存的系统快照及其他与init相关的信息。\nsystemd单元文件放置位置：\nsh 1 2 3 /usr/lib/systemd/system/systemd\t# 默认单元文件安装目录 /run/systemd/system\t# 单元运行时创建，这个目录优先于安装目录 /etc/systemd/system\t# 系统管理员创建和管理的单元目录，优先级最高。 4.2 Unit类型 类型 详解- Service unit 文件扩展名为service，用于定义系统服务。 Target unit 文件扩展名为.target，用于模拟实现“运行级别” Device unit 文件扩展名为.device，用于定义内核识别的设备。 Mount unit 文件扩展名为.mount，定义文件系统挂载点 Socket unit 文件扩展名为.socket，用于表示进程间通信用的socket文件 Snapshot unit 文件扩展名为.sanpshot，管理系统快照 Swap unit 文件扩展名为.swap，用于表示swap设备 Automount unit 文件扩展名为.automount，文件系统的自动挂载点 Path unit 文件扩展名为.path，用于定义文件系统中的一个文件或目录 .service 与服务对应的后缀名为service的unit、文件，无需执行权限，仅仅为systemd的配置文件。当systemd探测到有进程访问时，按需激活这个服务的机制，任何依赖与这个服务的其他服务想启动的话，\n服务的并行启动：\n.device 在某个硬件设备被激活或变得可用时，从而激活服务\n.path：某个文件路径变得可用或里面有文件时（文件发生变动）激活某个服务\n系统快照：\nsystemd能将所有unit当前状态保存到临时文件中（临时保存到一个持久设备上）。启动时，可从保存的快照开始继续向后运行。 必要时能自动载入。\n向后兼容：\nsysV init脚本。（能够兼容 start、stop restart status至少这4个服务脚本）以前启动服务的脚本放到centos7里直接可以用。\nCentOS 7的systemd向后兼容 systemd被设计成尽可能向后兼容SysV init和Upstart，下面是一些特别要注意的和之前主要版本的RHEL不再兼容的部分。\n5.1 systemd对运行级别支持有限 为了保存兼容，systemd提供有限target单元，“模拟”一些运行级别，也可以被早期的分布式的运行级别命令支持。不是所有的target都可以被映射到运行级别，在这种情况下，使用runlevel命令有可能会返回一个为N的不知道的运行级别，所以推荐尽量避免在RHEL7中使用runlevel命令。\n5.2 systemd不支持像init脚本那样的个性化命令。 除了一些标准命令参数例如：start、stop、status，SysV init脚本可以根据需要支持想要的任何参数，通过参数提供附加的功能，因为SysV init的服务器脚本实际上就是shell脚本，命令参数实际上就是shell子函数。\n举个例子，RHEL6的iptables服务脚本可以执行panic命令行参数，这个参数可以让系统立即进入紧急模式，丢弃所有的进入和发出的数据包。但是类似这样的命令行参数在systemd中是不支持的，systemd只支持在配置文件中指定命令行参数。\n5.3 systemd不支持和没有从systemd启动的服务通讯。 当systemd启动服务的时候，他保存进程的主ID以便于追踪，systemctl工具使用进程PID查询和管理服务。相反的，如果用户从命令行启动特定的服务，systemctl命令是没有办法判断这个服务的状态是启动还是运行的。\n5.4 systemd可以只停止运行的服务 在RHEL6及之前的版本，当关闭系统的程序启动之后，RHEL6的系统会执行/etc/rc0.d/下所有服务脚本的关闭操作，不管服务是处于运行或者根本没有运行的状态。而systemd可以做到只关闭在运行的服务，这样可以大大节省关机的时间。\n5.5 不能从标准输出设备读到系统服务信息。 systemd启动服务的时候，将标准输出信息定向到/dev/null，以免打扰用户。\n5.6 systemd不继承任何上下文环境。 systemd不继承任何上下文环境，如用户或者会话的HOME或者PATH的环境变量。每个服务得到的是干净的上下文环境。\n5.7 SysV init脚本依赖性 当systemd启动SysV init脚本，systemd在运行的时候，从LinuxStandardBase(LSB)Linux标准库头文件读取服务的依赖信息并继承。\n5.8 超时机制 为了防止系统被卡住，所有的服务有5分钟的超时机制。\nsystemd服务管理 使用systemcl命令可以控制服务，service命令和chkconfig命令依然可以使用，但是主要是出于兼容的原因，应该尽量避免使用service命令和chkconfig命令。\n使用systemctl命令的时候，服务名字的扩展名可以写全，例如：\nsh 1 systemctl stop httpd.service 也可以忽略，例如：\nsh 1 systemctl stop httpd 6.1 常用命令 6.2 服务管理 说明 命令 启动服务 service name start ==\tsystemctl start name.service 停止服务 service name stop\t== systemctl stop name.service 重启服务 service name restart\t== systemctl restart name.service 查看服务状态 service name status == systemctl status name.service 条件式重启 service name condrestart == systemctl try-restart name.service 重载或重启服务 systemctl reload-or-restart name.service 重载或条件式重启 systemctl reload-or-try-restart name.service 禁止设定为开机自启动 systemctl mask name.service 取消设定为开机自启动 systemctl unmask name.service 查看服务当前激活与否的状态 systemctl is-active name.service 允许服务开机启动 systemctl enable name.service 禁止服务开机启动 systemclt disable name.service 级别切换 systemctl list-units –type target 获取默认运行级别 systemctl get-default 修改默认级别 systemctl set-default name.service 切换至紧急救援模式 systemctl rescue 切换至emergency模式 systemctl emergency 关机 systemctl halt systemctl poweroff 重启 systemctl reboot 挂起 systemctl suspend 快照 systemctl hibernate 快照并挂起 systemctl hybrid-sleep 6.3 查看服务详细信息 查看所有已激活的服务。默认只列出处于激活状态的服务，如果希望看到所有的服务，使用–all或-a参数：\nsh 1 systemctl list-units --type service 查看所有的服务\nsh 1 systemctl list-units --type service --all 检查服务开机启动状态\nsh 1 2 systemctl status name.service systemctl is-enabled name.service 列出所有服务并且检查是否开机启动\nsh 1 systemctl list-unit-files --type service 选项重新加载所以单元文件并重新创建依赖书，在需要立即应用单元文件改变的时候使用。另外，也可以使用init q的命令达到同样的目的。还有，如果修改的是一个正在运行服务的单元文件，服务需要被重启下：\nsh 1 2 systemct lrestart name.service systemctl daemon-reload 查看服务依赖关系\nsh 1 systemctl list-dependencies systemd target 在RHEL7之前的版本，使用运行级别代表特定的操作模式。运行级别被定义为七个级别，用数字0到6表示，每个级别可以启动特定的一些服务。RHEL7使用target替换运行基本。\nsystemd target使用target单元文件描述，target单位文件扩展名是.target，target单元文件的唯一目标是将其他systemd单元文件通过一连串的依赖关系组织在一起。举个例子，graphical.target单元，用于启动一个图形会话，systemd会启动像GNOME显示管理(gdm.service)、帐号服务（axxounts-daemon）这样的服务，并且会激活multi-user.target单元。相似的multi-user.target单元，会启动必不可少NetworkManager.service、dbus.service服务，并激活basic.target单元。\nRHEL7预定义了一些target和之前的运行级别或多或少有些不同。为了兼容，systemd也提供一些target映射为SysV init的运行级别，具体的对应信息如下：\n代码 命令 说明 0 runlevel0.target,poweroff.targe 关闭系统。 1 runlevel1.target,rescue.target 进入救援模式。 2 runlevel2.target,multi-user.target 进入非图形界面的多用户方式。 3 runlevel3.target,multi-user.target 进入非图形界面的多用户方式。 4 runlevel4.target,multi-user.target 进入非图形界面的多用户方式。 5 runlevel5.target,graphical.target 进入图形界面的多用户方式。 6 runlevel6.target,reboot.target 重启系统。 注：对于systemd来说 234没有区别\n7.1 target管理 使用如下命令查看目前可用的target：\nsh 1 systemctl list-units --type target 改变当前的运行基本使用如下命令：\nsh 1 2 3 4 systemctl isolate name.target systemctl isolate rescue.target $ runlevel 1 3 7.2 修改默认的运行级别 使用systemctl get-default命令得到默认的运行级别：\nsh 1 2 $ systemctl get-default multi-user.target 使用systemctl set-default name.target修改默认的运行级别：\nsh 1 2 3 4 systemctl set-default graphical.target # 可以看到。默认级别就是操作如下两步骤 rm '/etc/systemd/system/default.target' ln-s'/usr/lib/systemd/system/graphical.target''/etc/systemd/system/default.target' 使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用。 查看 multi-user.target 包含的所有服务\nsh 1 systemctl list-dependencies multi-user.target 一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。\n7.3 Target 的配置文件 Target 也有自己的配置文件。\nsh 1 2 3 4 5 6 7 8 9 10 11 12 13 [Unit] Description=Multi-User System Documentation=man:systemd.special(7) Requires=basic.target\t# Requires字段：要求basic.target一起运行。 # 冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。 Conflicts=rescue.service rescue.target # 表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。 After=basic.target rescue.service rescue.target # 允许使用systemctl isolate命令切换到multi-user.target。 AllowIsolate=yes 注意，Target 配置文件里面没有启动命令。\n7.4 救援模式和紧急模式 使用进入救援模式，如果连救援模式都进入不了，可以进入紧急模式：\nsh 1 2 systemctl rescue # 救援模式（进入救援模式，如果连救援模式都进入不了，可以进入紧急模式） systtmctl emergency # 紧急模式 紧急模式进入最小的系统环境，以便于修复系统。紧急模式根目录以只读方式挂载，不激活网络，只启动很少的服务，进入紧急模式需要root密码。\n关闭、暂停、休眠系统 RHEL7中，使用systemctl替换一些列的电源管理命令，原有的命令依旧可以使用，但是建议尽量不用使用。systemctl和这些命令的对应关系为：\n说明 SysV/Upstart system 停止系统（关机） halt systemctl hatl 关闭系统，关闭系统电源 poweroff systemctl poweroff 重启系统 reboot systemctl reboot 暂停系统 pm-suspend systemctl suspend 休眠系统 pm-hibernate systemct lhibernate 暂停并休眠系统 pm-suspend-hybrid systemctl hybrid-sleep 通过systemd管理远程系统 不光是可以管理本地系统，systemd还可以控制远程系统，管理远程系统主要是通过SSH协议，只有确认可以连接远程系统的SSH，在systemctl命令后面添加-H或者–host参数，加上远程系统的ip或者主机名就可以。\n创建和修改systemd单元文件 10.1 单元文件概述 一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。\n配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。找到配置文件以后，使用文本编辑器打开即可。\n下面以sshd.service文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。\nsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D $OPTIONS ExecReload=/bin/kill -HUP $MAINPID Type=simple KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ systemctl status rsyncd rsyncd.service - fast remote file copy program daemon Loaded: loaded (/usr/lib/systemd/system/rsyncd.service; disabled) # loaded 服务已经被加载，显示单元文件绝对路径，标志单元文件可用。 # disabled表示开机不允许启动Status服务的附件信息。 Active: active (running) since 四 2017-01-26 21:59:41 CST; 5min ago # active表示当前状态 从什么时间被激活 Main PID: 1360 (rsync) # main pid 与进程名字一致的PID，主进程PID。进程可能有多个进程可能有一组 CGroup: /system.slice/rsyncd.service └─1360 /usr/bin/rsync --daemon --no-detach # cgroup表示资源组，启动命令是/usr/bin/rsync --daemon --no-detach 1月 26 21:59:41 lnmp systemd[1]: Starting fast remote file copy program daemon... 1月 26 21:59:41 lnmp systemd[1]: Started fast remote file copy program daemon. $ systemctl status rsyncd rsyncd.service - fast remote file copy program daemon Loaded: loaded (/usr/lib/systemd/system/rsyncd.service; disabled) Active: inactive (dead)/ 上面的输出结果含义如下:\"\"\nLoaded行：配置文件的位置，是否设为开机启动 Active行：表示正在运行 Main PID行：主进程ID Status行：由应用本身（这里是 httpd ）提供的软件当前状态 Cgroup块：应用的所有子进程 日志块：应用的日志 10.2 理解单元文件结构 10.3 单元文件概述 可以看到，配置文件分成几个区块，每个区块包含若干条键值对。 典型的单元文件包含三节：\n[Unit]：包含不依赖单元类型的一般选项，这些选型提供单元描述，知道单元行为，配置单元和其他单元的依赖性。\n[unittype]：如果单元有特定的类型指令，在unittype节这些指令被组织在一起。举个例子，服务单元文件包含[Service]节，里面有经常使用的服务配置。\n[Install]：包含systemctl enable或者disable的命令安装信息。\n10.3.1 [Unit]节选项 字段 说明 Description 字段给出当前服务的简单描述 Documentation 给出文档位置。 启动顺序 注意:After和Before字段只涉及启动顺序，不涉及依赖关系 After 表示sshd.service应该在network.target sshd-keygen.service之后启动。 Before 定义sshd.service应该在哪些服务之前启动。 举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。 设置依赖关系，需要使用Wants字段和Requires字段。 Wants 表示sshd.service与sshd-keygen.service之间存在 “弱依赖” 关系，即如果\"sshd-keygen.service\"启动失败或停止运行，不影响sshd.service继续执行。 Requires 表示 “强依赖” 关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。 注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。 10.3.2 [Service] 区块：启动行为 Service区块定义如何启动当前服务。\n启动命令\n许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。\nEnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。\r上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。\n配置文件里面最重要的字段是ExecStart。\nExecStart：定义启动进程时执行的命令。\r上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。\n与之作用相似的，还有如下这些字段：\n选项 说明 ExecStart 指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。 ExecStop 指定单元停止时执行的命令或者脚本。 ExecReload 指定单元重新加载是执行的命令或者脚本。 ExecStartPre 启动服务之前执行的命令 ExecStartPost 启动服务之后执行的命令 ExecStopPost 停止服务之后执行的命令 Restart 这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。 RemainAfterExit 如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。 请看下面的例子。\nsh 1 2 3 4 5 6 [Service] ExecStart=/bin/echo execstart1 ExecStart= ExecStart=/bin/echo execstart2 ExecStartPost=/bin/echo 1 ExecStartPost=/bin/echo 2 上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。\nsh 1 2 3 4 5 6 7 8 9 10 $ systemctl start test $ systemctl status test test.service - test daemon Loaded: loaded (/usr/lib/systemd/system/test.service; disabled) Active: inactive (dead) 1月 30 07:11:16 lnmp systemd[1]: Starting test daemon... 1月 30 07:11:16 lnmp systemd[1]: Started test daemon. 1月 30 07:11:16 lnmp echo[1822]: test1_start 1月 30 07:11:16 lnmp echo[1824]: test1_stop 所有的启动设置之前，都可以加上一个连词号（-），表示“抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd 文件不存在，也不会抛出错误。\n启动类型\nType字段定义启动类型。它可以设置的值如下。\n选项值 说明 simple 默认值，ExecStart字段启动的进程为主进程 forking 进程作为服务主进程的一个子进程启动，父进程在完全启动之后退出。 oneshot 类似于simple，但只执行一次，进程在启动单元之后随之退出。 dbus 类似于simple，但随着单元启动后只有主进程得到D-BUS名字。 notify 类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务 idle 类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合 下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。\nsh 1 2 3 4 5 6 7 8 9 [Unit] Description=Switch-off Touchpad [Service] Type=oneshot ExecStart=/usr/bin/touchpad-off [Install] WantedBy=multi-user.target 上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。\n如果关闭以后，将来某个时候还想打开，配置文件修改如下。\nsh 1 2 3 4 5 6 7 8 9 10 11 [Unit] Description=Switch-off Touchpad [Service] Type=oneshot ExecStart=/usr/bin/touchpad-off start ExecStop=/usr/bin/touchpad-off stop RemainAfterExit=yes [Install] WantedBy=multi-user.target 上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。\n重启行为\nService区块有一些字段，定义了重启行为。\nsh 1 KillMode字段：定义 Systemd 如何停止 sshd 服务。 上面这个例子中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对sshd很重要，否则你停止服务的时候，会连自己打开的SSH session一起杀掉。\nKillMode字段可以设置的值如下：\n选项值 说明 control-group （默认值）\t当前控制组里面的所有子进程，都会被杀掉 process 只杀主进程 mixed 主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号 none 没有进程会被杀掉，只是执行服务的 stop 命令。 Restart字段。\nRestart字段：定义了 sshd 退出后，Systemd 的重启方式。\n上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。\nRestart字段可以设置的值如下。\n选项值 说明 no 默认值；退出后不会重启 on-success 只有正常退出时（退出状态码为0），才会重启 on-failure 非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启 on-abnormal 只有被信号终止和超时，才会重启 on-abort 只有在收到没有捕捉到的信号终止时，才会重启 on-watchdog 超时退出，才会重启 always 不管是什么退出原因，总是重启 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。\nRestartSec字段。\nRestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。\n[Install] 区块\r说明：Install区块，定义如何安装这个配置文件，即怎样做到开机启动。\rWantedBy字段：表示该服务所在的 Target。\rTarget的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。\n这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。\nSystemd 有默认的启动 Target。\nsh 1 2 $ systemctl get-default multi-user.target 上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。\n修改配置文件后重启\n修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。\nsh 1 2 # 重新加载配置文件 systemctl daemon-reload 10.4 一个postfix服务的例子： 单元文件位于/usr/lib/systemd/system/postifix.service，内容如下：\nsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [Unit] Description=PostfixMailTransportAgent After=syslog.targetnetwork.target Conflicts=sendmail.serviceexim.service [Service] Type=forking PIDFile=/var/spool/postfix/pid/master.pid EnvironmentFile=-/etc/sysconfig/network ExecStartPre=-/usr/libexec/postfix/aliasesdb ExecStartPre=-/usr/libexec/postfix/chroot-update ExecStart=/usr/sbin/postfixstart ExecReload=/usr/sbin/postfixreload ExecStop=/usr/sbin/postfixstop [Install] WantedBy=multi-user.target 10.5 创建自定义的单元文件 以下几种场景需要自定义单元文件：\n希望自己创建守护进程； 为现有的服务创建第二个实例； 引入SysV init脚本。 另外一方面，有时候需要修改已有的单元文件。下面介绍创建单元文件的步骤：\n准备自定义服务的执行文件。 可执行文件可以是脚本，也可以是软件提供者的的程序，如果需要，为自定义服务的主进程准备一个PID文件，一保证PID保持不变。另外还可能需要的配置环境变量的脚本，确保所以脚本都有可执行属性并且不需要交互。\n2.在/etc/systemd/system/目录创建单元文件，并且保证只能被root用户编辑\nsh 1 2 touch /etc/systemd/system/mariadb.service chmod 644 /etc/systemd/system/mariadb.service 注：文件不需要执行权限。\n打开name.service文件，添加服务配置，各种变量如何配置视所添加的服务类型而定，下面是一个依赖网络服务的配置例子： sh 1 2 3 4 5 6 7 8 9 10 11 12 13 [Unit] Description=mariadb multi demo 3306 After=network.target [Service] ExecStart=/data/3306/mysql start ExecReload=/data/3306/mysql restart ExecStop=/data/3306/mysql stop Type=forking PIDFile=/data/3306/mysqld.pid [Install] WantedBy=multi-user.target 4.通知systemd有个新服务添加：\nsh 1 2 systemctl daemon-reload systemctl start name.service 10.5 创建第二个sshd服务的例子\r1.拷贝sshd_config文件\nsh 1 2 cp /etc/ssh/sshd{,-second}_config # {,second} 等于 和second ，类似与 {a,c}的用法 2.编辑sshd-second_config文件，添加22220的端口，和PID文件：\ntext 1 2 Port 22220 PidFile /var/run/sshd-second.pid 如果还需要修改其他参数，请阅读帮助。\n3.拷贝单元文件：\nsh 1 cp /usr/lib/systemd/system/sshd{,-second}.service 4.编辑单元文件sshd-second.service\nsh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=OpenSSH server second instance daemon After=syslog.target network.targe tauditd.service sshd.service [Service] EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd -D -f /etc/ssh/sshd-second_config $OPTIONS ExecReload=/bin/kill -HUP $MAINPID KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 5.如果使用SELinux，添加tcp端口，负责第二sshd服务的端口就会被拒绝绑定：\nsh 1 semanage port -a -tssh_port_t -p tcp22220 6.设置开机启动并测试：\nsh 1 2 systemctl enable sshd-second.service ssh -p 22220 user@server 10.6 修改已经存在的单元文件 systemd unit配置文件默认保存在/usr/lib/systemd/system/目录，不建议直接修改这个目录下的文件，自定义的文件在/etc/systemd/system/目录下，如果有扩展的需求，可以使用以下方案：\n创建一个目录/etc/systemd/system/unit.d/，这个是最推荐的一种方式，可以参考初始的单元文件，通过附件配置文件来扩展默认的配置，对默认单元文件的升级会被自动升级和应用。\n从/usr/lib/systemd/system/拷贝一份原始配置文件到/etc/systemd/system/，然后修改。复制的版本会覆盖原始配置，这种方式不能增加附件的配置包，用于不需要附加功能的场景。\n如果需要恢复到默认的配置文件，只需要删除/etc/systemd/system/下的配置文件就可以了，不需要重启机器。\nReference [CentOS7/RHEL7 systemd详解](CentOS7/RHEL7 systemd详解)\nsystemd.index 中文手册\nSystemd 入门教程：实战篇\n","wordCount":"1248","inLanguage":"zh","datePublished":"2016-04-21T00:00:00Z","dateModified":"2023-03-22T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2016/04/systemd/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Linux服务管理 - systemd</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2016-04-21</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>1248 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>6 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/linux/>#Linux</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%85%b3%e4%ba%8elinux%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86 aria-label=关于Linux服务管理>关于Linux服务管理</a><ul><li><a href=#11-sysv-init%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label="1.1 SysV init的优缺点">1.1 SysV init的优缺点</a><li><a href=#12-upstart%e7%9a%84%e6%94%b9%e8%bf%9b aria-label="1.2 UpStart的改进">1.2 UpStart的改进</a><li><a href=#13-systemd%e7%9a%84%e8%af%9e%e7%94%9f aria-label="1.3 systemd的诞生">1.3 systemd的诞生</a><li><a href=#14-%e4%b8%ba%e4%bb%80%e4%b9%88systemd%e8%83%bd%e5%81%9a%e5%88%b0%e5%90%af%e5%8a%a8%e5%be%88%e5%bf%ab aria-label="1.4 为什么systemd能做到启动很快">1.4 为什么systemd能做到启动很快</a></ul><li><a href=#systemd%e7%9a%84%e7%89%b9%e6%80%a7 aria-label=systemd的特性>systemd的特性</a><li><a href=#centos-7%e7%9a%84systemd%e7%89%b9%e6%80%a7 aria-label="CentOS 7的systemd特性">CentOS 7的systemd特性</a><ul><li><a href=#31-%e5%a5%97%e6%8e%a5%e5%ad%97%e6%9c%8d%e5%8a%a1%e4%bf%9d%e6%8c%81%e6%bf%80%e6%b4%bb%e5%8a%9f%e8%83%bd aria-label="3.1 套接字服务保持激活功能">3.1 套接字服务保持激活功能</a><li><a href=#32-%e8%bf%9b%e7%a8%8b%e9%97%b4%e9%80%9a%e8%ae%af%e4%bf%9d%e6%8c%81%e6%bf%80%e6%b4%bb%e5%8a%9f%e8%83%bd aria-label="3.2 进程间通讯保持激活功能">3.2 进程间通讯保持激活功能</a><li><a href=#33-%e8%ae%be%e5%a4%87%e4%bf%9d%e6%8c%81%e6%bf%80%e6%b4%bb%e5%8a%9f%e8%83%bd aria-label="3.3 设备保持激活功能">3.3 设备保持激活功能</a><li><a href=#34-%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84%e4%bf%9d%e6%8c%81%e6%bf%80%e6%b4%bb%e5%8a%9f%e8%83%bd aria-label="3.4 文件路径保持激活功能">3.4 文件路径保持激活功能</a><li><a href=#35-%e7%b3%bb%e7%bb%9f%e7%8a%b6%e6%80%81%e5%bf%ab%e7%85%a7 aria-label="3.5 系统状态快照">3.5 系统状态快照</a><li><a href=#36-%e6%8c%82%e8%bd%bd%e5%92%8c%e8%87%aa%e5%8a%a8%e6%8c%82%e8%bd%bd%e7%82%b9%e7%ae%a1%e7%90%86 aria-label="3.6 挂载和自动挂载点管理">3.6 挂载和自动挂载点管理</a><li><a href=#37-%e9%97%aa%e7%94%b5%e5%b9%b6%e8%a1%8c%e5%90%af%e5%8a%a8 aria-label="3.7 闪电并行启动">3.7 闪电并行启动</a><li><a href=#38-%e5%8d%95%e5%85%83%e9%80%bb%e8%be%91%e6%a8%a1%e6%8b%9f%e6%a3%80%e6%9f%a5 aria-label="3.8 单元逻辑模拟检查">3.8 单元逻辑模拟检查</a><li><a href=#39-%e5%92%8csysv-init%e5%90%91%e5%90%8e%e5%85%bc%e5%ae%b9 aria-label="3.9 和SysV init向后兼容">3.9 和SysV init向后兼容</a></ul><li><a href=#%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5unit aria-label=核心概念:unit>核心概念:unit</a><ul><li><a href=#41-%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e5%85%83 aria-label="4.1 什么是单元">4.1 什么是单元</a><li><a href=#42-unit%e7%b1%bb%e5%9e%8b aria-label="4.2 Unit类型">4.2 Unit类型</a></ul><li><a href=#centos-7%e7%9a%84systemd%e5%90%91%e5%90%8e%e5%85%bc%e5%ae%b9 aria-label="CentOS 7的systemd向后兼容">CentOS 7的systemd向后兼容</a><ul><li><a href=#51-systemd%e5%af%b9%e8%bf%90%e8%a1%8c%e7%ba%a7%e5%88%ab%e6%94%af%e6%8c%81%e6%9c%89%e9%99%90 aria-label="5.1 systemd对运行级别支持有限">5.1 systemd对运行级别支持有限</a><li><a href=#52-systemd%e4%b8%8d%e6%94%af%e6%8c%81%e5%83%8finit%e8%84%9a%e6%9c%ac%e9%82%a3%e6%a0%b7%e7%9a%84%e4%b8%aa%e6%80%a7%e5%8c%96%e5%91%bd%e4%bb%a4 aria-label="5.2 systemd不支持像init脚本那样的个性化命令。">5.2 systemd不支持像init脚本那样的个性化命令。</a><li><a href=#53-systemd%e4%b8%8d%e6%94%af%e6%8c%81%e5%92%8c%e6%b2%a1%e6%9c%89%e4%bb%8esystemd%e5%90%af%e5%8a%a8%e7%9a%84%e6%9c%8d%e5%8a%a1%e9%80%9a%e8%ae%af aria-label="5.3 systemd不支持和没有从systemd启动的服务通讯。">5.3 systemd不支持和没有从systemd启动的服务通讯。</a><li><a href=#54-systemd%e5%8f%af%e4%bb%a5%e5%8f%aa%e5%81%9c%e6%ad%a2%e8%bf%90%e8%a1%8c%e7%9a%84%e6%9c%8d%e5%8a%a1 aria-label="5.4 systemd可以只停止运行的服务">5.4 systemd可以只停止运行的服务</a><li><a href=#55-%e4%b8%8d%e8%83%bd%e4%bb%8e%e6%a0%87%e5%87%86%e8%be%93%e5%87%ba%e8%ae%be%e5%a4%87%e8%af%bb%e5%88%b0%e7%b3%bb%e7%bb%9f%e6%9c%8d%e5%8a%a1%e4%bf%a1%e6%81%af aria-label="5.5 不能从标准输出设备读到系统服务信息。">5.5 不能从标准输出设备读到系统服务信息。</a><li><a href=#56-systemd%e4%b8%8d%e7%bb%a7%e6%89%bf%e4%bb%bb%e4%bd%95%e4%b8%8a%e4%b8%8b%e6%96%87%e7%8e%af%e5%a2%83 aria-label="5.6 systemd不继承任何上下文环境。">5.6 systemd不继承任何上下文环境。</a><li><a href=#57-sysv-init%e8%84%9a%e6%9c%ac%e4%be%9d%e8%b5%96%e6%80%a7 aria-label="5.7 SysV init脚本依赖性">5.7 SysV init脚本依赖性</a><li><a href=#58-%e8%b6%85%e6%97%b6%e6%9c%ba%e5%88%b6 aria-label="5.8 超时机制">5.8 超时机制</a></ul><li><a href=#systemd%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86 aria-label=systemd服务管理>systemd服务管理</a><ul><li><a href=#61-%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label="6.1 常用命令">6.1 常用命令</a><li><a href=#62-%e6%9c%8d%e5%8a%a1%e7%ae%a1%e7%90%86 aria-label="6.2 服务管理">6.2 服务管理</a><li><a href=#63-%e6%9f%a5%e7%9c%8b%e6%9c%8d%e5%8a%a1%e8%af%a6%e7%bb%86%e4%bf%a1%e6%81%af aria-label="6.3 查看服务详细信息">6.3 查看服务详细信息</a></ul><li><a href=#systemd-target aria-label="systemd target">systemd target</a><ul><li><a href=#71-target%e7%ae%a1%e7%90%86 aria-label="7.1 target管理">7.1 target管理</a><li><a href=#72-%e4%bf%ae%e6%94%b9%e9%bb%98%e8%ae%a4%e7%9a%84%e8%bf%90%e8%a1%8c%e7%ba%a7%e5%88%ab aria-label="7.2 修改默认的运行级别">7.2 修改默认的运行级别</a><li><a href=#73-target-%e7%9a%84%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-label="7.3 Target 的配置文件">7.3 Target 的配置文件</a><li><a href=#74-%e6%95%91%e6%8f%b4%e6%a8%a1%e5%bc%8f%e5%92%8c%e7%b4%a7%e6%80%a5%e6%a8%a1%e5%bc%8f aria-label="7.4 救援模式和紧急模式">7.4 救援模式和紧急模式</a></ul><li><a href=#%e5%85%b3%e9%97%ad%e6%9a%82%e5%81%9c%e4%bc%91%e7%9c%a0%e7%b3%bb%e7%bb%9f aria-label=关闭、暂停、休眠系统>关闭、暂停、休眠系统</a><li><a href=#%e9%80%9a%e8%bf%87systemd%e7%ae%a1%e7%90%86%e8%bf%9c%e7%a8%8b%e7%b3%bb%e7%bb%9f aria-label=通过systemd管理远程系统>通过systemd管理远程系统</a><li><a href=#%e5%88%9b%e5%bb%ba%e5%92%8c%e4%bf%ae%e6%94%b9systemd%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6 aria-label=创建和修改systemd单元文件>创建和修改systemd单元文件</a><ul><li><a href=#101-%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6%e6%a6%82%e8%bf%b0 aria-label="10.1 单元文件概述">10.1 单元文件概述</a><li><a href=#102-%e7%90%86%e8%a7%a3%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label="10.2 理解单元文件结构">10.2 理解单元文件结构</a><li><a href=#103-%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6%e6%a6%82%e8%bf%b0 aria-label="10.3 单元文件概述">10.3 单元文件概述</a><ul><li><a href=#1031-unit%e8%8a%82%e9%80%89%e9%a1%b9 aria-label="10.3.1 [Unit]节选项">10.3.1 [Unit]节选项</a><li><a href=#1032-service-%e5%8c%ba%e5%9d%97%e5%90%af%e5%8a%a8%e8%a1%8c%e4%b8%ba aria-label="10.3.2 [Service] 区块：启动行为">10.3.2 [Service] 区块：启动行为</a></ul><li><a href=#104-%e4%b8%80%e4%b8%aapostfix%e6%9c%8d%e5%8a%a1%e7%9a%84%e4%be%8b%e5%ad%90 aria-label="10.4 一个postfix服务的例子：">10.4 一个postfix服务的例子：</a><ul><li><a href=#105-%e5%88%9b%e5%bb%ba%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6 aria-label="10.5 创建自定义的单元文件">10.5 创建自定义的单元文件</a><li><a href=#106-%e4%bf%ae%e6%94%b9%e5%b7%b2%e7%bb%8f%e5%ad%98%e5%9c%a8%e7%9a%84%e5%8d%95%e5%85%83%e6%96%87%e4%bb%b6 aria-label="10.6 修改已经存在的单元文件">10.6 修改已经存在的单元文件</a></ul></ul><li><a href=#reference aria-label=Reference>Reference</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=关于linux服务管理>关于Linux服务管理<a hidden class=anchor aria-hidden=true href=#关于linux服务管理>#</a></h2><p>Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。
SysV init UpStart systemd主要是解决服务引导管理的问题。</p><ul><li>CentOS 5：SysV init</li><li>CentOS 6：Upstart</li><li>CentOS 7：Systemd <a href=http://www.linuxidc.com/Linux/2015-04/115937.htm target=_blank rel="noopener nofollow noreferrer">http://www.linuxidc.com/Linux/2015-04/115937.htm</a></li></ul><h3 id=11-sysv-init的优缺点>1.1 SysV init的优缺点<a hidden class=anchor aria-hidden=true href=#11-sysv-init的优缺点>#</a></h3><p>SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。</p><p>SysV init方案的优点：</p><ul><li>1.原理简单，易于理解；</li><li>2.依靠shell脚本控制，编写服务脚本门槛比较低。</li></ul><p>缺点是：</p><ul><li>1.服务顺序启动，启动过程比较慢。</li><li>2.不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。</li></ul><h3 id=12-upstart的改进>1.2 UpStart的改进<a hidden class=anchor aria-hidden=true href=#12-upstart的改进>#</a></h3><p>为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。</p><h3 id=13-systemd的诞生>1.3 systemd的诞生<a hidden class=anchor aria-hidden=true href=#13-systemd的诞生>#</a></h3><p>SysV init服务启动慢，在以前并不是一个问题，尤其是Linux系统以前主要是在服务器系统上，常年也难得重启一次。有的服务器光硬件检测都需要5分钟以上，相对来说系统启动已经很快了。</p><p>但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。</p><p><strong>systemd的设计思路是</strong>：</p><ul><li>尽可能的快速启动服务。</li><li>尽可能的减少系统资源占用。</li></ul><h3 id=14-为什么systemd能做到启动很快>1.4 为什么systemd能做到启动很快<a hidden class=anchor aria-hidden=true href=#14-为什么systemd能做到启动很快>#</a></h3><p>systemd使用并行的方法启动服务，不像SysV init是顺序执行的，所以大大节省了系统启动时间。</p><p>使用并行启动，最大的难点是要解决服务之间的依赖性，systemd的解决办法是使用类似缓冲池的办法。比如对TCP有依赖的服务，在启动的时候会检查依赖服务的TCP端口，systemd会把对TCP端口的请求先缓存起来，当依赖的服务器启动之后，在将请求传递给服务，使两个服务通讯。同样的进程间通讯的D-BUS也是这样的原理，目录挂载则是先让服务以为目录被挂载了，到真正访问目录的时候，才去真正操作。</p><h2 id=systemd的特性>systemd的特性<a hidden class=anchor aria-hidden=true href=#systemd的特性>#</a></h2><p><strong>systemd解决了那些问题？</strong></p><ul><li>按需启动服务，减少系统资源消耗；</li><li>尽可能并行启动进程，减少系统启动等待时间；</li><li>提供一个一致的配置环境，不光是服务配置；</li><li>提供服务状态快照，可以恢复特定点的服务状态。</li></ul><h2 id=centos-7的systemd特性>CentOS 7的systemd特性<a hidden class=anchor aria-hidden=true href=#centos-7的systemd特性>#</a></h2><h3 id=31-套接字服务保持激活功能>3.1 套接字服务保持激活功能<a hidden class=anchor aria-hidden=true href=#31-套接字服务保持激活功能>#</a></h3><p>在系统启动的时候，systemd为所有支持套接字激活功能的服务创建监听端口，当服务启动后，就将套接字传给这些服务。这种方式不仅可以允许服务在启动的时候平行启动，也可以保证在服务重启期间，试图连接服务的请求，不会丢失。对服务端口的请求被保留，并且存放到队列中。</p><h3 id=32-进程间通讯保持激活功能>3.2 进程间通讯保持激活功能<a hidden class=anchor aria-hidden=true href=#32-进程间通讯保持激活功能>#</a></h3><p>当有客户端应用第一次通过D-Bus方式请求进程间通讯时，systemd会立即启动对应的服务。systemd依据D-Bus的配置文件使用进程间通讯保持激活功能。</p><h3 id=33-设备保持激活功能>3.3 设备保持激活功能<a hidden class=anchor aria-hidden=true href=#33-设备保持激活功能>#</a></h3><p>当特定的硬件插入时，systemd启动对应的硬件服务支持。systemd依据硬件服务单元配置文件保持硬件随时被激活。</p><h3 id=34-文件路径保持激活功能>3.4 文件路径保持激活功能<a hidden class=anchor aria-hidden=true href=#34-文件路径保持激活功能>#</a></h3><p>当特定的文件或者路径状态发生改变的时候，systemd会激活对应的服务。systemd依据路径服务单元配置文件保证服务被激活。</p><h3 id=35-系统状态快照>3.5 系统状态快照<a hidden class=anchor aria-hidden=true href=#35-系统状态快照>#</a></h3><p>systemd可以临时保存当前所有的单元配置文件，或者从前一个快照中恢复单元配置文件。为了保存当前系统服务状态，systemd可以动态的生成单元文件快照。</p><h3 id=36-挂载和自动挂载点管理>3.6 挂载和自动挂载点管理<a hidden class=anchor aria-hidden=true href=#36-挂载和自动挂载点管理>#</a></h3><p>systemd监控和管理挂载和自动挂载点，并根据挂载点的单元配置文件进行挂载。</p><h3 id=37-闪电并行启动>3.7 闪电并行启动<a hidden class=anchor aria-hidden=true href=#37-闪电并行启动>#</a></h3><p>因为使用套接字保持激活功能，systemd可以并行的启动所以套接字监听服务，大大减少系统启动时间。</p><h3 id=38-单元逻辑模拟检查>3.8 单元逻辑模拟检查<a hidden class=anchor aria-hidden=true href=#38-单元逻辑模拟检查>#</a></h3><p>当激活或者关闭一个单元，systemd会计算依赖行，产生一个临时的模拟检查，并且校验一直性。如果不一致，systemd会尝试自动修正，并且移除报错的不重要的任务。</p><h3 id=39-和sysv-init向后兼容>3.9 和SysV init向后兼容<a hidden class=anchor aria-hidden=true href=#39-和sysv-init向后兼容>#</a></h3><p>systemd完全支持SysV init Linux标准的基础核心规范脚本，这样的脚本易于升级到systemd服务单元。</p><h2 id=核心概念unit>核心概念:unit<a hidden class=anchor aria-hidden=true href=#核心概念unit>#</a></h2><h3 id=41-什么是单元>4.1 什么是单元<a hidden class=anchor aria-hidden=true href=#41-什么是单元>#</a></h3><p>在RHEL7之前，服务管理是分布式的被SysV init或UpStart通过 <font color=#f8070d size=3><code>/etc/rc.d/init.d</code></font> 下的脚本管理。这些脚本是经典的Bash脚本，允许管理员控制服务的状态。在RHEL7中，这些脚本被服务单元文件替换。</p><p>在systemd中，服务、挂载等资源统一被称为单元，所以systemd中有许多单元类型，服务单元文件的扩展名是.service，同脚本的功能相似。例如有查看、启动、停止、重启、启用或者禁止服务的参数。</p><p>配置文件进行标识和配置：文件中主要包含了系统服务、监听socket、保存的系统快照及其他与init相关的信息。</p><p><strong>systemd单元文件放置位置</strong>：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>/usr/lib/systemd/system/systemd		<span class=c1># 默认单元文件安装目录</span>
</span></span><span class=line><span class=cl>/run/systemd/system					      <span class=c1># 单元运行时创建，这个目录优先于安装目录</span>
</span></span><span class=line><span class=cl>/etc/systemd/system					      <span class=c1># 系统管理员创建和管理的单元目录，优先级最高。</span></span></span></code></pre></td></tr></table></div></div></div></div><h3 id=42-unit类型>4.2 Unit类型<a hidden class=anchor aria-hidden=true href=#42-unit类型>#</a></h3><table><thead><tr><th>类型</th><th>详解-</th></tr></thead><tbody><tr><td>Service unit</td><td>文件扩展名为service，用于定义系统服务。</td></tr><tr><td>Target unit</td><td>文件扩展名为.target，用于模拟实现“运行级别”</td></tr><tr><td>Device unit</td><td>文件扩展名为.device，用于定义内核识别的设备。</td></tr><tr><td>Mount unit</td><td>文件扩展名为.mount，定义文件系统挂载点</td></tr><tr><td>Socket unit</td><td>文件扩展名为.socket，用于表示进程间通信用的socket文件</td></tr><tr><td>Snapshot unit</td><td>文件扩展名为.sanpshot，管理系统快照</td></tr><tr><td>Swap unit</td><td>文件扩展名为.swap，用于表示swap设备</td></tr><tr><td>Automount unit</td><td>文件扩展名为.automount，文件系统的自动挂载点</td></tr><tr><td>Path unit</td><td>文件扩展名为.path，用于定义文件系统中的一个文件或目录</td></tr></tbody></table><p><code>.service</code> 与服务对应的后缀名为service的unit、文件，无需执行权限，仅仅为systemd的配置文件。当systemd探测到有进程访问时，按需激活这个服务的机制，任何依赖与这个服务的其他服务想启动的话，</p><p>服务的并行启动：</p><p><code>.device</code> 在某个硬件设备被激活或变得可用时，从而激活服务</p><p><code>.path</code>：某个文件路径变得可用或里面有文件时（文件发生变动）激活某个服务</p><p><strong>系统快照</strong>：</p><p>systemd能将所有unit当前状态保存到临时文件中（临时保存到一个持久设备上）。启动时，可从保存的快照开始继续向后运行。 必要时能自动载入。</p><p><strong>向后兼容</strong>：</p><p>sysV init脚本。（能够兼容 start、stop restart status至少这4个服务脚本）以前启动服务的脚本放到centos7里直接可以用。</p><h2 id=centos-7的systemd向后兼容>CentOS 7的systemd向后兼容<a hidden class=anchor aria-hidden=true href=#centos-7的systemd向后兼容>#</a></h2><p>systemd被设计成尽可能向后兼容SysV init和Upstart，下面是一些特别要注意的和之前主要版本的RHEL不再兼容的部分。</p><h3 id=51-systemd对运行级别支持有限>5.1 systemd对运行级别支持有限<a hidden class=anchor aria-hidden=true href=#51-systemd对运行级别支持有限>#</a></h3><p>为了保存兼容，systemd提供有限target单元，“模拟”一些运行级别，也可以被早期的分布式的运行级别命令支持。不是所有的target都可以被映射到运行级别，在这种情况下，使用runlevel命令有可能会返回一个为N的不知道的运行级别，所以推荐尽量避免在RHEL7中使用runlevel命令。</p><h3 id=52-systemd不支持像init脚本那样的个性化命令>5.2 systemd不支持像init脚本那样的个性化命令。<a hidden class=anchor aria-hidden=true href=#52-systemd不支持像init脚本那样的个性化命令>#</a></h3><p>除了一些标准命令参数例如：start、stop、status，SysV init脚本可以根据需要支持想要的任何参数，通过参数提供附加的功能，因为SysV init的服务器脚本实际上就是shell脚本，命令参数实际上就是shell子函数。</p><p>举个例子，RHEL6的iptables服务脚本可以执行panic命令行参数，这个参数可以让系统立即进入紧急模式，丢弃所有的进入和发出的数据包。但是类似这样的命令行参数在systemd中是不支持的，systemd只支持在配置文件中指定命令行参数。</p><h3 id=53-systemd不支持和没有从systemd启动的服务通讯>5.3 systemd不支持和没有从systemd启动的服务通讯。<a hidden class=anchor aria-hidden=true href=#53-systemd不支持和没有从systemd启动的服务通讯>#</a></h3><p>当systemd启动服务的时候，他保存进程的主ID以便于追踪，systemctl工具使用进程PID查询和管理服务。相反的，如果用户从命令行启动特定的服务，systemctl命令是没有办法判断这个服务的状态是启动还是运行的。</p><h3 id=54-systemd可以只停止运行的服务>5.4 systemd可以只停止运行的服务<a hidden class=anchor aria-hidden=true href=#54-systemd可以只停止运行的服务>#</a></h3><p>在RHEL6及之前的版本，当关闭系统的程序启动之后，RHEL6的系统会执行/etc/rc0.d/下所有服务脚本的关闭操作，不管服务是处于运行或者根本没有运行的状态。而systemd可以做到只关闭在运行的服务，这样可以大大节省关机的时间。</p><h3 id=55-不能从标准输出设备读到系统服务信息>5.5 不能从标准输出设备读到系统服务信息。<a hidden class=anchor aria-hidden=true href=#55-不能从标准输出设备读到系统服务信息>#</a></h3><p>systemd启动服务的时候，将标准输出信息定向到/dev/null，以免打扰用户。</p><h3 id=56-systemd不继承任何上下文环境>5.6 systemd不继承任何上下文环境。<a hidden class=anchor aria-hidden=true href=#56-systemd不继承任何上下文环境>#</a></h3><p>systemd不继承任何上下文环境，如用户或者会话的HOME或者PATH的环境变量。每个服务得到的是干净的上下文环境。</p><h3 id=57-sysv-init脚本依赖性>5.7 SysV init脚本依赖性<a hidden class=anchor aria-hidden=true href=#57-sysv-init脚本依赖性>#</a></h3><p>当systemd启动SysV init脚本，systemd在运行的时候，从LinuxStandardBase(LSB)Linux标准库头文件读取服务的依赖信息并继承。</p><h3 id=58-超时机制>5.8 超时机制<a hidden class=anchor aria-hidden=true href=#58-超时机制>#</a></h3><p>为了防止系统被卡住，所有的服务有5分钟的超时机制。</p><h2 id=systemd服务管理>systemd服务管理<a hidden class=anchor aria-hidden=true href=#systemd服务管理>#</a></h2><p>使用systemcl命令可以控制服务，service命令和chkconfig命令依然可以使用，但是主要是出于兼容的原因，应该尽量避免使用service命令和chkconfig命令。</p><p>使用systemctl命令的时候，服务名字的扩展名可以写全，例如：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl stop httpd.service</span></span></code></pre></td></tr></table></div></div></div></div><p>也可以忽略，例如：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl stop httpd</span></span></code></pre></td></tr></table></div></div></div></div><h3 id=61-常用命令>6.1 常用命令<a hidden class=anchor aria-hidden=true href=#61-常用命令>#</a></h3><h3 id=62-服务管理>6.2 服务管理<a hidden class=anchor aria-hidden=true href=#62-服务管理>#</a></h3><table><thead><tr><th>说明</th><th>命令</th></tr></thead><tbody><tr><td>启动服务</td><td>service name start == systemctl start name.service</td></tr><tr><td>停止服务</td><td>service name stop == systemctl stop name.service</td></tr><tr><td>重启服务</td><td>service name restart == systemctl restart name.service</td></tr><tr><td>查看服务状态</td><td>service name status == systemctl status name.service</td></tr><tr><td>条件式重启</td><td>service name condrestart == systemctl try-restart name.service</td></tr><tr><td>重载或重启服务</td><td>systemctl reload-or-restart name.service</td></tr><tr><td>重载或条件式重启</td><td>systemctl reload-or-try-restart name.service</td></tr><tr><td>禁止设定为开机自启动</td><td>systemctl mask name.service</td></tr><tr><td>取消设定为开机自启动</td><td>systemctl unmask name.service</td></tr><tr><td>查看服务当前激活与否的状态</td><td>systemctl is-active name.service</td></tr><tr><td>允许服务开机启动</td><td>systemctl enable name.service</td></tr><tr><td>禁止服务开机启动</td><td>systemclt disable name.service</td></tr><tr><td>级别切换</td><td>systemctl list-units &ndash;type target</td></tr><tr><td>获取默认运行级别</td><td>systemctl get-default</td></tr><tr><td>修改默认级别</td><td>systemctl set-default name.service</td></tr><tr><td>切换至紧急救援模式</td><td>systemctl rescue</td></tr><tr><td>切换至emergency模式</td><td>systemctl emergency</td></tr><tr><td>关机</td><td>systemctl halt systemctl poweroff</td></tr><tr><td>重启</td><td>systemctl reboot</td></tr><tr><td>挂起</td><td>systemctl suspend</td></tr><tr><td>快照</td><td>systemctl hibernate</td></tr><tr><td>快照并挂起</td><td>systemctl hybrid-sleep</td></tr></tbody></table><h3 id=63-查看服务详细信息>6.3 查看服务详细信息<a hidden class=anchor aria-hidden=true href=#63-查看服务详细信息>#</a></h3><p>查看所有已激活的服务。默认只列出处于激活状态的服务，如果希望看到所有的服务，使用&ndash;all或-a参数：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-units --type service</span></span></code></pre></td></tr></table></div></div></div></div><p>查看所有的服务</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-units --type service --all</span></span></code></pre></td></tr></table></div></div></div></div><p>检查服务开机启动状态</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl status name.service
</span></span><span class=line><span class=cl>systemctl is-enabled name.service</span></span></code></pre></td></tr></table></div></div></div></div><p>列出所有服务并且检查是否开机启动</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-unit-files --type service</span></span></code></pre></td></tr></table></div></div></div></div><p>选项重新加载所以单元文件并重新创建依赖书，在需要立即应用单元文件改变的时候使用。另外，也可以使用init q的命令达到同样的目的。还有，如果修改的是一个正在运行服务的单元文件，服务需要被重启下：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemct lrestart name.service
</span></span><span class=line><span class=cl>systemctl daemon-reload</span></span></code></pre></td></tr></table></div></div></div></div><p>查看服务依赖关系</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-dependencies</span></span></code></pre></td></tr></table></div></div></div></div><h2 id=systemd-target>systemd target<a hidden class=anchor aria-hidden=true href=#systemd-target>#</a></h2><p>在RHEL7之前的版本，使用运行级别代表特定的操作模式。运行级别被定义为七个级别，用数字0到6表示，每个级别可以启动特定的一些服务。RHEL7使用target替换运行基本。</p><p>systemd target使用target单元文件描述，target单位文件扩展名是.target，target单元文件的唯一目标是将其他systemd单元文件通过一连串的依赖关系组织在一起。举个例子，graphical.target单元，用于启动一个图形会话，systemd会启动像GNOME显示管理(gdm.service)、帐号服务（axxounts-daemon）这样的服务，并且会激活multi-user.target单元。相似的multi-user.target单元，会启动必不可少NetworkManager.service、dbus.service服务，并激活basic.target单元。</p><p>RHEL7预定义了一些target和之前的运行级别或多或少有些不同。为了兼容，systemd也提供一些target映射为SysV init的运行级别，具体的对应信息如下：</p><table><thead><tr><th>代码</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>runlevel0.target,poweroff.targe</td><td>关闭系统。</td></tr><tr><td>1</td><td>runlevel1.target,rescue.target</td><td>进入救援模式。</td></tr><tr><td>2</td><td>runlevel2.target,multi-user.target</td><td>进入非图形界面的多用户方式。</td></tr><tr><td>3</td><td>runlevel3.target,multi-user.target</td><td>进入非图形界面的多用户方式。</td></tr><tr><td>4</td><td>runlevel4.target,multi-user.target</td><td>进入非图形界面的多用户方式。</td></tr><tr><td>5</td><td>runlevel5.target,graphical.target</td><td>进入图形界面的多用户方式。</td></tr><tr><td>6</td><td>runlevel6.target,reboot.target</td><td>重启系统。</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><hr><p>注：对于systemd来说 234没有区别</p><hr><h3 id=71-target管理>7.1 target管理<a hidden class=anchor aria-hidden=true href=#71-target管理>#</a></h3><p>使用如下命令查看目前可用的target：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-units --type target</span></span></code></pre></td></tr></table></div></div></div></div><p>改变当前的运行基本使用如下命令：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl isolate name.target
</span></span><span class=line><span class=cl>systemctl isolate rescue.target
</span></span><span class=line><span class=cl>$ runlevel 
</span></span><span class=line><span class=cl><span class=m>1</span> <span class=m>3</span></span></span></code></pre></td></tr></table></div></div></div></div><h3 id=72-修改默认的运行级别>7.2 修改默认的运行级别<a hidden class=anchor aria-hidden=true href=#72-修改默认的运行级别>#</a></h3><p>使用systemctl get-default命令得到默认的运行级别：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ systemctl get-default 
</span></span><span class=line><span class=cl>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><p>使用systemctl set-default name.target修改默认的运行级别：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl set-default graphical.target 
</span></span><span class=line><span class=cl><span class=c1># 可以看到。默认级别就是操作如下两步骤</span>
</span></span><span class=line><span class=cl>rm <span class=s1>&#39;/etc/systemd/system/default.target&#39;</span>
</span></span><span class=line><span class=cl>ln-s<span class=s1>&#39;/usr/lib/systemd/system/graphical.target&#39;&#39;/etc/systemd/system/default.target&#39;</span></span></span></code></pre></td></tr></table></div></div></div></div><p>使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用。
查看 multi-user.target 包含的所有服务</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl list-dependencies multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><p>一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。</p><h3 id=73-target-的配置文件>7.3 Target 的配置文件<a hidden class=anchor aria-hidden=true href=#73-target-的配置文件>#</a></h3><p>Target 也有自己的配置文件。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>Multi-User System
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:systemd.special<span class=o>(</span>7<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>Requires</span><span class=o>=</span>basic.target		<span class=c1># Requires字段：要求basic.target一起运行。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。</span>
</span></span><span class=line><span class=cl><span class=nv>Conflicts</span><span class=o>=</span>rescue.service rescue.target
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。</span>
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>basic.target rescue.service rescue.target
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 允许使用systemctl isolate命令切换到multi-user.target。</span>
</span></span><span class=line><span class=cl><span class=nv>AllowIsolate</span><span class=o>=</span>yes</span></span></code></pre></td></tr></table></div></div></div></div><p>注意，Target 配置文件里面没有启动命令。</p><h3 id=74-救援模式和紧急模式>7.4 救援模式和紧急模式<a hidden class=anchor aria-hidden=true href=#74-救援模式和紧急模式>#</a></h3><p>使用进入救援模式，如果连救援模式都进入不了，可以进入紧急模式：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl rescue 	  <span class=c1># 救援模式（进入救援模式，如果连救援模式都进入不了，可以进入紧急模式）</span>
</span></span><span class=line><span class=cl>systtmctl emergency <span class=c1># 紧急模式</span></span></span></code></pre></td></tr></table></div></div></div></div><p>紧急模式进入最小的系统环境，以便于修复系统。紧急模式根目录以只读方式挂载，不激活网络，只启动很少的服务，进入紧急模式需要root密码。</p><h2 id=关闭暂停休眠系统>关闭、暂停、休眠系统<a hidden class=anchor aria-hidden=true href=#关闭暂停休眠系统>#</a></h2><p>RHEL7中，使用systemctl替换一些列的电源管理命令，原有的命令依旧可以使用，但是建议尽量不用使用。systemctl和这些命令的对应关系为：</p><table><thead><tr><th>说明</th><th>SysV/Upstart</th><th>system</th></tr></thead><tbody><tr><td>停止系统（关机）</td><td>halt</td><td>systemctl hatl</td></tr><tr><td>关闭系统，关闭系统电源</td><td>poweroff</td><td>systemctl poweroff</td></tr><tr><td>重启系统</td><td>reboot</td><td>systemctl reboot</td></tr><tr><td>暂停系统</td><td>pm-suspend</td><td>systemctl suspend</td></tr><tr><td>休眠系统</td><td>pm-hibernate</td><td>systemct lhibernate</td></tr><tr><td>暂停并休眠系统</td><td>pm-suspend-hybrid</td><td>systemctl hybrid-sleep</td></tr></tbody></table><h2 id=通过systemd管理远程系统>通过systemd管理远程系统<a hidden class=anchor aria-hidden=true href=#通过systemd管理远程系统>#</a></h2><p>不光是可以管理本地系统，systemd还可以控制远程系统，管理远程系统主要是通过SSH协议，只有确认可以连接远程系统的SSH，在systemctl命令后面添加-H或者&ndash;host参数，加上远程系统的ip或者主机名就可以。</p><h2 id=创建和修改systemd单元文件>创建和修改systemd单元文件<a hidden class=anchor aria-hidden=true href=#创建和修改systemd单元文件>#</a></h2><h3 id=101-单元文件概述>10.1 单元文件概述<a hidden class=anchor aria-hidden=true href=#101-单元文件概述>#</a></h3><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。找到配置文件以后，使用文本编辑器打开即可。</p><p>下面以sshd.service文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>OpenSSH server daemon
</span></span><span class=line><span class=cl><span class=nv>Documentation</span><span class=o>=</span>man:sshd<span class=o>(</span>8<span class=o>)</span> man:sshd_config<span class=o>(</span>5<span class=o>)</span>
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>network.target sshd-keygen.service
</span></span><span class=line><span class=cl><span class=nv>Wants</span><span class=o>=</span>sshd-keygen.service
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>EnvironmentFile</span><span class=o>=</span>/etc/sysconfig/sshd
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/sbin/sshd -D <span class=nv>$OPTIONS</span>
</span></span><span class=line><span class=cl><span class=nv>ExecReload</span><span class=o>=</span>/bin/kill -HUP <span class=nv>$MAINPID</span>
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>simple
</span></span><span class=line><span class=cl><span class=nv>KillMode</span><span class=o>=</span>process
</span></span><span class=line><span class=cl><span class=nv>Restart</span><span class=o>=</span>on-failure
</span></span><span class=line><span class=cl><span class=nv>RestartSec</span><span class=o>=</span>42s
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ systemctl status rsyncd
</span></span><span class=line><span class=cl>rsyncd.service - fast remote file copy program daemon
</span></span><span class=line><span class=cl>   Loaded: loaded <span class=o>(</span>/usr/lib/systemd/system/rsyncd.service<span class=p>;</span> disabled<span class=o>)</span> 
</span></span><span class=line><span class=cl>   <span class=c1># loaded 服务已经被加载，显示单元文件绝对路径，标志单元文件可用。</span>
</span></span><span class=line><span class=cl>   <span class=c1># disabled表示开机不允许启动Status服务的附件信息。</span>
</span></span><span class=line><span class=cl>   Active: active <span class=o>(</span>running<span class=o>)</span> since 四 2017-01-26 21:59:41 CST<span class=p>;</span> 5min ago
</span></span><span class=line><span class=cl>   <span class=c1># active表示当前状态  从什么时间被激活</span>
</span></span><span class=line><span class=cl> Main PID: <span class=m>1360</span> <span class=o>(</span>rsync<span class=o>)</span> <span class=c1># main pid 与进程名字一致的PID，主进程PID。进程可能有多个进程可能有一组</span>
</span></span><span class=line><span class=cl>   CGroup: /system.slice/rsyncd.service
</span></span><span class=line><span class=cl>           └─1360 /usr/bin/rsync --daemon --no-detach
</span></span><span class=line><span class=cl><span class=c1># cgroup表示资源组，启动命令是/usr/bin/rsync --daemon --no-detach</span>
</span></span><span class=line><span class=cl>1月 <span class=m>26</span> 21:59:41 lnmp systemd<span class=o>[</span>1<span class=o>]</span>: Starting fast remote file copy program daemon...
</span></span><span class=line><span class=cl>1月 <span class=m>26</span> 21:59:41 lnmp systemd<span class=o>[</span>1<span class=o>]</span>: Started fast remote file copy program daemon.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ systemctl status rsyncd
</span></span><span class=line><span class=cl>rsyncd.service - fast remote file copy program daemon
</span></span><span class=line><span class=cl>   Loaded: loaded <span class=o>(</span>/usr/lib/systemd/system/rsyncd.service<span class=p>;</span> disabled<span class=o>)</span>
</span></span><span class=line><span class=cl>   Active: inactive <span class=o>(</span>dead<span class=o>)</span>/</span></span></code></pre></td></tr></table></div></div></div></div><p>上面的输出结果含义如下:""</p><ul><li>Loaded行：配置文件的位置，是否设为开机启动</li><li>Active行：表示正在运行</li><li>Main PID行：主进程ID</li><li>Status行：由应用本身（这里是 httpd ）提供的软件当前状态</li><li>Cgroup块：应用的所有子进程</li><li>日志块：应用的日志</li></ul><h3 id=102-理解单元文件结构>10.2 理解单元文件结构<a hidden class=anchor aria-hidden=true href=#102-理解单元文件结构>#</a></h3><h3 id=103-单元文件概述>10.3 单元文件概述<a hidden class=anchor aria-hidden=true href=#103-单元文件概述>#</a></h3><p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。
典型的单元文件包含三节：</p><ul><li><p><strong>[Unit]</strong>：包含不依赖单元类型的一般选项，这些选型提供单元描述，知道单元行为，配置单元和其他单元的依赖性。</p></li><li><p><strong>[unittype]</strong>：如果单元有特定的类型指令，在unittype节这些指令被组织在一起。举个例子，服务单元文件包含[Service]节，里面有经常使用的服务配置。</p></li><li><p><strong>[Install]</strong>：包含systemctl enable或者disable的命令安装信息。</p></li></ul><h4 id=1031-unit节选项>10.3.1 [Unit]节选项<a hidden class=anchor aria-hidden=true href=#1031-unit节选项>#</a></h4><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>Description</td><td>字段给出当前服务的简单描述</td></tr><tr><td>Documentation</td><td>给出文档位置。</td></tr><tr><td></td><td>启动顺序 <strong><font color=#0215cd size=2>注意:After和Before字段只涉及启动顺序，不涉及依赖关系</font></strong></td></tr><tr><td>After</td><td>表示sshd.service应该在network.target sshd-keygen.service之后启动。</td></tr><tr><td>Before</td><td>定义sshd.service应该在哪些服务之前启动。</td></tr><tr><td></td><td>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</td></tr><tr><td></td><td><strong><font color=#0215cd size=2>设置依赖关系，需要使用Wants字段和Requires字段。</font></strong></td></tr><tr><td>Wants</td><td>表示sshd.service与sshd-keygen.service之间存在<font style=background:#ff0 size=2> &ldquo;弱依赖&rdquo; </font>关系，即如果"sshd-keygen.service"启动失败或停止运行，不影响sshd.service继续执行。</td></tr><tr><td>Requires</td><td>表示<font style=background:#ff0 size=2> &ldquo;强依赖&rdquo; </font>关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。</td></tr><tr><td></td><td><strong><font color=#0215cd size=2>注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</font></strong></td></tr></tbody></table><h4 id=1032-service-区块启动行为>10.3.2 [Service] 区块：启动行为<a hidden class=anchor aria-hidden=true href=#1032-service-区块启动行为>#</a></h4><p> Service区块定义如何启动当前服务。</p><blockquote><p><strong>启动命令</strong></p></blockquote><p> 许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。</p><pre><code>  EnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。
</code></pre><p> 上面的例子中，sshd 的环境参数文件是<font color=#f8070d size=3><code>/etc/sysconfig/sshd</code></font>。</p><p> 配置文件里面最重要的字段是ExecStart。</p><pre><code>  ExecStart：定义启动进程时执行的命令。
</code></pre><p>上面的例子中，启动sshd，执行的命令是<font color=#f8070d size=3><code>/usr/sbin/sshd -D $OPTIONS</code></font>，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段：</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>ExecStart</td><td>指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</td></tr><tr><td>ExecStop</td><td>指定单元停止时执行的命令或者脚本。</td></tr><tr><td>ExecReload</td><td>指定单元重新加载是执行的命令或者脚本。</td></tr><tr><td>ExecStartPre</td><td>启动服务之前执行的命令</td></tr><tr><td>ExecStartPost</td><td>启动服务之后执行的命令</td></tr><tr><td>ExecStopPost</td><td>停止服务之后执行的命令</td></tr><tr><td>Restart</td><td>这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</td></tr><tr><td>RemainAfterExit</td><td>如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</td></tr></tbody></table><p>请看下面的例子。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/bin/echo execstart1
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/bin/echo execstart2
</span></span><span class=line><span class=cl><span class=nv>ExecStartPost</span><span class=o>=</span>/bin/echo <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>ExecStartPost</span><span class=o>=</span>/bin/echo <span class=m>2</span></span></span></code></pre></td></tr></table></div></div></div></div><p>上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ systemctl start <span class=nb>test</span> 
</span></span><span class=line><span class=cl>$ systemctl status <span class=nb>test</span>
</span></span><span class=line><span class=cl>test.service - <span class=nb>test</span> daemon
</span></span><span class=line><span class=cl>   Loaded: loaded <span class=o>(</span>/usr/lib/systemd/system/test.service<span class=p>;</span> disabled<span class=o>)</span>
</span></span><span class=line><span class=cl>   Active: inactive <span class=o>(</span>dead<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1月 <span class=m>30</span> 07:11:16 lnmp systemd<span class=o>[</span>1<span class=o>]</span>: Starting <span class=nb>test</span> daemon...
</span></span><span class=line><span class=cl>1月 <span class=m>30</span> 07:11:16 lnmp systemd<span class=o>[</span>1<span class=o>]</span>: Started <span class=nb>test</span> daemon.
</span></span><span class=line><span class=cl>1月 <span class=m>30</span> 07:11:16 lnmp echo<span class=o>[</span>1822<span class=o>]</span>: test1_start
</span></span><span class=line><span class=cl>1月 <span class=m>30</span> 07:11:16 lnmp echo<span class=o>[</span>1824<span class=o>]</span>: test1_stop</span></span></code></pre></td></tr></table></div></div></div></div><p>所有的启动设置之前，都可以加上一个连词号（-），表示<font style=background:#ff0 size=2>&ldquo;抑制错误&rdquo;</font>，即发生错误的时候，不影响其他命令的执行。比如，<font color=#f8070d size=3><code>EnvironmentFile=-/etc/sysconfig/sshd</code></font>（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd 文件不存在，也不会抛出错误。</p><blockquote><p><strong>启动类型</strong></p></blockquote><p>Type字段定义启动类型。它可以设置的值如下。</p><table><thead><tr><th>选项值</th><th>说明</th></tr></thead><tbody><tr><td>simple</td><td>默认值，ExecStart字段启动的进程为主进程</td></tr><tr><td>forking</td><td>进程作为服务主进程的一个子进程启动，父进程在完全启动之后退出。</td></tr><tr><td>oneshot</td><td>类似于simple，但只执行一次，进程在启动单元之后随之退出。</td></tr><tr><td>dbus</td><td>类似于simple，但随着单元启动后只有主进程得到D-BUS名字。</td></tr><tr><td>notify</td><td>类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</td></tr><tr><td>idle</td><td>类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</td></tr><tr><td></td><td></td></tr></tbody></table><p>下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>Switch-off Touchpad
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>oneshot
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/bin/touchpad-off
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><p>上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>Switch-off Touchpad
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>oneshot
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/bin/touchpad-off start
</span></span><span class=line><span class=cl><span class=nv>ExecStop</span><span class=o>=</span>/usr/bin/touchpad-off stop
</span></span><span class=line><span class=cl><span class=nv>RemainAfterExit</span><span class=o>=</span>yes
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><p>上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。</p><blockquote><p><strong>重启行为</strong></p></blockquote><p> Service区块有一些字段，定义了重启行为。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>  KillMode字段：定义 Systemd 如何停止 sshd 服务。</span></span></code></pre></td></tr></table></div></div></div></div><p>上面这个例子中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对sshd很重要，否则你停止服务的时候，会连自己打开的SSH session一起杀掉。</p><p>KillMode字段可以设置的值如下：</p><table><thead><tr><th>选项值</th><th>说明</th></tr></thead><tbody><tr><td>control-group</td><td>（默认值） 当前控制组里面的所有子进程，都会被杀掉</td></tr><tr><td>process</td><td>只杀主进程</td></tr><tr><td>mixed</td><td>主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</td></tr><tr><td>none</td><td>没有进程会被杀掉，只是执行服务的 stop 命令。</td></tr></tbody></table><blockquote><p><strong>Restart字段。</strong></p></blockquote><p> Restart字段：定义了 sshd 退出后，Systemd 的重启方式。</p><p>上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。</p><p>Restart字段可以设置的值如下。</p><table><thead><tr><th>选项值</th><th>说明</th></tr></thead><tbody><tr><td>no</td><td>默认值；退出后不会重启</td></tr><tr><td>on-success</td><td>只有正常退出时（退出状态码为0），才会重启</td></tr><tr><td>on-failure</td><td>非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</td></tr><tr><td>on-abnormal</td><td>只有被信号终止和超时，才会重启</td></tr><tr><td>on-abort</td><td>只有在收到没有捕捉到的信号终止时，才会重启</td></tr><tr><td>on-watchdog</td><td>超时退出，才会重启</td></tr><tr><td>always</td><td>不管是什么退出原因，总是重启</td></tr></tbody></table><p> 对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。</p><blockquote><p><strong>RestartSec字段。</strong></p></blockquote><p> RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p><h5 id=10.2.3>[Install] 区块
&nbsp;说明：Install区块，定义如何安装这个配置文件，即怎样做到开机启动。
WantedBy字段：表示该服务所在的 Target。<p>Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。</p><p>这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。</p><p>Systemd 有默认的启动 Target。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>$ systemctl get-default
</span></span><span class=line><span class=cl>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><p>上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</p><blockquote><p><strong>修改配置文件后重启</strong></p></blockquote><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># 重新加载配置文件</span>
</span></span><span class=line><span class=cl>systemctl daemon-reload</span></span></code></pre></td></tr></table></div></div></div></div><h3 id=104-一个postfix服务的例子>10.4 一个postfix服务的例子：<a hidden class=anchor aria-hidden=true href=#104-一个postfix服务的例子>#</a></h3><p>单元文件位于<font color=#f8070d size=3><code>/usr/lib/systemd/system/postifix.service</code></font>，内容如下：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>PostfixMailTransportAgent 
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>syslog.targetnetwork.target 
</span></span><span class=line><span class=cl><span class=nv>Conflicts</span><span class=o>=</span>sendmail.serviceexim.service 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>forking 
</span></span><span class=line><span class=cl><span class=nv>PIDFile</span><span class=o>=</span>/var/spool/postfix/pid/master.pid 
</span></span><span class=line><span class=cl><span class=nv>EnvironmentFile</span><span class=o>=</span>-/etc/sysconfig/network
</span></span><span class=line><span class=cl><span class=nv>ExecStartPre</span><span class=o>=</span>-/usr/libexec/postfix/aliasesdb
</span></span><span class=line><span class=cl><span class=nv>ExecStartPre</span><span class=o>=</span>-/usr/libexec/postfix/chroot-update
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/sbin/postfixstart
</span></span><span class=line><span class=cl><span class=nv>ExecReload</span><span class=o>=</span>/usr/sbin/postfixreload
</span></span><span class=line><span class=cl><span class=nv>ExecStop</span><span class=o>=</span>/usr/sbin/postfixstop
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><h4 id=105-创建自定义的单元文件>10.5 创建自定义的单元文件<a hidden class=anchor aria-hidden=true href=#105-创建自定义的单元文件>#</a></h4><p>以下几种场景需要自定义单元文件：</p><ul><li>希望自己创建守护进程；</li><li>为现有的服务创建第二个实例；</li><li>引入SysV init脚本。</li></ul><p>另外一方面，有时候需要修改已有的单元文件。下面介绍创建单元文件的步骤：</p><blockquote><ol><li>准备自定义服务的执行文件。</li></ol></blockquote><p>可执行文件可以是脚本，也可以是软件提供者的的程序，如果需要，为自定义服务的主进程准备一个PID文件，一保证PID保持不变。另外还可能需要的配置环境变量的脚本，确保所以脚本都有可执行属性并且不需要交互。</p><blockquote><p>2.在<font color=#f8070d size=3><code>/etc/systemd/system/</code></font>目录创建单元文件，并且保证只能被root用户编辑</p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>touch /etc/systemd/system/mariadb.service
</span></span><span class=line><span class=cl>chmod <span class=m>644</span> /etc/systemd/system/mariadb.service</span></span></code></pre></td></tr></table></div></div></div></div><hr><p><strong><font color=#f8070d size=3>注：文件不需要执行权限</font>。</strong></p><hr><blockquote><ol start=3><li>打开name.service文件，添加服务配置，各种变量如何配置视所添加的服务类型而定，下面是一个依赖网络服务的配置例子：</li></ol></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>mariadb multi demo <span class=m>3306</span>
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>network.target
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/data/3306/mysql start
</span></span><span class=line><span class=cl><span class=nv>ExecReload</span><span class=o>=</span>/data/3306/mysql restart
</span></span><span class=line><span class=cl><span class=nv>ExecStop</span><span class=o>=</span>/data/3306/mysql stop
</span></span><span class=line><span class=cl><span class=nv>Type</span><span class=o>=</span>forking
</span></span><span class=line><span class=cl><span class=nv>PIDFile</span><span class=o>=</span>/data/3306/mysqld.pid
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><blockquote><p>4.通知systemd有个新服务添加：</p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl daemon-reload 
</span></span><span class=line><span class=cl>systemctl start name.service</span></span></code></pre></td></tr></table></div></div></div></div><h4 id=10.5>10.5 创建第二个sshd服务的例子<blockquote><p><strong>1.拷贝sshd_config文件</strong></p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cp /etc/ssh/sshd<span class=o>{</span>,-second<span class=o>}</span>_config
</span></span><span class=line><span class=cl><span class=c1># {,second} 等于 和second ，类似与 {a,c}的用法</span></span></span></code></pre></td></tr></table></div></div></div></div><blockquote><p><strong>2.编辑sshd-second_config文件，添加22220的端口，和PID文件</strong>：</p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Port 22220 
</span></span><span class=line><span class=cl>PidFile /var/run/sshd-second.pid</span></span></code></pre></td></tr></table></div></div></div></div><p>如果还需要修改其他参数，请阅读帮助。</p><blockquote><p><strong>3.拷贝单元文件</strong>：</p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl> cp /usr/lib/systemd/system/sshd<span class=o>{</span>,-second<span class=o>}</span>.service</span></span></code></pre></td></tr></table></div></div></div></div><blockquote><p><strong>4.编辑单元文件sshd-second.service</strong></p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=o>[</span>Unit<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>Description</span><span class=o>=</span>OpenSSH server second instance daemon 
</span></span><span class=line><span class=cl><span class=nv>After</span><span class=o>=</span>syslog.target network.targe tauditd.service sshd.service 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Service<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>EnvironmentFile</span><span class=o>=</span>/etc/sysconfig/sshd
</span></span><span class=line><span class=cl><span class=nv>ExecStart</span><span class=o>=</span>/usr/sbin/sshd -D -f /etc/ssh/sshd-second_config <span class=nv>$OPTIONS</span> 
</span></span><span class=line><span class=cl><span class=nv>ExecReload</span><span class=o>=</span>/bin/kill -HUP <span class=nv>$MAINPID</span> 
</span></span><span class=line><span class=cl><span class=nv>KillMode</span><span class=o>=</span>process 
</span></span><span class=line><span class=cl><span class=nv>Restart</span><span class=o>=</span>on-failure 
</span></span><span class=line><span class=cl><span class=nv>RestartSec</span><span class=o>=</span>42s 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[</span>Install<span class=o>]</span> 
</span></span><span class=line><span class=cl><span class=nv>WantedBy</span><span class=o>=</span>multi-user.target</span></span></code></pre></td></tr></table></div></div></div></div><blockquote><p><strong>5.如果使用SELinux，添加tcp端口，负责第二sshd服务的端口就会被拒绝绑定</strong>：</p></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>semanage port -a -tssh_port_t -p tcp22220</span></span></code></pre></td></tr></table></div></div></div></div><blockquote><blockquote><p><strong>6.设置开机启动并测试</strong>：</p></blockquote></blockquote><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>sh</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>systemctl <span class=nb>enable</span> sshd-second.service 
</span></span><span class=line><span class=cl>ssh -p <span class=m>22220</span> user@server</span></span></code></pre></td></tr></table></div></div></div></div><h4 id=106-修改已经存在的单元文件>10.6 修改已经存在的单元文件<a hidden class=anchor aria-hidden=true href=#106-修改已经存在的单元文件>#</a></h4><p>systemd unit配置文件默认保存在/usr/lib/systemd/system/目录，不建议直接修改这个目录下的文件，自定义的文件在/etc/systemd/system/目录下，如果有扩展的需求，可以使用以下方案：</p><p>创建一个目录/etc/systemd/system/unit.d/，这个是最推荐的一种方式，可以参考初始的单元文件，通过附件配置文件来扩展默认的配置，对默认单元文件的升级会被自动升级和应用。</p><p>从/usr/lib/systemd/system/拷贝一份原始配置文件到/etc/systemd/system/，然后修改。复制的版本会覆盖原始配置，这种方式不能增加附件的配置包，用于不需要附加功能的场景。</p><p>如果需要恢复到默认的配置文件，只需要删除/etc/systemd/system/下的配置文件就可以了，不需要重启机器。</p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><blockquote><p>[CentOS7/RHEL7 systemd详解](CentOS7/RHEL7 systemd详解)</p><p><a href=http://www.jinbuguo.com/systemd/systemd.index.html target=_blank rel="noopener nofollow noreferrer">systemd.index 中文手册</a></p><p><a href=https://web.archive.org/web/20230204201903/https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html target=_blank rel="noopener nofollow noreferrer">Systemd 入门教程：实战篇</a></p></blockquote></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：Linux服务管理 - systemd</p><p>文章链接：<a href=https://www.oomkill.com/2016/04/systemd/ target=_blank>https://www.oomkill.com/2016/04/systemd/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2016/04/syslog/><span>Linux日志管理 - syslog</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2016/06/apache-php/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>配置apache httpd支持php</span>
</a><a class=next href=https://www.oomkill.com/2016/04/syslog/><span class=title></span>
<span>Linux日志管理 - syslog&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/blogs","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/systemd","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>