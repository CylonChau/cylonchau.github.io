<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go面试题收集 | Cylon's Collection</title>
<meta name=keywords content="prometheus,go面试题收集"><meta name=description content="数据结构 数据类型总结 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础数据类型包括：
基础类型： 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。 复合数据类型包括： 指针、数组、切片、字典、通道、结构体、接口。 什么是反射 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。
在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。
场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。
rune与byte的区别 byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。 golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节 切片 切片的扩容：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4
切片的截取：在截取时，capacity 不能超过原slice的 capacity
new() 与 make() 的区别 new(T) 和 make(T, args) 是Go语言内建函数，用来分配内存，但适用的类型不用。
new函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，new(int)将分配一个类型为int且值为0的对象，并返回一个指向该地址的指针。可以使用*运算符访问指针指向的值。 make函数用于创建和初始化内置类型（如map、slice、channel）的数据结构，并返回其指针。它比new函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，make(map[string]int)将创建一个空的map。它有一个string类型的键和一个int类型的值。 nil切片和空切片指向的地址一样吗？ nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 什么是Receiver Golang的Receiver是绑定function到特定type成为其method的一个参数，即一个function加了receiver就成为一个type的method。
构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别） T 的方法集仅拥有 T Receiver。 *T 方法集则包含全部方法 (Receiver + *Receiver)。 sync.once 是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同
init 函数是在文件包首次被加载的时候执行，且只执行一次
sync.Onc 是在代码运行中需要的时候执行，且只执行一次
当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once
实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式
首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行 加锁，确保并发安全 在执行函数前，二次确认 done 是否等于 0，等于 0 则执行 将 done 置 1，同时释放锁 疑问一: 为什么不使用乐观锁 CAS 简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值 疑问二: 为什么读取 done 值的方式没有统一 比较 done 是否等于 0，为什么有的地方用的是 atomic."><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2021/10/interview-go/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2021/10/interview-go/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><meta property="og:title" content="go面试题收集"><meta property="og:description" content="数据结构 数据类型总结 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础数据类型包括：
基础类型： 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。 复合数据类型包括： 指针、数组、切片、字典、通道、结构体、接口。 什么是反射 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。
在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。
场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。
rune与byte的区别 byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。 golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节 切片 切片的扩容：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4
切片的截取：在截取时，capacity 不能超过原slice的 capacity
new() 与 make() 的区别 new(T) 和 make(T, args) 是Go语言内建函数，用来分配内存，但适用的类型不用。
new函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，new(int)将分配一个类型为int且值为0的对象，并返回一个指向该地址的指针。可以使用*运算符访问指针指向的值。 make函数用于创建和初始化内置类型（如map、slice、channel）的数据结构，并返回其指针。它比new函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，make(map[string]int)将创建一个空的map。它有一个string类型的键和一个int类型的值。 nil切片和空切片指向的地址一样吗？ nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 什么是Receiver Golang的Receiver是绑定function到特定type成为其method的一个参数，即一个function加了receiver就成为一个type的method。
构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别） T 的方法集仅拥有 T Receiver。 *T 方法集则包含全部方法 (Receiver + *Receiver)。 sync.once 是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同
init 函数是在文件包首次被加载的时候执行，且只执行一次
sync.Onc 是在代码运行中需要的时候执行，且只执行一次
当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once
实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式
首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行 加锁，确保并发安全 在执行函数前，二次确认 done 是否等于 0，等于 0 则执行 将 done 置 1，同时释放锁 疑问一: 为什么不使用乐观锁 CAS 简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值 疑问二: 为什么读取 done 值的方式没有统一 比较 done 是否等于 0，为什么有的地方用的是 atomic."><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2021/10/interview-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-18T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="go面试题收集"><meta name=twitter:description content="数据结构 数据类型总结 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
基础数据类型包括：
基础类型： 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。 复合数据类型包括： 指针、数组、切片、字典、通道、结构体、接口。 什么是反射 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。
在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。
场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。
rune与byte的区别 byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。 golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节 切片 切片的扩容：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4
切片的截取：在截取时，capacity 不能超过原slice的 capacity
new() 与 make() 的区别 new(T) 和 make(T, args) 是Go语言内建函数，用来分配内存，但适用的类型不用。
new函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，new(int)将分配一个类型为int且值为0的对象，并返回一个指向该地址的指针。可以使用*运算符访问指针指向的值。 make函数用于创建和初始化内置类型（如map、slice、channel）的数据结构，并返回其指针。它比new函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，make(map[string]int)将创建一个空的map。它有一个string类型的键和一个int类型的值。 nil切片和空切片指向的地址一样吗？ nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 什么是Receiver Golang的Receiver是绑定function到特定type成为其method的一个参数，即一个function加了receiver就成为一个type的method。
构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别） T 的方法集仅拥有 T Receiver。 *T 方法集则包含全部方法 (Receiver + *Receiver)。 sync.once 是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同
init 函数是在文件包首次被加载的时候执行，且只执行一次
sync.Onc 是在代码运行中需要的时候执行，且只执行一次
当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once
实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式
首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行 加锁，确保并发安全 在执行函数前，二次确认 done 是否等于 0，等于 0 则执行 将 done 置 1，同时释放锁 疑问一: 为什么不使用乐观锁 CAS 简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值 疑问二: 为什么读取 done 值的方式没有统一 比较 done 是否等于 0，为什么有的地方用的是 atomic."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"go面试题收集","item":"https://www.oomkill.com/2021/10/interview-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go面试题收集","name":"go面试题收集","description":"数据结构 数据类型总结 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。\n基础数据类型包括：\n基础类型： 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。 复合数据类型包括： 指针、数组、切片、字典、通道、结构体、接口。 什么是反射 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。\n在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。\n场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。\nrune与byte的区别 byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。 golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节 切片 切片的扩容：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4\n切片的截取：在截取时，capacity 不能超过原slice的 capacity\nnew() 与 make() 的区别 new(T) 和 make(T, args) 是Go语言内建函数，用来分配内存，但适用的类型不用。\nnew函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，new(int)将分配一个类型为int且值为0的对象，并返回一个指向该地址的指针。可以使用*运算符访问指针指向的值。 make函数用于创建和初始化内置类型（如map、slice、channel）的数据结构，并返回其指针。它比new函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，make(map[string]int)将创建一个空的map。它有一个string类型的键和一个int类型的值。 nil切片和空切片指向的地址一样吗？ nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 什么是Receiver Golang的Receiver是绑定function到特定type成为其method的一个参数，即一个function加了receiver就成为一个type的method。\n构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别） T 的方法集仅拥有 T Receiver。 *T 方法集则包含全部方法 (Receiver + *Receiver)。 sync.once 是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同\ninit 函数是在文件包首次被加载的时候执行，且只执行一次\nsync.Onc 是在代码运行中需要的时候执行，且只执行一次\n当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once\n实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式\n首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行 加锁，确保并发安全 在执行函数前，二次确认 done 是否等于 0，等于 0 则执行 将 done 置 1，同时释放锁 疑问一: 为什么不使用乐观锁 CAS 简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值 疑问二: 为什么读取 done 值的方式没有统一 比较 done 是否等于 0，为什么有的地方用的是 atomic.","keywords":["prometheus","go面试题收集"],"articleBody":"数据结构 数据类型总结 Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。\n基础数据类型包括：\n基础类型： 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。 复合数据类型包括： 指针、数组、切片、字典、通道、结构体、接口。 什么是反射 在计算机科学领域，反射是指一类应用，它们能够自描述和自控制。\n在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。\n场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。\nrune与byte的区别 byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。 golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节 切片 切片的扩容：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4\n切片的截取：在截取时，capacity 不能超过原slice的 capacity\nnew() 与 make() 的区别 new(T) 和 make(T, args) 是Go语言内建函数，用来分配内存，但适用的类型不用。\nnew函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，new(int)将分配一个类型为int且值为0的对象，并返回一个指向该地址的指针。可以使用*运算符访问指针指向的值。 make函数用于创建和初始化内置类型（如map、slice、channel）的数据结构，并返回其指针。它比new函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，make(map[string]int)将创建一个空的map。它有一个string类型的键和一个int类型的值。 nil切片和空切片指向的地址一样吗？ nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 什么是Receiver Golang的Receiver是绑定function到特定type成为其method的一个参数，即一个function加了receiver就成为一个type的method。\n构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别） T 的方法集仅拥有 T Receiver。 *T 方法集则包含全部方法 (Receiver + *Receiver)。 sync.once 是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同\ninit 函数是在文件包首次被加载的时候执行，且只执行一次\nsync.Onc 是在代码运行中需要的时候执行，且只执行一次\n当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once\n实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式\n首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行 加锁，确保并发安全 在执行函数前，二次确认 done 是否等于 0，等于 0 则执行 将 done 置 1，同时释放锁 疑问一: 为什么不使用乐观锁 CAS 简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值 疑问二: 为什么读取 done 值的方式没有统一 比较 done 是否等于 0，为什么有的地方用的是 atomic.LoadUint32，有的地方用的却是 o.done。主要原因是 atomic.LoadUint32 可以保证原子读取到 done 值，是并发安全的，而在 doSlow 中，已经加锁了，那么临界区就是并发安全的，使用 o.done 就可以来读取值就可以了 原子操作和互斥锁的区别 文档：https://zhuanlan.zhihu.com/p/147618421\nGMP模型 文档：https://zhuanlan.zhihu.com/p/261590663 文档：https://juejin.cn/post/6844904104343388168\nG：goroutine\nM：Machine，内核线程\nP：Logical Processor，处理器；代表了M所需要的上下文环境\nruntime.GOMAXPROCS (numLogicalProcessors)可以设置多少个处理器，go 1.5开始，默认是CPU核数； 实际运行时P和CPU核心数并无任何关联，P最大不超过256；P可以理解为并行度的多少，也就是说当前最多只能有P个线程在运行；(是不是很像线程池) P一旦初始化了，就不能修改了 三者关系 M的数量和P不一定匹配，可以设置很多M，M和P绑定后才可运行，多余的M处于休眠状态。\nP包含一个LRQ（Local Run Queue）本地运行队列，这里面保存着P需要执行的协程G的队列。\n除了每个P自身保存的G的队列外，调度器还拥有一个全局的G队列GRQ（Global Run Queue），这个队列存储的是所有未分配的协程G。\ngo func()执行流程 创建一个G对象，加入到本地队列或全局队列； 如果还有空闲的P，则创建一个M； M会启动一个底层线程，并结合P，循环执行G； P执行G的顺序是，先从本地队列找，没有则到全局队列找（一次性转移[全局G个数/P个数]），再到其他P中找（一次性转移一半）； G是执行顺序是按照队列顺序的； P管理着G队列，但是G要运行，还需要M的绑定； runtime.GOMAXPROCS只会影响P的数量，不会影响M的数量； P和M的关系，就好比用户线程和内核线程的N：M模型； 没有足够的M关联P时，会创建M；在runtime执行系统监控或垃圾回收等任务的时候也会导致新的M的创建。 所以，runtime.GOMAXPROCS只是类似线程池的大小设置而已； 当然，go也可以通过runtime/debug.SeMaxThreads限制操作系统线程数；SetMaxThreads主要用于限制程序无限制的创造线程导致的灾难。目的是让程序在干掉操作系统之前，先干掉它自己。 goroutine是按照抢占式调度的，一个goroutine最多执行10ms就会换作下一个； 死锁 死锁是：多个进（线）程是相互竞争的关系，并且互持资源，相互等待，这样产生的永久阻塞的现象称为死锁。\n死锁产生的原因：\n互斥 占有且等待 不可抢占 循环等待 死锁如何解决：死锁的发生很难通过人为干预来解决，只能避免（打破死锁产生的条件）\n互斥：线程安全是通过互斥来实现的（无法干预） 占有且等待：申请资源时获取所有所需资源 不可抢占：占用资源的进程在进一步申请其他资源时，如申请不到主动释放已占有的资源 循环等待：按需预防，对所需资源进行排序，按照大小依次申请 Refer deadlock\nGo中产生死锁的原因：\n无缓冲；解决：缓冲或先读后写 缓冲已满（只写不读）；解决，需要有消费端 读写互斥；（读写加锁导致一段阻塞变成死锁） 未初始化的channel（读，写，关闭） 多线程只要保证个线程的执行，可以允许死锁 如主进程只读不写造成阻塞，这种情况在没有子线程情况下是死锁 slice和map区别 slice是有序的，map是无序的，在每次迭代时，无法确定其顺序 slice有容量，map没有容量，map是由go内部控制的数据结构 slice可以使用appen()，map不可以 slice和map都是引用类型，当作为参数传递时共享相同地址 如何复制slice、map和interface？ 这些类型的变量是内存引用类型，可以使用内置函数 copy() 来完成复制 Refer to\ngo 1 2 3 4 5 6 a := []int{1, 2} b := []int{3, 4} check := a copy(a, b) fmt.Println(a, b, check) // Output: [3 4] [3 4] [3 4] 什么是goroutine go的多线程是包含在运行时内的一种机制，用的模型是两级，即runtime帮助申请和释放线程，而这个gorutine可以为一对一，也可以为一对多，即操作系统中的 “两级模型”（Two-Level）是严格意义上的多对多模型，可以为单个用户线程专门一对一绑定内核线程的能力的模型\n用户线程的缺点：\n用户级线程与操作系统的集成度不高；如用空闲线程调度进程，阻塞其线程发起 I/O 的进程，即使该进程有其他线程可以运行，以及有锁的线程取消调度进程。 用户级线程需要非阻塞系统调用，否则，当一个线程阻塞，即使进程中还有可运行的线程，整个进程也会在内核中阻塞。例如，如果一个线程导致页面错误，则进程阻塞。 用户线程和操作系统内核之间缺乏协调性；无论进程有 1 个线程还是 1000 个线程，都仅能获得一个CPU时间片。由每个线程主动将控制权交给其他线程。 由于进程时资源分配的最小单位，多线程情况下，每个线程得到的时间片较少，执行会较慢。 C语言的线程和Goroutine的区别主要表现在以下几个方面 实现方式不同：C语言的线程是由操作系统内核来实现的，而Goroutine则是通过Go语言的runtime来实现的。 内存分配方式不同：C语言的线程需要在内存中分配一定的栈空间，而Goroutine则通过自动扩展栈来实现。 调度方式不同：C语言的线程是由操作系统内核来调度的，而Goroutine是通过Go语言的runtime自己实现的调度器来调度的。 轻量级：Goroutine是轻量级的线程，一个Goroutine只需要2KB的栈空间，而C语言的线程需要占用更多的内存空间。 效率高：由于Goroutine是由Go语言的runtime来实现的，因此它具有非常高的执行效率和并发性能，比C语言的线程更加高效。 总的来说，Goroutine是Go语言的并发特性中非常重要的一部分，通过Goroutine可以非常方便地实现高效的并发程序。而C语言的线程则更多地是由操作系统来实现，对于一些需要最大化利用机器性能的场景会更为适合。\n应用 Go语言创建TCP连接 conn.dial conn.write/read ","wordCount":"232","inLanguage":"zh","datePublished":"2021-10-01T00:00:00Z","dateModified":"2023-03-18T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2021/10/interview-go/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">go面试题收集</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2021-10-01</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>232 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>2 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/interview/>#Interview</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%80%bb%e7%bb%93 aria-label=数据类型总结>数据类型总结</a><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%b0%84 aria-label=什么是反射>什么是反射</a><li><a href=#rune%e4%b8%8ebyte%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=rune与byte的区别>rune与byte的区别</a><li><a href=#%e5%88%87%e7%89%87 aria-label=切片>切片</a><li><a href=#new-%e4%b8%8e-make-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="new() 与 make() 的区别">new() 与 make() 的区别</a><li><a href=#nil%e5%88%87%e7%89%87%e5%92%8c%e7%a9%ba%e5%88%87%e7%89%87%e6%8c%87%e5%90%91%e7%9a%84%e5%9c%b0%e5%9d%80%e4%b8%80%e6%a0%b7%e5%90%97 aria-label=nil切片和空切片指向的地址一样吗？>nil切片和空切片指向的地址一样吗？</a><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afreceiver aria-label=什么是Receiver>什么是Receiver</a><li><a href=#%e6%9e%84%e4%bd%93%e6%96%b9%e6%b3%95%e8%b7%9f%e7%bb%93%e6%9e%84%e4%bd%93%e6%8c%87%e9%92%88%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%ba%e5%88%abreceiver%e5%92%8c%e6%8c%87%e9%92%88receiver%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别）>构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别）</a><li><a href=#synconce aria-label=sync.once>sync.once</a><li><a href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e5%92%8c%e4%ba%92%e6%96%a5%e9%94%81%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=原子操作和互斥锁的区别>原子操作和互斥锁的区别</a><li><a href=#gmp%e6%a8%a1%e5%9e%8b aria-label=GMP模型>GMP模型</a><li><a href=#go-func%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-label="go func()执行流程">go func()执行流程</a><li><a href=#%e6%ad%bb%e9%94%81 aria-label=死锁>死锁</a><li><a href=#slice%e5%92%8cmap%e5%8c%ba%e5%88%ab aria-label=slice和map区别>slice和map区别</a></ul><li><a href=#%e5%a6%82%e4%bd%95%e5%a4%8d%e5%88%b6slicemap%e5%92%8cinterface aria-label=如何复制slice、map和interface？>如何复制slice、map和interface？</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afgoroutine aria-label=什么是goroutine>什么是goroutine</a><li><a href=#c%e8%af%ad%e8%a8%80%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%92%8cgoroutine%e7%9a%84%e5%8c%ba%e5%88%ab%e4%b8%bb%e8%a6%81%e8%a1%a8%e7%8e%b0%e5%9c%a8%e4%bb%a5%e4%b8%8b%e5%87%a0%e4%b8%aa%e6%96%b9%e9%9d%a2 aria-label=C语言的线程和Goroutine的区别主要表现在以下几个方面>C语言的线程和Goroutine的区别主要表现在以下几个方面</a></ul><li><a href=#%e5%ba%94%e7%94%a8 aria-label=应用>应用</a><ul><li><a href=#go%e8%af%ad%e8%a8%80%e5%88%9b%e5%bb%batcp%e8%bf%9e%e6%8e%a5 aria-label=Go语言创建TCP连接>Go语言创建TCP连接</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2><h3 id=数据类型总结>数据类型总结<a hidden class=anchor aria-hidden=true href=#数据类型总结>#</a></h3><p>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。</p><p>基础数据类型包括：</p><ul><li>基础类型：<ul><li>布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。</li></ul></li><li>复合数据类型包括：<ul><li>指针、数组、切片、字典、通道、结构体、接口。</li></ul></li></ul><h3 id=什么是反射>什么是反射<a hidden class=anchor aria-hidden=true href=#什么是反射>#</a></h3><p>在计算机科学领域，反射是指一类应用，它们能够<em><strong>自描述</strong></em>和<em><strong>自控制</strong></em>。</p><p>在go中，编译时不知道类型的情况下，可更新变量、运行时查看值、调用方法以及直接对他们的布局进行操作的机制，称为反射。</p><p>场景：无法透视一个未知类型的时候，这时候就需要有反射来帮忙你处理，反射使用TypeOf和ValueOf函数从接口中获取目标对象的信息，轻松完成目的。</p><h3 id=rune与byte的区别>rune与byte的区别<a hidden class=anchor aria-hidden=true href=#rune与byte的区别>#</a></h3><ul><li>byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。</li><li>golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节</li></ul><h3 id=切片>切片<a hidden class=anchor aria-hidden=true href=#切片>#</a></h3><p><strong>切片的扩容</strong>：切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4</p><p><strong>切片的截取</strong>：在截取时，capacity 不能超过原slice的 capacity</p><h3 id=new-与-make-的区别>new() 与 make() 的区别<a hidden class=anchor aria-hidden=true href=#new-与-make-的区别>#</a></h3><p><code>new(T)</code> 和 <code>make(T, args)</code> 是Go语言内建函数，用来分配内存，但适用的类型不用。</p><ul><li><code>new</code>函数用于分配指定类型的零值对象，并返回指向其内存地址的指针。例如，<code>new(int)</code>将分配一个类型为<code>int</code>且值为0的对象，并返回一个指向该地址的指针。可以使用<code>*</code>运算符访问指针指向的值。</li><li><code>make</code>函数用于创建和初始化内置类型（如<code>map</code>、<code>slice</code>、<code>channel</code>）的数据结构，并返回其指针。它比<code>new</code>函数更加复杂很多，因为它需要知道类型的大小和结构，以便为其分配内存并初始化其字段或元素。例如，<code>make(map[string]int)</code>将创建一个空的<code>map</code>。它有一个<code>string</code>类型的键和一个<code>int</code>类型的值。</li></ul><h3 id=nil切片和空切片指向的地址一样吗>nil切片和空切片指向的地址一样吗？<a hidden class=anchor aria-hidden=true href=#nil切片和空切片指向的地址一样吗>#</a></h3><ul><li>nil切片和空切片指向的地址==不一样==。nil空切片引用数组指针地址为0（无指向任何实际地址）</li><li>空切片的引用数组指针地址是有的，且固定为一个值</li></ul><h3 id=什么是receiver>什么是Receiver<a hidden class=anchor aria-hidden=true href=#什么是receiver>#</a></h3><p>Golang的Receiver是绑定<code>function</code>到特定<code>type</code>成为其<code>method</code>的一个参数，即一个<code>function</code>加了<code>receiver</code>就成为一个type的method。</p><h3 id=构体方法跟结构体指针方法的区别receiver和指针receiver的区别>构体方法跟结构体指针方法的区别（Receiver和指针Receiver的区别）<a hidden class=anchor aria-hidden=true href=#构体方法跟结构体指针方法的区别receiver和指针receiver的区别>#</a></h3><ul><li>T 的方法集仅拥有 T Receiver。</li><li>*T 方法集则包含全部方法 (<code>Receiver</code> + <code>*Receiver</code>)。</li></ul><h3 id=synconce>sync.once<a hidden class=anchor aria-hidden=true href=#synconce>#</a></h3><ul><li><p>是 Golang package 中使方法只执行一次的对象实现，作用与 init 函数类似。但也有所不同</p></li><li><p>init 函数是在文件包首次被加载的时候执行，且只执行一次</p></li><li><p>sync.Onc 是在代码运行中需要的时候执行，且只执行一次</p></li><li><p>当一个函数不希望程序在一开始的时候就被执行的时候，我们可以使用 sync.Once</p></li><li><p>实现：sync.Once 的源码实现非常简单，采用的是双重检测锁机制 (Double-checked Locking)，是并发场景下懒汉式单例模式的一种实现方式</p><ul><li>首先判断 done 是否等于 0，等于 0 则表示回调函数还未被执行</li><li>加锁，确保并发安全</li><li>在执行函数前，二次确认 done 是否等于 0，等于 0 则执行</li><li>将 done 置 1，同时释放锁
疑问一: 为什么不使用乐观锁 CAS
简单的来说就是 f() 的执行结果最终可能是不成功的，所以你会看到现在采用的是双重检测锁机制来实现，同时需要等 f() 执行完成才修改 done 值
疑问二: 为什么读取 done 值的方式没有统一
比较 done 是否等于 0，为什么有的地方用的是 atomic.LoadUint32，有的地方用的却是 o.done。主要原因是 atomic.LoadUint32 可以保证原子读取到 done 值，是并发安全的，而在 doSlow 中，已经加锁了，那么临界区就是并发安全的，使用 o.done 就可以来读取值就可以了</li></ul></li></ul><h3 id=原子操作和互斥锁的区别>原子操作和互斥锁的区别<a hidden class=anchor aria-hidden=true href=#原子操作和互斥锁的区别>#</a></h3><p>文档：https://zhuanlan.zhihu.com/p/147618421</p><h3 id=gmp模型>GMP模型<a hidden class=anchor aria-hidden=true href=#gmp模型>#</a></h3><p>文档：https://zhuanlan.zhihu.com/p/261590663
文档：https://juejin.cn/post/6844904104343388168</p><ul><li><p>G：goroutine</p></li><li><p>M：Machine，内核线程</p></li><li><p>P：Logical Processor，处理器；代表了M所需要的上下文环境</p><ul><li>runtime.GOMAXPROCS (numLogicalProcessors)可以设置多少个处理器，go 1.5开始，默认是CPU核数；</li><li>实际运行时P和CPU核心数并无任何关联，P最大不超过256；P可以理解为并行度的多少，也就是说当前最多只能有P个线程在运行；(是不是很像线程池)</li><li>P一旦初始化了，就不能修改了
<strong>三者关系</strong></li></ul></li><li><p>M的数量和P不一定匹配，可以设置很多M，M和P绑定后才可运行，多余的M处于休眠状态。</p></li><li><p>P包含一个LRQ（Local Run Queue）本地运行队列，这里面保存着P需要执行的协程G的队列。</p></li><li><p>除了每个P自身保存的G的队列外，调度器还拥有一个全局的G队列GRQ（Global Run Queue），这个队列存储的是所有未分配的协程G。</p></li></ul><h3 id=go-func执行流程>go func()执行流程<a hidden class=anchor aria-hidden=true href=#go-func执行流程>#</a></h3><ul><li>创建一个G对象，加入到本地队列或全局队列；</li><li>如果还有空闲的P，则创建一个M；</li><li>M会启动一个底层线程，并结合P，循环执行G；</li><li>P执行G的顺序是，先从本地队列找，没有则到全局队列找（一次性转移[全局G个数/P个数]），再到其他P中找（一次性转移一半）；</li><li>G是执行顺序是按照队列顺序的；</li><li>P管理着G队列，但是G要运行，还需要M的绑定；</li><li>runtime.GOMAXPROCS只会影响P的数量，不会影响M的数量；</li><li>P和M的关系，就好比用户线程和内核线程的N：M模型；</li><li>没有足够的M关联P时，会创建M；在runtime执行系统监控或垃圾回收等任务的时候也会导致新的M的创建。 所以，runtime.GOMAXPROCS只是类似线程池的大小设置而已；</li><li>当然，go也可以通过runtime/debug.SeMaxThreads限制操作系统线程数；SetMaxThreads主要用于限制程序无限制的创造线程导致的灾难。目的是让程序在干掉操作系统之前，先干掉它自己。</li><li>goroutine是按照抢占式调度的，一个goroutine最多执行10ms就会换作下一个；</li></ul><h3 id=死锁>死锁<a hidden class=anchor aria-hidden=true href=#死锁>#</a></h3><p><strong>死锁是</strong>：多个进（线）程是相互竞争的关系，并且互持资源，相互等待，这样产生的永久阻塞的现象称为死锁。</p><p><strong>死锁产生的原因</strong>：</p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ul><p><strong>死锁如何解决</strong>：死锁的发生很难通过人为干预来解决，只能避免（打破死锁产生的条件）</p><ul><li>互斥：线程安全是通过互斥来实现的（无法干预）</li><li>占有且等待：申请资源时获取所有所需资源</li><li>不可抢占：占用资源的进程在进一步申请其他资源时，如申请不到主动释放已占有的资源</li><li>循环等待：按需预防，对所需资源进行排序，按照大小依次申请</li></ul><blockquote><p>Refer <a href=https://cylonchau.github.io/ch11-deadlock.html#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95 target=_blank rel="noopener nofollow noreferrer">deadlock</a></p></blockquote><p><strong>Go中产生死锁的原因</strong>：</p><ul><li>无缓冲；解决：缓冲或先读后写</li><li>缓冲已满（只写不读）；解决，需要有消费端</li><li>读写互斥；（读写加锁导致一段阻塞变成死锁）</li><li>未初始化的channel（读，写，关闭）</li><li>多线程只要保证个线程的执行，可以允许死锁<ul><li>如主进程只读不写造成阻塞，这种情况在没有子线程情况下是死锁</li></ul></li></ul><h3 id=slice和map区别>slice和map区别<a hidden class=anchor aria-hidden=true href=#slice和map区别>#</a></h3><ul><li>slice是有序的，map是无序的，在每次迭代时，无法确定其顺序</li><li>slice有容量，map没有容量，map是由go内部控制的数据结构</li><li>slice可以使用appen()，map不可以</li><li>slice和map都是引用类型，当作为参数传递时共享相同地址</li></ul><h2 id=如何复制slicemap和interface>如何复制slice、map和interface？<a hidden class=anchor aria-hidden=true href=#如何复制slicemap和interface>#</a></h2><p>这些类型的变量是内存引用类型，可以使用内置函数 <code>copy()</code> 来完成复制 <a href=https://www.toptal.com/go/interview-questions target=_blank rel="noopener nofollow noreferrer">Refer to</a></p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>check</span> <span class=o>:=</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl><span class=nb>copy</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>check</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Output: [3 4] [3 4] [3 4]
</span></span></span></code></pre></td></tr></table></div></div></div></div><h3 id=什么是goroutine>什么是goroutine<a hidden class=anchor aria-hidden=true href=#什么是goroutine>#</a></h3><p>go的多线程是包含在运行时内的一种机制，用的模型是两级，即runtime帮助申请和释放线程，而这个gorutine可以为一对一，也可以为一对多，即操作系统中的 “两级模型”（<code>Two-Level</code>）是严格意义上的多对多模型，可以为单个用户线程专门一对一绑定内核线程的能力的模型</p><p>用户线程的缺点：</p><ul><li>用户级线程与操作系统的集成度不高；如用空闲线程调度进程，阻塞其线程发起 I/O 的进程，即使该进程有其他线程可以运行，以及有锁的线程取消调度进程。</li><li>用户级线程需要非阻塞系统调用，否则，当一个线程阻塞，即使进程中还有可运行的线程，整个进程也会在内核中阻塞。例如，如果一个线程导致页面错误，则进程阻塞。</li><li>用户线程和操作系统内核之间缺乏协调性；无论进程有 1 个线程还是 1000 个线程，都仅能获得一个CPU时间片。由每个线程主动将控制权交给其他线程。</li><li>由于进程时资源分配的最小单位，多线程情况下，每个线程得到的时间片较少，执行会较慢。</li></ul><h3 id=c语言的线程和goroutine的区别主要表现在以下几个方面>C语言的线程和Goroutine的区别主要表现在以下几个方面<a hidden class=anchor aria-hidden=true href=#c语言的线程和goroutine的区别主要表现在以下几个方面>#</a></h3><ol><li>实现方式不同：C语言的线程是由操作系统内核来实现的，而Goroutine则是通过Go语言的runtime来实现的。</li><li>内存分配方式不同：C语言的线程需要在内存中分配一定的栈空间，而Goroutine则通过自动扩展栈来实现。</li><li>调度方式不同：C语言的线程是由操作系统内核来调度的，而Goroutine是通过Go语言的runtime自己实现的调度器来调度的。</li><li>轻量级：Goroutine是轻量级的线程，一个Goroutine只需要2KB的栈空间，而C语言的线程需要占用更多的内存空间。</li><li>效率高：由于Goroutine是由Go语言的runtime来实现的，因此它具有非常高的执行效率和并发性能，比C语言的线程更加高效。</li></ol><p>总的来说，Goroutine是Go语言的并发特性中非常重要的一部分，通过Goroutine可以非常方便地实现高效的并发程序。而C语言的线程则更多地是由操作系统来实现，对于一些需要最大化利用机器性能的场景会更为适合。</p><h2 id=应用>应用<a hidden class=anchor aria-hidden=true href=#应用>#</a></h2><h3 id=go语言创建tcp连接>Go语言创建TCP连接<a hidden class=anchor aria-hidden=true href=#go语言创建tcp连接>#</a></h3><ul><li>conn.dial</li><li>conn.write/read</li></ul></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：go面试题收集</p><p>文章链接：<a href=https://www.oomkill.com/2021/10/interview-go/ target=_blank>https://www.oomkill.com/2021/10/interview-go/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2021/10/interview-monitor/><span>监控类面试题</span></a></li><li><a href=/2020/11/prometheus-operator/><span>prometheus operator使用</span></a></li><li><a href=/2019/09/telegram-bot-send-post-json/><span>telegram接收altermanager消息</span></a></li><li><a href=/2019/06/prometheus-golang_client/><span>prometheus golang_client开发Exporter</span></a></li><li><a href=/2019/04/prometheus-install/><span>prometheus传统架构安装</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/interview/>Interview</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2021/10/pipe-size-problem/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>由PIPE size 引起的线上故障</span>
</a><a class=next href=https://www.oomkill.com/2021/10/interview-kubernetes/><span class=title></span>
<span>kubernetes面试题收集&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/interview go","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>