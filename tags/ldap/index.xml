<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ldap on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/ldap/</link>
    <description>Recent content in ldap on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 16 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/ldap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>深入理解Kubernetes 4A - Authentication源码解析</title>
      <link>https://www.oomkill.com/2022/11/ch31-authentication/</link>
      <pubDate>Wed, 16 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/11/ch31-authentication/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<blockquote>
<p>本文是关于Kubernetes 4A解析的第一章</p>
<ul>
<li>深入理解Kubernetes 4A - Authentication源码解析</li>
<li><a href="https://cylonchau.github.io/kubernetes-authorization.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Authorization源码解析</a></li>
<li><a href="https://cylonchau.github.io/ch3.7-admission-webhook.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Admission Control源码解析</a></li>
<li><a href="https://cylonchau.github.io/kubernetes-auditing.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Audit源码解析</a></li>
</ul>
<p>所有关于Kubernetes 4A部分代码上传至仓库 github.com/cylonchau/hello-k8s-4A</p>
</blockquote>
<p>本章主要简单阐述kubernetes 认证相关原理，最后以实验来阐述kubernetes用户系统的思路</p>
<p><strong>objective</strong>：</p>
<ul>
<li>了解kubernetes 各种认证机制的原理</li>
<li>了解kubernetes 用户的概念</li>
<li>了解kubernetes authentication webhook</li>
<li>完成实验，如何将其他用户系统接入到kubernetes中的一个思路</li>
</ul>
<p>如有错别字或理解错误地方请多多担待，代码是以1.24进行整理，实验是以1.19环境进行，差别不大。</p>
<h2 id="kubernetes-认证">Kubernetes 认证</h2>
<p>在Kubernetes apiserver对于认证部分所描述的，对于所有用户访问Kubernetes API（通过任何客户端，客户端库，<code>kubectl</code> 等）时都会经历 验证 (<em><strong>Authentication</strong></em>) , 授权 (<em><strong>Authorization</strong></em>), 和准入控制 (<em><strong>Admission control</strong></em>) 三个阶段来完成对 “用户” 进行授权，整个流程正如下图所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/vhesGDFN3dLdzXwS7vzPdXkI3aglQYZgGhjc-Cx_boaV6URKFFoe8mFRZZUuJyGHywa_bOkeUlIkm-nJkCVMHPk9dr2dXFwNzAQJKzft2phsTcEDjdObjmugBcYtpdPLpLIYuIGzeFYvtsR2Lw.jpeg" alt="image-20221025003822017" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Kubernetes API 请求的请求处理步骤图</center>
<center><em>Source：</em>https://www.armosec.io/blog/kubernetes-admission-controller/</center><br>
<p>其中在大多数教程中，在对这三个阶段所做的工作大致上为：</p>
<ul>
<li>
<p><em><strong>Authentication</strong></em> 阶段所指用于确认请求访问Kubernetes API 用户是否为合法用户，拒绝为401</p>
</li>
<li>
<p><em><strong>Authorization</strong></em> 阶段所指的将是这个用户是否有对操作的资源的权限，拒绝为403</p>
</li>
<li>
<p><em><strong>Admission control</strong></em> 阶段所指控制对请求资源进行控制，通俗来说，就是一票否决权，即使前两个步骤完成</p>
</li>
</ul>
<p>到这里了解到了Kubernetes API实际上做的工作就是 “人类用户” 与 “kubernetes service account&quot; <sup><a href="#2">[2]</a></sup>；那么就引出了一个重要概念就是 “用户” 在Kubernetes中是什么，以及用户在认证中的也是本章节的中心。</p>
<p>在Kubernetes官方手册中给出了 ”用户“ 的概念，Kubernetes集群中存在的用户包括 ”普通用户“ 与 “service account” 但是 Kubernetes 没有普通用户的管理方式，只是将使用集群的证书CA签署的有效证书的用户都被视为合法用户 <sup><a href="#3">[3]</a></sup></p>
<p>那么对于使得Kubernetes集群有一个真正的用户系统，就可以根据上面给出的概念将Kubernetes用户分为 ”外部用户“ 与 ”内部用户“。如何理解外部与内部用户呢？实际上就是有Kubernetes管理的用户，即在kubernetes定义用户的数据模型这种为 “内部用户” ，正如 service account；反之，非Kubernetes托管的用户则为 ”外部用户“ 这中概念也更好的对kubernetes用户的阐述。</p>
<p>对于外部用户来说，实际上Kubernetes给出了多种用户概念 <sup><a href="#3">[3]</a></sup>，例如：</p>
<ul>
<li>拥有kubernetes集群证书的用户</li>
<li>拥有Kubernetes集群token的用户（<code>--token-auth-file</code> 指定的静态token）</li>
<li>用户来自外部用户系统，例如 <em>OpenID</em>，<em>LDAP</em>，<em>QQ connect</em>, <em>google identity platform</em> 等</li>
</ul>
<h2 id="向外部用户授权集群访问的示例">向外部用户授权集群访问的示例</h2>
<h3 id="场景1通过证书请求k8s">场景1：通过证书请求k8s</h3>
<p>该场景中kubernetes将使用证书中的cn作为用户，ou作为组，如果对应 <code>rolebinding/clusterrolebinding</code> 给予该用户权限，那么请求为合法</p>
<pre><code class="language-bash">$ curl https://hostname:6443/api/v1/pods \
	--cert ./client.pem \
	--key ./client-key.pem \
	--cacert ./ca.pem 
</code></pre>
<p>接下来浅析下在代码中做的事情</p>
<p>确认用户是 <em><strong>apiserver</strong></em> 在 <em><strong>Authentication</strong></em> 阶段 做的事情，而对应代码在 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator</a> 下，整个文件就是构建了一系列的认证器，而x.509证书指是其中一个</p>
<pre><code class="language-go">// 创建一个认证器，返回请求或一个k8s认证机制的标准错误
func (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, error) {
    
...

	// X509 methods
    // 可以看到这里就是将x509证书解析为user
	if config.ClientCAContentProvider != nil {
		certAuth := x509.NewDynamic(config.ClientCAContentProvider.VerifyOptions, x509.CommonNameUserConversion)
		authenticators = append(authenticators, certAuth)
	}
...
</code></pre>
<p>接下来看实现原理，NewDynamic函数位于代码 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/request/x509/x509.go#L126-L130" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/request/x509/x509.go</a></p>
<p>通过代码可以看出，是通过一个验证函数与用户来解析为一个 <em>Authenticator</em></p>
<pre><code class="language-go">// NewDynamic returns a request.Authenticator that verifies client certificates using the provided
// VerifyOptionFunc (which may be dynamic), and converts valid certificate chains into user.Info using the provided UserConversion
func NewDynamic(verifyOptionsFn VerifyOptionFunc, user UserConversion) *Authenticator {
	return &amp;Authenticator{verifyOptionsFn, user}
}
</code></pre>
<p>验证函数为 CAContentProvider 的方法，而x509部分实现为 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/server/dynamiccertificates/dynamic_cafile_content.go#L253-L261" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/server/dynamiccertificates/dynamic_cafile_content.go.VerifyOptions</a>；可以看出返回是一个 <code>x509.VerifyOptions</code> + 与认证的状态</p>
<pre><code class="language-go">// VerifyOptions provides verifyoptions compatible with authenticators
func (c *DynamicFileCAContent) VerifyOptions() (x509.VerifyOptions, bool) {
	uncastObj := c.caBundle.Load()
	if uncastObj == nil {
		return x509.VerifyOptions{}, false
	}

	return uncastObj.(*caBundleAndVerifier).verifyOptions, true
}
</code></pre>
<p>而用户的获取则位于  <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/request/x509/x509.go#L248-L258" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/request/x509/x509.go</a>；可以看出，用户正是拿的证书的CN，而组则是为证书的OU</p>
<pre><code class="language-go">// CommonNameUserConversion builds user info from a certificate chain using the subject's CommonName
var CommonNameUserConversion = UserConversionFunc(func(chain []*x509.Certificate) (*authenticator.Response, bool, error) {
	if len(chain[0].Subject.CommonName) == 0 {
		return nil, false, nil
	}
	return &amp;authenticator.Response{
		User: &amp;user.DefaultInfo{
			Name:   chain[0].Subject.CommonName,
			Groups: chain[0].Subject.Organization,
		},
	}, true, nil
})
</code></pre>
<p>由于授权不在本章范围内，直接忽略至入库阶段，入库阶段由 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/pkg/controlplane/instance.go#L561" target="_blank"
   rel="noopener nofollow noreferrer" >RESTStorageProvider</a> 实现 这里，每一个Provider都提供了 <code>Authenticator</code> 这里包含了已经允许的请求，将会被对应的REST客户端写入到库中</p>
<pre><code class="language-go">type RESTStorageProvider struct {
	Authenticator authenticator.Request
	APIAudiences  authenticator.Audiences
}
// RESTStorageProvider is a factory type for REST storage.
type RESTStorageProvider interface {
	GroupName() string
	NewRESTStorage(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter) (genericapiserver.APIGroupInfo, error)
}
</code></pre>
<h3 id="场景2通过token">场景2：通过token</h3>
<p>该场景中，当 <em><strong>kube-apiserver</strong></em> 开启了 <code>--enable-bootstrap-token-auth</code> 时，就可以使用 Bootstrap Token 进行认证，通常如下列命令，在请求头中增加 <code>Authorization: Bearer &lt;token&gt;</code> 标识</p>
<pre><code class="language-bash">$ curl https://hostname:6443/api/v1/pods \
  --cacert ${CACERT} \
  --header &quot;Authorization: Bearer &lt;token&gt;&quot; \
</code></pre>
<p>接下来浅析下在代码中做的事情</p>
<p>可以看到，在代码 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator.New()</a> 中当 <em><strong>kube-apiserver</strong></em> 指定了参数 <code>--token-auth-file=/etc/kubernetes/token.csv&quot;</code> 这种认证会被激活</p>
<pre><code class="language-go">if len(config.TokenAuthFile) &gt; 0 {
    tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))
}
</code></pre>
<p>此时打开 token.csv 查看下token长什么样</p>
<pre><code class="language-bash">$ cat /etc/kubernetes/token.csv
12ba4f.d82a57a4433b2359,&quot;system:bootstrapper&quot;,10001,&quot;system:bootstrappers&quot;
</code></pre>
<p>这里回到代码 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/token/tokenfile/tokenfile.go#L45-L91" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/token/tokenfile/tokenfile.go.NewCSV</a> ，这里可以看出，就是读取 <code>--token-auth-file=</code> 参数指定的tokenfile，然后解析为用户，<code>record[1]</code> 作为用户名，<code>record[2]</code> 作为UID</p>
<pre><code class="language-go">// NewCSV returns a TokenAuthenticator, populated from a CSV file.
// The CSV file must contain records in the format &quot;token,username,useruid&quot;
func NewCSV(path string) (*TokenAuthenticator, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	recordNum := 0
	tokens := make(map[string]*user.DefaultInfo)
	reader := csv.NewReader(file)
	reader.FieldsPerRecord = -1
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}
		if len(record) &lt; 3 {
			return nil, fmt.Errorf(&quot;token file '%s' must have at least 3 columns (token, user name, user uid), found %d&quot;, path, len(record))
		}

		recordNum++
		if record[0] == &quot;&quot; {
			klog.Warningf(&quot;empty token has been found in token file '%s', record number '%d'&quot;, path, recordNum)
			continue
		}

		obj := &amp;user.DefaultInfo{
			Name: record[1],
			UID:  record[2],
		}
		if _, exist := tokens[record[0]]; exist {
			klog.Warningf(&quot;duplicate token has been found in token file '%s', record number '%d'&quot;, path, recordNum)
		}
		tokens[record[0]] = obj

		if len(record) &gt;= 4 {
			obj.Groups = strings.Split(record[3], &quot;,&quot;)
		}
	}

	return &amp;TokenAuthenticator{
		tokens: tokens,
	}, nil
}
</code></pre>
<p>而token file中配置的格式正是以逗号分隔的一组字符串，</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<p>这种用户最常见的方式就是 <em><strong>kubelet</strong></em> 通常会以此类用户向控制平面进行身份认证，例如下列配置</p>
<pre><code class="language-bash">KUBELET_ARGS=&quot;--v=0 \
    --logtostderr=true \
    --config=/etc/kubernetes/kubelet-config.yaml \
    --kubeconfig=/etc/kubernetes/auth/kubelet.conf \
    --network-plugin=cni \
    --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 \
    --bootstrap-kubeconfig=/etc/kubernetes/auth/bootstrap.conf&quot;
</code></pre>
<p><code>/etc/kubernetes/auth/bootstrap.conf</code> 内容，这里就用到了 <em><strong>kube-apiserver</strong></em> 配置的 <code>--token-auth-file=</code> 用户名，组必须为 <code>system:bootstrappers</code></p>
<pre><code class="language-yaml">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: ......
    server: https://10.0.0.4:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: system:bootstrapper
  name: system:bootstrapper@kubernetes
current-context: system:bootstrapper@kubernetes
kind: Config
preferences: {}
users:
- name: system:bootstrapper
</code></pre>
<p>而通常在二进制部署时会出现的问题，例如下列错误</p>
<pre><code class="language-log">Unable to register node &quot;hostname&quot; with API server: nodes is forbidden: User &quot;system:anonymous&quot; cannot create resource &quot;nodes&quot; in API group &quot;&quot; at the cluster scope
</code></pre>
<p>而通常解决方法是执行下列命令，这里就是将 <em><strong>kubelet</strong></em> 与 <em><strong>kube-apiserver</strong></em> 通讯时的用户授权，因为kubernetes官方给出的条件是，用户组必须为 <code>system:bootstrappers</code>  <sup><a href="#4">[4]</a></sup></p>
<pre><code class="language-bash">$ kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --group=system:bootstrappers
</code></pre>
<p>生成的clusterrolebinding 如下</p>
<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: &quot;2022-08-14T22:26:51Z&quot;
  managedFields:
  - apiVersion: rbac.authorization.k8s.io/v1
    fieldsType: FieldsV1
   ...
    time: &quot;2022-08-14T22:26:51Z&quot;
  name: kubelet-bootstrap
  resourceVersion: &quot;158&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/kubelet-bootstrap
  uid: b4d70f4f-4ae0-468f-86b7-55e9351e4719
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:node-bootstrapper
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:bootstrappers
</code></pre>
<p>上述就是 bootstrap token，翻译后就是引导token，因为其做的工作就是将节点载入Kubernetes系统过程提供认证机制的用户。</p>
<blockquote>
<p>Notes：这种用户不存在与kubernetes内，可以算属于一个外部用户，但认证机制中存在并绑定了最高权限，也可以用来做其他访问时的认证</p>
</blockquote>
<h3 id="场景3serviceaccount">场景3：serviceaccount</h3>
<p>serviceaccount通常为API自动创建的，但在用户中，实际上认证存在两个方向，一个是 <code>--service-account-key-file</code> 这个参数可以指定多个，指定对应的证书文件公钥或私钥，用以办法sa的token</p>
<p>首先会根据指定的公钥或私钥文件生成token</p>
<pre><code class="language-go">if len(config.ServiceAccountKeyFiles) &gt; 0 {
    serviceAccountAuth, err := newLegacyServiceAccountAuthenticator(config.ServiceAccountKeyFiles, config.ServiceAccountLookup, config.APIAudiences, config.ServiceAccountTokenGetter)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
}
if len(config.ServiceAccountIssuers) &gt; 0 {
    serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountIssuers, config.ServiceAccountKeyFiles, config.APIAudiences, config.ServiceAccountTokenGetter)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
}
</code></pre>
<p>对于  <code>--service-account-key-file</code>  他生成的用户都是 “kubernetes/serviceaccount”  , 而对于 <code>--service-account-issuer</code> 只是对sa颁发者提供了一个称号标识是谁，而不是统一的 “kubernetes/serviceaccount” ，这里可以从代码中看到，两者是完全相同的，只是称号不同罢了</p>
<pre><code class="language-go">// newLegacyServiceAccountAuthenticator returns an authenticator.Token or an error
func newLegacyServiceAccountAuthenticator(keyfiles []string, lookup bool, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
	allPublicKeys := []interface{}{}
	for _, keyfile := range keyfiles {
		publicKeys, err := keyutil.PublicKeysFromFile(keyfile)
		if err != nil {
			return nil, err
		}
		allPublicKeys = append(allPublicKeys, publicKeys...)
	}
// 唯一的区别 这里使用了常量 serviceaccount.LegacyIssuer
	tokenAuthenticator := serviceaccount.JWTTokenAuthenticator([]string{serviceaccount.LegacyIssuer}, allPublicKeys, apiAudiences, serviceaccount.NewLegacyValidator(lookup, serviceAccountGetter))
	return tokenAuthenticator, nil
}

// newServiceAccountAuthenticator returns an authenticator.Token or an error
func newServiceAccountAuthenticator(issuers []string, keyfiles []string, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
	allPublicKeys := []interface{}{}
	for _, keyfile := range keyfiles {
		publicKeys, err := keyutil.PublicKeysFromFile(keyfile)
		if err != nil {
			return nil, err
		}
		allPublicKeys = append(allPublicKeys, publicKeys...)
	}
// 唯一的区别 这里根据kube-apiserver提供的称号指定名称
	tokenAuthenticator := serviceaccount.JWTTokenAuthenticator(issuers, allPublicKeys, apiAudiences, serviceaccount.NewValidator(serviceAccountGetter))
	return tokenAuthenticator, nil
}
</code></pre>
<p>最后根据ServiceAccounts，Secrets等值签发一个token，也就是通过下列命令获取的值</p>
<pre><code class="language-go">$ kubectl get secret multus-token-v6bfg -n kube-system -o jsonpath={&quot;.data.token&quot;}
</code></pre>
<h3 id="场景4openid">场景4：openid</h3>
<p>OpenID Connect是 OAuth2 风格，允许用户授权三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，下面是一张kubernetes 使用 OID 认证的逻辑图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/kube-login-oidc-ad4caf57f124e622897e0781fe1e3d6e1ecb5c6099776e6677ca800c4458f1de.jpg" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Kubernetes OID认证</center>
<center><em>Source：</em>https://developer.okta.com/blog/2021/11/08/k8s-api-server-oidc</center><br>
<h3 id="场景5webhook">场景5：webhook</h3>
<p>webhook是kubernetes提供自定义认证的其中一种，主要是用于认证 “<em><strong>不记名 token</strong></em>“ 的钩子，“<em><strong>不记名 token</strong></em>“ 将 由身份验证服务创建。当用户对kubernetes访问时，会触发准入控制，当对kubernetes集群注册了 authenticaion webhook时，将会使用该webhook提供的方式进行身份验证时，此时会为您生成一个 token 。</p>
<p>如代码 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator.New()</a>  中所示 newWebhookTokenAuthenticator 会通过提供的config (<code>--authentication-token-webhook-config-file</code>) 来创建出一个 WebhookTokenAuthenticator</p>
<pre><code class="language-go">if len(config.WebhookTokenAuthnConfigFile) &gt; 0 {
    webhookTokenAuth, err := newWebhookTokenAuthenticator(config)
    if err != nil {
        return nil, nil, err
    }

    tokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)
}
</code></pre>
<p>下图是kubernetes 中 WebhookToken 验证的工作原理</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/25d075712ff343ce492a5db30733cd93.svg" alt="Webhook 令牌认证插件" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：kubernetes WebhookToken验证原理</center>
<center><em>Source：</em>https://learnk8s.io/kubernetes-custom-authentication</center><br>
<p>最后由token中的authHandler，循环所有的Handlers在运行 <code>AuthenticateToken</code> 去进行获取用户的信息</p>
<pre><code class="language-go">func (authHandler *unionAuthTokenHandler) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {
   var errlist []error
   for _, currAuthRequestHandler := range authHandler.Handlers {
      info, ok, err := currAuthRequestHandler.AuthenticateToken(ctx, token)
      if err != nil {
         if authHandler.FailOnError {
            return info, ok, err
         }
         errlist = append(errlist, err)
         continue
      }

      if ok {
         return info, ok, err
      }
   }

   return nil, false, utilerrors.NewAggregate(errlist)
}
</code></pre>
<p>而webhook插件也实现了这个方法 <code>AuthenticateToken</code> ,这里会通过POST请求，调用注入的webhook，该请求携带一个JSON 格式的 <code>TokenReview</code> 对象，其中包含要验证的令牌</p>
<pre><code class="language-go">func (w *WebhookTokenAuthenticator) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {

    ....

		start := time.Now()
		result, statusCode, tokenReviewErr = w.tokenReview.Create(ctx, r, metav1.CreateOptions{})
		latency := time.Since(start)
...
}
</code></pre>
<p>webhook token认证服务要返回<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1beta1-authentication-k8s-io" target="_blank"
   rel="noopener nofollow noreferrer" >用户的身份信息</a>，就是上面token部分提到的数据结构（webhook来决定接受还是拒绝该用户）</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<h3 id="场景6代理认证">场景6：代理认证</h3>
<h2 id="实验基于ldap的身份认证">实验：基于LDAP的身份认证</h2>
<p>通过上面阐述，大致了解到kubernetes认证框架中的用户的分类以及认证的策略由哪些，实验的目的也是为了阐述一个结果，就是使用OIDC/webhook 是比其他方式更好的保护，管理kubernetes集群。首先在安全上，假设网络环境是不安全的，那么任意node节点遗漏 bootstrap token文件，就意味着拥有了集群中最高权限；其次在管理上，越大的团队，人数越多，不可能每个用户都提供单独的证书或者token，要知道传统教程中讲到token在kubernetes集群中是永久有效的，除非你删除了这个secret/sa；而Kubernetes提供的插件就很好的解决了这些问题。</p>
<h3 id="实验环境">实验环境</h3>
<ul>
<li>一个kubernetes集群</li>
<li>一个openldap服务，建议可以是集群外部的，因为webhook不像SSSD有缓存机制，并且集群不可用，那么认证不可用，当认证不可用时会导致集群不可用，这样事故影响的范围可以得到控制，也叫最小化半径</li>
<li>了解ldap相关技术，并了解go ldap客户端</li>
</ul>
<p><strong>实验大致分为以下几个步骤</strong>：</p>
<ul>
<li>建立一个HTTP服务器用于返回给kubernetes Authenticaion服务</li>
<li>查询ldap该用户是否合法
<ul>
<li>查询用户是否合法</li>
<li>查询用户所属组是否拥有权限</li>
</ul>
</li>
</ul>
<h3 id="实验开始">实验开始</h3>
<h4 id="初始化用户数据">初始化用户数据</h4>
<p>首先准备openldap初始化数据，创建三个 posixGroup 组，与5个用户 admin, admin1, admin11, searchUser, syncUser 密码均为111，组与用户关联使用的 <code>memberUid</code></p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapdelete -r  -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: dc=test,dc=com
objectClass: top
objectClass: organizationalUnit
objectClass: extensibleObject
description: US Organization
ou: people

dn: ou=tvb,dc=test,dc=com
objectClass: organizationalUnit
description: Television Broadcasts Limited
ou: tvb

dn: cn=admin,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10000
cn: admin

dn: cn=conf,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10001
cn: conf

dn: cn=dir,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10002
cn: dir

dn: uid=syncUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: syncUser
cn: syncUser
uidNumber: 10006
gidNumber: 10002
homeDirectory: /home/syncUser
loginShell: /bin/bash
sn: syncUser
givenName: syncUser
memberOf: cn=confGroup,ou=tvb,dc=test,dc=com

dn: uid=searchUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: searchUser
cn: searchUser
uidNumber: 10005
gidNumber: 10001
homeDirectory: /home/searchUser
loginShell: /bin/bash
sn: searchUser
givenName: searchUser
memberOf: cn=dirGroup,ou=tvb,dc=test,dc=com

dn: uid=admin1,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: admin1
sn: admin1
cn: admin
uidNumber: 10010
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin11,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
sn: admin11
pwdAttribute: userPassword
uid: admin11
cn: admin11
uidNumber: 10011
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
givenName: admin11
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: admin
cn: admin
uidNumber: 10009
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<p>接下来需要确定如何为认证成功的用户，上面讲到对于kubernetes中用户格式为 <code>v1.UserInfo</code> 的格式，即要获得用户，即用户组，假设需要查找的用户为，admin，那么在openldap中查询filter如下：</p>
<pre><code class="language-bash">&quot;(|(&amp;(objectClass=posixAccount)(uid=admin))(&amp;(objectClass=posixGroup)(memberUid=admin)))&quot;
</code></pre>
<p>上面语句意思是，找到 <code>objectClass=posixAccount</code> 并且 <code>uid=admin</code> 或者 <code>objectClass=posixGroup</code> 并且 <code>memberUid=admin</code> 的条目信息，这里使用 ”|“ 与 ”&amp;“ 是为了要拿到这两个结果。</p>
<h4 id="编写webhook查询用户部分">编写webhook查询用户部分</h4>
<p>这里由于openldap配置密码保存格式不是明文的，如果直接使用 ”=“ 来验证是查询不到内容的，故直接多用了一次登录来验证用户是否合法</p>
<pre><code class="language-go">func ldapSearch(username, password string) (*v1.UserInfo, error) {
	ldapconn, err := ldap.DialURL(ldapURL)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}
	defer ldapconn.Close()

	// Authenticate as LDAP admin user
	err = ldapconn.Bind(&quot;uid=searchUser,ou=tvb,dc=test,dc=com&quot;, &quot;111&quot;)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	// Execute LDAP Search request
	result, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixGroup)(memberUid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	userResult, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixAccount)(uid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	if len(result.Entries) == 0 {
		klog.V(3).Info(&quot;User does not exist&quot;)
		return nil, errors.New(&quot;User does not exist&quot;)
	} else {
		// 验证用户名密码是否正确
		if err := ldapconn.Bind(userResult.Entries[0].DN, password); err != nil {
			e := fmt.Sprintf(&quot;Failed to auth. %s\n&quot;, err)
			klog.V(3).Info(e)
			return nil, errors.New(e)
		} else {
			klog.V(3).Info(fmt.Sprintf(&quot;User %s Authenticated successfuly!&quot;, username))
		}
		// 拼接为kubernetes authentication 的用户格式
		user := new(v1.UserInfo)
		for _, v := range result.Entries {
			attrubute := v.GetAttributeValue(&quot;objectClass&quot;)
			if strings.Contains(attrubute, &quot;posixGroup&quot;) {
				user.Groups = append(user.Groups, v.GetAttributeValue(&quot;cn&quot;))
			}
		}

		u := userResult.Entries[0].GetAttributeValue(&quot;uid&quot;)
		user.UID = u
		user.Username = u
		return user, nil
	}
}
</code></pre>
<h4 id="编写http部分">编写HTTP部分</h4>
<p>这里有几个需要注意的部分，即用户或者理解为要认证的token的定义，此处使用了 ”username@password“ 格式作为用户的辨别，即登录kubernetes时需要直接输入 ”username@password“ 来作为登录的凭据。</p>
<p>第二个部分为返回值，返回给Kubernetes的格式必须为 <code>api/authentication/v1.TokenReview</code> 格式，<code>Status.Authenticated</code> 表示用户身份验证结果，如果该用户合法，则设置 <code>tokenReview.Status.Authenticated = true</code> 反之亦然。如果验证成功还需要 <code>Status.User</code> 这就是在<code>ldapSearch</code></p>
<pre><code class="language-go">func serve(w http.ResponseWriter, r *http.Request) {
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		httpError(w, err)
		return
	}
	klog.V(4).Info(&quot;Receiving: %s\n&quot;, string(b))

	var tokenReview v1.TokenReview
	err = json.Unmarshal(b, &amp;tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}

	// 提取用户名与密码
	s := strings.SplitN(tokenReview.Spec.Token, &quot;@&quot;, 2)
	if len(s) != 2 {
		klog.V(3).Info(fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		httpError(w, fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		return
	}
	username, password := s[0], s[1]
	// 查询ldap，验证用户是否合法
	userInfo, err := ldapSearch(username, password)
	if err != nil {
		// 这里不打印日志的原因是 ldapSearch 中打印过了
		return
	}

	// 设置返回的tokenReview
	if userInfo == nil {
		tokenReview.Status.Authenticated = false
	} else {
		tokenReview.Status.Authenticated = true
		tokenReview.Status.User = *userInfo
	}

	b, err = json.Marshal(tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}
	w.Write(b)
	klog.V(3).Info(&quot;Returning: &quot;, string(b))
}

func httpError(w http.ResponseWriter, err error) {
	err = fmt.Errorf(&quot;Error: %v&quot;, err)
	w.WriteHeader(http.StatusInternalServerError) // 500
	fmt.Fprintln(w, err)
	klog.V(4).Info(&quot;httpcode 500: &quot;, err)
}
</code></pre>
<p>下面是完整的代码</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;

	&quot;github.com/go-ldap/ldap&quot;
	&quot;k8s.io/api/authentication/v1&quot;
	&quot;k8s.io/klog/v2&quot;
)

var ldapURL string

func main() {
	klog.InitFlags(nil)
	flag.Parse()
	http.HandleFunc(&quot;/authenticate&quot;, serve)
	klog.V(4).Info(&quot;Listening on port 443 waiting for requests...&quot;)
	klog.V(4).Info(http.ListenAndServe(&quot;:443&quot;, nil))
	ldapURL = &quot;ldap://10.0.0.10:389&quot;
	ldapSearch(&quot;admin&quot;, &quot;1111&quot;)
}

func serve(w http.ResponseWriter, r *http.Request) {
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		httpError(w, err)
		return
	}
	klog.V(4).Info(&quot;Receiving: %s\n&quot;, string(b))

	var tokenReview v1.TokenReview
	err = json.Unmarshal(b, &amp;tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}

	// 提取用户名与密码
	s := strings.SplitN(tokenReview.Spec.Token, &quot;@&quot;, 2)
	if len(s) != 2 {
		klog.V(3).Info(fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		httpError(w, fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		return
	}
	username, password := s[0], s[1]
	// 查询ldap，验证用户是否合法
	userInfo, err := ldapSearch(username, password)
	if err != nil {
		// 这里不打印日志的原因是 ldapSearch 中打印过了
		return
	}

	// 设置返回的tokenReview
	if userInfo == nil {
		tokenReview.Status.Authenticated = false
	} else {
		tokenReview.Status.Authenticated = true
		tokenReview.Status.User = *userInfo
	}

	b, err = json.Marshal(tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}
	w.Write(b)
	klog.V(3).Info(&quot;Returning: &quot;, string(b))
}

func httpError(w http.ResponseWriter, err error) {
	err = fmt.Errorf(&quot;Error: %v&quot;, err)
	w.WriteHeader(http.StatusInternalServerError) // 500
	fmt.Fprintln(w, err)
	klog.V(4).Info(&quot;httpcode 500: &quot;, err)
}

func ldapSearch(username, password string) (*v1.UserInfo, error) {

	ldapconn, err := ldap.DialURL(ldapURL)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}
	defer ldapconn.Close()

	// Authenticate as LDAP admin user
	err = ldapconn.Bind(&quot;cn=admin,dc=test,dc=com&quot;, &quot;111&quot;)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	// Execute LDAP Search request
	result, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixGroup)(memberUid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	userResult, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixAccount)(uid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	if len(result.Entries) == 0 {
		klog.V(3).Info(&quot;User does not exist&quot;)
		return nil, errors.New(&quot;User does not exist&quot;)
	} else {
		// 验证用户名密码是否正确
		if err := ldapconn.Bind(userResult.Entries[0].DN, password); err != nil {
			e := fmt.Sprintf(&quot;Failed to auth. %s\n&quot;, err)
			klog.V(3).Info(e)
			return nil, errors.New(e)
		} else {
			klog.V(3).Info(fmt.Sprintf(&quot;User %s Authenticated successfuly!&quot;, username))
		}
		// 拼接为kubernetes authentication 的用户格式
		user := new(v1.UserInfo)
		for _, v := range result.Entries {
			attrubute := v.GetAttributeValue(&quot;objectClass&quot;)
			if strings.Contains(attrubute, &quot;posixGroup&quot;) {
				user.Groups = append(user.Groups, v.GetAttributeValue(&quot;cn&quot;))
			}
		}

		u := userResult.Entries[0].GetAttributeValue(&quot;uid&quot;)
		user.UID = u
		user.Username = u
		return user, nil
	}
}
</code></pre>
<h3 id="部署webhook">部署webhook</h3>
<p>kubernetes官方手册中指出，启用webhook认证的标记是在 <em><strong>kube-apiserver</strong></em> 指定参数 <code>--authentication-token-webhook-config-file</code> 。而这个配置文件是一个 <em>kubeconfig</em> 类型的文件格式 <sup><a href="#5">[5]</a></sup></p>
<p>下列是部署在kubernetes集群外部的配置</p>
<p>创建一个给 <em>kube-apiserver</em> 使用的配置文件 <code>/etc/kubernetes/auth/authentication-webhook.conf</code></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Config
clusters:
- cluster:
    server: http://10.0.0.1:88/authenticate
  name: authenticator
users:
- name: webhook-authenticator
current-context: webhook-authenticator@authenticator
contexts:
- context:
    cluster: authenticator
    user: webhook-authenticator
  name: webhook-authenticator@authenticator
</code></pre>
<p>修改 <em>kube-apiserver</em> 参数</p>
<pre><code class="language-bash"># 指向对应的配置文件
--authentication-token-webhook-config-file=/etc/kubernetes/auth/authentication-webhook.conf
# 这个是token缓存时间，指的是用户在访问API时验证通过后在一定时间内无需在请求webhook进行认证了
--authentication-token-webhook-cache-ttl=30m
# 版本指定为API使用哪个版本？authentication.k8s.io/v1或v1beta1
--authentication-token-webhook-version=v1
</code></pre>
<p>启动服务后，创建一个 kubeconfig 中的用户用于验证结果</p>
<pre><code class="language-conf">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: 
    server: https://10.0.0.4:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: k8s-admin
  name: k8s-admin@kubernetes
current-context: k8s-admin@kubernetes
kind: Config
preferences: {}
users:
- name: admin
  user: 
    token: admin@111
</code></pre>
<h3 id="验证结果">验证结果</h3>
<p><strong>当密码不正确时，使用用户admin请求集群</strong></p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
error: You must be logged in to the server (Unauthorized)
</code></pre>
<p><strong>当密码正确时，使用用户admin请求集群</strong></p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
Error from server (Forbidden): pods is forbidden: User &quot;admin&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
</code></pre>
<p>可以看到admin用户是一个不存在与集群中的用户，并且提示没有权限操作对应资源，此时将admin用户与集群中的cluster-admin绑定，测试结果</p>
<pre><code class="language-bash">$ kubectl create clusterrolebinding admin \
	--clusterrole=cluster-admin \
	--group=admin
</code></pre>
<p>此时再尝试使用admin用户访问集群</p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
NAME                      READY   STATUS    RESTARTS   AGE
netbox-85865d5556-hfg6v   1/1     Running   0          91d
netbox-85865d5556-vlgr4   1/1     Running   0          91d
</code></pre>
<h2 id="总结">总结</h2>
<p>kubernetes authentication 插件提供的功能可以注入一个认证系统，这样可以完美解决了kubernetes中用户的问题，而这些用户并不存在与kubernetes中，并且也无需为多个用户准备大量serviceaccount或者证书，也可以完成鉴权操作。首先返回值标准如下所示，如果kubernetes集群有对在其他用户系统中获得的 <code>Groups</code> 并建立了 <code>clusterrolebinding</code> 或 <code>rolebinding</code> 那么这个组的所有用户都将有这些权限。管理员只需要维护与公司用户系统中组同样多的 clusterrole 与 clusterrolebinding 即可</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<p>对于如何将 kubernetes 与其他平台进行融合可以参考 <a href="https://cylonchau.github.io/kubernetes-dashborad-based.html" target="_blank"
   rel="noopener nofollow noreferrer" >文章</a></p>
<blockquote>
<p>Notes：Kubernetes原生就支持OID，完全不用自己开发webhook从而实现接入其他系统，这里展示的只是一个思路</p>
</blockquote>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://learnk8s.io/kubernetes-custom-authentication" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Implementing a custom Kubernetes authentication method</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://kubernetes.io/docs/concepts/security/controlling-access/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Controlling Access to the Kubernetes API</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#users-in-kubernetes" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Users in Kubernetes</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>bootstrap tokens</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Webhook Token Authentication</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap - 使用SSSD接入OpenLDAP实现身份验证</title>
      <link>https://www.oomkill.com/2022/11/ch11-sssd/</link>
      <pubDate>Tue, 15 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/11/ch11-sssd/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>SSSD (<em><strong>System Security Services Daemon</strong></em>) 是一套用于远程身份验证的套件服务，为使用SSSD服务的客户端提供了远程访问身份认证服务来获取权限，其后端包括AD, LDAP等，本文将围绕下列方向来阐述SSSD：</p>
<ul>
<li>为什么需要SSSD，以及使用SSSD来解决什么</li>
<li>使用SSSD的好处</li>
<li>SSSD服务工作原理及架构</li>
<li>如何在Linux上配置SSSD+LDAP</li>
</ul>
<h2 id="为什么需要sssd">为什么需要SSSD</h2>
<p>SSSD设计主要是为了传统使用身份认证服务，例如PAM+NSS架构中存在的一些问题：</p>
<ul>
<li>PAM+NSS扩展性差，并配置较为复杂，尽管提供了 <code>authconfig</code> ，通常在大多数教程中以及不同的系统中配置都不相同</li>
<li>PAM+NSS不是真正意义上的离线身份认证，如果当 <code>nslcd</code> 或者 <code>slapd</code> 等服务异常时，无法完成用户认证</li>
<li>以及越来越多的后端，例如LDAP, AD, IPA, IdM,Kerberos等无法做到很好的适配</li>
</ul>
<p>SSSD就是为了解决上述的问题，对于Linux平台中，SSSD拥有比传统PAM+NSS更好的优势：</p>
<ul>
<li>符合现代Linux基础架构设计需求，可以适配更多的后端，并降低了操作配置的复杂性</li>
<li>增加了缓存功能，有效的减少了对于后端服务器的负载</li>
<li>因为有了缓存功能，实现了真正的离线认证功能，即使后端服务异常，例如LDAP服务down</li>
</ul>
<h2 id="了解sssd架构">了解SSSD架构</h2>
<p>了解SSSD架构，其实就是了解前两章的内容，要做到真正的多后端，真脱机，那么服务就有多个组件组成：</p>
<ul>
<li><em><strong>Monitor</strong></em>：所有SSSD的父进程，即用于管理 Providers 与 Responders</li>
<li><em><strong>Providers</strong></em>：用于感知验证后端的模块，后端就是提供目录树的一端</li>
<li><em><strong>Responders</strong></em>：为Linux提供与后端交互的功能，这部分通常为 NSS PAM sudo等</li>
</ul>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221114162326295.png" alt="image-20221114162326295" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：SSSD架构图</center>
<center><em>Source：</em>https://sssd.io/docs/architecture.html</center><br>
<h3 id="providers">Providers</h3>
<ul>
<li><strong>Local</strong>：保存在本地缓存中的账户信息</li>
<li><strong>LDAP</strong>, <strong>Kerberos</strong>, <strong>AD</strong>,</li>
<li><strong>IPA</strong> ：用于 Linux/UNIX 网络环境中集成身份和身份验证解决方案。</li>
<li><strong>IdM</strong>：一种使用本地 Linux 工具在 Linux 系统上创建身份存储、集中身份验证、Kerberos 和 DNS 服务的域控制以及授权策略的目录树后端</li>
<li><strong>sudo</strong>，<strong>autofs</strong> 与LDAP集成的功能</li>
</ul>
<h3 id="responders">Responders</h3>
<ul>
<li>nss：名称解析服务，用于解析组与用户信息</li>
<li>pam：用于用户验证的模块</li>
<li>autofs：自动挂载模块，通常用于与LDAP集成，用于映射LDAP目录树</li>
<li>sudo：linux中用户权限控制，通常也是与LDAP集成</li>
<li>ssh：</li>
<li>sssd_be：SSSD的后端进程：其中每一种后端都代表都作为一个sssd_be进程启动</li>
</ul>
<h3 id="monitor">monitor</h3>
<p>monitor是SSSD的进程，是用于管理（启动，停止，监控服务状态）Provider与Responders的功能</p>
<h3 id="sssd工作流程">SSSD工作流程</h3>
<p>当每次用户登录，使用 <code>id</code>, <code>getent</code>, <code>su</code> ,  <code>sudo</code> 等命令时，都会触发一次查询，下图是整个查询的流程</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/image-20221114213534770.png" alt="image-20221114213534770" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：SSSD查询流程</center>
<center><em>Source：</em>https://sssd.io/docs/architecture.html</center><br>
<p>可以看到图中描述了对用户 <em>Alice</em> 进行查询，从调用函数<code>getpwnam</code> 开始，首先会在memcache中检索用户数据，如果检索不到，此时 <code>sssd_nss</code>（sssd内置的模块）将从本地cache检索，如果此时还是检索不到，那么 <code>sssd_be</code> (上面提到过一个后端会有一个 sssd_be 进程) 将从远程后端检索。</p>
<p>通过这种模式，增加了缓存功能，有效的减少了对于后端服务器的负载，以及完整的脱机查询功能（即使LDAP服务短暂不可用），而存在的问题则是可能会造成本地资源负载过高，例如这个例子：由于服务器忙时，并且<code>sssd_nss</code> 造成与其他进程争抢资源 <sup><a href="#2">[2]</a></sup></p>
<h2 id="迁移nslcd到sssd">迁移nslcd到sssd</h2>
<h3 id="安装sssd">安装sssd</h3>
<ul>
<li>CentOS 6/CentOS 7：<code>yum install sssd sssd-tools</code> <sup><a href="#3">[3]</a></sup></li>
<li>Ubuntu/Debian：<code>apt install sssd-ldap ldap-utils </code> <sup><a href="#4">[4]</a></sup></li>
</ul>
<h3 id="配置sssd">配置SSSD</h3>
<p><strong>先决条件</strong>：建议使用SSL模式与openldap进行通信，此时数据是加密传输的</p>
<p>默认安装好sssd后，不存在配置文件，需要手动创建配置文件  <strong><code>/etc/sssd/sssd.conf</code></strong></p>
<pre><code class="language-bash">chown root:root /etc/sssd/sssd.conf
chmod 600 /etc/sssd/sssd.conf
</code></pre>
<p>复制下列配置到  <strong><code>/etc/sssd/sssd.conf</code></strong></p>
<pre><code class="language-conf">[sssd]
# sssd全局配置，service为需要使用的模块，这里将会启动一个子进程
# 例如传统的nss+pam作为linux认证的基础，这里开启就为nss,pam
services = nss, pam 
config_file_version = 2
# domains作为给后端配置提供的一个名称
domains = default 

# 如果需要对每个模块定义的配置可以[&lt;module_name&gt;]进行配置
[pam]
# 成功登录后的用户在sssd中缓存的天数。 如果为0将意味着永久保存。
offline_credentials_expiration = 60

[domain/default]
# 启用tls通讯
ldap_id_use_start_tls = True

# 这个与offline_credentials_expiration进行配合的参数
# 如果true 将在offline_credentials_expiration天后是否查找缓存
# 如果为false，或不填写该参数将不查找
cache_credentials = True

# 搜索的跟域
ldap_search_base = dc=ldapmaster,dc=kifarunix-demo,dc=com

# 下面是一系列provider
id_provider = ldap
auth_provider = ldap
chpass_provider = ldap
access_provider = ldap

# ldap相关配置
ldap_uri = ldap://ldapmaster.kifarunix-demo.com

# 搜索使用的ldap用户
ldap_default_bind_dn = cn=readonly,ou=system,dc=ldapmaster,dc=kifarunix-demo,dc=com

# 搜索使用的ldap用户的密码，仅支持明文
ldap_default_authtok = P@ssWOrd

# tls相关参数

# 这个参数是指定TLS绘画是否对服务器证书进行检查
# never 客户端不检查服务器证书
# allow 请求验证服务端证书，如果没有证书则会话正常进行，如果证书错误，将被忽略
# demand 请求验证服务端证书，如果证书错误或者没有证书，终止会话
# try  请求验证服务端证书，如果没有证书则会话正常进行，如果证书错误，终止会话
ldap_tls_reqcert = demand
ldap_tls_cacert = /etc/openldap/certs/cacert.pem

# 与ldap服务端通信超时相关配置
ldap_search_timeout = 50
ldap_network_timeout = 60

# 搜索用户的参数，下列是默认条件，这是强制参数，sssd在ldap上搜索用户的搜索条件，如果目录树是特别的名称需要更改
ldap_access_order = filter
ldap_access_filter = (objectClass=posixAccount)
# 例如 ldap_access_filter = memberOf=cn=allowedusers,ou=Groups,dc=example,dc=com
</code></pre>
<p>配置完成后可以启动服务，该服务与使用 <code>nlscd</code> 一样，需要开机自启，否则远端用户将不能完成认证</p>
<pre><code class="language-bash">systemctl start sssd
systemctl enable sssd
</code></pre>
<p>完成后需要配置下 nss 与 pam 的配置</p>
<ul>
<li>CentOS 7：<code>authconfig --enablesssd --enablesssdauth --enablemkhomedir --update</code></li>
<li>CentOS 8：<code>authselect apply-changes -b --backup=ldap-configuration-backup</code></li>
<li>Ubuntu：<code>pam-auth-update --enable mkhomedir</code></li>
</ul>
<blockquote>
<p>Notes：参数根据平台不同命令也不同，可以man查看下具体需要配置什么</p>
</blockquote>
<h3 id="sudo-over-sssd">sudo over sssd</h3>
<p>对于sudo方面，配置没有使用nss+pam架构那么复杂只需要加几个参数即可使用sssd作为sudo认证</p>
<pre><code class="language-conf">[sssd]
..
# service 增加 sudo
services = nss, pam, sudo, ssh
domains = default
debug_level = 6

[sudo]
# 枚举授信域
subdomain_enumerate = true
debug_level = 9

[domain/default]
...
# provider 增加 sudo_provider
sudo_provider = ldap
# 配置sudo默认搜索域，也就是sudoers的跟容器，这个必须设置
ldap_sudo_search_base = ou=SUDOers,dc=test,dc=com

# sssd在下载ldap服务端的sudo规则间隔秒数
# 默认21600
ldap_sudo_full_refresh_interval=86400

# 智能刷新，默认900秒，可以设置为0禁止只能刷新
# 该参数是指，下载条目为服务端USD高于当前SSSD的USN最高值的所有规则
# USD Update Sequence Number 代表数据变化的序列
ldap_sudo_smart_refresh_interval=3600
</code></pre>
<p>下面为sudo 与 NSS+PAM 迁移至SSSD的完整配置</p>
<pre><code class="language-conf">[sssd]
config_file_version = 2
services = nss, pam, sudo, ssh
domains = default
debug_level = 6

[pam]
offline_credentials_expiration = 60

[sudo]
subdomain_enumerate = true
debug_level = 9

[domain/default]
id_provider = ldap
auth_provider = ldap
sudo_provider = ldap
ldap_uri = ldaps://10.0.0.10/
ldap_search_base = dc=test,dc=com
ldap_sudo_search_base = ou=SUDOers,dc=test,dc=com
ldap_default_bind_dn = uid=searchUser,ou=tvb,dc=test,dc=com
ldap_default_authtok_type = password
ldap_default_authtok = 1
cache_credentials = True
ldap_search_timeout = 50
ldap_network_timeout = 60
ldap_access_order = filter
ldap_access_filter = (objectClass=posixAccount)
ldap_tls_cacert = /etc/ssl/certs/cacert.crt
ldap_id_use_start_tls = true
ldap_tls_reqcert = allow
ldap_sudo_full_refresh_interval=86400
ldap_sudo_smart_refresh_interval=3600
</code></pre>
<p>此时验证用户登录与sudo是使用SSSD缓存还是通过每次请求slapd</p>
<blockquote>
<p>Notes：对于更多的配置参数的说明，可以使用 <code> man sssd</code> , <code>man sssd-ldap</code> .. 进行查询 ，也可以通过 <a href="https://linux.die.net/man/5/sssd-ldap" target="_blank"
   rel="noopener nofollow noreferrer" >linux man</a> 手册进行查询</p>
</blockquote>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>ldap 日志报错 <code>TLS established tls_ssf=256 ssf=256</code> <sup><a href="#5">[5]</a></sup></p>
<pre><code class="language-log">Sep 19 12:16:40 centos6 slapd[16620]: conn=228 fd=14 ACCEPT from IP=client-IP:client-Port (IP=0.0.0.0:636)
Sep 19 12:16:40 centos6 slapd[16620]: conn=228 fd=14 TLS established tls_ssf=256 ssf=256
</code></pre>
<p>这里原因是，如果你使用TLS进行通讯，只有基于 <code>ldap://[port_389]</code> 才是TLS，如果使用 <code>ldaps://[port_636]</code> 那么是通过SSL隧道进行的</p>
<p>解决：对于SSSD端需要开启对应的TLS配置，如下</p>
<pre><code class="language-conf">ldap_tls_cacert = /etc/ssl/certs/cacert.crt
ldap_id_use_start_tls = true
# 对服务器提供的证书执行的检查,因为服务端配置了要验证客户端证书
ldap_tls_reqcert = allow
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://sssd.io/docs/architecture.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>sssd architecture</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://stackoverflow.com/questions/49618032/high-cpu-usage-by-sssd-nss-during-heavy-disk-io" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>High CPU usage by sssd_nss during heavy disk IO</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://ubuntu.com/server/docs/service-sssd-ldap" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>SSSD and LDAP</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_authentication_and_authorization_in_rhel/assembly_migrating-authentication-from-nslcd-to-sssd_restricting-domains-for-pam-services-using-sssd#doc-wrapper" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Chapter 10. Migrating authentication from nslcd to SSSD</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://www.linuxquestions.org/questions/linux-desktop-74/openldap-client-2-4-23-tls-negotiation-failure-903809/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>OpenLDAP Client 2.4.23: TLS negotiation failure</strong></em></a></p>
<p><sup id="6">[6]</sup> <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_authentication_and_authorization_in_rhel/assembly_migrating-authentication-from-nslcd-to-sssd_restricting-domains-for-pam-services-using-sssd#doc-wrapper" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Chapter 10. Migrating authentication from nslcd to SSSD</strong></em></a></p>
<p><sup id="7">[7]</sup> <a href="https://www.ibm.com/docs/en/cloud-paks/cp-management/2.2.x?topic=SSFC4F_2.2.0/Infra_mgmt/auth/ldap.htm#configure-sssd" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Configure SSSD</strong></em></a></p>
<p><sup id="8">[8]</sup> <a href="https://kifarunix.com/configure-openldap-sssd-client-on-centos-6-7/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Configure OpenLDAP SSSD client on CentOS 6/7</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap应用 - Linux系统接入OpenLDAP做认证后端</title>
      <link>https://www.oomkill.com/2019/09/ch10-linux-with-ldap/</link>
      <pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch10-linux-with-ldap/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>如果要使Linux账号通过LDAP进行身份认证，就需要配置Linux的 身份验证模块 (<em><strong>Pluggable Authentication Modules</strong></em>) 与 名称服务交换系统 (<em><strong>Name Service Switch</strong></em>) 与LDAP交互。</p>
<h2 id="pam-和-nss-supa-href33asup">PAM 和 NSS <sup><a href="#3">[3]</a></sup></h2>
<p>NSS (<em><strong>name service switch</strong></em>) 通俗理解为是一个数据库系统，他作用是用于如何将操作系统与各种名称的解析机制关联起来，例如主机名，用户名，组名等内容的查找；例如UID查找使用 <code>passwd</code> 库，GID的查找使用 <code>group</code> 库，并且还可以告知查找的来源，如文件，LDAP等</p>
<p>PAM (<em><strong>Pluggable Authentication Modules</strong></em>) 全称是可插拔的认证模块，PAM在Linux中是位于用户数据库与应用之间的认证模块，它本身并不工作，并且本身也不提供或扩展现有数据库系统，当登陆shell时，依赖于由NSS提供的密码库与组库等信息，完成对应的查询</p>
<p>例如下列两张图完整的阐述了PAM与NSS之间，在用户登陆时做了些什么</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/image-20221112160527824.png" alt="image-20221112160527824" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：pam和nss工作示意图1</center>
<center><em>Source：</em>https://medium.com/@fengliplatform/understanding-nss-and-pam-using-a-ssh-example-80512eb0f39e</center><br>
<p>由图可以看出，当在进行 <code>ping</code> , <code>id</code> 等操作时，会通过nss找到 <code>passwd</code> 库找到用户id，以及通过nss确定是 hosts解析还是dns服务解析对应的域名</p>
<p>如果这张图不明白可以看下一张图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/image-20221112160836827.png" alt="image-20221112160836827" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：pam和nss工作示意图2-1</center>
<center><em>Source：</em>https://medium.com/@fengliplatform/understanding-nss-and-pam-using-a-ssh-example-80512eb0f39e</center><br>
<p>图2-1 中使用了tom用户去登录pecan主机，此时在节点 <code>yam</code> 上，将寻找 pecan主机的IP，这是通过 <code>/etc/nsswitch.conf</code> 来确定是通过 <code>hosts</code> 还是 dns服务进行查找。</p>
<p>接下来找到pecan的IP，这里会输入用户名与密码，这里将会被sshd服务接管，此时 pecan 主机的sshd接收到用户端请求连接后，将用户名通过nss进行识别，确定是否为合法用户，如果用户有效，则通过PAM进行认证。认证的源也将由 <code>/etc/nsswitch.conf</code>  中配置的对应 <code>passwd</code> 库来找到，例如ldap,file等。正如下图2-2所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/image-20221112161605611.png" alt="image-20221112161605611" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：pam和nss工作示意图2-2</center>
<center><em>Source：</em>https://medium.com/@fengliplatform/understanding-nss-and-pam-using-a-ssh-example-80512eb0f39e</center><br>
<h2 id="linux-with-ldap-supa-href11asup">Linux with LDAP <sup><a href="#1">[1]</a></sup></h2>
<p>在大致了解了Linux登录认证的原理后，知道了要使Linux使用LDAP需要配置两个部分，NSS与PAM，通常有下述几种方案：</p>
<ul>
<li>NSS + PAM</li>
<li>SSSD (<em><strong>System Security Services Daemon</strong></em>)，SSSD是提供严重的一种工具，可以包含多种源例如LDAP，AD，Kerberos 等，并且提供了缓存功能（当ldap不可用时提供服务）</li>
</ul>
<h3 id="配置nss">配置NSS</h3>
<p>安装 <code>nss-pam-ldapd</code></p>
<ul>
<li>CentOS/Redhat：<code>	yum install -y nss-pam-ldapd</code></li>
<li>Debian/Ubuntu：<code>apt-get install libnss-ldapd</code></li>
</ul>
<p>配置 <em><strong>/etc/nsswitch.conf</strong></em> ，该文件保存了各数据库，需要对 <code>group</code> , <code>passwd </code> , <code>shadow </code> 库开启 ldap</p>
<pre><code class="language-conf">passwd:     files sss ldap
shadow:     files sss ldap
group:      files sss ldap
</code></pre>
<h3 id="配置pam">配置PAM</h3>
<ul>
<li>CentOS/Redhat：<code>	yum install -y pam_ldap</code></li>
<li>Debian/Ubuntu：<code>apt-get install libpam-ldapd</code></li>
</ul>
<p>要想通过本地 Sudo 实现 OpenLDAP 用户提权，可按以下步骤操作。</p>
<pre><code class="language-sh">authconfig \
--enableldap \
--enableldapauth \
--ldapserver=ldap://10.0.0.10:389 \
--ldapbasedn=&quot;dc=test,dc=org&quot; \
--enablemkhomedir \
--ldapbasedn=&quot;ou=tvb,dc=test,dc=org&quot; \
--enableshadow \
--update \
</code></pre>
<blockquote>
<p>Notes：</p>
<ul>
<li>
<p>CentOS/RedHat 也可以使用 SSSD替代，<code>yum install -y sssd</code> ，上面提供的方案是NSS+PAM</p>
</li>
<li>
<p>通常情况下Ubuntu会使用 SSSD 服务替代，SSSD包含了 PAM模块 和 NSS模块</p>
</li>
<li>
<p>Ubuntu中，没有被 <code>authconfig</code> 没有被打包在 SSSD 中，通常需要安装 <code>sudo apt install ldap-auth-config</code></p>
</li>
</ul>
</blockquote>
<h2 id="linux用户权限控制">Linux用户权限控制</h2>
<p>部署此功能的原因是能够在所有基础结构服务器上仅使用一个用户，并且无需每次在每台服务器上手动更新 <font color="#f8070d" size=3><code>/etc/sudoers</code></font> 文件，即可为此用户提供sudo权限。现在，这些天您可以使用像ansible这样的工具来执行此操作，但是并不是说OpenLDAP用法必须仅用于posixGroup用户访问，因此OpenLDAP只擅长它。OpenLDAP集成应扩展到您部署的每个集中式系统，并且您唯一的“管理员”用户可以访问基础架构范围内的所有系统。</p>
<h3 id="sudoers在slapd部分配置">sudoers在slapd部分配置</h3>
<p>要使 <code>OpenLDAP</code> 服务端实现用户权限控制，具体的实施步骤可以大致分为如下几步：</p>
<ul>
<li>
<p>创建 ldap 中 sudoers容器，并创建默认的搜索域</p>
</li>
<li>
<p>为 <code>slapd</code> 导入sudo schema</p>
</li>
<li>
<p>定义sudo规则条目及sudo组</p>
<ul>
<li>
<p>通过手动定义用户加入sudo组，集成sudo权限</p>
<ul>
<li>命令添加及修改</li>
</ul>
</li>
<li>
<p>通过转换 本地 sudoers 配置文件 为LDAP ldif格式文件</p>
<ul>
<li>OpenLDAP 提供的 perl脚本  <code>sudoers2ldif</code> ，通常会看到，如果没有可以从 <a href="https://github.com/lbt/sudo/blob/master/plugins/sudoers/sudoers2ldif" target="_blank"
   rel="noopener nofollow noreferrer" >Github</a> 中下载</li>
<li>sudo 提供的转换命令 <code>cvtsudoers</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>图形化管理界面配置</p>
</li>
<li>
<p>客户端配置加入OpenLDAP服务端</p>
</li>
<li>
<p>客户端识别sudo策略及验证用户权限</p>
</li>
</ul>
<h3 id="openldap服务端导入sudo-schema">OpenLDAP服务端导入sudo schema</h3>
<pre><code class="language-sh"># 找到sudo的openldap schema
rpm -ql sudo | grep schema

# 将其复制到openldap schema目录
cp /usr/share/doc/sudo-1.8.23/schema.OpenLDAP /etc/openldap/schema/sudo.schema  

# 生成include sudo.ldif
echo &quot;include   /etc/openldap/schema/sudo.schema&quot; &gt;  /tmp/sudo.conf
slapcat -f /tmp/sudo.conf -F /tmp/ -n 0 -s &quot;cn={0}sudo,cn=schema,cn=config&quot; &gt; /tmp/sudo.ldif

# 最后需要删除后面几行
sed -i &quot;s@{0}sudo@sudo@g&quot; /tmp/sudo.ldif
head -n -8 /tmp/sudo.ldif &gt; /etc/openldap/schema/sudo.ldif
</code></pre>
<p>生成的对应schema在：<font color="#f8070d" size=3><code>/etc/openldap/slapd.d/cn=config/cn=schema/</code></font></p>
<h3 id="为-openldap-创建-suers-容器">为 OpenLDAP 创建 suers 容器</h3>
<p>创建ldap的sudoers容器，官网有给出提示，sudoers如果在ldap中使用必须放在 <code>ou=SUDOers</code> 中，其中 <code>cn=default</code> 为最先被查找的条目</p>
<blockquote>
<p>The <em>sudoers</em> configuration is contained in the ‘<code>ou=SUDOers</code>’ LDAP container. <sup><a href="#2">[2]</a></sup></p>
</blockquote>
<p>默认情况下，sudo检索的域为  <code>cn=default,ou=SUDOers,dc=xx,dc=xx</code> 如果找到，那么该条目中所有 <code>sudoOption</code> 属性都会被解析为全局默认值，这类似于服务端中查询一个 sudo 用户权限时一般有两到三次查询。</p>
<ul>
<li>第一次查询解析全局配置</li>
<li>第二次查询匹配用户名或者用户所在的组（特殊标签 ALL 也在此次查询中匹配），如果没有找到相关匹配项，则发出第三次查询，此次查询返回所有包含用户组的条目并检查该用户是否存在于这些组中</li>
</ul>
<p>下面命令是创建一个 sudoers 在 ldap中的根容器 <code>ou=SUDOers</code> ，这个步骤总是需要手动执行，因为默认通过 <code>/etc/sudoers</code> 转换过来的 ldif 是不带这个域的</p>
<pre><code class="language-bash">$ cat &lt;&lt; EOF | ldapadd -D &quot;cn=admin,dc=test,dc=com&quot; -w 111 -H ldap://10.0.0.10:389
dn: ou=SUDOers,dc=test,dc=com
objectclass: organizationalunit
ou: SUDOers
EOF
</code></pre>
<p>下面步骤是将 <code>/etc/sudoers</code> 转换为 ldap <code>ldif</code></p>
<p>创建一个环境变量 <code>SUDOERS_BASE</code> ，这个在perl脚本执行的必须条件。</p>
<pre><code class="language-bash">export SUDOERS_BASE=&quot;ou=SUDOers,dc=test,dc=com&quot;
</code></pre>
<p>接下来，使用sudo包中提供了一个命令 <code>cvtsudoers </code> 可以将  sudoers的配置文件 <code>/etc/sudoers</code> 转换为LDAP ldif格式文件</p>
<pre><code class="language-bash">cvtsudoers /etc/sudoers -f ldif -o sudoers_defaults.ldif
</code></pre>
<p>另外，通过脚本将 sudoers的配置文件 <code>/etc/sudoers</code> 转换为LDAP ldif格式的文件，将用这个来创建默认的<code>cn=default</code> 的sudoers</p>
<pre><code class="language-bash">perl sudoers2ldif /etc/sudoers &gt; sudoers_defaults.ldif
</code></pre>
<blockquote>
<p>Notes：openldap还有一种操作为 <em>ldif to schema</em>，通过下述命令可以完成 <sup><a href="#4">[4]</a></sup></p>
<pre><code class="language-bash">sed '/^dn: /d;/^objectClass: /d;/^cn: /d;s/olcAttributeTypes:/attributetype/g;s/olcObjectClasses:/objectclass/g' file.ldif &gt; file.schema
</code></pre>
</blockquote>
<p>接下来将这些配置导入到ldap中</p>
<pre><code class="language-bash">ldapadd -D &quot;cn=admin,dc=test,dc=com&quot; -w 111 -H ldap://10.0.0.10:389 -f sudoers_defaults.ldif
</code></pre>
<h3 id="配置客户端主机支持sudo-over-ldap">配置客户端主机支持sudo over ldap</h3>
<p>在客户端，需要两个额外步骤。</p>
<p><strong>需要添加</strong>：<font color="#f8070d" size=3><code> /etc/nsswitch.conf</code></font></p>
<pre><code class="language-sh"> ## 增加
 sudoers:    ldap files
 
 echo 'sudoers:    ldap files' &gt;&gt; /etc/nsswitch.conf
</code></pre>
<p><strong>需要提供</strong>：<font color="#f8070d" size=3><code>/etc/sudo-ldap.conf</code></font></p>
<pre><code class="language-sh">binddn cn=clientsearch,ou=admin,dc=cylon,dc=org
bindpw 111
uri ldap://10.0.0.20
sudoers_base ou=sudoers,dc=cylon,dc=org
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>错误：<code>invalid structural object class chain</code></p>
<pre><code class="language-bash">ldap_add: Object class violation (65)
	additional info: invalid structural object class chain (groupOfUniqueNames/posixGroup)
</code></pre>
<p>原因：在ldap中 <code>groupOfUniqueNames</code> / <code>posixGroup</code> / <code>inetOrgPerson</code> 实际上是同一种类型 <sup><a href="#6">[6]</a></sup> ，级别的对象组，其 <code>objectClass</code> 只能选择包含一个，要 <code>gidNumber</code> 就不能有 <code>memberOf</code> 了。</p>
<p><strong>问题出于</strong>：对于筛选来说，<code>posixGroup</code> 组并不支持  <code>memberOf</code>  属性，这种情况下可能无法做到权限的筛选与用户的筛选等，但是对于Linux 使用ldap管理用户权限时，普通的 <code>groupOfUniqueNames</code> 并不带有 <code>gidNumber</code> 属性，使得用户没有组，这时配置的组的权限，sudo实际不生效。</p>
<p><strong>解决</strong>：</p>
<ul>
<li>为 <code>posixGroup</code>  生成一个 <code>memberOf</code> 属性 <sup><a href="#5">[5]</a></sup>，这里在尝试导入 ldif 文件时 slapd 生成配置失败无报错</li>
<li>直接使用 <code>posixGroup</code> 替换组  <code>groupOfUniqueNames</code>
<ul>
<li><code>posixGroup</code> 使用的是 <code>memberUid</code> 进行关联，在检索时，可以使用 <code>uid=memberUid</code> 进行过滤</li>
<li>本质上 <code>posixGroup</code> 与  <code>groupOfUniqueNames</code> 只是对组，没有对用户</li>
<li>需要配置 refint 解决引用关系一致性问题，正如下列给出配置一样
<pre><code class="language-ldif">dn: olcOverlay=refint,olcDatabase={1}mdb,cn=config
objectClass: olcConfig
objectClass: olcOverlayConfig
objectClass: olcRefintConfig
objectClass: top
olcOverlay: refint
olcRefintAttribute: memberUid uid
olcRefintNothing: cn=default,dc=test,dc=com
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://joeho.xyz/blog-posts/configure-openldap-login-for-centos7/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Configure OpenLDAP login for CentOS 7</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://www.sudo.ws/docs/man/sudoers.ldap.man/#SUDOers_LDAP_container" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>sudoers.ldap.man</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://medium.com/@fengliplatform/understanding-nss-and-pam-using-a-ssh-example-80512eb0f39e" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Understanding nss and pam using a ssh example</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://serverfault.com/questions/818393/openldap-convert-ad-schema-from-ldif-to-schema" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Convert AD-Schema from *.ldif to *.schema</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="http://blog.oddbit.com/post/2013-07-22-generating-a-membero/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>GENERATING A MEMBEROF ATTRIBUTE FOR POSIXGROUPS</strong></em></a></p>
<p><sup id="6">[6]</sup> <a href="https://ldap.umich.narkive.com/4c1rn2Qz/how-to-fix-65-invalid-structural-object-class-chain-posixgroup-groupofnames" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>how to fix (65) invalid structural object class chain (posixGroup/groupOfNames)?</strong></em></a></p>
<p><sup id="7">[7]</sup> <a href="https://joeho.xyz/blog-posts/configure-openldap-login-for-centos7/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Configure OpenLDAP login for CentOS 7</strong></em></a></p>
<p><sup id="8">[8]</sup> <a href="https://linuxhint.com/linux-ldap-authentication-2/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Linux LDAP Authentication</strong></em></a></p>
<p><sup id="9">[9]</sup> <a href="https://www.vennedey.net/resources/1-Linux-user-management-with-LDAP" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Linux user management with LDAP</strong></em></a></p>
<p><sup id="10">[10]</sup> <a href="https://tldp.org/HOWTO/archived/LDAP-Implementation-HOWTO/pamnss.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>2. LDAP authentication using pam_ldap and nss_ldap</strong></em></a></p>
<p><sup id="11">[11]</sup> <a href="https://kifarunix.com/how-to-configure-sudo-via-openldap-server/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>How to Configure SUDO via OpenLDAP Server</strong></em></a></p>
<p><sup id="12">[12]</sup> <a href="http://pig.made-it.com/ldap-sudoers.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>SUDOers from OpenLDAP</strong></em></a></p>
<p><sup id="13">[13]</sup> <a href="https://wiki.shileizcc.com/confluence/pages/viewpage.action?pageId=40566794#OpenLDAPSudo%e6%9d%83%e9%99%90%e8%ae%b2%e8%a7%a3-OpenLDAPSudo%e6%9d%83%e9%99%90%e8%ae%b2%e8%a7%a3" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>OpenLDAPSudo权限讲解-OpenLDAPSudo权限讲解</strong></em></a></p>
<p><sup id="14">[14]</sup> <a href="https://linux.die.net/man/8/authconfig" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>authconfig</strong></em></a></p>
<p><sup id="15">[15]</sup> <a href="https://mariadb.com/kb/en/configuring-pam-authentication-and-user-mapping-with-ldap-authentication/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Configuring PAM Authentication and User Mapping with LDAP Authentication</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - openldap中的一些高级配置</title>
      <link>https://www.oomkill.com/2019/09/ch9-openldap-configuration/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch9-openldap-configuration/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="memberof">memberOf</h2>
<p>默认情况下，openldap提供的Posixgroup组，实际上并不能很有效的区分组与用户之间的关系。而 <code>memberOf</code> 则可以有效地检索用户与组的关系</p>
<h3 id="在openldap配置memberof模块">在OpenLDAP配置MemberOf模块</h3>
<p><strong>步骤一</strong>：可以检查在允许的slapd服务是否已经启用该模块</p>
<pre><code class="language-bash">$ slapcat -n 0 | grep olcModuleLoad
</code></pre>
<p>对于新部署的服务，可以按照如下方式添加</p>
<pre><code>dn: cn=module,cn=config
objectClass: olcModuleList
cn: module
olcModuleload: memberof.la
</code></pre>
<p>可以在线更改一个正在运行的slapd服务，使其加载 <code>memberOf</code> 模块，需要主义对应的 <code>module{0}</code> 是否正确</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapmodify -Q -Y EXTERNAL -H ldapi:///
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: memberof.la
EOF
</code></pre>
<p><strong>步骤二</strong>：配置overlay</p>
<p>在官方指南中看到<code>olcOverlay</code> 必须要配置到特定数据库的子条目。即此配置段需要在database配置后面。</p>
<blockquote>
<p>Overlays must be configured as child entries of  a  specific  database. <sup><a href="#1">[1]</a></sup></p>
</blockquote>
<pre><code>dn: olcOverlay={0}memberof,olcDatabase={2}hdb,cn=config
objectClass: olcConfig
objectClass: olcMemberOf
objectClass: olcOverlayConfig
objectClass: top
olcOverlay: memberof
olcMemberOfDangling: ignore
olcMemberOfRefInt: TRUE
olcMemberOfGroupOC: groupOfUniqueNames
olcMemberOfMemberAD: uniqueMember
olcMemberOfMemberOfAD: memberOf
</code></pre>
<p><strong>步骤三</strong>：配置refint</p>
<p>refint为 (<em><strong>referential integrity</strong></em>)，所引用完整性。是保持属性与所引用的条目保持一致。在使用 <code>memberOf</code> 时，当一个用户被归为 <code>memberOf</code> 组时，会存在 <code>memberOf</code> 的属性。当这个用户组重命名或删除时，<code>refintOverlay</code> 将自动修改或删除对应的属性。</p>
<pre><code class="language-ldif">dn: olcOverlay=refint,olcDatabase={2}hdb,cn=config
objectClass: olcConfig
objectClass: olcOverlayConfig
objectClass: olcRefintConfig
objectClass: top
olcOverlay: refint
olcRefintAttribute: memberOf uniqueMember uid cn ## 哪些属性被改动时修改其他所属关系。
</code></pre>
<p><strong>步骤四</strong>：配置memberOf</p>
<p>新建一个groupOfUniqueNames用户组，将用户放入组内</p>
<pre><code>cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: ou=tvb,dc=test,dc=com
objectClass: organizationalUnit
ou: tvb

dn: cn=adminGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: adminGroup
uniqueMember: uid=admin,ou=tvb,dc=test,dc=com

dn: cn=dirGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: dirGroup
uniqueMember: uid=searchUser,ou=tvb,dc=test,dc=com

dn: cn=confGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: confGroup
uniqueMember: uid=syncUser,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<p>创建测试用户</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=syncUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: syncUser
cn: syncUser
uidNumber: 10006
gidNumber: 10002
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
homeDirectory: /home/syncUser
loginShell: /bin/bash
sn: syncUser
givenName: syncUser
memberOf: cn=confGroup,ou=tvb,dc=test,dc=com

dn: uid=searchUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: searchUser
cn: searchUser
uidNumber: 10005
gidNumber: 10001
homeDirectory: /home/searchUser
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: searchUser
givenName: searchUser
memberOf: cn=dirGroup,ou=tvb,dc=test,dc=com

dn: uid=admin,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: admin
cn: admin
uidNumber: 0
gidNumber: 0
homeDirectory: /home/admin
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin1,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: admin1
cn: admin
uidNumber: 0
gidNumber: 0
homeDirectory: /home/admin
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<p>查看用户的memberof属性</p>
<pre><code>$ ldapsearch -x -H ldaps://10.0.0.4 -b dc=test,dc=com -D &quot;cn=admin,dc=test,dc=com&quot; -w 111 memberOf
</code></pre>
<h2 id="referential-integrity">Referential Integrity</h2>
<p>引用完整 (<em><strong>Referential Integrity</strong></em>) 模块是指在两个属性互相引用时，如果自动修改或删除了一端的值，将保持另一端也能够保持一致性，删除或更新。</p>
<p>例如下面示例，<code>uid=eve,ou=users,dc=tvb,dc=com</code> 是一个管理员用户，<code>uid=mallory,ou=users,dc=tvb,dc=com</code> 是一个普通用户，普通用户mallory的管理员是eve用户，当eve用户修改名称或者被删除时，mallory对应的 <code>manager</code> 也应该保持更新或删除</p>
<pre><code class="language-ldif">dn: uid=eve,ou=users,dc=tvb,dc=com
objectClass: posixAccount
objectClass: shadowAccount
objectClass: inetOrgPerson
cn: Eve
sn: Eavesdropper
uid: eve
uidNumber: 5000
gidNumber: 5000
homeDirectory: /home/eve
loginShell: /bin/sh
gecos: Eve Eavesdropper

dn: uid=mallory,ou=users,dc=tvb,dc=com
objectClass: posixAccount
objectClass: shadowAccount
objectClass: inetOrgPerson
cn: Mallory
sn: Malicious
uid: eve
uidNumber: 5001
gidNumber: 5000
homeDirectory: /home/mallory
loginShell: /bin/sh
gecos: Mallory Malicious
manager: uid=eve,ou=users,dc=tvb,dc=com
</code></pre>
<h3 id="在openldap配置referential-integrity模块">在OpenLDAP配置Referential Integrity模块</h3>
<p><strong>步骤一</strong>：可以检查在允许的slapd服务是否已经启用该模块</p>
<pre><code class="language-bash">$ slapcat -n 0 | grep olcModuleLoad
</code></pre>
<p>可以在线更改一个正在运行的slapd服务，使其加载 <code>refint</code> 模块，需要主义对应的 <code>module{0}</code> 是否正确</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapmodify -Q -Y EXTERNAL -H ldapi:///
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: refint.la
EOF
</code></pre>
<p>另外如果 模块目录不为标准的路径，也需要配置 <code>olcModulePath</code> ，当然这个参数只能指定一次</p>
<pre><code class="language-ldif">dn: cn=module,cn=config
cn: module 
objectClass: olcModuleList
olcModulePath: /opt/openldap-current/libexec/openldap
olcModuleLoad: refint.la
</code></pre>
<p>下表是关于各操作系统内置 openldap 服务模块的标准路径</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>PATH</th>
</tr>
</thead>
<tbody>
<tr>
<td>CentOS 7</td>
<td>/usr/lib64/openldap</td>
</tr>
<tr>
<td>openSUSE</td>
<td>/usr/lib64/openldap</td>
</tr>
<tr>
<td>Debian (Stretch)</td>
<td>/usr/lib/ldap</td>
</tr>
<tr>
<td>Source (Default)</td>
<td>/usr/local/libexec/openldap</td>
</tr>
</tbody>
</table>
<p>由于overlay的特性，需要指定为database的子模块</p>
<pre><code class="language-bash">$ cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcOverlay=refint,olcDatabase={1}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcRefintConfig
olcOverlay: refint
olcRefintAttribute: manager secretary
olcRefintNothing: cn=config
EOF
</code></pre>
<p>这里需要注意的属性为：</p>
<ul>
<li><code>olcDatabase={1}mdb</code> 数据库这里需要指定要配置的数据库</li>
<li><code>olcRefintAttribute</code> 这个属性指明了两个条目间关联的属性</li>
<li><code>olcRefintNothing</code> 可选参数，因为两端需要关联时，例如memberOf，组对象至少保留一个 <code>memberOf</code> 属性，当删除最后一个关联用户时，会提示非法，这个参数就是在删除最后一个用户时，指定一个占位符的该属性</li>
</ul>
<h2 id="password-policy">Password Policy</h2>
<p>openldap中 Password Policy 是指用户的密码策略，如过期时间，密码安全最低要求等</p>
<h3 id="在openldap配置ppolicy模块">在OpenLDAP配置ppolicy模块</h3>
<p>可以在线更改一个正在运行的slapd服务，使其加载 <code>ppolicy</code> 模块，需要主义对应的 <code>module{0}</code> 是否正确</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapmodify -Q -Y EXTERNAL -H ldapi:///
dn: cn=module{0},cn=config
changetype: modify
add: olcModuleLoad
olcModuleLoad: ppolicy.la
EOF
</code></pre>
<p>在加载完成后，需要叠加到database上才可以生效，如下列配置</p>
<pre><code class="language-ldif">dn: olcOverlay=ppolicy,olcDatabase={1}mdb,cn=config
objectClass: olcPPolicyConfig
olcOverlay: ppolicy
olcPPolicyDefault: cn=default,ou=tvb,dc=test,dc=com
olcPPolicyUseLockout: FALSE
olcPPolicyHashCleartext: TRUE
</code></pre>
<p>这里需要注意的一点是，<code>olcPPolicyDefault</code> 是指定的一个默认密码策略，即没有为用户配置密码策略时，将使用这个默认策略</p>
<h3 id="为用户配置默认策略">为用户配置默认策略</h3>
<p>如果需要使用模块 <code>ppolicy</code> ，必须做下述三个步骤其一才可满足为用户密码提供一个管理策略</p>
<ul>
<li>需要创建一个默认策略</li>
<li>为用户 ldift 添加属性  <code>pwdPolicySubentry</code> ，这可以为不同的用户设置不同的密码策略</li>
<li>属性 <code>pwdPolicy</code> 可以作为用户 ldif 中被多次引用，这代表可以设置多种不同的策略，这种比较繁琐</li>
</ul>
<p><strong>场景一</strong>：创建一个默认策略</p>
<p>例如在配置ppolicy的overlay时，默认策略名称填写了 <code>cn=default,ou=tvb,dc=test,dc=com</code> 那么需要用这个DN创建一个默认策略，而创建DN需要按层级创建，顾需要创建 <code>ou=plicies</code></p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: ou=tvb,dc=test,dc=com
objectClass: organizationalUnit
ou: policies
EOF
</code></pre>
<p>接下来创建默认的密码策略</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: cn=default,ou=tvb,dc=test,dc=com
objectClass: pwdPolicy
objectClass: organizationalRole
cn: default
pwdAttribute: userPassword
pwdMinLength: 3
pwdCheckQuality: 2
EOF
</code></pre>
<p>下表是对于一些密码策略的属性说明</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pwdAttribute</td>
<td>指定那个字段是密码</td>
</tr>
<tr>
<td>pwdMinAge</td>
<td>多少秒之间必须经过更改密码，默认0</td>
</tr>
<tr>
<td>pwdMaxAge</td>
<td>密码最大期限，如果密码过期用户将被拒绝登录。 默认的是密码永不过期。</td>
</tr>
<tr>
<td>pwdInHistory</td>
<td>存储多少个历史旧密码，例如更改密码时提示与历史使用密码类似。 默认为0，即可以重复使用旧密码</td>
</tr>
<tr>
<td>pwdMinLength</td>
<td>密码的最小的长度。 默认没有长度的要求。 这个属性将与 <code>pwdCheckQuality</code> 同时生效，当  <code>pwdCheckQuality</code> 为0，则长度限制不生效</td>
</tr>
<tr>
<td>pwdCheckQuality</td>
<td>如何对用户长度进行检查。 默认0不检查，<br>2 ：总是强制执行的质量检查；如果它不能检查它，密码就会被拒绝。<br>1 ：可被接受的密码</td>
</tr>
<tr>
<td>pwdMaxFailure</td>
<td>密码错误几次用户被锁定，默认0 代表不会被锁定，他们是锁着的。 为了对此采取影响，  必须关联属性 <code>pwdLockout=TRUE</code></td>
</tr>
<tr>
<td>pwdLockout</td>
<td><code>pwdLockout=TRUE</code> 时  pwdMaxFailure 会生效，否则忽略  <code>pwdMaxFailure</code> 配置</td>
</tr>
<tr>
<td>pwdLockoutDuration</td>
<td>账户自动解锁的时间</td>
</tr>
<tr>
<td>pwdMustChange</td>
<td>这是当管理员创建用户后，第一次登陆时需要必须修改密码</td>
</tr>
<tr>
<td>pwdPolicySubentry</td>
<td>表示设置密码的策略。 DN对应适用密码政策的条目。 默认策略由  <code>olcPPolicyDefault</code>  属性的配置。如果不存在，会使用 <code>olcPPolicyDefault</code> ，当存在时会覆盖 <code>olcPPolicyDefault</code></td>
</tr>
</tbody>
</table>
<p>如果需要上述的策略，需要引入对象 <code>objectClass: pwdPolicy</code> 例如修改一个用户的密码策略</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=searchUser,ou=tvb,dc=test,dc=com
changetype: modify
add: pwdMinLength
pwdMinLength: 4
-
add: pwdCheckQuality
pwdCheckQuality: 2
-
replace: pwdPolicySubentry
pwdPolicySubentry: cn=example2,ou=tvb,dc=tvb,dc=com
EOF
</code></pre>
<p>而上述属性  <code>pwdPolicySubentry</code>  代表那个策略适用于那个条目。 如果不存在则默认策略生效。如果需要引入存在的密码策略可以使用该属性进行应用。</p>
<p>例如，下述是创建两天密码策略</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: cn=example1,ou=tvb,dc=test,dc=com
cn: example1
objectClass: organizationalRole
objectClass: pwdPolicy
pwdAttribute: userPassword
pwdMinLength: 5
pwdCheckQuality: 2

dn: cn=example2,ou=tvb,dc=test,dc=com
cn: example2
objectClass: organizationalRole
objectClass: pwdPolicy
pwdAttribute: userPassword
pwdMinLength: 6
pwdCheckQuality: 2
pwdMaxFailure: 3
pwdLockout: TRUE
pwdLockoutDuration: 10
pwdInHistory: 5
EOF
</code></pre>
<p>当需要创建一个用户引用现有的一组密码策略时，可以对用户添加属性 <code> pwdPolicySubentry</code>，而不是重复的设置每条策略，例如下面示例</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=admin1,ou=tvb,dc=test,dc=com
changetype: modify
add: pwdPolicySubentry
pwdPolicySubentry: cn=example1,ou=tvb,dc=tvb,dc=com

dn: uid=searchUser,ou=tvb,dc=test,dc=com
changetype: modify
add: pwdPolicySubentry
pwdPolicySubentry: cn=example2,ou=tvb,dc=tvb,dc=com
EOF
</code></pre>
<h2 id="reference"><strong>Reference</strong></h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.openldap.org/software/man.cgi?query=slapd-config&amp;sektion=5&amp;apropos=0&amp;manpath=OpenLDAP&#43;2.4-Release#OVERLAYS" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>slapd-config</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - OpenLDAP备份与恢复策略</title>
      <link>https://www.oomkill.com/2019/09/ch8-backup-and-restore/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch8-backup-and-restore/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>本章基于openldap 2.4+版本进行，主要讲解 openldap 的两种备份方法：备份openldap <code>backend-database</code> 文件，另一种方式为导出 <code>LDIF</code> 目录方式</p>
<h2 id="backup">Backup</h2>
<p>备份部分将分为两种方式：使用基于 <code>slapcat</code> 导出目录文件方式，与直接备份数据库文件方式。</p>
<p><code>slapcat</code> 是可用于导出 slapd 数据库中数据为LDAP交换格式的命令行工具，它可以导出 slapd 的配置也可以导出 slapd的数据。</p>
<p><code>slapcat</code> 使用起来很简单，参数也是与 openldap 其他命令参数类似，</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a <em>filter</em></td>
<td>只导出与过滤器声明条件相匹配的数据<br>例如：<code>slapcat -a &quot;(!(entryDN:dnSubtreeMatch:=ou=People,dc=example,dc=com))&quot;</code></td>
</tr>
<tr>
<td style="text-align:center">-b <em>suffix</em></td>
<td>将只导出-b指定DN域内数据，-b 不能与 -n 同时使用</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td>忽略错误</td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td>-f 后接的文件将替代默认的配置文件，通常情况下备份在slapd本机执行可以不使用该参数</td>
</tr>
<tr>
<td style="text-align:center">-F</td>
<td>指定配置目录，-F比-f优先级高，同时指定生效为-F，也就是导出的目录</td>
</tr>
<tr>
<td style="text-align:center">-g</td>
<td>导出时不使用从属关系，仅仅为指定的数据库才会被导出</td>
</tr>
<tr>
<td style="text-align:center">-H</td>
<td>连接 slapd 服务的地址</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td>输出的文件，默认slapcat是将内容输出到标准输出stdout中</td>
</tr>
<tr>
<td style="text-align:center">-s <em>subtree-dn</em></td>
<td>仅导出符合dn子树的条目</td>
</tr>
</tbody>
</table>
<p>例如下列命令用于备份配置文件的</p>
<pre><code class="language-bash">$ slapcat -n 0 -l config.ldif
</code></pre>
<blockquote>
<p>Notes：slapd中，配置（0）永远是第一个数据库，跟着的就是在配置中指定的数据库，例如 {0}hdb 将表示1，{1}hdb 则是2</p>
</blockquote>
<p>下列命令用于导出为LDIF格式数据</p>
<pre><code class="language-bash">$ slapcat -n 1 -l data.ldif
</code></pre>
<h2 id="restore">Restore</h2>
<p>恢复配置时，建议直接删除原有配置，而后重新生成新的即可，下表为常见的操作系统openldap配置目录</p>
<table>
<thead>
<tr>
<th>OS</th>
<th>Configuration Directory</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian/Ubuntu</td>
<td>/etc/ldap/slapd.d</td>
</tr>
<tr>
<td>RHEL/CentOS</td>
<td>/etc/openldap/slapd.d</td>
</tr>
<tr>
<td>SuSE (Uses slapd.conf)</td>
<td>/etc/openldap/slapd.d</td>
</tr>
<tr>
<td>FreeBSD</td>
<td>/usr/local/etc/openldap/slapd.d</td>
</tr>
</tbody>
</table>
<p>下列命令是恢复配置的命令，<code>-l</code> 用户指定导出的ldif文件，<code>-F</code> 为配置目录，必须存在</p>
<pre><code class="language-bash">$ slapadd -n 0 -F /etc/openldap/slapd.d -l /backups/config.ldif
</code></pre>
<p>因为运行 slapd 进程的用户为 ldap，所以新配置目录的必须拥有权限</p>
<pre><code class="language-bash">$ chown -R ldap:ldap /etc/openldap/slapd.d
</code></pre>
<p>下列命令是恢复数据的命令。其实就是重新添加回去</p>
<pre><code class="language-bash">$ slapadd -n 1 -F /config/directory/slapd.d -l /backups/data.ldif -w
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - OpenLDAP访问控制（ACL）</title>
      <link>https://www.oomkill.com/2019/09/ch7-acl/</link>
      <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch7-acl/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>访问控制 (<em><strong>Access Control</strong></em>) 是对目录树中的IDT访问的权限控制。主要指 “谁” 应该能够 “访问记录” 在 “什么条件下” 他们应该能看到多少这样的记录，这些将是本节中阐述的问题 。</p>
<p>OpenLDAP控制目录数据访问的主要方法是 通过访问控制列表 (<em><strong>Access Control List</strong></em>)。使 slapd 服务端在处理来自客户端的请求时，会评估客户端是否具有访问所请求的 DIT 的权限。要执行此计算，slapd 将依次计算<em><strong>LDIF</strong></em> 中配置的每个ACL策略，以检查客户端是否有权限访问该 DIT。</p>
<hr>
<blockquote>
<p><strong>Note</strong>：</p>
<ul>
<li>ACL策略由上而下依次进行匹配</li>
<li>默认的访问控制策略是对所有客户端都允许读取，不管定义了什么ACL策略，<code>rootdn </code> （databases部分设置的）总是允许对所有和任何东西拥有完全的权限（即身份验证、搜索、比较、读和写 ）</li>
</ul>
</blockquote>
<hr>
<h2 id="acl介绍">ACL介绍</h2>
<p>访问控制主要定义三大方面：</p>
<ul>
<li><code>what</code> 定义对那些地方的访问，部分选择应用访问的条目和/或属性</li>
<li><code>who</code> 定义人员，部分指定授予哪些实体访问</li>
<li><code>access</code> 定义权限，部分指定授予的访问。</li>
</ul>
<pre><code>access to [what]
    by [who] [control]
    by [who] [control]
</code></pre>
<pre><code>access to [resources]
    by [who] [type of access granted] [control]
    by [who] [type of access granted] [control]
</code></pre>
<p>对于完整的ACL语法，如下面所示 <sup><a href="#1">[1]</a></sup></p>
<pre><code>&lt;access directive&gt; ::= access to &lt;what&gt;
	[by &lt;who&gt; [&lt;access&gt;] [&lt;control&gt;] ]+
&lt;what&gt; ::= * |
	[dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]
	[filter=&lt;ldapfilter&gt;] [attrs=&lt;attrlist&gt;]
&lt;basic-style&gt; ::= regex | exact
&lt;scope-style&gt; ::= base | one | subtree | children
&lt;attrlist&gt; ::= &lt;attr&gt; [val[.&lt;basic-style&gt;]=&lt;regex&gt;] | &lt;attr&gt; , &lt;attrlist&gt;
&lt;attr&gt; ::= &lt;attrname&gt; | entry | children
&lt;who&gt; ::= * | [anonymous | users | self
			| dn[.&lt;basic-style&gt;]=&lt;regex&gt; | dn.&lt;scope-style&gt;=&lt;DN&gt;]
	[dnattr=&lt;attrname&gt;]
	[group[/&lt;objectclass&gt;[/&lt;attrname&gt;][.&lt;basic-style&gt;]]=&lt;regex&gt;]
	[peername[.&lt;basic-style&gt;]=&lt;regex&gt;]
	[sockname[.&lt;basic-style&gt;]=&lt;regex&gt;]
	[domain[.&lt;basic-style&gt;]=&lt;regex&gt;]
	[sockurl[.&lt;basic-style&gt;]=&lt;regex&gt;]
	[set=&lt;setspec&gt;]
	[aci=&lt;attrname&gt;]
&lt;access&gt; ::= [self]{&lt;level&gt;|&lt;priv&gt;}
&lt;level&gt; ::= none | disclose | auth | compare | search | read | write | manage
&lt;priv&gt; ::= {=|+|-}{m|w|r|s|c|x|d|0}+
&lt;control&gt; ::= [stop | continue | break]
</code></pre>
<ul>
<li><code>what</code> 部分将确定如何控制客户端访问的条目，通常为三种方式：
<ul>
<li>通过DN</li>
<li>通过过滤器 (<em><strong>filter</strong></em>)</li>
<li>通过属性 (<em><strong>attributes</strong></em>)</li>
</ul>
</li>
<li><code>who</code> 部分将确定被授予访问权限的用户实体
<ul>
<li><code>&lt;who&gt;</code> ，  <code>&lt;access&gt;</code> ， <code>&lt;control&gt;</code></li>
</ul>
</li>
<li><code>access</code> 部分确定了实体的访问权限</li>
</ul>
<h2 id="控制访问内容">控制访问内容</h2>
<p>访问内容也是 ACL 中 <em><strong>what</strong></em> 部分，例如下属为简单表示的语法格式</p>
<pre><code>to * 
to dn[.&lt;basic-style&gt;]=&lt;regex&gt; 
to dn.&lt;scope-style&gt;=&lt;DN&gt;
</code></pre>
<ul>
<li>其中 <code>to *</code> 表示选择所有条目</li>
<li><code>to dn[.&lt;basic-style&gt;]=&lt;regex&gt; </code> ：通过正则表达式与DIT规范的DN来选择内容</li>
<li><code>to dn.&lt;scope-style&gt;=&lt;DN&gt;</code> ：内容将被限制在DN范围内</li>
</ul>
<p>其中范围包含下述几项：</p>
<ul>
<li>base：仅匹配提供DN的条目</li>
<li>one：父条目是指定DN的条目</li>
<li>subtree：匹配指定DN下的所有子树中的条目，包含RootDN</li>
<li>children：匹配指定的DN下的所有子条目，不包含RootDN</li>
</ul>
<p>例如下列实例</p>
<pre><code> 0: o=suffix 
 1: cn=Manager,o=suffix 
 2: ou=people,o=suffix 
 3: uid=kdz,ou=people,o=suffix 
 4: cn=addresses,uid=kdz,ou=people, o=suffix 
 5：uid=hyc,ou=people,o=suffix
</code></pre>
<ul>
<li>如果请求为 <code>dn.base=&quot;ou=people,o=suffix&quot;</code> 将匹配2</li>
<li>如果请求为 <code>dn.one=&quot;ou=people,o=suffix&quot;</code> 将匹配 3, 5</li>
<li>如果请求为 <code>dn.subtree=&quot;ou=people,o=suffix&quot;</code> 将匹配 2, 3, 4, 5</li>
<li>如果请求为 <code>dn.children=&quot;ou=people,o=suffix&quot;</code> 将匹配 3, 4, 5</li>
</ul>
<hr>
<blockquote>
<p><strong>Notes</strong>：在配置ACL时，<code>to *</code> 通常放置在ACL策略中最下层，即代表不匹配所有的权限时给的权限</p>
</blockquote>
<hr>
<h3 id="通过dn匹配示例">通过DN匹配示例</h3>
<pre><code>access to dn.regex=&quot;uid[^,]+,ou=Users,dc=example,dc=com&quot;
</code></pre>
<p>这表示 所有 来自任意 uid 为逗号开头的 <code>ou=Users,dc=example,dc=com</code> 域的权限</p>
<h3 id="使用filter匹配">使用filter匹配</h3>
<pre><code>to filter=&lt;ldap filter&gt;
</code></pre>
<p><strong>例</strong> ：DN与filter可以同时包含在 <code>&lt;what&gt; </code>子句中</p>
<pre><code>access to filter=(objectClass=person)
access to filter=&quot;(|(|(givenName=Matt)(givenName=Barbara))(sn=Kant))&quot;
access to dn.subtree=&quot;ou=Users,dc=example,dc=com&quot; filter=&quot;(employeeNumber=*)&quot;
</code></pre>
<p><strong>例</strong> ： <code>&lt;what&gt;</code> 子句中也可以包含属性来进行过滤，多个属性可以通过符号 “<code>,</code>” 分割</p>
<pre><code>attrs=&lt;attribute list&gt;
access to attrs=userPassword,shadowLastChange
</code></pre>
<p><strong>例</strong>：通过使用单个 <code>attribute</code> 与使用value选择器来过滤出特定的属性</p>
<pre><code>attrs=&lt;attribute&gt; val[.&lt;style&gt;]=&lt;regex&gt;

access to dn.children=&quot;cn=people,dc=stanford,dc=edu&quot; attrs=suPrivilegeGroup val.regex=&quot;^stanford:.+&quot;
</code></pre>
<blockquote>
<p>Notes： “ <code>*</code> ”  代表 <code>dn=*</code></p>
</blockquote>
<h3 id="who">WHO</h3>
<p><code>&lt;who&gt;</code> 部分标识被授权访问的角色，例如被授权访问的用户</p>
<hr>
<blockquote>
<p>Notes：who 代表的是一个实体，例如用户，组，域，二不是访问的条目</p>
</blockquote>
<hr>
<p><strong>下表总结了who拥有的角色</strong></p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>访问实体</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>所有，包括匿名和经过身份验证的用户</td>
</tr>
<tr>
<td>anonymous</td>
<td>匿名用户（未验证）</td>
</tr>
<tr>
<td>users</td>
<td>通过身份验证的用户</td>
</tr>
<tr>
<td>self</td>
<td>与目标条目关联的用户</td>
</tr>
<tr>
<td><code>dn[.&lt;basic style&gt;]=&lt;regex&gt;</code></td>
<td>匹配正则表达式的用户</td>
</tr>
<tr>
<td><code>dn.&lt;scope-style&gt;=&lt;DN&gt;</code></td>
<td>DN范围内的用户</td>
</tr>
</tbody>
</table>
<p><strong>例</strong>：who子句中的 <code>dnattr</code> 仅适用于符合ldap语法的DN的属性，而不是其他属性</p>
<pre><code>dnattr=&lt;dn-valued attribute name&gt;
by *dnattr*=orgaAdmin
</code></pre>
<h3 id="access">ACCESS</h3>
<p><code>access</code> 类型可以是下列之一：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th style="text-align:right">权限</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td style="text-align:right">0</td>
<td>禁止访问</td>
</tr>
<tr>
<td>disclose</td>
<td style="text-align:right">d</td>
<td>检测信息是否存在</td>
</tr>
<tr>
<td>auth</td>
<td style="text-align:right">dx</td>
<td>需要验证</td>
</tr>
<tr>
<td>compare</td>
<td style="text-align:right">cdx</td>
<td>需要比较</td>
</tr>
<tr>
<td>search</td>
<td style="text-align:right">scdx</td>
<td>需要应用搜索过滤器</td>
</tr>
<tr>
<td>read</td>
<td style="text-align:right">rscdx</td>
<td>需要读搜索结果</td>
</tr>
<tr>
<td>write</td>
<td style="text-align:right">wrscdx</td>
<td>需要修改/重命名</td>
</tr>
<tr>
<td>manage</td>
<td style="text-align:right">mwrscdx</td>
<td>需要管理</td>
</tr>
</tbody>
</table>
<p>其中权限字段字母意思为：</p>
<ul>
<li><code>w</code>：对记录或属性的写访问。</li>
<li><code>r</code>：对记录或属性的读访问。</li>
<li><code>s</code>：对记录或属性的搜索访问。</li>
<li><code>c</code>：访问对记录或属性运行比较操作。</li>
<li><code>x</code>：访问对记录或属性执行服务器端身份验证操作。</li>
<li><code>d</code>：访问记录或属性是否存在的信息 (d 代表“disclose” )。</li>
<li><code>0</code>：不允许访问记录或属性。这相当于 wrscxd 。</li>
<li><code>m</code>：管理权限</li>
</ul>
<p><strong>例</strong> ：最简单的access策略，限制所有人都可以读</p>
<pre><code>access to * by * read
</code></pre>
<p><strong>例</strong> ：下面示例为，对于条目所属者可以修改自己，匿名用户需要登陆，所有人可以读，对于 <code>by anonymous auth</code> 仅仅是声明了匿名用户可以登录，而读的属性是下面那条声明的。</p>
<pre><code>access to *
    by self write
    by anonymous auth
    by * read
</code></pre>
<p><strong>例</strong> ：使用 SSF <code>Security Strength Factor</code> 进行认证，SSF表示为openldap中保护的强度，与密钥长度有关</p>
<p>下列带包了，如果ssf强度大于128的将允许被修改自己，大于64的匿名用户可以读操作</p>
<pre><code>access to *
    by ssf=128 self write
    by ssf=64 anonymous auth
    by ssf=64 users read
</code></pre>
<p><strong>例</strong> ：下面示例为 DN示例，这将代表了人员必须有所有用户搜索 <code>dc=example,dc=com</code> 子目录，并且对  <code>dn.children=&quot;dc=com</code> 的子目录有读权限，而这里 <code>dc=example,dc=com</code> 为 <code>dc=com</code> 子目录，所以说如果要读 目录 <code>dc=example,dc=com</code> 此时没有权限，因为ACL策略是按照顺序进行的，匹配到后就结束了</p>
<pre><code>access to dn.children=&quot;dc=example,dc=com&quot;
	by * search
access to dn.children=&quot;dc=com&quot;
	by * read
</code></pre>
<p><strong>例</strong> ：还需要注意的一点是，所有列出的策略结尾都会隐式增加一条 <code>access to * by * none</code> 即，当没有通过who子句，也会被拒绝。</p>
<p>例如该策略将允许 <code>dc=example,dc=com</code> 子目录，并且属性 <code>homePhone</code> 的属于自己条目的可以写入，可以进行搜索，并包含 <code>dn=dc=example,dc=com</code> 下的所有子条目，并且网络客户端为10开头的ip都可以读，其他的将被隐式策略拒绝</p>
<pre><code>access to dn.subtree=&quot;dc=example,dc=com&quot; attrs=homePhone
    by self write
    by dn.children=&quot;dc=example,dc=com&quot; search
    by peername.regex=IP=10\..+ read
access to dn.subtree=&quot;dc=example,dc=com&quot;
    by self write
    by dn.children=&quot;dc=example,dc=com&quot; search
    by anonymous auth
</code></pre>
<p><strong>例</strong> ：有些场景下需要只有组内成员才能删除自己租的条目对象，这个时候就需要用到 <code>dnattr </code> 作为 who 子句的选择器；下面的策略表示只有符合这个域中的成员才能删除自己的DN，这里attrs是必须的</p>
<pre><code>access to attrs=member,entry
	by dnattr=member selfwrite
</code></pre>
<h3 id="acl的排序">ACL的排序</h3>
<p>ACL的顺序也非常重要，如果不配置，将按照默认的固定顺序进行，但是也可以控制顺序的先后，通过为每个值添加 <code>{x}</code> x 为数字，这样可以做到ACL的排序</p>
<p>例如下列策略，在执行时是由 slapd 服务自动维护的</p>
<pre><code>olcAccess: to attrs=member,entry 
	by dnattr=member selfwrite 
olcAccess: to dn.children=&quot;dc=example,dc=com&quot; 
	by * search 
olcAccess: to dn.children=&quot;dc=com&quot; 
	by * read
# 在没指定顺序时，将按照下列顺序执行
olcAccess: {0}to attrs=member,entry 
	by dnattr=member selfwrite 
olcAccess: {1}to dn.children=&quot;dc=example,dc=com&quot; 
	by * search 
olcAccess: {2}to dn.children=&quot;dc=com&quot; 
	by * read
</code></pre>
<p>比如说在生成好的策略进行动态修改时，例如下列所示，此时时修改顺序将是乱的</p>
<pre><code>changetype: modify
delete: olcAccess
olcAccess: to dn.children=&quot;dc=example,dc=com&quot; by * search
-
add: olcAccess
olcAccess: to dn.children=&quot;dc=example,dc=com&quot; by * write
</code></pre>
<p>为了确保可以修改到指定的条目，需要指定对应条目的index，如果并不确定index是多少，可以通过 <code>/etc/openldap/slapd.d/</code> 对应的文件查看</p>
<pre><code>changetype: modify
delete: olcAccess
olcAccess: {1}
-
add: olcAccess
olcAccess: {1}to dn.children=&quot;dc=example,dc=com&quot; by * write
</code></pre>
<h3 id="访问控制示例">访问控制示例</h3>
<ul>
<li>关闭匿名访问</li>
<li>创建一个目录管理员组，属于该组的人员都具有管理目录的权限</li>
<li>创建一个配置管理员组，属于该组的人员都具有配置 openldap 的权限</li>
<li>创建一个复制权限用户 ，该账号用于高可用之间的复制</li>
<li>创建一个搜索用户，用于 linux 集中账号认证时的，搜索</li>
</ul>
<blockquote>
<p>提示：</p>
<ul>
<li>目录管理员组：操作目录树的管理员都属于目录管理员组。</li>
<li>配置管理员组：可以操作服务器配置的（<code>slapd.ldif</code>）属于配置管理员组</li>
</ul>
</blockquote>
<h3 id="关闭匿名访问">关闭匿名访问</h3>
<p>首先slapd默认是允许匿名用户登录的，现在关闭匿名用户登录 在全局部分配置如下（通常全局在配置文件前几行）</p>
<pre><code>olcDisallows: bind_anon
</code></pre>
<h3 id="初始化一些组与用户">初始化一些组与用户</h3>
<p>创建RootDN与一些组，这里创建了三个组 ：目录管理员组 <code>dirGroup</code>，配置管理员组 <code>confGroup</code> ，与高级管理员组 <code>adminGroup</code> 。</p>
<blockquote>
<p>注：</p>
<ul>
<li>这些是在初始化安装好 openldap 环境进行的，而不是存在数据的环境</li>
<li>这里创建的组使用的 <code>groupOfUniqueNames</code></li>
</ul>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: ou=tvb,dc=test,dc=com
objectClass: organizationalUnit
ou: tvb

dn: cn=adminGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: adminGroup
uniqueMember: uid=admin,ou=tvb,dc=test,dc=com

dn: cn=dirGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: dirGroup
uniqueMember: uid=searchUser,ou=tvb,dc=test,dc=com

dn: cn=confGroup,ou=tvb,dc=test,dc=com
objectClass: groupOfUniqueNames
cn: confGroup
uniqueMember: uid=syncUser,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<p>初始化目录管理员用户 <code>syncUser</code> ，配置管理员用户 <code>searchUser</code> ，高级管理员用户 <code>admin</code> ，密码均为111</p>
<pre><code class="language-bash">
cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=syncUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: syncUser
cn: syncUser
uidNumber: 10006
gidNumber: 10002
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
homeDirectory: /home/syncUser
loginShell: /bin/bash
sn: syncUser
givenName: syncUser
memberOf: cn=confGroup,ou=tvb,dc=test,dc=com

dn: uid=searchUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: searchUser
cn: searchUser
uidNumber: 10005
gidNumber: 10001
homeDirectory: /home/searchUser
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: searchUser
givenName: searchUser
memberOf: cn=dirGroup,ou=tvb,dc=test,dc=com

#cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.10 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=admin,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: admin
cn: admin
uidNumber: 0
gidNumber: 0
homeDirectory: /home/admin
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin1,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
uid: admin1
cn: admin
uidNumber: 0
gidNumber: 0
homeDirectory: /home/admin
loginShell: /bin/bash
userPassword: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<h3 id="创建权限管理员用户组有所有权限">创建权限：管理员用户组有所有权限</h3>
<p>这句意思是筛选出dn下的所有不包含uniqueMember的用户，即找到<code>dn=cn=adminGroup,ou=tvb,dc=test,dc=com</code>  在上面我们把起规划为一个组，然后检查他的属性 <code>uniqueMember</code> ，<code>*</code> 表示递归，这里不用填，所有的 <code>uniqueMember</code> 均为最底层 <sup><a href="#2">[2]</a></sup></p>
<pre><code> by set=&quot;[cn=adminGroup,ou=tvb,dc=test,dc=com]/uniqueMember* &amp; user&quot; manage
</code></pre>
<h3 id="创建权限普通用户仅允许修改自己的密码">创建权限：普通用户仅允许修改自己的密码</h3>
<p>这里使用属性选择器进行属性筛选</p>
<pre><code class="language-bash">olcAccess: to attrs=&quot;userPassword&quot;
    by set=&quot;[cn=adminGroup,ou=tvb,dc=test,dc=com]/uniqueMember &amp; user&quot; manage
# 自己可以修改
    by self write
# 登录时候需要读，必须设置该选项
    by * read
</code></pre>
<h3 id="配置数据库的权限">配置数据库的权限</h3>
<p>对于客户端请求过来的权限，一般通过Frontend settings段来配置，这也可以理解是全局的ACL，对于后面的ACL会覆盖全局的ACL</p>
<pre><code class="language-ldif">#
# Configuration database
#
dn: olcDatabase=config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: config
olcAccess: to *
    by set=&quot;[cn=adminGroup,ou=tvb,dc=test,dc=com]/uniqueMember &amp; user&quot; manage
    by * none
</code></pre>
<p>完整的ACL配置部分</p>
<blockquote>
<p>Notes：slapd会根据配置的ACL顺序进行检测，匹配到后就不在继续了，所以在配置时，<code>what</code> 部分（选择器范围）要从小到大，这样可以控制范围就正确，正如上面例子，用户只能修改自己密码，属性选择器一旦写在DN选择器下面，将用远不被执行</p>
</blockquote>
<pre><code class="language-ldif">olcAccess: to attrs=&quot;userPassword&quot;
    by set=&quot;[cn=adminGroup,ou=tvb,dc=test,dc=com]/uniqueMember &amp; user&quot; manage
    by self write
    by * read
olcAccess: to dn.subtree=&quot;dc=test,dc=com&quot;
    by set=&quot;[cn=adminGroup,ou=tvb,dc=test,dc=com]/uniqueMember &amp; user&quot; manage
    by dn.children=&quot;dc=test,dc=com&quot; read
    by anonymous auth
    by * read
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>默认情况下，获取schema是没有权限的，此时需要添加权限使其可以读取schema权限。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1596103387323.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527344473.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<hr>
<blockquote>
<p><strong>注</strong>：在创建用户和组是需要查看schema权限</p>
</blockquote>
<hr>
<p><code>slapd.ldif</code> 文件中添加：</p>
<pre><code>dn: olcDatabase=frontend,cn=config
...
olcAccess: to dn.subtree=&quot;&quot;
    by * read
or

olcAccess: to dn.subtree=&quot;dn: cn=schema,cn=config&quot;
	by * read
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527344427.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>填写配置后重新生成配置文件报类似如下错误</strong></p>
<pre><code>$ slapadd  -n0 -F /etc/openldap/slapd.d -l kerberos.ldif
SYNTAX 1.3.6.1.4.1.1466.115.121.1.26)): empty AttributeDescription
slapadd: could not parse entry (line=1)
_# 6.36% eta none elapsed none spd 18.6 M/s
Closing DB...
</code></pre>
<p>问题原因：如上配置权限换行方式不可，官网给出的解决方法 <sup><a href="#1">[1]</a></sup></p>
<p><strong>Insufficient access (50)</strong></p>
<p>问题原因：没有权限</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.openldap.org/lists/openldap-technical/201705/msg00054.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>msg00054</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://www.openldap.org/doc/admin24/access-control.html#8.5.1.%20Groups%20of%20Groups" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Groups of Groups</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="http://www.uvm.edu/~fcs/tools/ACLs.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>ACLs</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://www.openldap.org/faq/data/cache/454.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Controls or what to do after a match</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://ubuntu.com/server/docs/service-ldap-access-control" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>LDAP Access Control</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - OpenLDAP中的4种复制机制</title>
      <link>https://www.oomkill.com/2019/09/ch6-replication/</link>
      <pubDate>Fri, 20 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch6-replication/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="ldap复制概述">LDAP复制概述</h2>
<p>openldap的复制 ( <em><strong>replication</strong></em>) 是可以将 LDAP <code>DIT</code> (<em><strong>Directory Information Tree</strong></em>) 同步更新复制到一个或多个LDAP (“ <code>slapd</code> ”) 系统，主要是用于实现备份或提升性能场景。在 openldap中，需要注意的一点是 “复制” 级别属于DIT级别而非LDAP服务级别运行。因此，在运行的一个服务 (<code>slapd</code>) 中的多个DIT，每一个DIT都可以被复制到不同的其他服务中 (<code>slapd</code>) 。本章节只讲述 <code>openldap 2.4+</code> 的四种复制模式。</p>
<hr>
<blockquote>
<p><strong>注意</strong>：在 <code>openldap 2.4-</code> 提供的复制功能，属于一个额外的守护进程 <code>slurpd</code>。仅适用于（2.3之前版本）。</p>
</blockquote>
<hr>
<h2 id="openldap的复制模式">openldap的复制模式</h2>
<p>在<code>openldap 2.4+</code> 中，提供了四种复制模式：</p>
<ul>
<li><code>Delta-syncrepl</code> ：2.3+</li>
<li><code>N-Way Multi-Provider</code>：2.4+</li>
<li><code>MirrorMode</code>：2.4+</li>
<li><code>Syncrepl Proxy Mode</code></li>
<li><code>slurpd</code>：2.3-，这种模式将不再本章节中阐述</li>
</ul>
<p>下面将由简到易来阐述四种复制模式</p>
<h2 id="delta-syncrepl">Delta-syncrepl</h2>
<p><code>Delta-syncrepl </code> 模式是基于日志模式 <code>syncrepl </code> 的一种变种模式，主要是为了解决openldap同步机制中的一些缺点。由于传统的同步机制是基于对象的同步机制，即当对象上的任何一个属性发生改变，每一个 <code>comsumer</code> 都会触发获取一次完整的对象（例如对象存在100个属性），这种模式存在以下特点：</p>
<ul>
<li>优点：对象发生改变时无需注意改变次数，仅需要结果即可，类似于kubernetes list-watch 机制</li>
<li>缺点：开支过大，例如存在102,400个对象，每个对象大小1KB，当跑脚本批量更改所有对象的其中一个属性时（2Byte），每个comsumer将要触发的同步数据将为100MB数据，来更改200KB数据，外加TCP/IP协议的开销</li>
</ul>
<p><code>Delta-syncrepl</code> 的诞生就是为了解决 <code>syncrepl</code> 机制的缺点</p>
<blockquote>
<p>Note:</p>
<ul>
<li>syncrepl 就是传统的 povider-comsumer/master-slave 模型</li>
<li>Delta-syncrepl 需要注意的一点就是，当两边数据完全不同（或为空）将使用 syncrepl 同步完成后切换为 Delta-syncrepl 模式</li>
</ul>
</blockquote>
<p>对于 <code>Delta-syncrepl</code> 与  <code>syncrepl</code> 模式来说可以产生多种变种模型，<code>push</code> 与 <code>pull</code></p>
<h3 id="主从拉取模式">主从拉取模式</h3>
<p>master-slave 拉取模式将按照下图所示的步骤进行同步</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/replication-refresh-only.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：master-slave拉取模式</center>
<center><em>Source：</em>https://www.zytrax.com/books/ldap/ch7/</center><br>
<p>如图所示</p>
<ul>
<li>
<p>(1) 与 (3) 为 slapd服务的 master 与 slave 角色 （编号与角色按顺序对应）</p>
</li>
<li>
<p>(4) 是master上的对象条目， (5) 为slave要拉去的数据</p>
</li>
<li>
<p>(2) 为同步的过程</p>
</li>
<li>
<p>(6) 与 (7) 分别为 master 与 slave 上需要配置的配置选项</p>
</li>
<li>
<p>(A-E) 为同步的步骤</p>
</li>
</ul>
<p>在图中可以看出，同步时提供者master会分配一个cookie (<strong>SyncCookie</strong>) 给消费者slave，本质上来说，cookie中包含了更改序列号，指发送给这个消费者的最后一个修改（时间戳），通过对比检查点，即同步会话发生开启时，将slave最后收到的cookie发送给master，以获得同步的限制，第一次时将会全量同步所有记录。</p>
<h3 id="主从推送模式">主从推送模式</h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/replication-refresh-persist.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：master-slave推送模式</center>
<center><em>Source：</em>https://www.zytrax.com/books/ldap/ch7/</center><br>
<p>如图所示</p>
<ul>
<li>
<p>(1) 与 (3) 为 slapd服务的 master 与 slave 角色 （编号与角色按顺序对应）</p>
</li>
<li>
<p>(4) 是master上的对象条目， (5) 为slave要拉去的数据</p>
</li>
<li>
<p>(2) 为同步的过程</p>
</li>
<li>
<p>(6) 与 (7) 分别为 master 与 slave 上需要配置的配置选项</p>
</li>
<li>
<p>(A-E) 为同步的步骤</p>
</li>
</ul>
<p>在该模式下，slave可以为多个，提供者master没有维护slave的信息，即任意slave都可以申请同步，只需要满足安全限制即可，同步请求本质时一个搜索，因为配置中会定义 DN，范围，过滤条件等信息。</p>
<p>并且在这种模式下，cookie的维护有提供者master维护，master定期发送一个同步cookie。同步的机制类似于拉去模式，并且该模式下只要申请了同步，那么这个链接会永久被维护，也就是图中 <code>persist</code> 代表的意义，除非master, slave网络发生故障。</p>
<p><strong>主从配置的缺点</strong>：</p>
<ul>
<li>多节点访问：如果所有或大多数客户端都需要更新DIT，则所有客户端必须访问同一个服务 (slave) 进行正常读访问，而另一个服务（master）进行更新。或者，客户端始终访问主服务。后一种情况下，slave仅提供备份功能</li>
<li>弹性。由于只存在一个服务为更新的节点，这意味着存在单点故障问题</li>
</ul>
<h3 id="主从模式的配置">主从模式的配置</h3>
<p>两种模式配置起来非常相似，只是所遇到场景的不同而需要不同的应用方法</p>
<h4 id="关停服务进行配置">关停服务进行配置</h4>
<p>在安装openldap部分，ldif文件中有配置database部分，这将代表了生成的配置文件，例如下面database部分的配置</p>
<pre><code class="language-ldif">#
# Backend database definitions
#
# 这里是数据库的参数配置
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
# 使用的数据库引擎是mdb
objectClass: olcMdbConfig
olcDatabase: mdb
# Suffix 为数据库的后缀，每个数据库至少一个，在搜索时-D 后面的域后缀为dc=test,dc=com将被pass到这里
olcSuffix: dc=test,dc=com
# 指不收前面配置的权限控制的管理员账户，拥有最最高权限
olcRootDN: cn=admin,dc=test,dc=com
# 特权账户的登录密码
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw
olcDbDirectory:	/var/lib/ldap
# 这是索引属性，下面是默认的属性
# 下列注释行意思为
#        olcDbIndex: default pres,eq
#        olcDbIndex: uid
#        olcDbIndex: cn,sn pres,eq,sub
#        olcDbIndex: objectClass eq
# pres,eq 为 present equality
# 第二行意思为，为uid属性类型维护默认索引集
# 第三行意思为，为cn,sn属性维护pres,eq,sub索引集
# 索引集类型有 pres,eq,approx,sub,none
olcDbIndex: objectClass eq,pres
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub
# 配置从缓冲区写入磁盘的，两个参数分别为多少kbyte大小的数据自上次（第二个参数）分钟则发生一次写入
olcDbCheckpoint: 1024 10
</code></pre>
<p>而在openldap中所有的同步模式的机制都是上面所示的database的子集，即需要拥有上述的配置，例如下列配置</p>
<blockquote>
<p>Notes：openldap中数据库可以有多个，因为openldap是基于对象而不是基于服务</p>
</blockquote>
<pre><code class="language-ldif">#
# Backend database definitions
#

dn: olcDatabase={1}mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcSuffix: dc=test,dc=com
olcRootDN: cn=admin,dc=test,dc=com
olcDbDirectory:	/var/lib/ldap
olcDbIndex: objectClass eq,pres
olcDbCheckpoint: 1024 10
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw

# 为dn为dn: olcDatabase={1}mdb,cn=config的数据库配置同步

dn: olcOverlay=syncprov,olcDatabase={1}mdb,cn=config 
objectclass: olcSyncProvConfig
objectClass: olcOverlayConfig
olcOverlay: syncprov
olcSpCheckpoint: 100 10

dn: olcDatabase={2}mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcSuffix: dc=test1,dc=com
olcRootDN: cn=admin,dc=test1,dc=com
olcDbDirectory: /var/lib/ldap
olcDbIndex: objectClass eq,pres
olcDbCheckpoint: 1024 10
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw
</code></pre>
<p>配置说明：</p>
<ul>
<li><strong>olcOverlay</strong> 属性是必须值</li>
<li><strong>olcSyncProvConfig</strong> 属性是基于 <strong>olcOverlay</strong> 后添加的属性</li>
<li>必须开启module <code>syncprov </code> 才可以使用</li>
</ul>
<p>上面的是master的配置，slave配置如下：</p>
<pre><code class="language-ldif">#
# Backend database definitions
#

dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcSuffix: dc=test,dc=com
olcRootDN: cn=admin,dc=test,dc=com
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw
olcDbDirectory:	/var/lib/ldap
olcDbIndex: objectClass eq,pres
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub
olcDbCheckpoint: 1024 10
olcSyncRepl: rid=002
  provider=ldap://10.0.0.10:389/
  bindmethod=simple
  binddn=&quot;cn=admin,dc=test,dc=com&quot;
  credentials=111
  searchbase=&quot;dc=test,dc=com&quot;
  scope=sub
  schemachecking=on
  type=refreshAndPersist
  retry=&quot;30 5 300 3&quot;
  interval=00:00:05:00
</code></pre>
<p>当配置完成后，可以看到master上已经收到slave申请的同步请求了</p>
<pre><code class="language-log">Nov  8 21:28:15 ldap slapd[65362]: conn=1001 fd=11 ACCEPT from IP=10.0.0.3:45860 (IP=0.0.0.0:389)
Nov  8 21:28:15 ldap slapd[65362]: conn=1001 op=0 BIND dn=&quot;cn=admin,dc=test,dc=com&quot; method=128
Nov  8 21:28:15 ldap slapd[65362]: conn=1001 op=0 BIND dn=&quot;cn=admin,dc=test,dc=com&quot; mech=SIMPLE ssf=0
Nov  8 21:28:15 ldap slapd[65362]: conn=1001 op=0 RESULT tag=97 err=0 text=
Nov  8 21:28:15 ldap slapd[65362]: conn=1001 op=1 SRCH base=&quot;dc=test,dc=com&quot; scope=2 deref=0 filter=&quot;(objectClass=*)&quot;
Nov  8 21:28:15 ldap slapd[65362]: conn=1001 op=1 SRCH attr=* +
</code></pre>
<h4 id="不停服务进行配置">不停服务进行配置</h4>
<p>openldap提供了一个api <code>ldapi:///</code> 可以在外部进行更改正在运行的服务，下面配置为master不停服务进行配置</p>
<p>首先找到对应的db配置看是属于哪个块，例如这里为 <code>olcDatabase={2}mdb</code></p>
<ul>
<li><code>ls /etc/openloda/slapd.d/cn\=config/olcDatabase\=\{2\}mdb.ldif</code></li>
</ul>
<p>那么接下来的dn就需要指定这个db</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcOverlay=syncprov,olcDatabase={2}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpSessionLog: 100
EOF
</code></pre>
<p>同理接下来配置slave，由于slave配置的dn为已经存在的，需要进行修改，同理这里也需要找到对应的 dn <code>olcDatabase={2}mdb,cn=config</code></p>
<blockquote>
<p>Notes: ldif也可以向yaml那样属于另外一个定义可以使用符号 “ <code>-</code> ” 分割</p>
</blockquote>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcDatabase={2}mdb,cn=config
changetype: modify
add: olcSyncRepl
olcSyncRepl: rid=001
  provider=ldap://10.0.0.10:389/
  bindmethod=simple
  binddn=&quot;cn=admin,dc=test,dc=com&quot;
  credentials=111
  searchbase=&quot;dc=test,dc=com&quot;
  scope=sub
  schemachecking=on
  type=refreshAndPersist
  retry=&quot;30 5 300 3&quot;
  interval=00:00:05:00
</code></pre>
<h2 id="mirrormode">MirrorMode</h2>
<p>镜像模式实际上属于master-slave的一个变种，是为master-slave模式提供了两端一致性的保障，就是两端互为porvider与comsumer，即一个HA)解决方案</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221108214329442.png" alt="image-20221108214329442" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：镜像模式在多数据中心的应用架构图</center>
<center><em>Source：</em>https://www.openldap.org/doc/admin24/replication.html#MirrorMode</center><br>
<h3 id="镜像模式的配置">镜像模式的配置</h3>
<p>镜像模式配置与主从模式完全相同，并且工作模式也是相同的，下面仅提供热配置的方式，这种配置完后重启服务也是生效的</p>
<p>首先提供porvider部分的配置，因为两端是相同的，只需要修改ServerID即可</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcOverlay=syncprov,olcDatabase={2}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpSessionLog: 100
-
dn: cn=config
changetype: modify
replace: olcServerID
olcServerID: 0
EOF
</code></pre>
<p>下面是comsumer部分的配置，因为两端是相同的，注意修改 <code>rid</code> , <code>credentials</code> , <code>provider</code> 值为正确的值， <code>provider</code> 由多个组成</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcDatabase={2}mdb,cn=config
changetype: modify
add: olcSyncRepl
olcSyncRepl: rid=001
  provider=ldap://10.0.0.10:389/
  bindmethod=simple
  binddn=&quot;cn=admin,dc=test,dc=com&quot;
  credentials=111
  searchbase=&quot;dc=test,dc=com&quot;
  scope=sub
  schemachecking=on
  type=refreshAndPersist
  retry=&quot;30 5 300 3&quot;
  interval=00:00:05:00
-
add: olcMirrorMode
olcMirrorMode: TRUE
EOF
</code></pre>
<h2 id="n-way-multi-master">N-way Multi-Master</h2>
<p>在 <code>openldap 2.4+</code> 引入了 多路多主 (<font color="#f8070d" size=3><em><strong>N-way Multi-Master</strong></em></font> ) 模式。该模式中任何数量的主机都可以彼此同步。由于 多路多主模式也是属于 <code>Syncrepl </code> 模式的变种，这里不过多阐述同步原理了。</p>
<blockquote>
<p>Notes：该模式中，所有master上的时钟同步是必须的</p>
</blockquote>
<p>下图为 <font color="#f8070d" size=3><em><strong>N-way Multi-Master</strong></em></font> 模式的架构图，在此模式下所有的节点即为master又为slave，所有的节点的slave都为集群数量减一个。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20200730181558472.png" alt="image-20200730181558472" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：N-way Multi-Master模式</center>
<center><em>Source：</em>https://www.openldap.org/doc/admin24/replication.html#MirrorMode</center><br>
<p>如图所示</p>
<ul>
<li>(1)  (2)  (3) 为 slapd服务，因为使用 <code>syncrepl</code> 复制技术需要为每个服务提供一个唯一的 <code>olcServerID/ServerID</code> 在整个集群中。</li>
<li>(5)  (6)  (7)  为 (1)  (2)  (3)  服务 <code>syncprov overlay</code> 的配置</li>
<li>(4) 是为 (1)  (2)  (3)  提供了 <code>provider syncprov overlay</code> 的配置</li>
<li>此模式中每个节点发生了写入动作后，都会同步至集群中另外的所有节点上</li>
</ul>
<blockquote>
<p>Notes：这种模式下不支持增量同步</p>
</blockquote>
<h3 id="syncrepl-n-way-multi-master配置">syncrepl N-Way Multi-Master配置</h3>
<p>这种模式与最基础的 <code>syncrepl</code> 是类似的，不在过多阐述</p>
<p>首先提供porvider部分的配置，注意修改ServerID即可，多个节点之间必须唯一</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcOverlay=syncprov,olcDatabase={2}mdb,cn=config
objectClass: olcOverlayConfig
objectClass: olcSyncProvConfig
olcOverlay: syncprov
olcSpSessionLog: 100
EOF

cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: cn=config
changetype: modify
replace: olcServerID
olcServerID: 0
EOF
</code></pre>
<p>下面是comsumer部分的配置，因为两端是相同的，注意修改 <code>rid</code> , <code>credentials</code> , <code>provider</code> 值为正确的值</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -Y EXTERNAL -H ldapi:///
dn: olcDatabase={2}mdb,cn=config
changetype: modify
add: olcSyncRepl
olcSyncRepl: {0}rid=001
  provider=ldap://10.0.0.10:389/
  bindmethod=simple
  binddn=&quot;cn=admin,dc=test,dc=com&quot;
  credentials=111
  searchbase=&quot;dc=test,dc=com&quot;
  scope=sub
  schemachecking=on
  type=refreshAndPersist
  retry=&quot;30 5 300 3&quot;
  interval=00:00:05:00
olcSyncRepl: {1}rid=002
  provider=ldap://10.0.0.10:389/
  bindmethod=simple
  binddn=&quot;cn=admin,dc=test,dc=com&quot;
  credentials=111
  searchbase=&quot;dc=test,dc=com&quot;
  scope=sub
  schemachecking=on
  type=refreshAndPersist
  retry=&quot;30 5 300 3&quot;
  interval=00:00:05:00
...
-
add: olcMirrorMode
olcMirrorMode: TRUE
EOF
</code></pre>
<h2 id="syncrepl-proxy">Syncrepl Proxy</h2>
<p>Syncrepl Proxy 模式就是 Syncrepl ，只不过通过acl控制slave为只读模式，因为配置相同，将不重复阐述</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/image-20221108222307430.png" alt="image-20221108222307430" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Syncrepl Proxy模式</center>
<center><em>Source：</em>https://www.openldap.org/doc/admin24/replication.html#Syncrepl%20Proxy</center><br>
<h2 id="创建指定用户同步">创建指定用户同步</h2>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -W -H ldap://10.0.0.20 -D cn=admin,dc=cylon,dc=org
dn: cn=123123,ou=group,dc=cylon,dc=org
objectClass: top
objectClass: posixGroup
gidNumber: 10011
cn: mygroup
EOF

cat &lt;&lt; EOF | ldapadd -x -W -H ldap://10.0.0.20 -D cn=admin,dc=cylon,dc=org
dn: uid=rpuser,dc=cylon,dc=org
objectClass: simpleSecurityObject
objectclass: account
uid: rpuser
description: Replication User
userPassword: root1234
EOF
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.openldap.org/doc/admin24/replication.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>replication</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://www.zytrax.com/books/ldap/ch7/#ol-syncrepl-mm" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Chapter 7 Replication &amp; Referral</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - OpenLDAP使用SSL/TLS通信安全</title>
      <link>https://www.oomkill.com/2019/09/ch05-openldap-ssl/</link>
      <pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch05-openldap-ssl/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="openldap-tlsssl-配置">OpenLDAP TLS/SSL 配置</h2>
<p>对于 TLS/SSL 方向的内容不过多阐述了，这里只阐述openldap TLS/SSL 配置方向的内容</p>
<p>openldap提供了两种方式进行 TLS/SSL 认证</p>
<ul>
<li>自动模式：客户端通过 <strong>ldaps://hostname/</strong> 形式的URL访问slapd，slapd默认为636端口提供 TLS 会话</li>
<li>主动定义：slapd标准端口389支持 TLS/SSL ，客户端通过显式配置 TLS/SSL 也可以使用 URL格式<strong>ldap://hostname/</strong> 进行访问，需要注意的是，在同步时如果使用 <strong>ldap://</strong> 格式URL需要指定参数 <strong>starttls=yes</strong> 或者 <strong>starttls=critical</strong> 使用 <strong>ldaps://</strong> 则不需要指定该参数</li>
</ul>
<h2 id="生成自签名证书">生成自签名证书</h2>
<p>创建CA证书</p>
<pre><code class="language-bash">openssl genrsa -out cakey.key 2048

openssl req -new -x509 \
	-key cakey.key \
	-out cacert.crt \
	-days 3650 \
	-subj &quot;/C=HK/ST=HK/O=TVB/OU=bigbigchannl/CN=tvb-ca&quot;
	
touch index.txt
echo &quot;01&quot; &gt; serial
</code></pre>
<p>生成证书请求</p>
<pre><code class="language-bash">openssl genrsa -out openldap.key 2048

openssl req -new \
	-key openldap.key \
	-out openldap.csr \
	-days 3650 \
	-subj &quot;/C=HK/ST=HK/O=TVB/OU=bigbigchannl/CN=10.0.0.4&quot;

openssl ca \
	-in openldap.csr \
	-cert cacert.crt \
	-keyfile cakey.key  \
	-out openldap.crt \
	-days 3650
</code></pre>
<h2 id="启用openldap-tls认证">启用openldap TLS认证</h2>
<p>slapd TLS 部分配置是在全局部分</p>
<h3 id="修改服务端参数">修改服务端参数</h3>
<pre><code># cn=config base（全局部分）

dn: cn=config
changetype: modify
# Security - TLS section
add: olcTLSCertificateFile
# cafile
olcTLSCertificateFile: /certs/ldapscert.pem
-
add: olcTLSCertificateKeyFile
# ca key
olcTLSCertificateKeyFile: /certs/keys/ldapskey.pem
-
# 证书
olcTLSCertificateFile: &quot;/etc/openldap/certs/openldap.crt&quot;
olcTLSCertificateKeyFile: &quot;/etc/openldap/certs/openldap.key&quot;
-
# the following directive is the default but 
# is explicitly included for visibility reasons
add: olcTLSVerifyClient
olcTLSVerifyClient: never
</code></pre>
<h3 id="修改客户端参数">修改客户端参数</h3>
<h3 id="命令行指令相关配置">命令行指令相关配置</h3>
<p>客户端时指 <code>ladpadd</code>，<code>ladpsearch</code> 相关配置文件，默认为  <code>/etc/openldap/ldap.conf</code></p>
<pre><code>URI	ldap://ldap.example.com ldaps://10.0.0.4:636

#SIZELIMIT	12
#TIMELIMIT	15
#DEREF		never

TLS_CACERTDIR	/etc/openldap/certs
TLS_CACERT /etc/openldap/certs/cacert.crt
TLS_CERT /etc/openldap/certs/openldap.csr
TLS_KEY  /etc/openldap/certs/openldap.key
</code></pre>
<p>修改服务要监听的地址</p>
<pre><code>SLAPD_URLS=&quot;ldapi:/// ldaps:///&quot;
</code></pre>
<h3 id="同步时相关配置">同步时相关配置</h3>
<p>在同步时仅仅需要修改slave部分配置即可</p>
<pre><code class="language-ldif">syncrepl
 rid=000
 type=RefreshandPersist
 provider=ldaps://ldap-master.example.com
 bindmethod=simple
 searchbase=&quot;dc=example,dc=com&quot;
 retry=&quot;5 3 300 +&quot;
 attrs=&quot;*,+&quot;
 binddn=&quot;....&quot;
 credentials=....
</code></pre>
<h2 id="troubleshooing">Troubleshooing</h2>
<p>错误 <code>Re: OpenLDAP/TLS main: TLS init def ctx failed: -207</code></p>
<ul>
<li><a href="https://www.openldap.org/lists/openldap-software/200901/msg00134.html" target="_blank"
   rel="noopener nofollow noreferrer" >OpenLDAP/TLS main: TLS init def ctx failed: -207</a></li>
<li><a href="https://www.openldap.org/lists/openldap-software/200812/msg00100.html" target="_blank"
   rel="noopener nofollow noreferrer" >how to configure tls and ldap</a></li>
</ul>
<p>错误 <code>Re: slapadd: could not parse entry (line=13)</code></p>
<ul>
<li>可能原因，上下文存在空行</li>
</ul>
<p>错误:  <code>openssl slapd tls init def ctx failed: -1</code> ；证书的路径，文件名，权限是否正确</p>
<p>验证证书 <code>openssl verify -CAfile {ca.crt} {.crt}</code></p>
<ul>
<li><a href="https://www.openldap.org/lists/openldap-technical/201502/msg00168.html" target="_blank"
   rel="noopener nofollow noreferrer" >RE: main: TLS init def ctx failed: -1</a></li>
</ul>
<blockquote>
<p>Reference：</p>
<p><a href="https://www.zytrax.com/books/ldap/ch15/#tls" target="_blank"
   rel="noopener nofollow noreferrer" >Chapter 15. LDAP Security</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap配置 - OpenLDAP架构与Schema设计</title>
      <link>https://www.oomkill.com/2019/09/ch4-schema/</link>
      <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/09/ch4-schema/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是schema">什么是schema</h2>
<p>schema又称为数据模型，是openldap中用于来指定一个条目所包含的对象类(objectClass)以及每个对象类所包含的属性值(attribute)，其中属性值又包含必要属性和可选属性。</p>
<blockquote>
<p>Notes：拥有schema的数据代表该数据是结构化数据，无论他是什么格式，甚至于是一个连续的字符串</p>
</blockquote>
<h2 id="如何理解schema">如何理解schema</h2>
<p>不管是在学习OpenLDAP时还是学习数据库时，都会遇到一个很迷糊的Schema的概念。</p>
<p>在数据库中，对数据库的设计可以称之为schema。即schema约束了数据库的设计结构，并提供了整个数据库的描述。schema仅展示数据库的设计，如表字段的类型，表与表之间的关联。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20210226195759348.png" alt="image-20210226195759348" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>在ldap中schema与database中的schema一样，如列出的schema中，这些代表了对应的ldap结构的设计。</p>
<p><a href="https://afteracademy.com/blog/what-is-a-schema" target="_blank"
   rel="noopener nofollow noreferrer" >what-is-a-schema</a></p>
<p><a href="https://docs.oracle.com/cd/B14099_19/idmanage.1012/b15883/schema_overview001.htm" target="_blank"
   rel="noopener nofollow noreferrer" >schema overview</a></p>
<pre><code>olcObjectClasses: ( 0.9.2342.19200300.100.4.19 NAME 'simpleSecurityObject'
  DESC 'RFC1274: simple security object'
  SUP top AUXILIARY
  MUST userPassword ) # 必须包含的属性
#
# RFC 1274 + RFC 2247
olcAttributeTypes: ( 0.9.2342.19200300.100.1.25
  NAME ( 'dc' 'domainComponent' ) # 表示属性名称
  DESC 'RFC1274/2247: domain component'
  EQUALITY caseIgnoreIA5Match # 相等性匹配
  SUBSTR caseIgnoreIA5SubstringsMatch  # 字符串匹配
  SYNTAX 1.3.6.1.4.1.1466.115.121.1.26 SINGLE-VALUE ) # 表示数据类型
</code></pre>
<h2 id="schema包含什么">schema包含什么</h2>
<p>在openldap的schema中，有四个重要的元素：</p>
<ul>
<li>
<p>Objectclass：Objectclass定义了一个类别，这个类别会被不同的目录（在LDAP中就是一个Entry）用到，它说明了该目录应该有哪些属性，哪些属性是必须的，哪些又是可选的。一个objectclass的定义包括名称（NAME），说明（DESC），类型（STRUCTURAL或AUXILARY），表示是结构型的还是辅助型的），必须属性（MUST），可选属性（MAY）等信息。</p>
</li>
<li>
<p>Attribute：Attribute就是一个上面Objectclass中可能包含的属性，对其的定义包括名称，数据类型，单值还是多值以及匹配规则等。后面用具体的例子来说明。</p>
</li>
<li>
<p>Syntax：syntax是LDAP中的 “语法”，其实就是LDAP中会用到的数据类型和数据约束，这个语法是遵从X.500中数据约束的定义的。其定义需要有一个ID（遵从X.500）以及说明（DESP）</p>
</li>
<li>
<p>Matching Rules：是用来指定某属性的匹配规则，实际上就是定义一个特殊的Syntax的别名，让LDAP服务器可以识别，并对定义的属性进行匹配。</p>
</li>
</ul>
<h3 id="schema-files">Schema Files</h3>
<p>OpenLDAP随附了一些schema，在<code>/usr/local/etc/openldap/ chema</code> 目录中</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>core.schema</td>
<td>OpenLDAP <em>core</em> (required)</td>
</tr>
<tr>
<td>cosine.schema</td>
<td>Cosine 和 Internet X.500</td>
</tr>
<tr>
<td>inetorgperson.schema</td>
<td>在添加账号时,额外的objectClass.</td>
</tr>
<tr>
<td>misc.schema</td>
<td></td>
</tr>
<tr>
<td>nis.schema</td>
<td>网络信息服务(FYI),也是一种集中账号管理实现.</td>
</tr>
<tr>
<td>openldap.schema</td>
<td>OpenLDAP Project(experimental)</td>
</tr>
<tr>
<td>dyngroup.schema</td>
<td>定义动态组时使用的schema,包括要使用sudo.schema时,也需要它</td>
</tr>
<tr>
<td>ppolicy.schema</td>
<td>需要做密码策略时,需要导入此schema</td>
</tr>
<tr>
<td>sudo.schema</td>
<td>定义sudo规则</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap - OpenLDAP客户端命令行使用</title>
      <link>https://www.oomkill.com/2019/08/ch3-commandline/</link>
      <pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/08/ch3-commandline/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="ldapsearch">ldapsearch</h2>
<h2 id="查询api-ldapsearch">查询api ldapsearch</h2>
<h3 id="ldapsearch命令参数说明">ldapsearch命令参数说明</h3>
<p>语法</p>
<pre><code>ldapsearch  [options]  filter [attributes]
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-W</td>
<td>指定密码，交互式，不需要在命令上写密码</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td>指定密码，需要命令上指定密码</td>
</tr>
<tr>
<td style="text-align:center">-H</td>
<td>ldapapi</td>
</tr>
<tr>
<td style="text-align:center">-D</td>
<td>所绑定的服务器的DN，如<code>cn=admin,dc=etiantian,dc=org</code></td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td>-f: filename.ldif文件</td>
</tr>
<tr>
<td style="text-align:center">-b</td>
<td>-b 指定作为查询节点而不是默认的</td>
</tr>
<tr>
<td style="text-align:center">-LLL</td>
<td>以LDIF格式打印响应，不带注释</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td>简单的认证</td>
</tr>
</tbody>
</table>
<h3 id="简单的搜索">简单的搜索</h3>
<p>最简单的在查询ldap条目的最简单方法是使用带有 “<code>-x</code>” 选项进行简单身份验证，并使用 “<code>-b</code>”  指定搜索域。</p>
<pre><code class="language-bash">$ ldapsearch -x -b &lt;search_base&gt; -H &lt;ldap_host&gt;
</code></pre>
<p>例如向 10.0.0.3 上openldap服务查询，该命令需要服务器接受匿名身份验证，这将可以查询而无需绑定管理员帐户</p>
<pre><code class="language-bash">$ ldapsearch -x -b &quot;dc=test,dc=com&quot; -H ldap://10.0.0.3
</code></pre>
<h3 id="使用管理员账户进行搜索">使用管理员账户进行搜索</h3>
<p>使用管理员帐户进行搜索，必须使用backend配置的 RootDN 并在命令行使用 “<code>-D</code>” 选项 和 “<code>-W</code>” ，如果要使用非交互式认证，使用选项 “<code>-w</code>”</p>
<pre><code class="language-bash">$ ldapsearch -x -b &lt;search_base&gt; -H &lt;ldap_host&gt; -D &lt;bind_dn&gt; -W
</code></pre>
<p>例如，上章在安装时配置了RootDN：“ <em>cn=admin,dc=test,dc=com</em> ”。如果要使用此帐户执行搜索，可以使用命令</p>
<pre><code class="language-bash">$ ldapsearch -x -b &quot;dc=test,dc=com&quot; -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -W 
</code></pre>
<h3 id="使用过滤器进行搜索">使用过滤器进行搜索</h3>
<p>上述讲到的查询方法，是进行全局查询，会输出所有的条目，这样浪费了时间和资源，在大多数情况下，都希望查询以在特定的目录树中查找特定对象。而 ”过滤器“ filter 就是为了解决这个问题的。</p>
<p>要使用过滤器搜索，需要在 <code>ldapsearch</code> 命令的末尾附加 filter 公式：<code>&lt;object_class&gt;=&lt;object_value&gt;</code></p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(object_type)=(object_value)&quot; &lt;optional_attributes&gt;
</code></pre>
<p>例如查找所有对象，可以使用过滤器 <code>objectclass</code> 并且值为 ”<code>*</code>“ ，</p>
<pre><code class="language-bash">$ ldapsearch -x -b &lt;search_base&gt; -H &lt;ldap_host&gt; -D &lt;bind_dn&gt; -W &quot;objectclass=*&quot;
</code></pre>
<h3 id="查找特定的用户">查找特定的用户</h3>
<p>如果查询目录树上的所有用户账户，如上一章初始化数据时，初始化的用户账户类为 ”posixAccount“ ，可以通过 ”posixAccount“ 来缩小查询范围</p>
<pre><code class="language-bash">ldapsearch -x -b &lt;search_base&gt; -H &lt;ldap_host&gt; -D &lt;bind_dn&gt; -W &quot;objectclass=posixAccount&quot;
</code></pre>
<p>如果每个条目输出的内容多的情况下，也可以输出的属性值来进一步缩小搜索范围，例如只需要 <code>uid</code> 与 <code>gidNumber</code></p>
<pre><code class="language-bash">$ ldapsearch -x -b &quot;dc=test,dc=com&quot; -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111 &quot;objectclass=posixAccount&quot; uid gidNumber
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: objectclass=posixAccount
# requesting: uid gidNumber 
#

# user01, group, test.com
dn: uid=user01,ou=group,dc=test,dc=com
uid: user01
gidNumber: 10001

# cylon, group, test.com
dn: uid=cylon,ou=group,dc=test,dc=com
uid: cylon
gidNumber: 10001

# search result
search: 2
result: 0 Success

# numResponses: 3
# numEntries: 2
</code></pre>
<h3 id="使用运算符进行筛选搜索">使用运算符进行筛选搜索</h3>
<p><code>ldapsearch</code> 可以使用多个过滤器，使用多个过滤器用运算符 “<code>AND</code>” 进行分割，需要注意的一点是，多个过滤器必须将所有条件括在括号中，并在查询的开头加一个 “<code>&amp;</code>”  字。</p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(&amp;(&lt;condition_1&gt;)(&lt;condition_2&gt;)...)&quot;
</code></pre>
<p>例如，查找具有 “<code>objectclass=posixAccount</code>” 与 “<code>uid=cylon</code>” 的条目，您将运行以下查询</p>
<pre><code class="language-bash">$ ldapsearch -x -b &quot;dc=test,dc=com&quot; -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111 &quot;(&amp;(objectclass=posixAccount)(uid=cylon))&quot;
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: (&amp;(objectclass=posixAccount)(uid=cylon))
# requesting: ALL
#

# cylon, group, test.com
dn: uid=cylon,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword:: e1NTSEF9MnB2RTRDNnh5OGRrbVcyYUQvZUVvY1Zhamc4QnVqV1c=
uidNumber: 10005
gidNumber: 10001
sn: cylon

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
</code></pre>
<p>也可以使用或运算符 ” <code>OR</code> “，使多个 “<code>OR</code>” 运算符，需要所有条件括在括号内，并使用符号 “ <code>|</code> ”  写在过滤条件开头。</p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(|(&lt;condition_1&gt;)(&lt;condition_2&gt;)...)&quot;
</code></pre>
<p>例如，搜索 <code>uid=user01</code> 或者 <code>uid=zhangsan</code> 的用户</p>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; '(|(uid=user01)(uid=zhangsan))'
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: (|(uid=user01)(uid=zhangsan))
# requesting: ALL
#

# user01, group, test.com
dn: uid=user01,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/user01
loginShell: /bin/bash
uid: user01
cn: user01
uidNumber: 10004
gidNumber: 10001
userPassword:: e1NTSEF9aEpwSUlWeGoxcVM5ZzA1cVVsZ0crbzdNTzE0RVhiRlE=
sn: user01
givenName: user01

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
</code></pre>
<p>也可以使用 “非” 运算符 ” <code>!</code> “，使多个 “<code>!</code>” 运算符，需要所有条件括在括号内，并使用符号 “ <code>!</code> ”  写在过滤条件开头。</p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(!(&lt;condition_1&gt;)(&lt;condition_2&gt;)...)&quot;
</code></pre>
<p>例如，匹配 <code>uid</code> 不为 <code>zhangsan</code> 的用户</p>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; '(!(uid=zhangsan))'
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: (!(uid=user01))
# requesting: ALL
#

# test.com
dn: dc=test,dc=com
objectClass: top
objectClass: organizationalUnit
objectClass: extensibleObject
description: US Organization
ou: people
dc: test

# group, test.com
dn: ou=group,dc=test,dc=com
objectClass: organizationalUnit
ou: group

# tech, group, test.com
dn: cn=tech,ou=group,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10001
cn: tech
memberUid: user01
memberUid: cylon

# cylon, group, test.com
dn: uid=cylon,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword:: e1NTSEF9MnB2RTRDNnh5OGRrbVcyYUQvZUVvY1Zhamc4QnVqV1c=
uidNumber: 10005
gidNumber: 10001
sn: cylon

# search result
search: 2
result: 0 Success

# numResponses: 5
# numEntries: 4
</code></pre>
<h3 id="使用多个过滤条件">使用多个过滤条件</h3>
<p>多个过滤条件可以使用 <code>()</code> 括起来所有的过滤条件</p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(|(&lt;condition_1&gt;)(&lt;condition_2&gt;)...)&quot;
</code></pre>
<h3 id="使用通配符进行搜索">使用通配符进行搜索</h3>
<p>除了运算符，还有一种高校过滤器就是通配符 “<code>*</code>” 这使得 <code>ldapsearch</code> 过滤器拥有一些正则表达式功能</p>
<p>使用通配符，只需要对应的查询条件字符串结尾或开头加上 “<code>*</code>” 即可</p>
<pre><code class="language-bash">$ ldapsearch &lt;previous_options&gt; &quot;(object_type)=*(object_value)&quot;

$ ldapsearch &lt;previous_options&gt; &quot;(object_type)=(object_value)*&quot;
</code></pre>
<p>例如查询 <code>uid</code> 以 “<code>c</code>” 开头的用户</p>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; '(uid=c*)'
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: (uid=c*)
# requesting: ALL
#

# cylon, group, test.com
dn: uid=cylon,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword:: e1NTSEF9MnB2RTRDNnh5OGRrbVcyYUQvZUVvY1Zhamc4QnVqV1c=
uidNumber: 10005
gidNumber: 10001
sn: cylon

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
</code></pre>
<h3 id="扩展过滤器">扩展过滤器</h3>
<p>可以由符合 “ <code>:</code> ”隔的其他过滤器，例如区分大小写与不区分大小写</p>
<ul>
<li><code>CaseIgnoreMatch </code> 不区分大小写</li>
<li><code>cn:caseExactMatch</code> 区分大小写</li>
<li></li>
</ul>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot;  &quot;cn:CaseIgnoreMatch:=USER01&quot;
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: cn:CaseIgnoreMatch:=USER01
# requesting: ALL
#

# user01, group, test.com
dn: uid=user01,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/user01
loginShell: /bin/bash
uid: user01
cn: user01
uidNumber: 10004
gidNumber: 10001
userPassword:: e1NTSEF9aEpwSUlWeGoxcVM5ZzA1cVVsZ0crbzdNTzE0RVhiRlE=
sn: user01
givenName: user01

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
</code></pre>
<p>例如类似值搜索</p>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot;  &quot;givenName~=usr01&quot;
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: givenName~=usr011
# requesting: ALL
#

# user01, group, test.com
dn: uid=user01,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/user01
loginShell: /bin/bash
uid: user01
cn: user01
uidNumber: 10004
gidNumber: 10001
userPassword:: e1NTSEF9aEpwSUlWeGoxcVM5ZzA1cVVsZ0crbzdNTzE0RVhiRlE=
sn: user01
givenName: user01

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1
</code></pre>
<h3 id="查找openldap服务配置">查找openldap服务配置</h3>
<p><code>ldapsearch</code> 命令有一种高级用法是查询 <code>slapd</code> 服务的配置。要进行这种搜索，必须使用选项 “<code>-Y</code>” 并指定 关键字 “<code>EXTERNAL</code>” 作为身份验证机制。</p>
<pre><code class="language-bash">$ ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config 
</code></pre>
<p>例如</p>
<pre><code class="language-bash">$ ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config
SASL/EXTERNAL authentication started
SASL username: gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth
SASL SSF: 0
# extended LDIF
#
# LDAPv3
# base &lt;cn=config&gt; with scope subtree
# filter: (objectclass=*)
# requesting: ALL
#

# config
dn: cn=config
objectClass: olcGlobal
cn: config
olcArgsFile: /var/run/openldap/slapd.args
olcDisallows: bind_anon
olcLogLevel: stats
olcPidFile: /var/run/openldap/slapd.pid
olcTLSCACertificatePath: /etc/openldap/certs
olcTLSCertificateFile: &quot;OpenLDAP Server&quot;
olcTLSCertificateKeyFile: /etc/openldap/certs/password

# schema, config
dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema
olcObjectIdentifier: OLcfg 1.3.6.1.4.1.4203.1.12.2

...

# {1}collective, schema, config
dn: cn={1}collective,cn=schema,cn=config
objectClass: olcSchemaConfig
cn: {1}collective

...

# {-1}frontend, config
dn: olcDatabase={-1}frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: {-1}frontend

# {0}config, config
dn: olcDatabase={0}config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {0}config
olcAccess: {0}to attrs=userPassword,shadowLastChange   by dn.children=&quot;cn=admi
 n,dc=test,dc=com&quot; write   by anonymous auth   by self write   by * none
olcAccess: {1}to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external
 ,cn=auth&quot; manage   by group.exact=&quot;cn=configadmin,ou=admin,dc=seal,dc=com&quot; wr
 ite   by * none

# {1}monitor, config
dn: olcDatabase={1}monitor,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {1}monitor
olcAccess: {0}to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external
 ,cn=auth&quot; read by dn.base=&quot;cn=Manager,dc=my-domain,dc=com&quot; read by * none

# {2}mdb, config
dn: olcDatabase={2}mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: {2}mdb
olcDbDirectory: /var/lib/ldap
olcSuffix: dc=test,dc=com
olcRootDN: cn=admin,dc=test,dc=com
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw
olcDbCheckpoint: 1024 10
olcDbIndex: objectClass eq,pres
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub

# search result
search: 2
result: 0 Success

# numResponses: 20
# numEntries: 19
</code></pre>
<blockquote>
<p>Notes：这种查询命令需要直接在slapd服务对应节点上运行。</p>
</blockquote>
<p>这类搜索也可以使用过滤器，例如指定搜索数据库的配置</p>
<pre><code class="language-bash">$ ldapsearch -Y EXTERNAL -H ldapi:/// -b cn=config &quot;(objectclass=olcDatabaseConfig)&quot;
</code></pre>
<h2 id="更新api-ldapmodify">更新API ldapmodify</h2>
<p><code>ldapmodify</code> 有两个参数来指定如何修改数据：</p>
<ul>
<li><code>replace</code> 要修改的字段</li>
<li><code>changetype: modify</code> 模式为修改模式</li>
<li><code>dn</code> 对那个条目进行搜索，RootDN的后缀，对于每个条目例如，user 为 <code>uid=&lt;&gt;,ou=&lt;&gt;,dc=test,dc=com</code></li>
</ul>
<p>例如下面命令是将 cylon用户的uid更改为10010</p>
<pre><code class="language-bash">$ cat &lt;&lt; EOF | ldapmodify -r  -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=cylon,ou=Group,dc=test,dc=com
changetype: modify
replace: uidNumber
uidNumber: 10010
EOF
</code></pre>
<h2 id="删除api-ldapdelete">删除API ldapdelete</h2>
<p>删除API与更新API类似，不过内容只需要一个 <code>dn</code> （这个dn是隐式的，不用单独声明字段），例如删除用户cylon</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapdelete -r  -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
uid=cylon,ou=Group,dc=test,dc=com
EOF
</code></pre>
<p>使用 <code>ldapmodify</code> 删除条目，只要吧 <code>changetype: delete</code> 在加上显式声明的 <code>dn</code> 也可以删除条目，例如</p>
<pre><code class="language-bash">$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; uid=cylon  
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: uid=cylon
# requesting: ALL
#

# cylon, group, test.com
dn: uid=cylon,ou=group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword:: e1NTSEF9MnB2RTRDNnh5OGRrbVcyYUQvZUVvY1Zhamc4QnVqV1c=
uidNumber: 10005
gidNumber: 10001
sn: cylon

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1



$ cat &lt;&lt; EOF | ldapmodify -r  -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=cylon,ou=Group,dc=test,dc=com
changetype: delete
EOF

deleting entry &quot;uid=cylon,ou=Group,dc=test,dc=com&quot;

$ ldapsearch -x -H ldap://10.0.0.3 -w 111 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; uid=cylon  
# extended LDIF
#
# LDAPv3
# base &lt;dc=test,dc=com&gt; with scope subtree
# filter: uid=cylon
# requesting: ALL
#

# search result
search: 2
result: 0 Success

# numResponses: 1
</code></pre>
<h2 id="插入api-ldapadd">插入API ldapadd</h2>
<p><code>ldapapp</code> 使用起来比较复杂，在添加时，区分与RootDN，子条目，并且属性相关都需要配置对</p>
<p>下列时增加一个用户</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=cylon,ou=Group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword: {SSHA}2pvE4C6xy8dkmW2aD/eEocVajg8BujWW
uidNumber: 10005
gidNumber: 10001
sn: cylon
EOF
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://docs.oracle.com/cd/E19693-01/819-0995/6n3cq3apv/index.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Managing Entries ldapmodify and ldapdelete</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://devconnected.com/how-to-search-ldap-using-ldapsearch-examples/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>How To Search LDAP using ldapsearch</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap - OpenLDAP安装</title>
      <link>https://www.oomkill.com/2019/08/ch2-install/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/08/ch2-install/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="生产服务器硬件配置需求">生产服务器硬件配置需求</h2>
<p>ldap服务对系统环境的要求不高，一般在生产场景，ldap服务应该最少是两台，这样某一台物理服务器岩机才不会因单点问题影响生产业务故障，对于硬件要求，本质上openldap使用硬件资源并不大，网上有两个帖子提出了openldap的硬件需求：</p>
<ul>
<li>2003年openldap官网留言，我想安装一个 LDAP 服务器来验证邮件服务器的用户，目前有200个用户需要多少内存和CPU？<sup><a href="#1">[1]</a></sup>
<ul>
<li>1GHZ PIII/512MB 足以</li>
</ul>
</li>
<li>运行于Ubuntu LXC 之上的openldap，用户150,000，sladp进程常驻内存为200-300MB，mdb数据库文件大小为377MB，10 并发平均响应时间为 9-11 毫秒 <sup><a href="#13">[13]</a></sup></li>
</ul>
<p>操作系统：Centos7/8 64bit。</p>
<table>
<thead>
<tr>
<th>操 作 系 统</th>
<th>其 它</th>
</tr>
</thead>
<tbody>
<tr>
<td>CentOS-7.6</td>
<td>当前很稳定且免费的Linux版本。</td>
</tr>
</tbody>
</table>
<p>网卡及IP资源</p>
<table>
<thead>
<tr>
<th>名 称</th>
<th>接 口</th>
<th>IP</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ldap主服务器01</td>
<td>eth0</td>
<td>10.0.0.17</td>
<td>外部管理IP，用于WAN数据转发。</td>
</tr>
<tr>
<td></td>
<td>eth1</td>
<td>10.0.0.17</td>
<td>备用管理IP，用于LAN内数据转发。</td>
</tr>
<tr>
<td>ldap从服务器02</td>
<td>eth0</td>
<td>10.0.0.8</td>
<td>管理IP，用于LAN数据转发。</td>
</tr>
<tr>
<td></td>
<td>eth1</td>
<td>10.0.0.18</td>
<td>外部管理IP，用于WAN数据转发。</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>Tips：内外网IP分配可采用最后8位相同的方式，这样使于管理。</p>
</blockquote>
<hr>
<h2 id="openldap-master服务安装">openldap master服务安装</h2>
<p>CentOS/Redhat 安装OpenLDAP组件</p>
<pre><code class="language-bash">yum install -y \
	openldap \
	openldap-servers \
	openldap-clients \
	openldap-devel \
	compat-openldap
</code></pre>
<p>Ubuntu18.04/22.04/20.04</p>
<pre><code class="language-bash">sudo apt -y install slapd ldap-utils
</code></pre>
<p>默认OpenLDAP服务所使用的端口为389，此端口采用明文传输数据，数据信息得不到保障。所以可以通过配置CA及结合TLS/SASL实现数据加密传输，所使用端口为636。</p>
<p>编译安装</p>
<pre><code>yum install -y \
	libtool-ltdl \
	libtool-ltdl-devel \
	gcc \
	openssl \
	openssl-devel
</code></pre>
<p>Openldap依赖的相关软件：</p>
<ul>
<li><a href="http://www.openldap.org/doc/admin24/install.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/doc/admin24/install.html</a></li>
</ul>
<h2 id="openldap参数配置优化">openldap参数配置优化</h2>
<p>openldap配置文件分为五部分</p>
<ul>
<li>sladp进程配置部分</li>
<li>frontend：是一个特殊的 <code>olcDatabaseConfig</code> 配置提供权限认证</li>
<li>database：存储的真实引擎</li>
<li>backend：backend在slapd中不是真是的数据库，而是提供的一种转发方式</li>
</ul>
<h3 id="openldap目录布局">openldap目录布局</h3>
<ul>
<li><code>/etc/openldap/slapd.d/*</code>： <code>/etc/openldap/slapd.ldif</code>配置信息生成的文件，每修改一次配置信息，这里的东西就要重新生成。</li>
<li><code>/var/lib/ldap/*</code>：OpenLDAP的数据文件。</li>
<li><code>/usr/share/openldap-servers/DB_CONFIG.example</code>：模板数据库配置文件。</li>
<li><code>/usr/share/openldap-servers/slapd.ldif</code>：默认模板配置文件。</li>
</ul>
<p>默认OpenLdap服务所使用的端口为<strong>389</strong>，此端口采用明文传输数据，数据信息得不到保障。所以可以通过配置CA及结合TLS/SSL实现数据加密传输，所使用端口为<strong>636</strong>。</p>
<pre><code>cp /usr/share/openldap-servers/slapd.ldif /etc/openldap/
</code></pre>
<p>指定密码，不提示</p>
<pre><code>$ slappasswd -s 111
{SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
</code></pre>
<pre><code class="language-ldif"># 指定要搜索的后缀
olcSuffix: dc=cylon,dc=org
# rootdn，使用这个dn可以登录服务器
olcRootDN: cn=admin,dc=cylon,dc=org
olcDbDirectory: /var/lib/ldap
# 指定ldapserver管理员密码==
olcRootPW: {SSHA}QnB7dO98+hoCUgiaAYaiJWnDzlhn2Tn6
</code></pre>
<h3 id="日志及缓存参数">日志及缓存参数。</h3>
<pre><code># 设置日志级别，记录日志信息方便调试 stats 256（日志连接/操作/结果） 
olcLogLevel: stats

# 设置ldap可以缓存的记录数
olcDbCacheSize: 1000

# checkpoint 可以吧内存中的数据写会数据文件的操作，此设置表示每达到2048kb或者10分钟执行一次
olcDbCheckpoint: 1024 10
</code></pre>
<h3 id="开启扩展schema">开启扩展schema</h3>
<p>openldap自带一些ldif文件 <sup><a href="#10">[10]</a></sup>，LDIF 是 <em><strong>LDAP Data Interchange Format</strong></em>  的缩写，是作为存储与LDAP中 ” <strong>文本格式</strong> “ 的数据交换格式，每个条目代表的存入LDAP中记录的属性，记录之间用空行分隔，每行都是 “属性:值” 的格式，例如我们存入LDAP中一个记录，其属性有</p>
<ul>
<li>dn (<em><strong>distinguished name</strong></em>) 用于标识目录中名称的唯一标识符</li>
<li>dc (<em><strong>domain component</strong></em>) 表示域组成，例如域名 <code>www.mydomain.com</code> 那么dc 应该配置为<code>DC=www,DC=mydomain,DC=com</code></li>
<li>ou (<em><strong>organizational unit</strong></em>) 这是指用户的组织，这里也可以代表用户组，例如 <code>OU=Lawyer,OU=Developer</code></li>
<li>cn (<em><strong>common name</strong></em>) 表示查询的个体对象的名称，这里可以代表用户名，服务名等，例如 <code>cn=cylon</code></li>
</ul>
<p>具有多个属性条目，在ldap中代表一条记录，例如</p>
<pre><code> dn: cn=The Postmaster,dc=example,dc=com
 objectClass: organizationalRole
 cn: The Postmaster
</code></pre>
<p>而ldif文件就是定义这些属性的文件，下面是openldap安装后默认的ldif文件说明：</p>
<ul>
<li>
<p><code>collective.ldif </code><strong>：<em>Collective Attribute</em></strong> 组成LDAP条目的共享属性</p>
</li>
<li>
<p><code>corba.ldif</code><strong>：<em>Common Object Request Broker Architecture</em></strong> 的缩写，旨在促进部署在不同平台上的系统的通信 <sup><a href="#2">[2]</a></sup></p>
</li>
<li>
<p><code>cosine.ldif</code><strong>：<em>Cooperation for Open Systems Interconnection Networking in Europe</em></strong>的缩写，用于给 <code>cosine</code> 与 <code>Internet X.500</code> 模式项目提供LDAP中的属性格式 <sup><a href="#3">[3]</a></sup></p>
</li>
<li>
<p><code>duaconf.ldif</code><strong>：<em>Directory User Agents</em></strong> 的缩写，DUA是协议客户端，是向ldap或<code>Internet X.500</code> DSA发起请求的一端，这是为DUA客户端提供了通用配置 <sup><a href="#4">[4]</a></sup></p>
</li>
<li>
<p><code>dyngroup.ldif</code><strong>：<em>Dynamic Group</em></strong>的缩写，动态组是LDAP中的一种组，与静态组相反，DG是以URL形式为搜索条件来隐式定义一组用户。<sup><a href="#5">[5]</a></sup></p>
<ul>
<li>静态组 <em><strong>Static Groups</strong></em> 使用一组DN显式定义一组用户</li>
</ul>
</li>
<li>
<p><code>inetorgperson.ldif</code><strong>：inetOrgPerson</strong>类是 <code>RFC2798中</code> 定义的类。在LDAP中为 <strong>user</strong> 的父类，比如说用户密码，登录时间等属性，更多可以参考 <sup><a href="#6">[6]</a></sup></p>
</li>
<li>
<p><code>java.ldif</code>：用于java的一些属性</p>
</li>
<li>
<p><code>misc.ldif</code><strong>：<em>Miscellaneous</em></strong> 的简写，这里主要是一些电子邮件相关属性</p>
</li>
<li>
<p><code>nis.ldif</code><strong>：<em>Network Information Service</em></strong> 的缩写，NIS是一种发现机制，这里是一种server-client的目录属性，例如网络中的主机名，用户名之类 <sup><a href="#7">[7]</a></sup></p>
</li>
<li>
<p><code>openldap.ldif</code>：</p>
</li>
<li>
<p><code>pmi.ldif</code><strong>：<em>Privilege Management Infrastructure</em></strong> 的缩写，是基于x.509的授权访问控制模型，这里是提供了基于PMI的一些属性</p>
</li>
<li>
<p><code>ppolicy.ldif</code><strong>：<em>password policy</em></strong> 的缩写，提供了增强的密码管理功能，例如账户到期时间，锁定等</p>
</li>
</ul>
<pre><code>include: file:///etc/openldap/schema/collective.ldif   # OpenLDAP的核心schema必须
include: file:///etc/openldap/schema/corba.ldif # 
include: file:///etc/openldap/schema/cosine.ldif
include: file:///etc/openldap/schema/duaconf.ldif
include: file:///etc/openldap/schema/dyngroup.ldif
include: file:///etc/openldap/schema/inetorgperson.ldif
include: file:///etc/openldap/schema/java.ldif
include: file:///etc/openldap/schema/misc.ldif
include: file:///etc/openldap/schema/nis.ldif
include: file:///etc/openldap/schema/openldap.ldif
include: file:///etc/openldap/schema/pmi.ldif
include: file:///etc/openldap/schema/ppolicy.ldif
</code></pre>
<h3 id="授权及安全参数配置">授权及安全参数配置</h3>
<pre><code class="language-ldif">access to dn=&quot;cn=subschema&quot; by * read
access to 
    by self write 
    by dn subtree=&quot;ou=sysusers,dc=test,dc=com&quot; read
    by anonymous auth
</code></pre>
<p><strong>关于更多权限管理的说明，可以参考官方手册第八章</strong> <sup><a href="#12">[12]</a></sup></p>
<hr>
<blockquote>
<p><strong>提示</strong>:</p>
<p>参数在文件中的先后位置不能随意动。</p>
<p>空行和以“#”开头的注释行将被忽略。如果一行以空格开头，它将被认为是接着前一行的（即使前一行是注释）。</p>
</blockquote>
<hr>
<h3 id="配置syslog记录ldap服务日志配置syslog">配置syslog记录ldap服务日志配置syslog</h3>
<p>记录ldap服务日志，默认级别为256；</p>
<pre><code class="language-sh">echo 'local4.*          /var/log/slapd.log' &gt;&gt; /etc/rsyslog.conf
local4.*                /var/log/slapd.log
</code></pre>
<h3 id="配置ldap数据库存放路径">配置LDAP数据库存放路径</h3>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<p>slapd.conf中设定了LDAP数据库格式为hdb，存储路径<code>/var/1ib/ldap</code></p>
</blockquote>
<hr>
<pre><code>cp /usr/share/openldap-servers/DB_CONFIG.example /var/lib/ldap/DB_CONFIG

chown ldap.ldap /var/lib/ldap/DB_CONFIG
chmod 700 /var/lib/ldap/DB_CONFIG
</code></pre>
<h3 id="整合的配置">整合的配置</h3>
<pre><code class="language-ldif">#
# See slapd-config(5) for details on configuration options.
# This file should NOT be world readable.
#

dn: cn=config
objectClass: olcGlobal
cn: config
olcArgsFile: /var/run/openldap/slapd.args
olcPidFile: /var/run/openldap/slapd.pid
olcLogLevel: stats
olcDisallows: bind_anon
#
# TLS settings
#
olcTLSCACertificatePath: /etc/openldap/certs
olcTLSCertificateFile: &quot;OpenLDAP Server&quot;
olcTLSCertificateKeyFile: /etc/openldap/certs/password
#
# Do not enable referrals until AFTER you have a working directory
# service AND an understanding of referrals.
#
#olcReferral: ldap://root.openldap.org
#
# Sample security restrictions
#	Require integrity protection (prevent hijacking)
#	Require 112-bit (3DES or better) encryption for updates
#	Require 64-bit encryption for simple bind
#
#olcSecurity: ssf=1 update_ssf=112 simple_bind=64

#
# Load dynamic backend modules:
# - modulepath is architecture dependent value (32/64-bit system)
# - back_sql.la backend requires openldap-servers-sql package
# - dyngroup.la and dynlist.la cannot be used at the same time
#

#dn: cn=module,cn=config
#objectClass: olcModuleList
#cn: module
#olcModulepath:	/usr/lib/openldap
#olcModulepath:	/usr/lib64/openldap
#olcModuleload: accesslog.la
#olcModuleload: auditlog.la
#olcModuleload: back_dnssrv.la
#olcModuleload: back_ldap.la
#olcModuleload: back_mdb.la
#olcModuleload: back_meta.la
#olcModuleload: back_null.la
#olcModuleload: back_passwd.la
#olcModuleload: back_relay.la
#olcModuleload: back_shell.la
#olcModuleload: back_sock.la
#olcModuleload: collect.la
#olcModuleload: constraint.la
#olcModuleload: dds.la
#olcModuleload: deref.la
#olcModuleload: dyngroup.la
#olcModuleload: dynlist.la
#olcModuleload: memberof.la
#olcModuleload: pcache.la
#olcModuleload: ppolicy.la
#olcModuleload: refint.la
#olcModuleload: retcode.la
#olcModuleload: rwm.la
#olcModuleload: seqmod.la
#olcModuleload: smbk5pwd.la
#olcModuleload: sssvlv.la
#olcModuleload: syncprov.la
#olcModuleload: translucent.la
#olcModuleload: unique.la
#olcModuleload: valsort.la


#
# Schema settings
#

dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

include: file:///etc/openldap/schema/core.ldif
include: file:///etc/openldap/schema/collective.ldif
include: file:///etc/openldap/schema/corba.ldif
include: file:///etc/openldap/schema/cosine.ldif
include: file:///etc/openldap/schema/duaconf.ldif
include: file:///etc/openldap/schema/dyngroup.ldif
include: file:///etc/openldap/schema/inetorgperson.ldif
include: file:///etc/openldap/schema/java.ldif
include: file:///etc/openldap/schema/misc.ldif
include: file:///etc/openldap/schema/nis.ldif
include: file:///etc/openldap/schema/openldap.ldif
include: file:///etc/openldap/schema/pmi.ldif
include: file:///etc/openldap/schema/ppolicy.ldif

#
# Frontend settings
#
# 这里是对前端权限的配置，通常默认，不添加权限
dn: olcDatabase=frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: frontend
#
# Sample global access control policy:
#	Root DSE: allow anyone to read it
#	Subschema (sub)entry DSE: allow anyone to read it
#	Other DSEs:
#		Allow self write access
#		Allow authenticated users read access
#		Allow anonymous users to authenticate
#
#olcAccess: to dn.base=&quot;&quot; by * read
#olcAccess: to dn.base=&quot;cn=Subschema&quot; by * read
#olcAccess: to *
#	by self write
#	by users read
#	by anonymous auth
#
# if no access controls are present, the default policy
# allows anyone and everyone to read anything but restricts
# updates to rootdn.  (e.g., &quot;access to * by * read&quot;)
#
# rootdn can always read and write EVERYTHING!
#

#
# Configuration database
#
# 这里是对后端数据库权限的配置
dn: olcDatabase=config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: config
olcAccess: to attrs=userPassword,shadowLastChange
    by dn.children=&quot;cn=admin,dc=test,dc=com&quot; write
    by anonymous auth
    by self write
    by * none
olcAccess: to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,cn=auth&quot; manage
    by group.exact=&quot;cn=configadmin,ou=admin,dc=seal,dc=com&quot; write
    by * none

#
# Server status monitoring
#

dn: olcDatabase=monitor,cn=config
objectClass: olcDatabaseConfig
olcDatabase: monitor
olcAccess: to * by dn.base=&quot;gidNumber=0+uidNumber=0,cn=peercred,cn=external,c
 n=auth&quot; read by dn.base=&quot;cn=Manager,dc=my-domain,dc=com&quot; read by * none

#
# Backend database definitions
#
# 这里是数据库的参数配置
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
# 使用的数据库引擎是mdb
objectClass: olcMdbConfig
olcDatabase: mdb
# Suffix 为数据库的后缀，每个数据库至少一个，在搜索时-D 后面的域后缀为dc=test,dc=com将被pass到这里
olcSuffix: dc=test,dc=com
# 指不收前面配置的权限控制的管理员账户，拥有最最高权限
olcRootDN: cn=admin,dc=test,dc=com
# 特权账户的登录密码
olcRootPW: {SSHA}xU9xFym/s7rawpmzpsYE+Q1qPsVPOwDw
olcDbDirectory:	/var/lib/ldap
# 这是索引属性，下面是默认的属性
# 下列注释行意思为
#        olcDbIndex: default pres,eq
#        olcDbIndex: uid
#        olcDbIndex: cn,sn pres,eq,sub
#        olcDbIndex: objectClass eq
# pres,eq 为 present equality
# 第二行意思为，为uid属性类型维护默认索引集
# 第三行意思为，为cn,sn属性维护pres,eq,sub索引集
# 索引集类型有 pres,eq,approx,sub,none
olcDbIndex: objectClass eq,pres
olcDbIndex: uid,ou,cn,mail,surname,givenname eq,pres,sub
# 配置从缓冲区写入磁盘的，两个参数分别为多少kbyte大小的数据自上次（第二个参数）分钟则发生一次写入
olcDbCheckpoint: 1024 10
</code></pre>
<p>更多配置文件选项说明可以参考 <sup><a href="#14">[14]</a></sup></p>
<h3 id="生成配置文件">生成配置文件</h3>
<p>修改配置文件后需要重新生成配置文件</p>
<pre><code>slapadd -n 0 -F /etc/openldap/slapd.d -l /etc/openldap/slapd.ldif
</code></pre>
<p>生成配置文件时的错误</p>
<pre><code class="language-bash">$ slapadd -n 0 -F /etc/openldap/slapd.d -l /etc/openldap/slapd.ldif
63678619 str2entry: entry -1 has no dn
slapadd: could not parse entry (line=31)
_########              43.66% eta   none elapsed            none spd   7.0 M/s 
</code></pre>
<p>对于 <code>slapd.ldif</code> 需要注意下列事项</p>
<ul>
<li>行首 <code>#</code> 为注释</li>
<li>行尾不能有任何空白，这里也是很难排查的一个点</li>
<li>对于不同的属性需要放对位置快否则会报错，例如 <code>olcDbCacheSize: 1000</code> 是hdb配置，mdb添加会报错，有明显提示</li>
<li>如果生产配置失败后，修改配置文件后再次生成需要删除 <code> rm -fr slapd.d/*</code></li>
</ul>
<p>例如下面就是一个有提示的典型例子</p>
<pre><code class="language-bash">63678513 Entry (cn=config), attribute 'olcDbCacheSize' not allowed
slapadd: dn=&quot;cn=config&quot; (line=1): (65) attribute 'olcDbCacheSize' not allowed
</code></pre>
<p>下面的报错比较不明显，通常删除 <code> rm -fr slapd.d/*</code> 后重试</p>
<pre><code class="language-bash">slapadd: could not add entry dn=&quot;cn=config&quot; (line=1): 
_###                   17.92% eta   none elapsed            none spd   6.3 M/s 
</code></pre>
<h2 id="为ldap初始化数据">为LDAP初始化数据</h2>
<p>部署完成后就是访问，ldap了，此时向OpenLDAP 搜索会发现没有内容</p>
<pre><code>$ ldapsearch -LLL -x -W -H ldap://10.0.0.4 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot; &quot;(uid=*)&quot;

Enter LDAP Password: 
No such object (32)
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<ul>
<li><a href="http://www.openldap.org/faq/data/cache/1.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/faq/data/cache/1.html</a></li>
<li><a href="http://www.openldap.org/doc/admin24/appendix-common-errors.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/doc/admin24/appendix-common-errors.html</a></li>
</ul>
</blockquote>
<h3 id="创建root条目">创建Root条目</h3>
<p>在第一次部署好openldap中，实际上是没有任何条目的，此时是无法存入数据，有人说在 database setting中配置了 <code>olcRootDN</code> ，这里是指标识用哪个数据库的（即那个root存入哪里），而不是一个具体的root dn，所以需要手动创建一个</p>
<p>例如下列，是创建一个RootDN</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: dc=test,dc=com
objectclass: top
objectClass: organizationalUnit
objectclass: extensibleObject
description: US Organization
ou: people
EOF
</code></pre>
<p>这里需要注意几点：</p>
<ul>
<li><code>dn: dc=test,dc=com</code> 是指定存储的地方，如果在database配置中为配置 <code>olcRootDN</code> 则报错不会被存储</li>
<li>由于创建的的是root，所以ou的 <code>objectClass</code> 会报错，需要用一个 <code>extensibleObject</code> 才可以创建 <sup><a href="#15">[15]</a></sup></li>
</ul>
<h3 id="创建子域">创建子域</h3>
<p>此时因为有了RootDN，可以指定dn为子域了，并且 <code>objectClass: organizationalUnit</code> 可以单独使用</p>
<p>这里子域其实可以理解为二级域名了，在公司中也可以为子公司</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: ou=group,dc=test,dc=com
objectClass: organizationalUnit
ou: group
EOF
</code></pre>
<h3 id="创建组">创建组</h3>
<p>这里使用 <code>posixGroup</code> <em><strong>Portable Operating System Interface of UNIX</strong></em> 的简写，这里可以理解为Linux用户管理的标准，包含一些标准的属性，类似于 <code>/etc/group</code></p>
<p>下面创建一个gid为10001的组，组名为tech</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: cn=tech,ou=group,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10001
cn: tech
EOF
</code></pre>
<h3 id="创建用户">创建用户</h3>
<p>创建用户user01</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=user01,ou=Group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/user01
loginShell: /bin/bash
uid: user01
cn: user01
uidNumber: 10004
gidNumber: 10001
userPassword: {SSHA}hJpIIVxj1qS9g05qUlgG+o7MO14EXbFQ
sn: user01
givenName: user01
</code></pre>
<p>创建用户cylon</p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapadd -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: uid=cylon,ou=Group,dc=test,dc=com
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/cylon
loginShell: /bin/bash
uid: cylon
cn: cylon
userPassword: {SSHA}2pvE4C6xy8dkmW2aD/eEocVajg8BujWW
uidNumber: 10005
gidNumber: 10001
sn: cylon
EOF
</code></pre>
<p>如上面所示，<code>objectClass</code> <sup><a href="#11">[11]</a></sup> 表示这个ldap条目拥有的属性，可以看到 <code>posixAccount</code>，<code>inetOrgPerson</code> 等都是导入的schema文件，其中 <code>uidNumber</code> ，<code>userPassword</code> 都是 NIS 定义的，<code>cn</code> 则是 core定义的</p>
<hr>
<blockquote>
<p><strong>提示</strong>:</p>
<ul>
<li>以上信息中ldap
<ul>
<li>用户1：user01密码 <code>111</code></li>
<li>用户2：cylon 密码 <code>123456</code></li>
</ul>
</li>
<li>这些原始信息是如何获得的？</li>
</ul>
</blockquote>
<hr>
<h3 id="检查初始化测试数据">检查初始化测试数据。</h3>
<p>查询导入的结果，默认查的是所有数据</p>
<pre><code>ldapsearch -LLL -w 111 -x -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -b &quot;dc=test,dc=com&quot;
</code></pre>
<h3 id="备份ldap数据库数据">备份ldap数据库数据</h3>
<pre><code class="language-bash">ldapadd -x -H ldap://cylon.org -D &quot;cn=admin,dc=cylon,dc=org&quot; -W -f base.ldif &gt;base.ldif
ldapadd -x -H ldap://cylon.org -D &quot;cn=admin,dc=cylon,dc=org&quot; -W -f test.ldif &gt;test.ldif
</code></pre>
<h2 id="reference-1">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.openldap.org/lists/openldap-software/200306/msg00281.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>msg00281</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://ldapwiki.com/wiki/Common%20Object%20Request%20Broker%20Architecture" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Object Request Broker Architecture</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://ldapwiki.com/wiki/Cooperation%20for%20Open%20Systems%20Interconnection%20Networking%20in%20Europe" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Cooperation for Open Systems Interconnection Networking in Europe</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://ldapwiki.com/wiki/DUA" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>DUA</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://ldapwiki.com/wiki/DynamicGroup" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>DynamicGroup</strong></em></a></p>
<p><sup id="6">[6]</sup> <a href="https://ldapwiki.com/wiki/InetOrgPerson" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>InetOrgPerson</strong></em></a></p>
<p><sup id="7">[7]</sup> <a href="https://ldapwiki.com/wiki/Network%20Information%20Service" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Network Information Service</strong></em></a></p>
<p><sup id="8">[8]</sup> <a href="https://ldapwiki.com/wiki/Privilege%20Management%20Infrastructure" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Privilege Management Infrastructure</strong></em></a></p>
<p><sup id="9">[9]</sup> <a href="https://ldapwiki.com/wiki/Password%20Policy" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Password Policy</strong></em></a></p>
<p><sup id="10">[10]</sup> <a href="https://ldapwiki.com/wiki/LDAP%20Data%20Interchange%20Format" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>LDAP Data Interchange Format</strong></em></a></p>
<p><sup id="11">[11]</sup> <a href="https://ldapwiki.com/wiki/ObjectClass" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Object Class</strong></em></a></p>
<p><sup id="12">[12]</sup> <a href="https://www.openldap.org/doc/admin24/access-control.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>8. Access Control</strong></em></a></p>
<p><sup id="13">[13]</sup> <a href="https://stackoverflow.com/questions/40080921/openldap-system-requirements-for-virtualization" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>openldap system requirements for virtualization</strong></em></a></p>
<p><sup id="14">[14]</sup> <a href="https://www.openldap.org/doc/admin24/slapdconf2.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>slapdconf2</strong></em></a></p>
<p><sup id="15">[15]</sup> <a href="https://community.oracle.com/tech/apps-infra/discussion/2013873/attribute-dc-is-not-allowed" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>attribute dc is not allowed</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>理解ldap - 什么是ldap</title>
      <link>https://www.oomkill.com/2019/08/ch1-understanding-ldap/</link>
      <pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/08/ch1-understanding-ldap/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是目录服务">什么是目录服务？</h2>
<p>==目录是一类为了浏览和搜索数据而设计的特殊的数据库==，例如：为人所熟知的微软公
司的活动目录（active directory）就是目录数据库的一种，目录服务是按照==树状形式==存储信息的，目录包含基于属性的描述性信息，并且支持高级的过滤功能。</p>
<ul>
<li><a href="http://www.openldap.org/doc/admin24/intro.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/doc/admin24/intro.html</a></li>
</ul>
<p>一般来说，目录不支持大多数事务型数据库所支持的<strong>高吞吐量</strong>和复杂的更新操作。目录进行更新操作，可以说是要么全部，要么都不的原子操作。目录服务适合的业务应用在于提供大量的<strong>查询和搜索</strong>操作，而不是大量的写入操作。Ldap可以说是活动目录在linux系统上的一个开源实现。</p>
<p>为了保证目录数据的可用性和可靠性，在确保使用目录服务提供快速查询和搜索操作的同时，目录服务还提供了==主从服务器同步目录数据信息的能力==，这相当于传统的MySQL数据库的主从同步功能一样，可以最大限度的确保基于目录业务的服务持续可用性与提供并发查询能力，微软公司的活动目录（active directory）就有主域和备份域的说法。</p>
<p>广义的目录服务概念，可以用多种不同的方式来提供目录服务。不同的目录所允许存储的信息是不同的，在信息如何被引用、查询、更新以及防止未经授权的访问等问题上，不同的目录服务的处理方式也有诸多的不同。</p>
<p>例如：一些目录服务是本地的，只提供受限的服务（比如，单机上的finger服务）。另一些服务是大范围的（global），提供广阔得多的服务（比如面向整个因特网），大范围的服务通常是分布式的，这也就意味着数据是分布在多台机器上的，这些机器一起来提供目录服务，典型的大范围服务定义一个统一的名称空间（namespace）来给出一个相同的数据视图（data view），而不管你相对于数据所在的位置。DNS是一个典型的大范围分布式目录服务的例子。</p>
<ul>
<li><a href="http://www.openldap.org/faq/data/cache/595.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/faq/data/cache/595.html</a></li>
</ul>
<h2 id="什么是ldap">什么是ldap？</h2>
<p>目录服务有两个国际标准，分别是<code>X.500</code>和<code>LDAP</code>。X.500是ITU定义的目录标准，而LDAP是基于TCP/IP的目录访问协议，是Intemet上目录服务的通用访问协议。</p>
<p>LDAP是 <code>Lightweight Directory Access Protocol</code>（轻量级目录访问协议）的缩写。正如它的名字所表明的那样，它是一个轻量级的目录访问协议，特指基于X.500的目录访问协议的简化版本。LDAP运行在 <code>TCP/IP</code> 或者其他的面向连接的传输服务之上。LDAP完整的技术规范由RFC2251“The Lightweight Directory Access Protocol（v3）”和其他几个在RFC3377中定义的文档组成。</p>
<ul>
<li>LDAP是轻量目录访问协议（Lielhtweiglht Directory Access Protocol）的缩写。</li>
<li>LDAP标准实际上是在X.500标准基础上产生的一个简化版本。</li>
</ul>
<h2 id="什么是x500">什么是X.500？</h2>
<p>X.500由ITU-T和ISO定义，它实际上不是一个协议，而是由一个==协议族==组成，包括了从X.501到X.525等一系列非常完整的目录服务协议。</p>
<p>从技术上来说，LDAP是一个到X.500目录服务的目录访问协议，X.500是一个OSI目录服务。最初，LDAP客户端通过网关访问X.500目录服务。网关在客户端和网关之间运行LDAP，而X.500目录访问协议（Directory Access Protocol，DAP），位于这个网关和X.500服务器之间。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/8778" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>LDAP是一个重量级的协议，在整个OSI协议栈上进行操作，而且需要占用大量的计算资源。而LDAP被设计为在TCP/IP层上操作，以小得多的代价实现了大多数LDAP的功能。</p>
<p>虽然LDAP仍旧可以通过网关访问X.500目录服务器，但是现在通常都是在X.500服务器上直接实现LDAP。</p>
<p>单独的LDAP守护程序openldap slapd，可以被看做是一个轻量级的X.500目录服务器。也就是说，它没有实现X.500完整的DAP协议。作为一个轻量级的目录服务器，slapd实现的仅仅是X.500模型的一个子集。</p>
<p>LDAP中的常用名词缩写及含义。</p>
<p>LDAP基本概念中的常用名词缩写及含义</p>
<table>
<thead>
<tr>
<th>关 键字</th>
<th>  英文全称</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>dc</td>
<td>Domain Component</td>
<td>城名的部分，其格式是将完整的城名分成几部分，如域名为exaple.com变成<code>dc=exaple,dc=com</code></td>
</tr>
<tr>
<td>uid</td>
<td>User Id</td>
<td>用户ID，如 “oldboy”。</td>
</tr>
<tr>
<td>ou</td>
<td>Organization Unit</td>
<td>组织单位，类似于Limux文件系统中的子目录，它是一个容器对象，组织单位可以包含其他各种对象（包括其他组织单元），如“tech，rongjunfeng，bingge”</td>
</tr>
<tr>
<td>cn</td>
<td>Common Name</td>
<td>公共名称，如 “Thowas Johansson”</td>
</tr>
<tr>
<td>sn</td>
<td>Surnase</td>
<td>姓，如 “Johansson”</td>
</tr>
<tr>
<td>dn</td>
<td>Distinguished Name</td>
<td>唯一辨别名，类似于Linux文件系统中的绝对路径，每个对象都有一个唯一的名称，如<code>uid=tos,ou=market,dc=example,dc=com</code>，在一个目录树中 总是唯一的。</td>
</tr>
<tr>
<td>rdn</td>
<td>Relative  dn</td>
<td>相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如<code>uid=tom</code>或<code>cn=Thoeas Johansscn</code>。</td>
</tr>
<tr>
<td>c</td>
<td>Country</td>
<td>国家，如“CN”或“US”等</td>
</tr>
<tr>
<td>o</td>
<td>organizatione</td>
<td>组织名，如“Example，Inc.”。</td>
</tr>
</tbody>
</table>
<h2 id="ldap目录服务的特点">LDAP目录服务的特点</h2>
<p>LDAP（openldap）目录服务具有下列特点：</p>
<ul>
<li>LDAP是一个跨平台的、标准的协议，近几年来得到了业界广泛的认可。</li>
<li>LDAP的结构用树型结构来表示，而不是用表格。因此不用SQL语句维护了。</li>
<li>LDAP提供了静态数据的快速查询方式，但在更新数据方面并不擅长。</li>
<li>LDAP服务可以使用基于“推”或“拉”的复制信息技术，用简单的或基于安全证书的安全认证，复制部分或全部数据，既保证了数据的安全性，又提高了数据的访问效率：</li>
<li>LDAP是一个安全的协议，LDAPv3支持SASL（Simple Authentication and Security Layer）、SSL（Secure Socket Layer）和TLS（Transport Layer Security），使用认证来确保事务的安全，另外，LDAP提供了不同层次的访问控制，以限制不同用户的访问权限。</li>
<li>LDAP支持异类数据存储，LDAP存储的数据可以是文本资料、二进制图片等。</li>
<li>Client/Server 模型：Server端用于存储树，Client端提供操作目录信息树的工具，通过这些工具，可以将数据库的内容以文本格式（LDAP数据交换格式，LDIF）呈现在我们的面前。</li>
<li>LDAP是一种开放Internet 标准，LDAP协议是跨平台的的Interent协议，它是基于X.500标准的，与X.500不同，LDAP支持TCP/IP（即可以分布式部署）。</li>
</ul>
<h2 id="ldap的目录结构">LDAP的目录结构</h2>
<p>LDAP目录服务是通过目录数据库来存储网络信息来提供目录服务的。为了方便用户迅速查找和定位信息，目录数据库是以目录信息树（Directory Infornation Tree，缩写为DIT）为存储方式的树型存储结构，目录信息树及其相关概念构成了LDAP协议的信息模型。</p>
<ul>
<li>在LDAP中，目录是按照树型结构组织一一目录信息树（Directory Information Tree简写DIT），DIT是一个主要进行读操作的数据库。</li>
<li>DIT由条目（Entry）组成，条目相当于关系数据库中的表的记录：</li>
</ul>
<p>条目是具有分辨名DN（Distinguished Name）的属性-值对（Attribute-value，简称AV）
的集合。</p>
<p>在UNIX文件系统中，最项层是根目录（root），LDAP目录通常也用ROOT做根，通常称为<code>BaseDN</code>。</p>
<p>因为历史（X.500）的原因，LDAP目录用OU（Organization Unit）从逻辑上把数据分开来。Ou也是一种条目&ndash;==容器条目==。Ou下面即是真正的用户条目。</p>
<blockquote>
<p><strong>什么是dn?</strong></p>
</blockquote>
<p>DN，Distinguished Name，即分辨名。</p>
<p>在LDAP中，一个条目的分辨名叫做“DN”，DN是该条目在整个树中的唯一名称标识，DN相当于关系数据席表中的关键字（Primary Key）；它是一个识别属性，通常用于检索。</p>
<blockquote>
<p><strong>DN的两种设置</strong></p>
</blockquote>
<p>基于cn（姓名），<code>cn=test,ou=auth,dc=cylon,dc=org</code>，最常见的cn是从 <code>/etc/group</code> 转来的条目。.</p>
<p>基于uid（User ID），<code>uid=test,ou=auth,dc=cylon,dc=org</code> 最常见的uid是 <code>/etc/passwd</code> 转来的条目。</p>
<blockquote>
<p><strong>Base DN</strong></p>
</blockquote>
<p>LDAP目录树的最顶部就是根，也就是Base DN.</p>
<blockquote>
<p><strong>LDIF格式</strong></p>
</blockquote>
<p>LDIF格式是用于LDAP数据导入、导出的格式。LDIF是LDAP数据库信息的一种文本格式。BDB。</p>
<blockquote>
<p><strong>什么样的信息可以存储在目录当中？</strong></p>
</blockquote>
<p>LDAP的信息模型是基于条目的（entry）。一个条目就是一些具有全局唯一的标识名（Distinguished Name，简写做==DN==）的属性的集合。DN用于无二义性的指代一个唯一的条目，条目的每一个属性都有一个类型（type），一个或者多个值（value），类型（type）往往是特定字符串的简写，比如用 <code>cn</code> 指代 <code>commpn name</code>，或者 <code>mail</code> 指代电子邮件地址。值（value）的语法依赖于类型（type），比如，类型为cn的属性可能包含值Babs Jensen。
类型为mail的属性可能包含值 <code>babs@example.com</code> 。类型为jpegPhoto的属性可能包含二进制格式的JPEG图象。</p>
<p>下面是LDAP中条目信息的例子；就相当于数据库表中的两行记录：</p>
<p>LDAP允许你通过使用一种叫做 <code>objectClass</code>的特殊属性来控制哪些属性是条目所必须的，哪些属性是条目可选的，<code>objectClass</code> 属性的值是由条目所必须遵从的方案（schema）
来建义的。</p>
<p>通过下面命令可以取出上面的内容。</p>
<pre><code class="language-sh">ldapsearch -LLL -w oldboy -x -H ldap://10.0.0.20 -D &quot;cn=admin,dc=cylon,dc=org&quot; -b &quot;dc=cylon,dc=org&quot; uid=&quot;*&quot;
</code></pre>
<p>信息在目录中是如何组织的？</p>
<p>在LDAP中，条目是按树状的层次结构组织的，传统上，这个结构往往是地理界限或者组织界限的反映。代表国家的条目位于整个目录树的顶层。之下的条目则代表各个州以及国家性的组织，再下面的条目则代表着组织单位、个人打印机、文件，或者你所能想到的其他东西，图1.1显示了按照传统命名方式组织的LDAP目录信息树。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/intro_tree.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图1.1：LDAP目录树（传统命名方式）</center>
<p>目录树也可以按照因特网域名结构组织。因为它允许按照DNS对目录服务进行定位，这种命名方式正变得越来越受欢迎。图1.2显示了按照域名进行组织的一个LDAP目录树的例子。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/intro_dctree.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<ul>
<li><a href="http://www.openldap.org/doc/admin24/intro.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/doc/admin24/intro.html</a></li>
</ul>
<p>root -&gt; 顶级域 -&gt; 二级 -&gt; ou -&gt; uid</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567525992883.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图1-2：LDAP目录树（域名命名方式）</center>
<p>例：<code>dn:cn=testlb,ou=People,ou=accounts,dc=cylon,dc=org</code></p>
<p>另外，LDAP允许你通过使用一种叫做objectClass的特殊属性来控制哪些属性是条目所必须的，哪些属性是条目可选的。objectClass属性的值是由条目所必须遵从的方案
（schema）来定义的。.</p>
<p>（3）信息是如何械引用的？</p>
<p>一个条目是通过它的标识名来引用的。而标识名是由相对标识名（Relative Distinguished Name或者RDN）和它的父条目名连在一起构成的。比如，在因特网命名的例子中，Barbara Jensen条目有相对标识名 <code>uid=babs</code> 和标识名为：<code>uid=babs,ou=People,de=example,dc=com</code> 。</p>
<h3 id="ldif数据文件介绍">LDIF数据文件介绍</h3>
<p>目录数据文件内容讲解</p>
<p>LDIF（LDAP Data Interchangep-omat）轻量级目录交换格式）一种ASCII文件格式，用来交换数据并使得在LDAP服务器间交换数据成为可能。</p>
<p>LDIF文件最常用的功能就是向目录导入或修改信息，这些信息的格式需要按照LDAP中架构（schema）格式组织，如果不符合其要求的格式就会出现错误。</p>
<p>LDIF文件的特点：</p>
<ul>
<li>通过空行来分割一个条目或定义。</li>
<li>以<code>#</code>开始的行为注释。</li>
<li>所有属性的赋值方法为：<code>&quot;属性: 属性值&quot;</code> 例如，dn:<code>dn=cylon,dc=org</code></li>
<li>属性可以被重复赋值。例如objectclass就可以有多个，每个属性独立一行。</li>
<li>每行的结尾不允许有空格。</li>
</ul>
<p>在LDAP的每条记录中必须包含一个objectclass属性，且其需要赋子至少一个值。objectclass属性有等级之分，属性相当于变量，它可以被自定义赋值，值不能相同。</p>
<p>目录数据展现的树形结构圆。以上ldif数据文件表现个内容为如下树形结构：ldap C/S工具呈现的。</p>
<h2 id="ldap是想样工作的">LDAP是想样工作的？</h2>
<p>LDAP目录服务是基于 C/S模式的。一个或者多个LDAP服务器包含着组成整个目录信息树（DIT）的数据，客户端连接到服务器并且发出一个请求（request），然后服务器要么以一个回答（answer）子以回应，要么给出一个指针，客户可以通过此指针获取到所需的数据（通常，该指针是指向另一个LDAP服务器），无论客户端连到哪个LDAP服务器，它看到的都是同一个目录视图（view）.这是LDAP这类全局目录服务的一个重要特征。</p>
<h2 id="ldap的几个重要配置模式">LDAP的几个重要配置模式</h2>
<p>LDAP服务的几个重要功能：</p>
<ul>
<li>★★★基本的目录查询服务。</li>
<li>目录查询代理服务。</li>
<li>异机复制数据（即主从同步）。</li>
</ul>
<h3 id="本地基本的目录查询服务">本地基本的目录查询服务</h3>
<p>在这种配置模式下，你的slapd只为你的本地域提供目录服务。它不会以任何方式与别的目录服务器交互。这种配置模式如图1所示。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567525992658.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>本地配置模式</center>
<h3 id="带有指针referrals的本地目录服务">带有指针（Referrals）的本地目录服务。</h3>
<p>即目录查询代理服务，类似DNS的转发服务器。</p>
<p>在这种配置模式下，你为你的本地域运行一个LDAP服务器，并且将它配置成为当客户的请求超出你的本地域的处理能力的时候能够返回一个指针，该指针指向一个具备处理客户请求能力的更高级的服务器的地址。你可以自己运行这一服务，也可以使用别人已提供给你的一个。这种配置模式如图2所示。：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567525992983.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>如果你想运行本地目录服务并且参与全属的目录，那么运行这种模式。例如：openldap作为微软活动目录的代理查询服务。</p>
<pre><code>referral &lt;URI&gt;
</code></pre>
<p>该指令指定了一个指针，当服务器的slapd找不到一个本地的数据库来处理一个请求的时候，它把该指针回传给客户。</p>
<p>示例：</p>
<pre><code>referral ldap://root.openldap.org
</code></pre>
<p>这将把非本地的请求“推”到OpenLDAP的根服务器上。“聪明的” LDAP客户会向反馈回来的指针所指的服务器重新发出请求。但是得注意大多数客户仅仅知道怎么样处理简单的LDAP的URL，其中包含主机部分和可选的DN部分。</p>
<h3 id="同多复制的目录服务">同多复制的目录服务。</h3>
<p>slarpd守护程序是用来将主slapd上的改变传播到一个或多个从属的slapd上。一个master-slave 类型的配置示例如图3所示。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/9100" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>这种配置模式可以和前面的两种配置模式之一合起来使用，在前面的两种情况中，单独的slapd不能提供足够的可用性和可靠性。</p>
<h3 id="简单易用的同步复制目录方案">简单易用的同步复制目录方案。</h3>
<p>利用inotify+ldap客户端命令方案，或者通过定时任务加上ldap客户端命令方案！举MYSQL同步的例子说明！</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567525992939.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="分布式的目录服务">分布式的目录服务。</h3>
<p>在这种配置模式下，本地的服务被分制成为多个更小的服务，每一个都可能被复制，并且通过上级（superior）或者下级（subordinate）指针（referral）粘合起来。在实际工作中，使用主从同步集群比较多一些，跨机房就是通过openvpn同步。</p>
<p>ldap企业架构逻辑图案例：ldap+haproxy/nginx/hearbeat集群高可用，验证的时候不跨机房。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567525993061.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="ldap服务的应用领域">LDAP服务的应用领域</h2>
<p>LDAP目录服务，适合那些需要从不同的地点读取信息，但是不需要经常更新的业务信息最为有用。</p>
<p>LDAP的应用主要涉及以下几种类型。I</p>
<ul>
<li>信息安全类：数字证书管理、授权管理、单点登录。</li>
<li>科学计算类：DCE（Distributed Computing Environment，分布式计算环境）、UDDI（Universal Description，Discovery and Integration，统一描述、发现和集成协议）。</li>
<li>网络资源管理类：MAIL系统、DNS系统、网络用户管理、电话号码簿。</li>
<li>电子政务资源管理类：内网组织信息服务、电子政务目录体系、人口基础库、法人基础库。</li>
</ul>
<p>在工作中，常用ldap作为<strong>公司入职后的所有员工账号等的基础信息库</strong>，例如：邮件账号，电脑登陆账号、办公平台账号、共享服务账号、SVN账号、VPN账号、服务器的账号，无线网登陆账号等的公共账号登陆信息库。可以理解为企业的活动目录一样，另外，LDAP也可以和微软活动目录打通。</p>
<p>画一个内网AD域，和机房的LDAP服务打通的架构图！</p>
<h2 id="ldap服务的常见开源产品">LDAP服务的常见开源产品</h2>
<p>Openldap是LDAP最好的开源实现，在其Openldap许可证下发行，并且已经被包含在众多流行的linux发行版中</p>
<p>官方网站为 <a href="http://www.openldap.org" target="_blank"
   rel="noopener nofollow noreferrer" >openldap.org</a></p>
<p>官方man手册 <a href="http://www.openldap.org/software/man.cgi" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.openldap.org/software/man.cgi</a></p>
<h2 id="openldap-ui">openldap UI</h2>
<p>ldap的客户端管理接口有很多，有b/s结构的web的，也有c/s结构的，我们以b/s结构的 <code>ldap-account-manager-3.7.tar.gz</code> 软件为例进行讲解</p>
<ul>
<li>B/S 架构的 <a href="https://www.ldap-account-manager.org/lamcms/" target="_blank"
   rel="noopener nofollow noreferrer" >LDAP Account Manager</a></li>
<li>C/S 架构的 <a href="http://www.ldapadmin.org/index.html" target="_blank"
   rel="noopener nofollow noreferrer" >LDAP Admin</a></li>
</ul>
<h3 id="ldap-account-manager">LDAP Account Manager</h3>
<p>LAM是php服务需要安装lamp环境</p>
<pre><code class="language-bash">yum install -y\
	nginx \
	php \
	php-ldap \
	php-gd \
	php-fpm

rpm -qa \
	nginx \
	php \
	php-ldap \
	php-gd \
	php-fpm
</code></pre>
<h3 id="下载解压配置ldap客户端软件">下载解压配置ldap客户端软件</h3>
<p>下载地址：https://www.ldap-account-manager.org/lamcms/releases</p>
<pre><code>cp config.cfg_sample config.cfg
cp lam.conf_sample lam.conf

sed -i 's@cn=Manager@cn=admin@g' lam.conf
sed -i 's@dc=my-domain@dc=cylon@g' lam.conf
sed -i 's@dc=com@dc=org@g' lam.conf

diff lam.conf_sample lam.conf
</code></pre>
<hr>
<blockquote>
<p><strong>提示</strong>： 此处改的地方很多</p>
</blockquote>
<hr>
<h3 id="配置nginx">配置nginx</h3>
<pre><code>chown nginx.nginx /var/www/html/ldap -R 
</code></pre>
<pre><code>worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   /var/www/html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
		
		location ~ \.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
		}
    }
}
</code></pre>
<h3 id="lam使用">LAM使用</h3>
<p><strong>步骤1</strong>：打开浏览器或者在前面的访问基础上刷新：http:/10.0.0.20/ldap，正常会出现界面如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251834.png" alt="image" style="zoom: 80%;" />
<p><strong>步骤2</strong>：点击右上角的“LAMconfiguration”链接进行配置。</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221023180610798.png" alt="image-20221023180610798" style="zoom:67%;" />
<p><strong>步骤3</strong>：点击上图中的 “Edit general settings” 链接进行配置</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251647.png" alt="image" style="zoom:67%;" />
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251610.png" alt="image"  />
<p>由于系统的密码为字母 “lam”，太简单了，我们先把密码改掉，其他的配置，我们根据需求以后可以再改，注意：这里是系统设置的权限密码，非页面上登录的密码。</p>
<p><strong>步骤5</strong>：上文点OK后就会到重新登录的界面进行登录，如下图：</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251845.png" alt="image" style="zoom:80%;" />
<hr>
<blockquote>
<p><strong>提示</strong>：</p>
<p>请牢记，这是 ==ldap管理员用户admin及密码==，非前面设置的系统内部配置密码，ldap 管理员用户admin及密码是在配置openldap中生成的</p>
</blockquote>
<hr>
<p><strong>步骤6</strong>：初始化ldap数据库的域。</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251713.png" alt="image" style="zoom:80%;" />
<p><strong>步骤7</strong>：命令查看下刚才的操作帮我们建立了什么？。</p>
<pre><code>$ ldapsearch -LLL -w 123 -x -H ldap://10.0.0.20 -D &quot;cn=admin,dc=cylon,dc=org&quot; -b &quot;dc=cylon,dc=org&quot; &quot;(uid=chau)&quot; 
dn: uid=chau,ou=People,dc=cylon,dc=org
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/chau
loginShell: /bin/bash
cn: cylon chau
uidNumber: 10006
gidNumber: 10000
userPassword:: e1NTSEF9c0YzZzBSbnFBU1NoWEVBWEFSS1lPdG41WjZRR1pxNCs=
sn: chau
givenName: cylon
uid: chau
</code></pre>
<p><strong>步骤8</strong>：继续添加ldap账号和组。</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251790.png" alt="image" style="zoom:80%;" />
<pre><code>dn: cn=tech,ou=group,dc=cylon,dc=org
objectClass: posixGroup
description:: 5oqA5pyv6Y0o
gidNumber: 10001
cn: tech
</code></pre>
<p>添加用户</p>
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527251960.png" alt="image" style="zoom:80%;" />
<img src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/clipboard-1567527252022.png" alt="image" style="zoom:80%;" />
<pre><code>$ ldapsearch -LLL -w 123 -x -H ldap://10.0.0.20 -D &quot;cn=admin,dc=cylon,dc=org&quot; -b &quot;dc=cylon,dc=org&quot; &quot;(uid=cylon)&quot;
dn: uid=cylon,ou=People,dc=cylon,dc=org
objectClass: posixAccount
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
homeDirectory: /home/chau
loginShell: /bin/bash
cn: cylon chau
uidNumber: 10006
userPassword:: e1NTSEF9c0YzZzBSbnFBU1NoWEVBWEFSS1lPdG41WjZRR1pxNCs=
sn: chau
givenName: cylon
uid: cylon
gidNumber: 10001
</code></pre>
<p>通过web接口管理ldap的配置完成！也已经初始化了用户组及用户</p>
<h3 id="phpldapadmin">phpldapadmin</h3>
<pre><code class="language-sh">yum install -y \
    php \
    php-fpm \
    php-ldap \
    php-gd \
    php-mbstring \
    php-pear \
    php-bcmath \
    php-xml \
    phpldapadmin \
    nginx
</code></pre>
<pre><code class="language-nginx">worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;
        root   /usr/share/phpldapadmin/htdocs;
        location / {
            index  index.html index.htm index.php;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        location ~ \.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        }
    }
}
</code></pre>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
