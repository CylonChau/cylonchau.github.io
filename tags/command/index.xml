<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>command on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/command/</link>
    <description>Recent content in command on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 12 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/command/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>长期总结 - Linux性能分析命令</title>
      <link>https://www.oomkill.com/2022/12/performance-command/</link>
      <pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/12/performance-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="perf-supa-href11asup">perf <sup><a href="#1">[1]</a></sup></h2>
<p><em><strong>perf</strong></em> 是基于内核子系统的Linux的性能计数器，也被称为 <em><strong>perf_events</strong></em>，它提供了为所有事件进行性能分析的框架，<em><strong>perf</strong></em> 由两部分组成：</p>
<ul>
<li>内核系统调用，用于提供对这些性能数据的访问</li>
<li>用户空间工具，用于提供收集，显示分析这些性能数据的用户空间程序</li>
</ul>
<p>由于 perf 是内核的一部分，但要想使用 perf 还需要安装另外一部分，通常情况下安装的版本是Linux内核版本，如操作系统内核版本为 5.10 那么安装 linux-tool 后则为 5.10</p>
<pre><code class="language-bash">$ apt-get install linux-perf

$ perf --version
perf version 5.10.149
</code></pre>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>linux-perf | linux-tools</code>  ；<code>apt-get install linux-perf</code></li>
<li>CentOS/Fedora:  <code>perf </code> ；<code>yum install -y perf</code></li>
</ul>
<h3 id="list---列出可用事件描述符">list - 列出可用事件描述符</h3>
<p>使用 perf 子命令 <code>list</code>  可以列出所有的 perf 可测量事件</p>
<pre><code class="language-bash">perf list

List of pre-defined events (to be used in -e):

  branch-instructions OR branches                    [Hardware event]
  branch-misses                                      [Hardware event]
  cache-misses                                       [Hardware event]
  cache-references                                   [Hardware event]
  cpu-cycles OR cycles                               [Hardware event]
  instructions                                       [Hardware event]
  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]
  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]

  alignment-faults                                   [Software event]
  bpf-output                                         [Software event]
  context-switches OR cs                             [Software event]
  cpu-clock                                          [Software event]
  cpu-migrations OR migrations                       [Software event]
  dummy                                              [Software event]
  emulation-faults                                   [Software event]
  major-faults                                       [Software event]
  minor-faults                                       [Software event]
  page-faults OR faults                              [Software event]
  task-clock                                         [Software event]

  duration_time                                      [Tool event]

  L1-dcache-load-misses                              [Hardware cache event]
  L1-dcache-loads                                    [Hardware cache event]
  L1-dcache-prefetches                               [Hardware cache event]
  L1-icache-load-misses                              [Hardware cache event]
  L1-icache-loads                                    [Hardware cache event]
  branch-load-misses                                 [Hardware cache event]
  branch-loads                                       [Hardware cache event]
  dTLB-load-misses                                   [Hardware cache event]
  dTLB-loads                                         [Hardware cache event]
  iTLB-load-misses                                   [Hardware cache event]
  iTLB-loads                                         [Hardware cache event]
</code></pre>
<p>list 子命令后还可以加过滤器以查看对应类型的事件，示例：</p>
<pre><code class="language-bash"># 列出TCP相关事件
$ perf list tcp

List of pre-defined events (to be used in -e):


  syscalls:sys_enter_getcpu                          [Tracepoint event]
  syscalls:sys_exit_getcpu                           [Tracepoint event]
  tcp:tcp_destroy_sock                               [Tracepoint event]
  tcp:tcp_probe                                      [Tracepoint event]
  tcp:tcp_rcv_space_adjust                           [Tracepoint event]
  tcp:tcp_receive_reset                              [Tracepoint event]
  tcp:tcp_retransmit_skb                             [Tracepoint event]
  tcp:tcp_retransmit_synack                          [Tracepoint event]
  tcp:tcp_send_reset                                 [Tracepoint event]

# 列出bpf相关事件
$ perf list bpf

List of pre-defined events (to be used in -e):

  bpf-output                                         [Software event]


  bpf_test_run:bpf_test_finish                       [Tracepoint event]
  bpf_trace:bpf_trace_printk                         [Tracepoint event]
  syscalls:sys_enter_bpf                             [Tracepoint event]
  syscalls:sys_exit_bpf                              [Tracepoint event]

# 列出硬件相关事件
$ perf list hardware

List of pre-defined events (to be used in -e):

  branch-instructions OR branches                    [Hardware event]
  branch-misses                                      [Hardware event]
  cache-misses                                       [Hardware event]
  cache-references                                   [Hardware event]
  cpu-cycles OR cycles                               [Hardware event]
  instructions                                       [Hardware event]
  stalled-cycles-backend OR idle-cycles-backend      [Hardware event]
  stalled-cycles-frontend OR idle-cycles-frontend    [Hardware event]
</code></pre>
<h3 id="top---查看系统实时信息">top - 查看系统实时信息</h3>
<p>perf 的 top子命令可以查看CPU的实时信息</p>
<pre><code class="language-bash">$ perf top
  23.69%  [kernel]          [k] mpt_put_msg_frame
  14.27%  [kernel]          [k] read_tsc
  13.34%  [kernel]          [k] asm_sysvec_apic_timer_interrupt
  11.72%  [kernel]          [k] vmware_sched_clock
   5.79%  perf_5.10         [.] 0x00000000002901f4
   5.11%  [kernel]          [k] delay_tsc
   4.87%  [kernel]          [k] native_read_msr
   4.57%  perf_5.10         [.] 0x0000000000284c2d
   3.13%  perf_5.10         [.] 0x0000000000284c1a
   3.09%  [kernel]          [k] native_write_msr
   2.07%  [kernel]          [k] s_show
   1.99%  [kernel]          [k] mpt_interrupt
   1.82%  perf_5.10         [.] 0x0000000000284d46
   1.69%  [kernel]          [k] asm_sysvec_call_function_single
   0.86%  [kernel]          [k] __es_tree_search.isra.0
   0.83%  [kernel]          [k] security_task_free
   0.78%  [vdso]            [.] 0x0000000000000698
   0.38%  perf_5.10         [.] 0x0000000000284d57
</code></pre>
<p>上面的信息的展示类似于 <code>top</code> 命令，从左右到信息为：</p>
<ul>
<li>第一列：与CPU使用率百分比占用的相关函数</li>
<li>第二列：那个库或者进程使用的这个函数</li>
<li>第三列：<strong>[k]</strong> 表示内核空间， <strong>[.]</strong> 表示用户空间</li>
<li>第四列：符号或函数的名称</li>
</ul>
<p>默认情况下 <code>perf top</code> 监控的是所有CPU，也可以使用子选项，例如下表（一些常用的命令参数）</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>监控所有CPU包含空闲值</td>
</tr>
<tr>
<td>-c</td>
<td>收集</td>
</tr>
<tr>
<td>-C</td>
<td>收集指定CPU的样本，后接CPU核心编号</td>
</tr>
<tr>
<td>-d</td>
<td>后接数字，将延迟几秒刷新</td>
</tr>
<tr>
<td>-e</td>
<td>指定特殊的事件，事件通过 <code>perf list</code> 查看</td>
</tr>
<tr>
<td>-F</td>
<td>控制采样的频率</td>
</tr>
<tr>
<td>-p</td>
<td>指定PID的进程的事件信息</td>
</tr>
<tr>
<td>-g</td>
<td>启用 显示调用图记录</td>
</tr>
<tr>
<td>-i</td>
<td>不继承模式，子任务将不继承计数器</td>
</tr>
<tr>
<td>-t</td>
<td>指定线程ID的事件信息</td>
</tr>
<tr>
<td>-u</td>
<td>指定user的事件信息</td>
</tr>
</tbody>
</table>
<p>更多选项可以使用 <code>perf top -h</code></p>
<h3 id="stat---cpu相关统计">stat - CPU相关统计</h3>
<p>使用 perf 子命令 <code>stat</code>  可以对指定命令的CPU性能统计</p>
<pre><code class="language-bash">perf stat &lt;commond&gt;
</code></pre>
<p><strong>查看指定命令的CPU计数器统计信息</strong></p>
<pre><code class="language-bash">perf stat &lt;command&gt;
# 如果需要更详细信息可以跟 -d 选项
perf stat -d &lt;command&gt;
</code></pre>
<p>示例</p>
<pre><code class="language-bash">$ perf stat curl baidu.com

 Performance counter stats for 'curl baidu.com':

             31.09 msec task-clock                #    0.012 CPUs utilized          
                27      context-switches          #    0.868 K/sec                  
                 1      cpu-migrations            #    0.032 K/sec                  
               577      page-faults               #    0.019 M/sec                  
        41,691,320      cycles                    #    1.341 GHz                      (17.63%)
                 0      stalled-cycles-frontend                                     
                 0      stalled-cycles-backend    #    0.00% backend cycles idle    
                 0      instructions              #    0.00  insn per cycle           (82.37%)
     &lt;not counted&gt;      branches                                                      (0.00%)
     &lt;not counted&gt;      branch-misses                                                 (0.00%)

       2.646439514 seconds time elapsed

       0.026403000 seconds user
       0.013201000 seconds sys


Some events weren't counted. Try disabling the NMI watchdog:
	echo 0 &gt; /proc/sys/kernel/nmi_watchdog
	perf stat ...
	echo 1 &gt; /proc/sys/kernel/nmi_watchdog
</code></pre>
<p><strong>查看指定PID的CPU计数器统计信息</strong></p>
<p>统计命令将会直到 ctrl - c 结束</p>
<pre><code class="language-bash">perf stat -p &lt;PID&gt; 
</code></pre>
<p>示例：例如统计一个进程的CPU使用情况</p>
<pre><code class="language-bash">perf stat -p 477
^C
 Performance counter stats for process id '477':

            146.96 msec task-clock                #    0.034 CPUs utilized          
                88      context-switches          #    0.599 K/sec                  
                 8      cpu-migrations            #    0.054 K/sec                  
             4,991      page-faults               #    0.034 M/sec                  
       153,052,247      cycles                    #    1.041 GHz                      (36.77%)
                 0      stalled-cycles-frontend                                       (50.31%)
                 0      stalled-cycles-backend    #    0.00% backend cycles idle      (57.94%)
                 0      instructions              #    0.00  insn per cycle           (63.23%)
                 0      branches                  #    0.000 K/sec                    (49.69%)
                 0      branch-misses             #    0.00% of all branches          (42.06%)

       4.336415211 seconds time elapsed
</code></pre>
<p><strong>只统计缓存信息</strong></p>
<pre><code class="language-bash">perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches
</code></pre>
<ul>
<li>LLC <em><strong>last-level cache</strong></em> 是指内存分层结构中主内存之前的最后一级</li>
<li>LLC-loads：命中的指标</li>
<li>LLC-load-misses：未命中指标，显示这个周期内尚未处理的比率</li>
<li>LLC-stores</li>
<li>LLC-prefetches：事件发生在的 L2 硬件预取中</li>
</ul>
<p>示例：</p>
<pre><code class="language-bash"># 使用原始 PMC 计数器，例如，计算未暂停的核心周期： 

# 使用原始PMC计数器，例如，计数未改变的核心周期:
perf stat -e r003c -a sleep 5 

# 统计系统范围内每秒的系统调用： 
perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5 

# 统计系统范围内每秒的系统调用：
perf stat -e raw_syscalls:sys_enter -I 1000 -a 

# 按类型计算指定PID的系统调用，直到Ctrl-C结束
perf stat -e 'syscalls:sys_enter_*' -p &lt;PID&gt; 

# 按类型统计整个系统范围内的系统调用，持续 5 秒： 
perf stat -e 'syscalls:sys_enter_*' -a sleep 5 

# 按类型计数整个系统的系统调用，持续5秒:
perf stat -e 'syscalls:sys_enter_*' -a sleep 5

# 记录指定PID进程的调度器事件直到Ctrl-C结束
perf stat -e 'sched:*' -p PID

# 记录指定PID进程的调度器事件，持续10s
perf stat -e 'sched:*' -p PID sleep 10

# 记录整个系统内的ext4事件，持续10s
perf stat -e 'ext4:*' -a sleep 10

# 统计整个系统的块设备 I/O 事件，持续10s
perf stat -e 'block:*' -a sleep 10

# 统计所有 vmscan 事件，每秒打印一份报告：
perf stat -e 'vmscan:*' -a -I 1000
</code></pre>
<h3 id="record---将cpu事件记录到文件">record - 将CPU事件记录到文件</h3>
<p><strong>导出事件记录到文件</strong></p>
<p>perf的子命令 <code>record</code> 是可以将事件记录到 perf.data，例如要CPU周期事件，可以使用record子命令并通过 tag <code>-e</code> 来指定事件名称</p>
<pre><code class="language-bash"># 通过perf list 可以看出 CPU周期事件为 cpu-cycles OR cycles
perf record -e cycles sleep 10
</code></pre>
<p><strong>通过查看文件的记录</strong></p>
<p>结果将保存到 perf.data 文件中，如果需要查看 perf.data 需要使用子命令 <code>report</code> 查看，report 子命令默认查找当前目录下的 perf.data 文件，如果需要指定特定目录的需要使用tag <code>-i</code></p>
<pre><code class="language-bash">perf report -i ./perf.data
</code></pre>
<p><strong>修改样本文件输出的结果格式</strong></p>
<p>report 子命令也可以改变要显示的结果样式，例如想输出为标准输出，可以使用 <code>--stdio</code></p>
<pre><code class="language-bash">$ perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 18  of event 'cycles'
# Event count (approx.): 440
#
# Overhead  Command  Shared Object      Symbol              
# ........  .......  .................  ....................
#
    90.91%  sleep    [kernel.kallsyms]  [k] native_write_msr
     9.09%  perf_5.  [kernel.kallsyms]  [k] native_write_msr


#
# (Tip: Order by the overhead of source file name and line number: perf report -s srcline)
#
</code></pre>
<p>如果想显示事件的编号以及对特定列排序可以使用下面域名</p>
<pre><code class="language-bash">$ perf report -n --sort comm,symbol --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 18  of event 'cycles'
# Event count (approx.): 440
#
# Overhead       Samples  Command  Symbol                IPC   [IPC Coverage]
# ........  ............  .......  ....................  ....................
#
    90.91%             9  sleep    [k] native_write_msr  -      -            
     9.09%             9  perf_5.  [k] native_write_msr  -      -            


#
# (Tip: Show current config key-value pairs: perf config --list)
#
</code></pre>
<h3 id="script---trace做了什么">script - trace做了什么</h3>
<p>perf 子命令 script 可以trace perf.data 中所有的事件；例如上面的 perf.data 最终两个事件展开为</p>
<p>perf script 子命令也是作为一个后期处理数据的一个命令</p>
<pre><code class="language-bash">$ perf script 
       perf_5.10  2730 28762.537401:          1 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.537540:          1 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.537670:          1 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.537798:          2 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.537901:          3 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.538003:          4 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.538105:          6 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.538207:          9 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
       perf_5.10  2730 28762.538320:         13 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.542839:         26 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543041:         26 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543233:         26 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543421:         30 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543558:         35 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543683:         41 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543806:         53 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.543929:         70 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
           sleep  2730 28772.544065:         93 cycles:  ffffffffbd46b466 native_write_msr+0x6 ([kernel.kallsyms])
</code></pre>
<p>输出显示文件的头信息，例如跟踪何时开始、持续了多长时间、CPU信息以及获取数据的命令。 事件列表在头信息之后。</p>
<p><strong>显示trace的头信息</strong></p>
<p>使用tag <code>--header</code> 可以显示文件的头信息，例如跟何时开始trace、持续的事件、CPU信息以及获取数据的命令。 事件列表在头信息之后。事件头信息是由 <code># ========</code> 包含著的信息</p>
<pre><code class="language-bash"># ========
# captured on    : Tue Dec  6 04:44:38 2022
# header version : 1
# data offset    : 256
# data size      : 11528
# feat offset    : 11784
# hostname : debian-template
# os release : 5.10.0-16-amd64
# perf version : 5.10.149
# arch : x86_64
# nrcpus online : 2
# nrcpus avail : 2
# cpudesc : AMD Ryzen 7 5800U with Radeon Graphics
# cpuid : AuthenticAMD,25,80,0
# total memory : 1996352 kB
# cmdline : /usr/bin/perf_5.10 record -e cycles sleep 10 
# event : name = cycles, , id = { 471, 472 }, size = 120, { sample_period, sample_freq } = 2250, sample_type = IP|TID|TIME|PERIOD, read_forma&gt;
# CPU_TOPOLOGY info available, use -I to display
# NUMA_TOPOLOGY info available, use -I to display
# pmu mappings: software = 1, power = 9, uprobe = 7, cpu = 4, breakpoint = 5, tracepoint = 2, kprobe = 6, msr = 8
# CACHE info available, use -I to display
# time of first sample : 28762.537401
# time of last sample : 28772.544065
# sample duration :  10006.663 ms
# MEM_TOPOLOGY info available, use -I to display
# bpf_prog_info 3: bpf_prog_47dd357395126b0c addr 0xffffffffc00eb59c size 309
# bpf_prog_info 4: bpf_prog_6deef7357e7b4530 addr 0xffffffffc00f2168 size 54
# bpf_prog_info 5: bpf_prog_6deef7357e7b4530 addr 0xffffffffc00f40e0 size 54
# bpf_prog_info 6: bpf_prog_b73cbcf8b8c71a5b addr 0xffffffffc02591c8 size 307
# bpf_prog_info 7: bpf_prog_6deef7357e7b4530 addr 0xffffffffc025b584 size 54
# bpf_prog_info 8: bpf_prog_6deef7357e7b4530 addr 0xffffffffc025db10 size 54
# bpf_prog_info 9: bpf_prog_ee0e253c78993a24 addr 0xffffffffc0534640 size 255
# bpf_prog_info 10: bpf_prog_ce28cc67158d681f addr 0xffffffffc04947f0 size 447
# bpf_prog_info 11: bpf_prog_6deef7357e7b4530 addr 0xffffffffc052fe4c size 54
# bpf_prog_info 12: bpf_prog_6deef7357e7b4530 addr 0xffffffffc0531224 size 54
# cpu pmu capabilities: max_precise=0
# missing features: TRACING_DATA BRANCH_STACK GROUP_DESC AUXTRACE STAT CLOCKID DIR_FORMAT COMPRESSED CLOCK_DATA 
# ========
</code></pre>
<p><strong>导出16进制的原生数据</strong></p>
<p>导出原生数据是ASIIC格式事件信息</p>
<pre><code class="language-bash">$ perf script -D
0x100 [0x50]: event: 1
.
. ... raw event: size 80 bytes
.  0000:  01 00 00 00 01 00 50 00 ff ff ff ff 00 00 00 00  ......P.........
.  0010:  00 00 40 bd ff ff ff ff f7 1d c0 00 00 00 00 00  ..@.............
.  0020:  00 00 40 bd ff ff ff ff 5b 6b 65 72 6e 65 6c 2e  ..@.....[kernel.
.  0030:  6b 61 6c 6c 73 79 6d 73 5d 5f 74 65 78 74 00 00  kallsyms]_text..
.  0040:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................

0 0x100 [0x50]: PERF_RECORD_MMAP -1/0: [0xffffffffbd400000(0xc01df7) @ 0xffffffffbd400000]: x [kernel.kallsyms]_text

0x150 [0x78]: event: 1
.
. ... raw event: size 120 bytes
.  0000:  01 00 00 00 01 00 78 00 ff ff ff ff 00 00 00 00  ......x.........
.  0010:  00 10 0a c0 ff ff ff ff 00 00 04 00 00 00 00 00  ................
.  0020:  00 00 00 00 00 00 00 00 2f 6c 69 62 2f 6d 6f 64  ......../lib/mod
.  0030:  75 6c 65 73 2f 35 2e 31 30 2e 30 2d 31 36 2d 61  ules/5.10.0-16-a
.  0040:  6d 64 36 34 2f 6b 65 72 6e 65 6c 2f 64 72 69 76  md64/kernel/driv
.  0050:  65 72 73 2f 73 63 73 69 2f 73 63 73 69 5f 6d 6f  ers/scsi/scsi_mo
.  0060:  64 2e 6b 6f 00 00 00 00 00 00 00 00 00 00 00 00  d.ko............
.  0070:  00 00 00 00 00 00 00 00
</code></pre>
<h3 id="trace---更高性能的strace的替代品">trace - 更高性能的strace的替代品</h3>
<p>trace是linux 3.7 增加的功能，可以用作strace命令的替代品，因为不需要用户-内核空间切换，所以性能将更快</p>
<pre><code class="language-bash"> perf trace &lt;command&gt;
</code></pre>
<p>也可以使用tag <code>-e</code> 来指定仅对指定事件trace</p>
<pre><code class="language-bash">perf trace -e read,write &lt;command&gt;
</code></pre>
<p>可以看到对应事件将只有 read 与 write</p>
<pre><code class="language-bash">$ perf trace -e read,write ls
     0.000 (1					 nginx-1.22.0		       nginx_1.22.0.orig.tar.gz		 perf.data
1.c					 nginx_1.22.0-1.debian.tar.xz  nginx-1.22.0.tar.gz		 perf.data.old
deb-multimedia-keyring_2016.8.1_all.deb  nginx_1.22.0-1.dsc	       paping_1.5.5_x86-64_linux.tar.gz
 0.058 ms): ls/3126 read(fd: 3, buf: 0x7ffcd2548068, count: 832)                          = 832
     0.132 ( 0.034 ms): ls/3126 read(fd: 3, buf: 0x7ffcd2548048, count: 832)                          = 832
     0.232 ( 0.033 ms): ls/3126 read(fd: 3, buf: 0x7ffcd2548028, count: 832)                          = 832
     0.324 ( 0.032 ms): ls/3126 read(fd: 3, buf: 0x7ffcd2548008, count: 832)                          = 832
     0.416 ( 0.032 ms): ls/3126 read(fd: 3, buf: 0x7ffcd2547fc8, count: 832)                          = 832
     0.828 ( 0.048 ms): ls/3126 read(fd: 3, buf: 0x55c4bb555500, count: 1024)                         = 361
     0.907 ( 0.028 ms): ls/3126 read(fd: 3, buf: 0x55c4bb555500, count: 1024)                         = 0
     1.127 ( 0.060 ms): ls/3126 write(fd: 1, buf: 0x55c4bb555500, count: 65)                          = 65
     1.219 ( 0.385 ms): ls/3126 write(fd: 1, buf: 0x55c4bb555500, count: 75)                          = 75
     1.638 ( 0.049 ms): ls/3126 write(fd: 1, buf: 0x55c4bb555500, count: 100)                         = 100
</code></pre>
<h3 id="probe---动态追踪">probe - 动态追踪</h3>
<p>perf probe子命令是可以动态的在linux内核中自定义追踪事件（追踪点），追踪点的运行时可以在被放置任何任何地方，并且每次通过该追踪点时，都可以记录其值。</p>
<p><strong>如何使用 perf probe</strong>？</p>
<p><strong>查看可探测的函数</strong></p>
<p><code>perf probe -F</code> 可以找到可用的追踪点，如果模糊查找可以使用filter</p>
<pre><code class="language-bash">perf probe -F -–filter dev*xmit*
</code></pre>
<p><strong>probe参数</strong></p>
<table>
<thead>
<tr>
<th>Option</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>-L</td>
<td>显示源代码</td>
</tr>
<tr>
<td>-x</td>
<td>可执行文件的名称或路径</td>
</tr>
<tr>
<td>-l</td>
<td>列出所有probe探测事件</td>
</tr>
<tr>
<td>-k</td>
<td>指定vmlinux文件</td>
</tr>
<tr>
<td>-a</td>
<td>**`&lt;[EVENT=]FUNC[@SRC][+OFF</td>
</tr>
<tr>
<td></td>
<td>EVENT 事件名称</td>
</tr>
<tr>
<td></td>
<td>FUNC  函数名</td>
</tr>
<tr>
<td></td>
<td>+OFF  函数入口的偏移量</td>
</tr>
<tr>
<td></td>
<td>%return 探针位置为函数返回处</td>
</tr>
<tr>
<td></td>
<td>SRC  源代码路径</td>
</tr>
<tr>
<td></td>
<td>RL  相对函数入口处的行号</td>
</tr>
<tr>
<td></td>
<td>AL  在文件内的绝对行号</td>
</tr>
<tr>
<td></td>
<td>ARG:    探测参数（局部变量名 或 <code>kprobe-tracer</code> 参数格式。</td>
</tr>
</tbody>
</table>
<pre><code>perf probe -x tst --add 'out=func%return $retval'
perf record -g -e probe_tst:out -aR ./tst
</code></pre>
<p><strong>一些使用示例</strong></p>
<pre><code class="language-bash"># 添加一个追踪点到linux内核函数tcp_sendmsg()至入口
perf probe --add tcp_sendmsg

# 删除linux内核tcp_sendmsg()函数上的追踪点
perf probe -d tcp_sendmsg

# 列出现有的追踪点
perf probe -l

# 添加一个追踪点到linux内核函数tcp_sendmsg()返回部分
perf probe 'tcp_sendmsg%return'
</code></pre>
<h4 id="通过probe检测内核函数">通过probe检测内核函数</h4>
<p><strong>probe使用示例说明</strong></p>
<ul>
<li>内核函数：<strong>tcp_sendmsg()</strong></li>
</ul>
<p>在内核函数上 tcp_sendmsg 添加一个事件</p>
<pre><code class="language-bash">perf probe --add tcp_sendmsg
</code></pre>
<p>此时会存在一个追踪点，通过 <code>perf probe -l</code> 可以查看</p>
<p>trace此追踪点5s，记录堆栈信息</p>
<pre><code class="language-bash">perf record -e probe:tcp_sendmsg -a -g -- sleep 5 
</code></pre>
<p>通过 report 子命令可以查看对应信息</p>
<pre><code class="language-bash">$ perf report --stdio  -i perf.data
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 13  of event 'probe:tcp_sendmsg'
# Event count (approx.): 13
#
# Children      Self  Command  Shared Object     Symbol                            
# ........  ........  .......  ................  ..................................
#
   100.00%   100.00%  sshd     [kernel.vmlinux]  [k] tcp_sendmsg
            |          
            |--92.31%--0
            |          getnetbyaddr_r@@GLIBC_2.2.5
            |          entry_SYSCALL_64_after_hwframe
            |          do_syscall_64
            |          ksys_write
            |          vfs_write
            |          new_sync_write
            |          sock_write_iter
            |          sock_sendmsg
            |          tcp_sendmsg
            |          
             --7.69%--0x1b81475c085
                       getnetbyaddr_r@@GLIBC_2.2.5
                       entry_SYSCALL_64_after_hwframe
                       do_syscall_64
                       ksys_write
                       vfs_write
                       new_sync_write
                       sock_write_iter
                       sock_sendmsg
                       tcp_sendmsg

   100.00%     0.00%  sshd     libc-2.31.so      [.] getnetbyaddr_r@@GLIBC_2.2.5
            |
            ---getnetbyaddr_r@@GLIBC_2.2.5
               entry_SYSCALL_64_after_hwframe

</code></pre>
<p>删除对应跟踪点</p>
<pre><code class="language-bash">perf probe -d &lt;probe_name&gt;
</code></pre>
<p><strong>也可以通过内核函数的变量进行检查</strong></p>
<p>查看内核函数参数，可以看到存在三个参数 <code>size</code> int类型, <code>msg</code> 结构体指针，<code>sk</code> 结构体指针</p>
<pre><code class="language-bash">$ perf probe -V tcp_sendmsg 
Available variables at tcp_sendmsg
        @&lt;tcp_sendmsg+0&gt;
                size_t  size
                struct msghdr*  msg
                struct sock*    sk
</code></pre>
<p>使用 <code>size</code> 变量作为 <code>tcp_sendmsg</code> 探测点的探测器</p>
<pre><code class="language-bash">perf probe --add 'tcp_sendmsg size'
</code></pre>
<h4 id="通过probe检测用户空间程序-supa-href22asup">通过probe检测用户空间程序 <sup><a href="#2">[2]</a></sup></h4>
<p>准备一段代码，即每次循环，打印该值并打印该值+5</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int func(int xxx)
{
    int zzz = xxx;

    printf(&quot;zzz: %d\n&quot;, zzz);
    return zzz+5;
}
int main(int argc, char* argv[])
{
    int i=0;
    for( i=0; i&lt;10; i++)
        printf(&quot;yyy: %d\n&quot;, func(argc + i));

    return 0;
}
</code></pre>
<p>这里使用环境为 debian11，内核 5.10，需要注意的是，在新内核中版本中传参的命令与老内核有少许差别</p>
<p>运行编译后的程序可以看到结果</p>
<pre><code class="language-bash">$ gcc -g -o tst tst.c &amp;&amp; ./tst
zzz: 1
yyy: 6
zzz: 2
yyy: 7
zzz: 3
yyy: 8
zzz: 4
yyy: 9
zzz: 5
yyy: 10
zzz: 6
yyy: 11
zzz: 7
yyy: 12
zzz: 8
yyy: 13
zzz: 9
yyy: 14
zzz: 10
yyy: 15
</code></pre>
<p>这里编译时使用了 <code>-g</code> 选项，<code>-g</code> 是一个编译选项，即在源代码编译的过程中起作用，让gcc把更多调试信息（也就包括符号信息）收集起来并将存放到最终的可执行文件</p>
<p>接下来为程序创建一个追踪事件，</p>
<pre><code class="language-bash">perf probe -x tst --add 'out=func%return $retval'
# 格式将严格遵循 &lt;[EVENT=]FUNC[@SRC][+OFF|%return|:RL|;PT]|SRC:AL|SRC;PT [[NAME=]ARG ...]&gt;
# out=func%return %retval
# EVENT=FUNC%return ARG
# EVENT 探测事件名
# FUNC  函数名
# %return 在函数return处放置探针
# ARG 参数
</code></pre>
<p>此时可以执行这个程序，让probe可以追踪到数据</p>
<pre><code class="language-bash">$ perf record -g -e probe_tst:out__return -aR ./tst
Lowering default frequency rate to 2750.
Please consider tweaking /proc/sys/kernel/perf_event_max_sample_rate.
zzz: 1
yyy: 6
zzz: 2
yyy: 7
zzz: 3
yyy: 8
zzz: 4
yyy: 9
zzz: 5
yyy: 10
zzz: 6
yyy: 11
zzz: 7
yyy: 12
zzz: 8
yyy: 13
zzz: 9
yyy: 14
zzz: 10
yyy: 15
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.163 MB perf.data (10 samples) ]
</code></pre>
<p>执行的结果保存在 <code>perf.data</code> 中</p>
<pre><code class="language-bash">$ perf report --stdio
# To display the perf.data header info, please use --header/--header-only options.
#
#
# Total Lost Samples: 0
#
# Samples: 10  of event 'probe_tst:out__return'
# Event count (approx.): 10
#
# Children      Self  Command  Shared Object     Symbol                
# ........  ........  .......  ................  ......................
#
   100.00%   100.00%  tst      tst               [.] main
            |
            ---0x5541d68949564100
               cancel_handler
               main

   100.00%     0.00%  tst      [unknown]         [.] 0x5541d68949564100
            |
            ---0x5541d68949564100
               cancel_handler
               main

   100.00%     0.00%  tst      libc-2.31.so      [.] cancel_handler
            |
            ---cancel_handler
               main
</code></pre>
<p>使用 <code>script</code> 子命令查看这个程序的trace记录，可以看到</p>
<pre><code class="language-bash">perf script 
tst  2272 [000] 28276.947273: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0x6
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947282: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0x7
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947288: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0x8
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947294: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0x9
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947300: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xa
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947306: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xb
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947311: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xc
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947317: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xd
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947322: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xe # 14
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])

tst  2272 [000] 28276.947328: probe_tst:out__return: (55dc41f11135 &lt;- 55dc41f11192) arg1=0xf # 15
            55dc41f11192 main+0x2e (/root/tst)
            7f67337bed0a cancel_handler+0x3a (/usr/lib/x86_64-linux-gnu/libc-2.31.so)
        5541d68949564100 [unknown] ([unknown])
</code></pre>
<p>可以通过上面看到，这里制作的探针在用户空间程序 tst.func 函数中，当他返回时，记录了要返回的值作为arg1，也就是每行返回的 <code>0xf</code> 这类16进制值，也可以看到每次命中该探针的部分</p>
<h3 id="troubleshooting">Troubleshooting</h3>
<h4 id="uhhuh-nmi-received-for-unknown-reason">Uhhuh. NMI received for unknown reason</h4>
<pre><code class="language-bash">Message from syslogd@phab1 at Dec 26 19:16:16 ...
kernel:Uhhuh. NMI received for unknown reason 30 on CPU 0.

Message from syslogd@phab1 at Dec 26 19:16:16 ...
kernel:Do you have a strange power saving mode enabled?

Message from syslogd@phab1 at Dec 26 19:16:16 ...
kernel:Dazed and confused, but trying to continue
</code></pre>
<p>上述问题通常发生于虚拟化环境</p>
<p>Solve solution: disable c-state in bios</p>
<h4 id="failed-to-find-the-path-for-kernel-invalid-elf-file">Failed to find the path for kernel: Invalid ELF file</h4>
<pre><code class="language-bash">Failed to find the path for kernel: Invalid ELF file
  Error: Failed to show vars.
</code></pre>
<p>这个错误通常使用 <code>perf probe -V</code> 时出现，这里需要内核支持 <em><strong>debug symbols</strong></em>，即使用公开发行版需要安装对应内核包</p>
<ul>
<li>RHEL/CentOS：安装 <code>kernel-debuginfo-common</code> 与 <code>kernel-debuginfo package</code></li>
<li>Debian/Ubuntu：安装 <code>linux-image-&lt;kernel_version&gt;-amd64-dbg</code> debian下保持需要至少5G空间 <sup><a href="#3">[3]</a></sup></li>
</ul>
<h4 id="failed-to-find-source-file-path">Failed to find source file path</h4>
<pre><code class="language-bash">$ perf probe -L tcp_sendmsg
Failed to find source file path.
  Error: Failed to show lines.
</code></pre>
<p>思路：可以通过 <code>strace</code> 命令看看为什么报错</p>
<p>原因：<code>perf probe -L</code> 将显示对应内核探测点的源代码，此时perf会寻找构建的内核目录，而操作系统发行版供应商对于系统都是通过包管理，包括内核，并未提供这些源码，此状态为正确的，如果非要解决，可以自行编译内核。</p>
<h2 id="dmesg">dmesg</h2>
<p><em><strong>dmesg</strong></em> 是来自内核的一个环形缓冲区，而通过 <em><strong>dmesg</strong></em> 命令可以看到来自该缓冲区的消息，而该消息也被称为 ”<em><strong>driver message</strong></em>“ 或 ”<em><strong>display message</strong></em>“</p>
<h3 id="示例1对dmesg输出着色">示例1：对dmesg输出着色</h3>
<pre><code class="language-bash">$ dmesg -L
</code></pre>
<h3 id="示例2dmesg输出消息增加时间">示例2：dmesg输出消息增加时间</h3>
<pre><code class="language-bash">$ dmesg -T
</code></pre>
<h3 id="示例3过滤相关级别信息">示例3：过滤相关级别信息</h3>
<p>可以通过 <code>--level</code> 来进行过滤出不同级别的日志，可用级别有</p>
<ul>
<li>emerg,</li>
<li>alert,</li>
<li>crit,</li>
<li>err,</li>
<li>warn,</li>
<li>notice,</li>
<li>info</li>
<li>debug</li>
</ul>
<pre><code class="language-bash">$ dmesg --level=err

$ dmesg --level=warn
</code></pre>
<h3 id="示例4过滤相关事件信息">示例4：过滤相关事件信息</h3>
<p>dmesg 可以通过参数指定 <code>--facility</code> 来指定对应事件的日志，可用的设施有：</p>
<ul>
<li>kern</li>
<li>user</li>
<li>mail</li>
<li>daemon</li>
<li>auth</li>
<li>lpr</li>
<li>news</li>
</ul>
<pre><code class="language-bash">$  dmesg --facility=daemon
[    1.793879] systemd[1]: Inserted module 'autofs4'
[    1.807871] systemd[1]: systemd 247.3-7 running in system mode. (+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +ZSTD +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=unified)
[    1.807925] systemd[1]: Detected virtualization vmware.
[    1.807927] systemd[1]: Detected architecture x86-64.
[    1.808612] systemd[1]: Set hostname to &lt;debian-template&gt;.
[    1.881058] systemd[1]: Queued start job for default target Graphical Interface.
[    1.882132] systemd[1]: Created slice system-getty.slice.
[    1.882337] systemd[1]: Created slice system-modprobe.slice.
[    1.882724] systemd[1]: Created slice system-systemd\x2dfsck.slice.
[    1.882869] systemd[1]: Created slice User and Session Slice.
[    1.882902] systemd[1]: Started Dispatch Password Requests to Console Directory Watch.
[    1.882920] systemd[1]: Started Forward Password Requests to Wall Directory Watch.
[    1.883019] systemd[1]: Set up automount Arbitrary Executable File Formats File System Automount Point.
[    1.883036] systemd[1]: Reached target Local Encrypted Volumes.
[    1.883049] systemd[1]: Reached target Paths.
[    1.883054] systemd[1]: Reached target Remote File Systems.
[    1.883058] systemd[1]: Reached target Slices.
[    1.883080] systemd[1]: Reached target Swap.
[    1.883152] systemd[1]: Listening on Syslog Socket.
[    1.883193] systemd[1]: Listening on fsck to fsckd communication Socket.
[    1.883218] systemd[1]: Listening on initctl Compatibility Named Pipe.
[    1.883285] systemd[1]: Listening on Journal Audit Socket.
[    1.883322] systemd[1]: Listening on Journal Socket (/dev/log).
[    1.883364] systemd[1]: Listening on Journal Socket.
[    1.883422] systemd[1]: Listening on udev Control Socket.
[    1.883456] systemd[1]: Listening on udev Kernel Socket.
[    1.883961] systemd[1]: Mounting Huge Pages File System...
</code></pre>
<h3 id="示例5实时打印dmesg日志">示例5：实时打印dmesg日志</h3>
<pre><code class="language-bash">$ dmesg --follow
</code></pre>
<h3 id="示例6显示dmesg原生信息">示例6：显示dmesg原生信息</h3>
<pre><code class="language-bash">$ dmesg -r
</code></pre>
<h3 id="示例7dmesg信息重定向到syslog">示例7：dmesg信息重定向到syslog</h3>
<p>dmesg本身只是一个用户空间命令，而 ”<em><strong>driver message</strong></em>“ 是内存中一个缓冲器，在Linux标识为 <code>/dev/kmsg</code>，而这个缓冲区是存在与内存中，如果需要将其重定向到syslog，可以通过参数 <code>-S</code> 实现，<code>-s</code> 则是设置这个环形buffer的大小</p>
<h3 id="示例8过滤硬件设备相关信息">示例8：过滤硬件设备相关信息</h3>
<pre><code class="language-bash"># usb设备
$ dmesg | grep -i usb
# 还可以通过grep查看其它硬件设备相关信息
$ dmesg | grep -i dma
$ dmesg | grep -i scsi
$ dmesg | grep -i acpi
$ dmesg | grep -i memory
$ dmesg | grep -i tty
$ dmesg | grep sda
</code></pre>
<h3 id="示例9清空buffer">示例9：清空buffer</h3>
<pre><code class="language-bash"># 直接清空
dmesg -C
# 读取并清空
dmesg -c
</code></pre>
<h2 id="vmstat">vmstat</h2>
<p>vmstat 命令是Linux虚拟内存统计信息的命令，带来的是与进程有关的信息，如processes, memory, paging, block IO</p>
<p><strong>没有任何参数的vmstat</strong></p>
<pre><code class="language-bash">$ vmstat 
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1246808  24308 507656    0    0     5     0   60  130  0  0 100  0  0
</code></pre>
<p>vmstat输出包含的字段</p>
<ul>
<li>Procs – r: 等待运行的数量</li>
<li>Procs – b: 忙碌进程的数量</li>
<li>Memory – swpd: 已使用的虚拟内存</li>
<li>Memory – free: 空闲的虚拟内存</li>
<li>Memory – buff: 用作buffer的内存</li>
<li>Memory – cache: 用作cache的内存</li>
<li>Swap – si: 从磁盘交换至内存 (for every second)</li>
<li>Swap – so: 内存交换到磁盘 (for every second)</li>
<li>IO – bi (<em>Blocks in</em>). i.e 从设备接受到的块(for every second)</li>
<li>IO – bo (<em>Blocks out</em>). i.e 发送到设备的块 (for every second)</li>
<li>System – in (<em>Interrupts per second</em>) 每秒的中断</li>
<li>System – cs (<em>Context switches</em>) 上下文切换</li>
<li>CPU – us, sy, id, wa, st: CPU user time, system time, idle time, wait time</li>
</ul>
<h3 id="示例1显示活动和非活动内存">示例1：显示活动和非活动内存</h3>
<pre><code class="language-bash">$ vmstat -a
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1247060 294352 314540    0    0     5     0   60  130  0  0 100  0  0
</code></pre>
<h3 id="示例2显示启动系统后所有fork系统调用">示例2：显示启动系统后所有fork系统调用</h3>
<p>显示所有 fork、vfork 和 clone 系统调用计数</p>
<pre><code class="language-bash">$ vmstat -f
         2889 forks
</code></pre>
<h3 id="示例3动态展示">示例3：动态展示</h3>
<p>展示结果将以 x 秒刷新，直到 crtl - c 退出</p>
<pre><code class="language-bash">$ vmstat 2
</code></pre>
<p>也可以接俩个参数，一个是刷新时间，一个是刷新多少次，例如，2秒刷新一次，一共刷新10次，完成后退出命令</p>
<pre><code class="language-bash">$ vmstat 2 10
</code></pre>
<h3 id="示例4打印时间">示例4：打印时间</h3>
<pre><code class="language-bash">$ vmstat -t 1 2
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- -----timestamp-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st                 PST
 1  0      0 1247424  24396 507656    0    0     5     0   60  130  0  0 100  0  0 2022-12-10 08:10:03
 1  0      0 1247416  24396 507656    0    0     0     8  130  277  0  0 100  0  0 2022-12-10 08:10:04
</code></pre>
<h3 id="示例5显示slab相关信息">示例5：显示slab相关信息</h3>
<p>slab是一种内存管理机制，目的是为了更有效的分配内存对象</p>
<pre><code class="language-bash">vmstat -m
Cache                       Num  Total   Size  Pages
nf_conntrack                102    102    320     51
ovl_inode                    94     94    688     47
ext4_groupinfo_1k           120    120    136     60
fuse_request                  0      0    152     53
fuse_inode                    0      0    832     39
ext4_groupinfo_4k           112    112    144     56
ext4_fc_dentry_update         0      0     80     51
ext4_inode_cache          13554  13554   1184     27
ext4_system_zone            204    204     40    102
ext4_io_end                 128    128     64     64
ext4_extent_status         3060   3060     40    102
jbd2_journal_handle         146    146     56     73
...
</code></pre>
<h3 id="场景6输出格式为表格形式">场景6：输出格式为表格形式</h3>
<pre><code class="language-bash">$ vmstat -s
      1996352 K total memory
       216852 K used memory
       314636 K active memory
       294352 K inactive memory
      1247416 K free memory
        24428 K buffer memory
       507656 K swap cache
            0 K total swap
            0 K used swap
            0 K free swap
         3635 non-nice user cpu ticks
            2 nice user cpu ticks
         8204 system cpu ticks
      9759423 idle cpu ticks
          310 IO-wait cpu ticks
            0 IRQ cpu ticks
          320 softirq cpu ticks
            0 stolen cpu ticks
       498371 pages paged in
        45598 pages paged out
            0 pages swapped in
            0 pages swapped out
      5866212 interrupts
     12709713 CPU context switches
   1670639441 boot time
         2922 forks
</code></pre>
<h3 id="场景7磁盘相关信息">场景7：磁盘相关信息</h3>
<pre><code class="language-bash">$ vmstat -d 1 20
disk- ------------reads------------ ------------writes----------- -----IO------
       total merged sectors      ms  total merged sectors      ms    cur    sec
sda     7835   2737  996742    2134   5719   2598   91620    6219      0      9
sda     7835   2737  996742    2134   5747   2598   91908    6230      0      9
</code></pre>
<h3 id="场景8输出格式增加宽度">场景8：输出格式增加宽度</h3>
<pre><code class="language-bash">vmstat -w 1 3
--procs-- -----------------------memory---------------------- ---swap-- -----io---- -system-- --------cpu--------
   r    b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st
   0    0            0      1247440        24468       507656    0    0     5     0   60  130   0   0 100   0   0
   0    0            0      1247440        24468       507656    0    0     0     0  135  265   0   0 100   0   0
   0    0            0      1247440        24468       507656    0    0     0     0  126  262   0   0 100   0   0
</code></pre>
<h3 id="场景9输出单位格式化">场景9：输出单位格式化</h3>
<pre><code class="language-bash">vmstat -S k
vmstat: -S requires k, K, m or M (default is KiB)
</code></pre>
<h2 id="mpstat">mpstat</h2>
<p>mpstat是统计CPU相关信息的命令</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install sysstat -y</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y sysstat</code></li>
</ul>
<pre><code class="language-bash">$ mpstat

08:22:07 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
08:22:07 AM  all    0.04    0.00    0.09    0.00    0.00    0.00    0.00    0.00    0.00   99.87
</code></pre>
<p>看懂 mpstat 输出结果</p>
<ul>
<li><strong>CPU</strong>：处理器编号. all为所有CPU在一段时间内的平均统计信息.</li>
<li><strong>%usr</strong>：在用户级别（应用程序）执行时的CPU平均使用率。</li>
<li><strong>%nice</strong>：具有良好级别的用户级别（应用程序）执行时的CPU平均使用率。</li>
<li><strong>%sys</strong>：显示在内核级别执行时发生的CPU使用率。 这里不包括耗时的硬/软中断服务</li>
<li><strong>%iowait</strong>：CPU 或 CPU 处于空闲状态期间系统有未完成的磁盘 I/O 请求。</li>
<li><strong>%irq</strong>：一个或多个 CPU 在中断时，硬中断所花费的时间的百分比。</li>
<li><strong>%soft</strong>： 一个或多个CPU用于中断时，软中断所花费的时间百分比。</li>
<li><strong>%steal</strong>： 一个或多个虚拟CPU当在虚拟机管理器服务与另一个虚拟处理器时非自愿等待时间所花费的百分比</li>
<li><strong>%guest</strong>：一个或多个CPU在运行一个虚拟处理器使用时间的百分比</li>
<li><strong>%idle</strong> : 一个或多个CPU处于idle状态，并且系统没有尚未完成的磁盘 I/O 请求</li>
</ul>
<pre><code class="language-bash"># 显示所有信息
mpstat -A

# 按照独立核心展示
mpstat -P ALL

# 使用编号指定单独的CPU编号
mpstat -P 1

# 第一个参数表示刷新时间，第二个参数表示刷新次数
mpstat 2 10

# CPU利用率
mpstat -u %usr

# CPU中断信息
mpstat -I { SUM | CPU | SCPU | ALL }
</code></pre>
<h2 id="pidstat">pidstat</h2>
<p><em><strong>pidstat</strong></em> 是 <em><strong>sysstat</strong></em> 包的一部分，可以统计单个进程并生成报告。用以通过 PID 来评估资源的使用率</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install sysstat -y</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y sysstat</code></li>
</ul>
<pre><code class="language-bash"># 显示所有进程
pidstat -p ALL

# 查看特定进程
pidstat -p 514

# 根据进程名称来查看
pidstat -C &quot;mysql&quot;

# 指定实时刷新
pidstat -p 23493 1

# 显示指定进程的I/O统计信息
pidstat -p &lt;pid&gt; -d

# 显示指定进程的活动分页统计信息
pidstat -p &lt;pid&gt; -r

# 显示结果时加上进程程序所在路径、参数等信息
pidstat -C java -l

# 第一个参数表示刷新时间，第二个参数表示刷新次数
pidstat 2 5

# 显示进程的子进程信息
# -T: CHILD, or TASKS, or ALL.
pidstat -p 1 -T CHILD

# 显示为依赖进程树格式
pidstat -t -C &quot;ssh&quot;

# 展示一个水平线上的性能
# option “r”  page faults and memory utilization
# option “d”  I/O statistics
# option “u”  CPU utilization
# 展示结果将按照 r d u 依次输出
pidstat -rud
</code></pre>
<h2 id="iostat">iostat</h2>
<p><em><strong>iostat</strong></em> 是 <em><strong>sysstat</strong></em> 包的一部分，可以通过命令来统计CPU使用率, I/O, （设备，分区）, 网络文件系统等</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install sysstat -y</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y sysstat</code></li>
</ul>
<p><strong>iostat命令参数</strong></p>
<ul>
<li><strong>-c</strong>: 显示CPU使用率</li>
<li><strong>-d</strong>: 显示设备使用率</li>
<li><strong>-k</strong>: 以kb为单位统计（每秒）</li>
<li><strong>-m</strong>: 以mb为单位统计（每秒）</li>
<li><strong>-x</strong>: 展示一些扩展的统计文件</li>
</ul>
<p>iostat结果为两部分，avg-cpu 与 Device，均是指自开机以来的统计</p>
<p>avg-cpu部分：</p>
<ul>
<li><strong>%user</strong>：在用户级别（应用程序）执行时的CPU平均使用率。</li>
<li><strong>%nice</strong>：具有良好级别的<strong>用户</strong>级别（应用程序）执行时的CPU平均使用率。</li>
<li><strong>%system</strong>：显示在<strong>内核</strong>级别执行时发生的CPU使用率。 这里不包括耗时的硬/软中断服务</li>
<li><strong>%iowait</strong>：CPU 或 CPU 处于空闲状态期间系统有未完成的磁盘 I/O 请求。</li>
<li><strong>%steal</strong>： 一个或多个虚拟CPU当在虚拟机管理器服务与另一个虚拟处理器时非自愿等待时间所花费的百分比</li>
<li><strong>%idle</strong> : 一个或多个CPU处于idle状态，并且系统没有尚未完成的磁盘 I/O 请求</li>
</ul>
<p>Device部分：</p>
<ul>
<li><strong>tps</strong> - 表示每秒发送给设备的传输次数。</li>
<li><strong>Blk_read/s (kB_read/s, MB_read/s)</strong> - 表示每秒从设备读取的数据量，以块（KB、MB）表示。</li>
<li><strong>Blk_wrtn/s (kB_read/s, MB_read/s)</strong> - 表示每秒写入设备的数据量，以块（KB、MB）表示。</li>
<li><strong>Blk_read (kB_read, MB_read)</strong> - 读取块总数（KB、MB）</li>
<li><strong>Blk_wrtn (kB_read, MB_read)</strong>- 写入块总数（KB、MB）</li>
</ul>
<pre><code class="language-bash">$ iostat
Linux 5.10.0-16-amd64 (debian-template) 	12/11/2022 	_x86_64_	(2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.04    0.00    0.09    0.00    0.00   99.87

Device             tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd
sda               0.26         8.22         1.88         0.00     578135     131934          0
</code></pre>
<p><strong>使用示例</strong></p>
<pre><code class="language-bash"># 显示CPU使用率
iostat -c

# 显示CPU使用率 按照周期刷新 sec
iostat -c N

# 设备使用率
iostat -d

# 以人类可读方式展示
iostat -h

# 显示一些扩展选项
iostat -x

# 以kb为单位展示
iostat -k

# 以mb为单位展示
iostat -m

# 显示设备与分区的使用率
iostat -p

# 显示指定设备的使用率
iostat -p &lt;device_name&gt;

# 忽略非活跃设备
iostat -z
</code></pre>
<h2 id="htop">htop</h2>
<p>htop可以理解为linux中的与windows任务管理器相同的产品，与top不同的是，htop是一个支持交互式的top命令</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install htop -y</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y htop</code></li>
</ul>
<h3 id="cpu和内存使用状态">CPU和内存使用状态</h3>
<p>htop上部屏幕，为CPU和存储使用详情</p>
<h3 id="显示的颜色">显示的颜色</h3>
<p><strong>默认模式</strong></p>
<ul>
<li>蓝色：低优先级进程（nice&gt; 0）</li>
<li>绿色：正常（用户）流程</li>
<li>红色：内核时间（内核，iowait，irqs &hellip;）</li>
<li>橙色：有效时间（窃取时间+访客时间）</li>
</ul>
<p><strong>详细模式</strong></p>
<ul>
<li>蓝色：低优先级线程（nice&gt; 0）</li>
<li>绿色：正常（用户）流程</li>
<li>红色：系统进程</li>
<li>橙色：IRQ时间</li>
<li>洋红色：IRQ时间较慢</li>
<li>灰色：IO等待时间</li>
<li>青色：偷时间</li>
<li>青色：访客时间</li>
</ul>
<p><strong>内存计量</strong>器更简单：</p>
<ul>
<li>绿色：已用内存页</li>
<li>蓝色：缓冲页</li>
<li>橙色：缓存页面</li>
</ul>
<blockquote>
<p>可以通过f1查看帮助对于颜色的说明</p>
</blockquote>
<h2 id="ldd">ldd</h2>
<h2 id="sar">sar</h2>
<p>sar <strong>S</strong>ystem <strong>A</strong>ctivity <strong>R</strong>eport的简写，可以用于收集、报告或保存系统活动的统计信息，如 Linux 系统中的 CPU 利用率、内存使用情况、I/O 设备使用情况。 sar 命令显示自系统启动以来的平均统计信息。它在输出中生成报告，也可以保存在文件中。</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install sysstat -y</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y sysstat</code></li>
</ul>
<blockquote>
<p>Notes：sar是服务，需要开启收集才可以查询到，配置 <code>/etc/default/sysstat </code> 修改为 <code>ENABLED=&quot;false&quot;</code> 然后重启服务 <code>systemctl restart sysstat.service</code></p>
</blockquote>
<p>sar语法</p>
<pre><code class="language-bash">$ sar [option] [interval] [count]
</code></pre>
<p>更多可以参考 <sup><a href="#5">[5]</a></sup></p>
<h2 id="ioping">ioping</h2>
<p>ioping是一款磁盘延迟监控工具</p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y ioping</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y ioping</code></li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>-c</strong> <em>count</em></td>
<td>ping的次数</td>
</tr>
<tr>
<td><strong>-i</strong> <em>interval</em></td>
<td>每次请求的间隔</td>
</tr>
<tr>
<td><strong>-t</strong> <em>time</em></td>
<td>最大有效的请求事件，太慢的请求将被忽略</td>
</tr>
<tr>
<td><strong>-s</strong> <em>size</em></td>
<td>请求大小</td>
</tr>
<tr>
<td><strong>-S</strong> <em>wsize</em></td>
<td></td>
</tr>
<tr>
<td><strong>-o</strong> <em>offset</em></td>
<td>在 file/device 开始的偏移量</td>
</tr>
<tr>
<td><strong>-w</strong> <em>deadline</em></td>
<td>在多少时间后停止</td>
</tr>
<tr>
<td><strong>-p</strong> <em>period</em></td>
<td>打印每秒请求的原生统计数据</td>
</tr>
<tr>
<td><strong>-A</strong></td>
<td>使用异步IO (syscalls <strong><a href="https://www.systutorials.com/docs/linux/man/2-io_submit/" target="_blank"
   rel="noopener nofollow noreferrer" >io_submit</a></strong>(2), <strong><a href="https://www.systutorials.com/docs/linux/man/2-io_submit/" target="_blank"
   rel="noopener nofollow noreferrer" >io_submit</a></strong>(2),</td>
</tr>
<tr>
<td><strong>-B</strong></td>
<td>批量模式，以安静的原始数据方式统计最终的数据</td>
</tr>
<tr>
<td><strong>-C</strong></td>
<td>使用 cached I/O 在posix_fadvise(2)读取之前 和写入 fdatasync(2)之后，来抑制缓存失效。</td>
</tr>
<tr>
<td><strong>-D</strong></td>
<td>使用direct I/O (<strong>O_DIRECT</strong> in <strong><a href="https://www.systutorials.com/docs/linux/man/2-open/" target="_blank"
   rel="noopener nofollow noreferrer" >open</a></strong>(2)).</td>
</tr>
<tr>
<td><strong>-L</strong></td>
<td>使用序列操作而不是随机操作，这相当于设置了默认大小，例如 <code>-s 256k</code> 与这个是相同的</td>
</tr>
<tr>
<td><strong>-R</strong></td>
<td>磁盘查找速度测试，这个选项将以人类可读模式输出每个请求<br>设置默认间隔为0, -i=0<br/>停止测量将在3秒后停止 -w=3<br/>设置工作集大小为64m -S=64m</td>
</tr>
<tr>
<td><strong>-W</strong></td>
<td>写而不是读。目录目标安全。写入 I/O 为不支持或在某种级别缓存非缓存读取从而提供更可靠的结果。对于file/device来说是<em>危险的</em>：这将会粉碎数据。</td>
</tr>
<tr>
<td><strong>-Y</strong></td>
<td>使用同步IO (<strong>O_SYNC</strong> in <strong><a href="https://www.systutorials.com/docs/linux/man/2-open/" target="_blank"
   rel="noopener nofollow noreferrer" >open</a></strong>(2)).</td>
</tr>
<tr>
<td><strong>-y</strong></td>
<td>使用数据同步IO  (<strong>O_DSYNC</strong> in <strong><a href="https://www.systutorials.com/docs/linux/man/2-open/" target="_blank"
   rel="noopener nofollow noreferrer" >open</a></strong>(2)).</td>
</tr>
<tr>
<td><strong>-k</strong></td>
<td>重用临时工作目录文件 &ldquo;ioping.tmp&rdquo; （仅对于目标目录生效）</td>
</tr>
<tr>
<td><strong>-q</strong></td>
<td>Suppress periodical human-readable output.</td>
</tr>
</tbody>
</table>
<p>使用示例</p>
<p>RAW STATISTICS</p>
<pre><code class="language-bash">$ ioping -p 100 -c 200 -i 0 -q .
100 16282962 6141 25155128 130599 162830 328499 37909 101 17115660
</code></pre>
<p>上面输出的结果意思为：</p>
<ul>
<li>统计请求的计数</li>
<li>运行时间 <strong>usec</strong> 微秒</li>
<li>每秒请求 (iops)</li>
<li>传输速率 (bytes/sec)</li>
<li>最小请求时间 (usec)</li>
<li>平均请求时间 (usec)</li>
<li>最大请求时间 (usec)</li>
<li>请求时间偏差 (usec)</li>
<li>总请求 （包含很慢和很快的）</li>
<li>总共运行时间 (usec)</li>
</ul>
<pre><code class="language-bash"># 使用默认值和当前目录 测试磁盘 I/O 延迟，ctrl - c 中断。
ioping .

# 测量/tmp设备的延迟，总计使用10个请求，每个请求1MB
ioping -c 10 -s 1M /tmp

# 测量 设备  /dev/sda 的查找速度
ioping -R /dev/sda

# 测试设备磁盘序列速度
ioping -RL /dev/sda

# 获取磁盘序列的速度（每秒多少字节）
ioping -RLB . | awk '{print $4}'
</code></pre>
<h2 id="vnstat">vnstat</h2>
<p>vnstat是 Linux 中用于监控网络参数的命令，通常查看带宽消耗或一些流入或流出的流量，与网络接口上的流量。</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y vnstat</code></li>
<li>RHEL/CentOS/Fedora：epel <code>yum install -y vnstat</code></li>
</ul>
<p>vnstat是一个守护进程，如果需要记录需要启动这个服务才可以，而不是一个单独的命令</p>
<pre><code class="language-bash"># 以小时显示流量
vnstat -h

# 以天显示流量
vnstat -d

# 以月为单位展示
vnstat -m

# 计算接口多长时间内的流量（这个是实时的，可以不用启动服务）
vnstat -tr 10 # 10 sec

# 指定一个接口
vnstat -i eth0

# 指定输出格式
vnstat --json
vnstat --xml
</code></pre>
<h2 id="ifstat">ifstat</h2>
<p>ifstat是Linux下网络接口统计的命令</p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y ifstat</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y ifstat</code></li>
</ul>
<pre><code class="language-bash"># 指定接口名
ifstat eth0

# 查看全部接口
ifstat -a

# 清除网络接口的数据
ifstat -z &lt;interface_name&gt;

# 展示x秒内网络数据的平均值
ifstat -t 10
</code></pre>
<h2 id="iptraf">iptraf</h2>
<p>iptraf是Linux 中交互式的网络监控命令，通过交互式实现展示</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y iptraf-ng</code></li>
<li>RHEL/CentOS/Fedora：<code>yum install -y iptraf-ng</code></li>
</ul>
<h2 id="iftop">iftop</h2>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y iftop</code></li>
<li>RHEL/CentOS/Fedora：epel <code>yum install -y iftop</code></li>
</ul>
<pre><code class="language-bash"># 指定端口的带宽统计
iftop -i enp0s8

# 隐藏顶部的流量刻度栏
iftop -b

# 不使用域名解析
iftop -n -i enp0s8

# 直接输出为文字，而不是交互式
iftop -t

# 显示指定子网的流量
iftop -F 192.168.2.0/24

# 根据source addr排序
iftop -o source

# 根据destnation addr排序
iftop -o destination

# 显示使用的带宽
iftop -B -i enp0s8
</code></pre>
<h2 id="arpwatch">arpwatch</h2>
<p>arpwatch是Linux上用于监视ARP记录的</p>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian/Mint：<code>apt install -y arpwatch</code></li>
<li>RHEL/CentOS/Fedora：epel <code>yum install -y arpwatch</code></li>
</ul>
<table>
<thead>
<tr>
<th>Option</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>debug模式</td>
</tr>
<tr>
<td>-f</td>
<td>设置用于存储 ethernet/ip address 的文件，默认在  /var/arpwatch/arp.dat</td>
</tr>
<tr>
<td>-i</td>
<td>指定默认接口</td>
</tr>
<tr>
<td>-n</td>
<td>指定本地网络</td>
</tr>
<tr>
<td>-u</td>
<td>指定用户或用户组</td>
</tr>
<tr>
<td>-Q</td>
<td>The  flags prevents arpwatch from sending reports by mail</td>
</tr>
<tr>
<td>-z</td>
<td>设置忽略的 IP范围，IP和掩码用 &ldquo;/&rdquo; 化为，如 <code>-z 192.168.10.0/255.255.255.0</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-bash"># 指定一个接口，命令并没有输出，当有新IP或MAC被改变时，会保存到/var/log/messages
arpwatch -i eth0
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://www.brendangregg.com/perf.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>perf Examples</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="http://notes.secretsauce.net/notes/2015/01/28_user-space-introspection-with-linux-perf.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>User-space introspection with Linux perf</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://drgn.readthedocs.io/en/latest/getting_debugging_symbols.html" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Getting Debugging Symbols</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="http://oliveryang.net/2016/07/linux-perf-tools-tips/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Linux Perf Tools Tips</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://www.golinuxcloud.com/sar-command-in-linux/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>20 sar command examples in Linux</strong></em></a></p>
<p><sup id="6">[6]</sup> <a href="https://www.linuxfordevices.com/tutorials/linux/htop-command-in-linux" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>A Guide to the htop command in Linux</strong></em></a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>bash shell常用示例</title>
      <link>https://www.oomkill.com/2021/10/awesome-bash-shell/</link>
      <pubDate>Fri, 22 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/awesome-bash-shell/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>该文整理一些常用的shell用法，及语法，并非介绍如何使用</p>
<h2 id="变量">变量</h2>
<p>变量可分为两类：环境变量ENV（全局）和局部变量。</p>
<p>bash环境变量</p>
<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>_=</td>
<td>上一条命令的最后一个参数</td>
</tr>
<tr>
<td>BASH_VERSION=&ldquo;4.1.2(1)-release&rdquo;</td>
<td>当前bash实例的版本号</td>
</tr>
<tr>
<td>COLORS=&quot;/etc/DIR_COLORS&quot;</td>
<td></td>
</tr>
<tr>
<td>COLUMNS=80</td>
<td>设置该变量就给shell编辑模式和选择命令定义了编辑窗口的宽度</td>
</tr>
<tr>
<td>CVS_RSH=&ldquo;ssh&rdquo;</td>
<td></td>
</tr>
<tr>
<td>DIRSTACK</td>
<td>代表目录栈当前的内容</td>
</tr>
<tr>
<td>EUID=0</td>
<td>为在shell启动时被初始化的当前用户的有效ID</td>
</tr>
<tr>
<td>G_BROKEN_FILENAMES=1</td>
<td></td>
</tr>
<tr>
<td>GROUPS=()</td>
<td>当前用户所属组</td>
</tr>
<tr>
<td>HISTFILE=/root/.bash_history</td>
<td>历史记录文件的全路径</td>
</tr>
<tr>
<td>HISTFILESIZE=50</td>
<td>历史文件能包含的最大行数</td>
</tr>
<tr>
<td>HISTSIZE=50</td>
<td>记录在命令行历史文件中的命令行数</td>
</tr>
<tr>
<td>HOME=/root</td>
<td>当前用户家目录</td>
</tr>
<tr>
<td>HOSTNAME=</td>
<td>当前主机机器名称</td>
</tr>
<tr>
<td>HOSTTYPE=x86_64</td>
<td></td>
</tr>
<tr>
<td>IFS=$&rsquo;\t\n'</td>
<td>内容字段分隔符，一般是空格符、制表符、和换行符，用于由命令替换，循环结构中的表和读取的输入产生的词的字段划分。</td>
</tr>
<tr>
<td>INPUTRC=/etc/inputrc</td>
<td>readline启动文件的文件名。取代默认的~/.inputrc</td>
</tr>
<tr>
<td>JAVA_HOME=/app/jdk1.6</td>
<td></td>
</tr>
<tr>
<td>KDENIR=/usr</td>
<td></td>
</tr>
<tr>
<td>KDE IS PRELINKED=1</td>
<td></td>
</tr>
<tr>
<td>LANG=zh_CN.GB18030</td>
<td></td>
</tr>
<tr>
<td>LESSONPEN</td>
<td></td>
</tr>
<tr>
<td>LINES=36</td>
<td></td>
</tr>
<tr>
<td>LONGNAME=root</td>
<td>登陆的用户名</td>
</tr>
<tr>
<td>LS_COLORS=xx</td>
<td></td>
</tr>
<tr>
<td>MACHTYPE=x86_64-redhat-linux-gnu</td>
<td>包含一个描述正在运行bash的系统串</td>
</tr>
<tr>
<td>MAILCHECK=60</td>
<td>这个参数定义shell将隔多长时间（以秒为单位检查一次由参数MAILPATH或MAILFILE）指定的文件，看看是否有邮件到达。默认600秒</td>
</tr>
<tr>
<td>MAIL=/var/spool/mail/root</td>
<td>邮件全路径</td>
</tr>
<tr>
<td>OLDPWD=/root</td>
<td>前一个当前工作目录</td>
</tr>
<tr>
<td>OPTERR=1</td>
<td>如果设置为1，秒年十时毫，来自getopts内置命令的错误信息。</td>
</tr>
<tr>
<td>OPTIND=1</td>
<td>下一个有getopts内置命令处理的参数序号</td>
</tr>
<tr>
<td>OSTYPE=linux-gnu</td>
<td>自动设置称一个串，该串标书正在运行bash的操作系统，默认值有系统决定</td>
</tr>
<tr>
<td>PATH</td>
<td>全局PATH路径。命令搜索路径。一个有冒号分隔的目录列表，shell用它来搜索命令。默认路径有系统决定，并且由安装bash的管理员设置。</td>
</tr>
<tr>
<td>PIPESTATUS=([0]=0 [1]=1)</td>
<td>一个数组，包含一列最进在管道执行的前台作业的进程退出状态值。</td>
</tr>
<tr>
<td>PPID=1112</td>
<td>父进程的进程ID</td>
</tr>
<tr>
<td>PS1=[\u@\h \W]$</td>
<td>主提示符串，默认值是$</td>
</tr>
<tr>
<td>PS2= &gt;</td>
<td>次提示符串，默认值是&gt;</td>
</tr>
<tr>
<td>PS4=+</td>
<td>当开启追踪时使用的调试提示符串，默认值是+，追踪可用set-x开启。</td>
</tr>
<tr>
<td>PWD</td>
<td>当前用户家目录。</td>
</tr>
<tr>
<td>SHELL=/bin/bash</td>
<td></td>
</tr>
<tr>
<td>SHLVL=1</td>
<td>每启动一个bash实例就将其加1</td>
</tr>
<tr>
<td>TMOUT=3600</td>
<td>退出前等待超时的秒数。</td>
</tr>
<tr>
<td>UID=0</td>
<td>当前用户的UID，在shell启动时初始化。</td>
</tr>
<tr>
<td>USER=root</td>
<td>当前用户的用户名，在shell启动时初始化。</td>
</tr>
</tbody>
</table>
<p>自定义环境变量 <code>export</code></p>
<p>默认的环境变量 <code>env</code>（<code>printenv</code>）或<code>set</code></p>
<p>消除本地变量和环境变量 <code>unset </code></p>
<p>定义变量：<em><strong>习惯：数字不加引号，其他默认加双引号</strong></em></p>
<h3 id="引号">引号</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>单引     号</td>
<td>可以说是所见即所得：即将单引号内的所有内容都原样输出，或者描述为单引号里面看到的是什么就会输出什么。</td>
</tr>
<tr>
<td>双引号</td>
<td>把双引号内的所有内容都输出出来；如果内容中有命令（要反引下）、变量、特殊转义符等，会先把变量、命令解析出结果，然后再输出最终内容来。</td>
</tr>
<tr>
<td>无引号</td>
<td>把内容输出出来前，会将含有空格的字符串视为一个整体输出，如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容来，如果字符串中带有空格等特殊字符，则不能完整的输出，需要改加双引号，一般连续的字符串，数字，路径等可以不加任何引号，不过无引号的情况最好用双引号替代之。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="变量的命名规范">变量的命名规范</h3>
<ul>
<li>
<p><strong>变量名要统一</strong>，使用全部大写字母，如<code>APCHE_ERR_NUM</code>；语义要清晰，能够正确表达变量内容含义，过长的英文单词可采用前几个字符代替，多个单词连接用“_”连接，引用时，最好以<code>${APACHE_ERR_NUM}</code>或&quot;<code>${APACHE_ERR_NUM}</code>&ldquo;的方式引用变量。</p>
</li>
<li>
<p><strong>避免无意义字符或数字</strong>：例如下面的COUNT，并不知道其确切含义</p>
</li>
<li>
<p>范例1：COUNT的不确切定义  <code>COUNT=$(grep keywords file)</code></p>
</li>
<li>
<p>全局变量和局部变量命名</p>
<ul>
<li><strong>脚本中的全局变量定义</strong>，如<code>USER_HOME</code>或<code>USERHOME</code>，在变量使用时，使用 <code>{ }</code>将变量括或&rdquo;<code>${APACHE_ERR_NUM}&quot;</code>了；变量后还有字符串隔不开的情况下，用大括号扩一下 <code>${金庸}</code>新著作</li>
<li><strong>脚本中局部变量定义</strong>：存在于脚本函数<code>（function）</code>中的变量称为局部变量，要以local方式进行生命，使之只在本函数作用域内有效，防止变量在函数中的命名于变量外部程序中变量重名造成程序异常。下面是函数中的变量定义例子：</li>
</ul>
</li>
</ul>
<h3 id="特殊变量">特殊变量</h3>
<table>
<thead>
<tr>
<th>No</th>
<th>位置变量</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>$0</code></strong></td>
<td>当前执行的shell脚本的文件名，如果执行脚本带路径则包括脚本路径。</td>
</tr>
<tr>
<td><strong><code>$n</code></strong></td>
<td>当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本文件名，如果n大于9用大括号括起来<code>${10}</code>.</td>
</tr>
<tr>
<td><strong><code>$#</code></strong></td>
<td>当前执行的shell脚本后面接的参数的总个数</td>
</tr>
<tr>
<td><strong><code>$*</code></strong></td>
<td>当前shell的所有传参的参数，将所有的参数视为单个字符串，相当于<code>“$1$2$3..</code>”注意$与#的区别</td>
</tr>
<tr>
<td><strong><code>$@</code></strong></td>
<td>这个程序的所有参数<code>“$1” “$​2” “$3” ....”</code>，这是将参数传递给其他程序的最佳方式，因为会保留所有内嵌在每个参数里的任何空白。</td>
</tr>
<tr>
<td></td>
<td><font color="red"><strong>进程状态变量</strong></font></td>
</tr>
<tr>
<td><strong><code>$$</code></strong></td>
<td>获得当前shell脚本的进程号（PID）</td>
</tr>
<tr>
<td><strong><code>$?</code></strong></td>
<td>执行上一个指令的返回值（0为成功，非0为失败）</td>
</tr>
<tr>
<td><strong><code>$!</code></strong></td>
<td>执行上一个指令的PID</td>
</tr>
<tr>
<td><strong><code>$_</code></strong></td>
<td>在此之前执行的命令或脚本的最后一个参数。</td>
</tr>
</tbody>
</table>
<p><code>$?</code>  返回值参考</p>
<table>
<thead>
<tr>
<th>no</th>
<th>意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>表示允许成功</td>
</tr>
<tr>
<td>2</td>
<td>权限拒绝</td>
</tr>
<tr>
<td>1~125</td>
<td>表示运行失败，脚本命令、系统命令错误或参数传递错误</td>
</tr>
<tr>
<td>126</td>
<td>找到该命令了，但是无法运行</td>
</tr>
<tr>
<td>127</td>
<td>为找打要运行的命令<code>$ zhangsan-bash: zhangsan: command not found</code> <code>$ echo $? 127</code></td>
</tr>
<tr>
<td>&gt;128</td>
<td>命令被系统强制结束<code>$ sleep 100000^C</code> <code>$ echo $?130</code></td>
</tr>
</tbody>
</table>
<h3 id="变量子串">变量子串</h3>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>${#string}</code></td>
<td>返回$string的长度</td>
</tr>
<tr>
<td><code>${string:position}</code></td>
<td>在$string中，从位置$position之后开始提取子串</td>
</tr>
<tr>
<td><code>${string:position:length}</code></td>
<td>在$string中，从位置position之后开始提取长度为length的子串</td>
</tr>
<tr>
<td><code>${string#sub}</code></td>
<td>从变量string开头开始删除最短匹配sub子串</td>
</tr>
<tr>
<td><code>${string##sub}</code></td>
<td>从变量开头开始删除最长匹配子串</td>
</tr>
<tr>
<td><code>${string%sub}</code></td>
<td>从变量string结尾开始删除最短匹配sub子串</td>
</tr>
<tr>
<td><code>${string%%sub}</code></td>
<td>从变量string结尾开始删除最长匹配sub子串</td>
</tr>
<tr>
<td><code>${string/sub/rep}</code></td>
<td>使用rep，来代替第一个匹配的sub</td>
</tr>
<tr>
<td><code>${string/#sub/rep}</code></td>
<td>如果string前缀匹配sub就用rep代替匹配sub</td>
</tr>
</tbody>
</table>
<h3 id="变量替换">变量替换</h3>
<table>
<thead>
<tr>
<th>运算符号</th>
<th>替换</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>${value:-word}</code></td>
<td>如果变量名存在且非null，则返回变量的值。否则，返回word字符串。用途：如果变量未定义，则返回默认值。范例：<code>${value:-word}</code>，如果value未定义，则表达式的值为word</td>
</tr>
<tr>
<td><code>${value:=word}</code></td>
<td>如果变量名存在且非null，则返回变量值。否则，设置这个变量值未word，并返回其值。用途：如果变量未定义，则设置变量为默认值，并返回默认值。范例：<code>${value:=word}</code>，如果value未定义，则设置value的值为word，返回表达式的值也为word。</td>
</tr>
<tr>
<td><code>${value:?&quot;not defined&quot;}</code></td>
<td>如果变量名存在且非null，则返回变量的值。否则显示变量名：msg，并退出当前的命令或脚本。用途：用于捕捉由于变量未定义而导致的错误，并退出程序。范例：<code>${value:?&quot;not defined&quot;}</code>如果value未定义，则显示<code>-bash:value:not defined</code>并退出。</td>
</tr>
<tr>
<td><code>${value:+word}</code></td>
<td>如果变量名存在且非null，则返回word。否则返回null。用途：测试变量是否存在。范例：<code>${value:+word}</code> 如果value已经定义，返回word（也是就是真）。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="数值整数计算">数值（整数）计算</h2>
<h3 id="-">(( ))</h3>
<p>如果要执行简单的整数运算，只需将特定的算数表达式用 <code>(( </code> 和  <code>))</code> 括起来即可。</p>
<p>shell的算数运算符号常置于<code>$((</code> 和  <code>))</code>的语法中。这一语法如同双引号用能，除了内嵌双引号无需转义。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>++ &ndash;</td>
<td>增加及减少，可前置也可放在结尾</td>
</tr>
<tr>
<td>+ - ！~</td>
<td>一元的正号与负号；逻辑与位的取反</td>
</tr>
<tr>
<td>* / %</td>
<td>乘法、除法、与取余</td>
</tr>
<tr>
<td>+ -</td>
<td>加法、减法</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;=</td>
<td>比较负号</td>
</tr>
<tr>
<td>== !=</td>
<td>相等与不相等，一个“=”赋值</td>
</tr>
<tr>
<td>&laquo; &raquo;</td>
<td>向左位移 向右位移</td>
</tr>
<tr>
<td>&amp;</td>
<td>位的AND</td>
</tr>
<tr>
<td>^</td>
<td>位的异或</td>
</tr>
<tr>
<td>|</td>
<td>位的或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑的AND（make &amp;&amp; mak install）</td>
</tr>
<tr>
<td>||</td>
<td>逻辑的OR（make || make install）</td>
</tr>
<tr>
<td>?:</td>
<td>条件表达式</td>
</tr>
<tr>
<td>= += -= *= /= &amp;= ^= &laquo;= &raquo;= |=</td>
<td>赋值运算符 a+=1都相当a=a+1</td>
</tr>
</tbody>
</table>
<ul>
<li><code>**</code> 为幂运算：<code>%</code> 为取模运算（就是除法当中取余数）。</li>
<li>上面涉及到的参数变量必须位整数（==整型==）。不能是小数（浮点数）或者字符串。后面的bc命令可以进行浮点数运算，但一般较少用到。</li>
<li><code>echo $((a++))</code> 和 <code>$((a--))</code> 表示先输出a自身的值，然后在进行 <code>++-- </code>的运算，<code>echo$((++a))</code> 和 <code>echo$((--a))</code> 表示先进行 <code>++--</code> 的运算，在输出a自身的值。</li>
</ul>
<p><em><strong>记忆方法：变量在前，先输出变量值，变量在后，就是先运算后输出变量的值</strong></em></p>
<h3 id="let">let</h3>
<p>let赋值表达式，【注】let赋值表达式功能等同于<code>((赋值表达式))</code>  ，例如 <code>let i=i+8</code></p>
<h3 id="expr">expr</h3>
<p><strong>expr（evaluate（求值）expressions（表达式））命令</strong>：</p>
<p>expr命令一般用于整数值，但也可用于字符串，用来求表达式变量的值，同时expr是一个手工命令行计算器。</p>
<ul>
<li><code>expr 2 + 2</code></li>
<li><code>expr 2 - 1</code></li>
<li><code>expr 2 * 1</code></li>
<li><code>expr 2 \* 1</code></li>
<li><code>expr 3 % 2</code></li>
</ul>
<blockquote>
<p>expr$[$a+$b]表达式形式</p>
<pre><code class="language-bash"># expr $[2+3]
5
# expr $[2**3]
8
# echo $[2**3]
8
2、
# a=1
# b=2
# expr $[$a+$b]
3
expr 将其后的串解释为表达式计算其值，运算符前后需有空格
</code></pre>
</blockquote>
<h3 id="bc">bc</h3>
<p>bc是UNXI下的计算器，它也可以用在命令行中，bc支持科学计算，所以这种方法功能非常强大</p>
<pre><code class="language-bash"># 一般工作中不这么用
$ bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
1*5
5
1/5
0
5/3
1
10+2
12

# 
$ echo 5+10|bc
15
$ echo 5*20|bc
100
$ echo 10%3|bc
1
$ echo 10.5+3.1|bc
13.6
# 与expr的区别
$ echo `expr 1+1`
1+1
$ echo `expr 1 + 1`
2
$ echo `expr 1 + 1.2`
expr: 参数数目错误

$ echo 1+1|bc
2
$ echo 1 + 1|bc
2
# 保留小数位数
$ echo &quot;scale=2;10.45246/2.2315&quot;|bc
4.68
$ echo &quot;10.45246/2.2315&quot;|bc        
4
$ echo 10.45246/2.2315|bc  
4
# 进制转换
$ echo &quot;obase=2;2&quot;|bc
10
$ echo &quot;obase=10;10&quot;|bc
10
$ echo &quot;obase=8;10&quot;|bc 
12
范例：通过命令输出1+2+3+4..+10=XX的表达式，并计算出结果
$ echo `seq -s &quot;+&quot; 10`=`seq -s '+' 10|bc` 
1+2+3+4+5+6+7+8+9+10=55
$ echo `seq -s &quot;+&quot; 10`=$((`seq -s &quot;+&quot; 10`))
1+2+3+4+5+6+7+8+9+10=55
$ echo `seq -s &quot;+&quot; 10`=`seq -s ' + ' 10|xargs expr` 
1+2+3+4+5+6+7+8+9+10=55
$ echo {1..10}|tr &quot; &quot; &quot;+&quot;
1+2+3+4+5+6+7+8+9+10
$ echo {1..10}|tr &quot; &quot; &quot;+&quot;|bc
55
</code></pre>
<h3 id="heading">$[]</h3>
<pre><code class="language-bash"># echo $[2+3]
5
# echo $[  2  * 3  ]
6
</code></pre>
<h2 id="条件测试">条件测试</h2>
<p>​</p>
<h3 id="测试语句">测试语句</h3>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>语法1：<code>test &lt;测试表达式&gt;</code></td>
<td>利用test命令进行条,<strong>test后有一个空格</strong></td>
</tr>
<tr>
<td>语法2：<code>[ &lt;测试表达式&gt; ]</code></td>
<td>通过单中括号进行,<strong>单中括号中的内容前后都有一个空格</strong></td>
</tr>
<tr>
<td>语法3：<code>[[ &lt;测试表达式&gt; ]]</code></td>
<td>通过双中括号进行,<strong>双中括号中的内容前后都有一个空格</strong></td>
</tr>
<tr>
<td>语法4：<code>((&lt;测试表达式&gt;))</code></td>
<td>通过双小括号进行,<strong>双小括号中的内容前后无空格</strong></td>
</tr>
</tbody>
</table>
<p>在<code>[[ ]]</code>中可以使用通配符进行模式匹配。<code>&amp;&amp; || &gt; &lt;</code>等操作符可以应用于<code>[[ ]]</code>中，不能应用于<code>[ ]</code>中。<code>[]</code>中一般用<code>-a、-o、-gt</code> 等替代对整数进行关系运算，也可以使用Shell的算数运算符 <code>(( ))</code></p>
<h3 id="文件测试操作符"><strong>文件测试操作符</strong></h3>
<table>
<thead>
<tr>
<th>测试操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-f 文件file</td>
<td>若文件存在且为普通文件则真</td>
</tr>
<tr>
<td>-d 文件 directory</td>
<td>若文件存在且为目录文件则真</td>
</tr>
<tr>
<td>-s 文件 size</td>
<td>若文件存在切不为空（文件大小非0）则真</td>
</tr>
<tr>
<td>-e 文件 exist</td>
<td>若文件存在则真，要区别-f</td>
</tr>
<tr>
<td>-r 文件 read</td>
<td>若文件存在且可读则真</td>
</tr>
<tr>
<td>-w 文件write</td>
<td>若文件存在且可写则真</td>
</tr>
<tr>
<td>-x 文件 excute</td>
<td>若文件存在且可执行则真</td>
</tr>
<tr>
<td>-L 文件link</td>
<td>若文件存在且为链接文件则真</td>
</tr>
<tr>
<td>f1 -nt f2 never than</td>
<td>若文件f1比文件f2新则真</td>
</tr>
<tr>
<td>f1 -ot f2 older than</td>
<td>若文件f1比文件f2旧则真</td>
</tr>
<tr>
<td>f1 -ef f2</td>
<td>两个文件具有同样的设备号和i结点号</td>
</tr>
<tr>
<td>-k file</td>
<td>文件是否設置了粘着位(Sticky Bit)，如果是，則返回 true。 [ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>文件是否設置了 SUID 位，如果是，則返回 true。 [ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-x file</td>
<td>文件是否可執行，如果是，則返回 true。</td>
</tr>
<tr>
<td>-p file</td>
<td>文件是否是有名管道，如果是，則返回 true。     [ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-w file</td>
<td>文件是否可寫，如果是，則返回 true。           [ -w $file ] 返回 true。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="字符串测试操作符"><strong>字符串测试操作符</strong></h3>
<table>
<thead>
<tr>
<th>常用字符串测试操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-z &ldquo;string&rdquo;</td>
<td>若串长度为0则真，-z可以理解为zero</td>
</tr>
<tr>
<td>-n &ldquo;string&rdquo;</td>
<td>若长度不为0则真，-n可以理解为no zero</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>&ldquo;string1&rdquo;=&ldquo;string2&rdquo;</td>
<td>若串1等于串2则真，可使用“==”代替“=”</td>
</tr>
<tr>
<td>&ldquo;string1&rdquo; != &ldquo;string2&rdquo;</td>
<td>若串1不等于串2则真。但不能用“!==”代替“!=”</td>
</tr>
</tbody>
</table>
<h3 id="二元比较操作符">二元比较操作符</h3>
<table>
<thead>
<tr>
<th>在[]中使用的比较符</th>
<th>在[[ ]]中使用的比较符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td>==</td>
<td>equal的缩写，相等返回真</td>
</tr>
<tr>
<td>-ne</td>
<td>!=</td>
<td>not equal的缩写，不相等返回真</td>
</tr>
<tr>
<td>-gt</td>
<td>&gt;</td>
<td>大于greater than</td>
</tr>
<tr>
<td>-ge</td>
<td>&gt;=</td>
<td>大于等于 greate equal</td>
</tr>
<tr>
<td>-lt</td>
<td>&lt;</td>
<td>小于类似less than</td>
</tr>
<tr>
<td>-le</td>
<td>&lt;=</td>
<td>小于等于less equal</td>
</tr>
</tbody>
</table>
<h3 id="逻辑操作符">逻辑操作符</h3>
<table>
<thead>
<tr>
<th>在[ ]中使用的比较符</th>
<th>在[[ ]]中使用的比较符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>&amp;&amp;</td>
<td>and 与，两端都为真，则真</td>
</tr>
<tr>
<td>-o</td>
<td>||</td>
<td>or 或，两端有一个为真则真</td>
</tr>
<tr>
<td>!</td>
<td>!</td>
<td>not 非，相反则为真</td>
</tr>
</tbody>
</table>
<h2 id="字体颜色">字体颜色</h2>
<p>颜色范围：30-37</p>
<pre><code class="language-bash">echo -e &quot;\033[30m 黑字体 test \033[0m&quot;
echo -e &quot;\033[31m 红字体 test \033[0m&quot;
echo -e &quot;\033[32m 绿字体 test \033[0m&quot;
echo -e &quot;\033[33m 黄字体 test \033[0m&quot;
echo -e &quot;\033[34m 蓝字体 test \033[0m&quot;
echo -e &quot;\033[35m 紫字体 test \033[0m&quot;
echo -e &quot;\033[36m 天蓝字 test \033[0m&quot;
echo -e &quot;\033[37m 白色字 test \033[0m&quot;
</code></pre>
<p>40-47</p>
<pre><code class="language-bash">echo -e &quot;\033[40;37m 黑底白字 welcome \033[0m&quot;
echo -e &quot;\033[41;37m 红底白字 welcome \033[0m&quot; 
echo -e &quot;\033[42;37m 绿底白字 welcome \033[0m&quot; 
echo -e &quot;\033[43;37m 黄底白字 welcome \033[0m&quot; 
echo -e &quot;\033[44;37m 蓝底白字 welcome \033[0m&quot; 
echo -e &quot;\033[45;37m 紫底白字 welcome \033[0m&quot; 
echo -e &quot;\033[46;37m 天蓝底白字 welcome \033[0m&quot; 
echo -e &quot;\033[47;37m 白底白字 welcome \033[0m&quot; 
echo -e &quot;\033[47;30m 白底黑字 welcome \033[0m&quot; 
</code></pre>
<h3 id="通过定义变量方式给字体加颜色">通过定义变量方式给字体加颜色</h3>
<pre><code class="language-bash">#!/bin/bash
red='\033[31m'
green='\033[32m'
yellow='\033[33m'
blue='\033[34m'
pink='\E[1;35m'
end='\E[0m'

echo -e &quot;${red} ======red======${end}&quot;
echo -e &quot;${yellow} =====yellow=====${end}&quot;
</code></pre>
<h2 id="循环">循环</h2>
<h3 id="当型循环和直到型循环">当型循环和直到型循环</h3>
<pre><code class="language-bash">while条件句
语法：
while 条件
do
指令...
done
</code></pre>
<p>until</p>
<pre><code class="language-bash">until 条件.
do
指令...
done
</code></pre>
<p>for循环</p>
<pre><code>for varName in 变量取值列表
do
 	指令...
done
</code></pre>
<h3 id="读取文件">读取文件</h3>
<pre><code class="language-bash">1. 
cat.log|while read line
do
done
2.
while read line
do
done&lt;a.log
3)
exec &lt;a.log
while read line
do
done
</code></pre>
<h3 id="linux产生随机数的">linux产生随机数的</h3>
<ul>
<li>
<p>系统环境变量<code>$RANDAM</code> 范围 ==0-32767==</p>
<ul>
<li>
<p>随机数01-99之间的数字</p>
<pre><code class="language-bash">$[RANDOM%99+1] # 一个数和一个数取余这个数，这个数一定小于这个数
</code></pre>
</li>
</ul>
</li>
<li>
<p>openssl: <code> openssl rand -base64 8</code></p>
</li>
<li>
<p>通过时间获得随机数（date）: <code>date +%s%N</code></p>
</li>
<li>
<p><code>/dev/random</code>设备：/dev/random设备，存储着系统当前运行的环境的实时数据。它可以看作是系统某个时候，唯一值数据，因此可以用作随机数元数据。我们可以通过文件读取方式，读得里面数据。我们可以通过文件读取方式，读得里面数据。/dev/urandom这个设备数据与random里面一样。只是，他是非阻塞的随机数发生器，读取操作不会产生阻塞。</p>
</li>
<li>
<p>UUID：<code>cat /proc/sys/kernel/random/uuid</code></p>
</li>
<li>
<p><code>mkpasswd -l 8</code></p>
</li>
</ul>
<h2 id="数组">数组</h2>
<p>Shell 数组用==括号==来表示，元素用==&ldquo;空格&rdquo;==符号分割开：<code>array=(value1 value2 ... valuen)</code></p>
<ul>
<li>使用下标来定义数组: 	<code>array[0]=value0</code></li>
<li>读取数组：<code>${array[index]}</code></li>
<li>数组中的所有元素：<code>${array[*]}&quot;</code> 或  <code>${array[@]}&quot;</code></li>
<li>数组的长度：<code> ${#array[*]}</code> 或  <code> ${#array[@]}</code></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>awk常用案例</title>
      <link>https://www.oomkill.com/2021/06/awesome-awk-command/</link>
      <pubDate>Wed, 02 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/06/awesome-awk-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h3 id="awk运算符">AWK运算符</h3>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>运算符</strong></th>
<th style="text-align:left"><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>赋值运算符</em></td>
<td style="text-align:left"><strong>= += -= *= /= %= ^= **=</strong></td>
</tr>
<tr>
<td style="text-align:center"><em>逻辑运算符</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><strong>||</strong></td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:center"><strong>&amp;&amp;</strong></td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:center"><em>正则运算符</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><strong>~ !~</strong></td>
<td style="text-align:left">匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td style="text-align:center"><em>关系运算符</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><strong>&lt; &lt;= &gt; &gt;= != ==</strong></td>
<td style="text-align:left">关系运算符</td>
</tr>
<tr>
<td style="text-align:center"><em>算术运算符</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><strong>+ -</strong></td>
<td style="text-align:left">加，减</td>
</tr>
<tr>
<td style="text-align:center">*** / &amp;**</td>
<td style="text-align:left">乘，除与求余</td>
</tr>
<tr>
<td style="text-align:center"><strong>+ - !</strong></td>
<td style="text-align:left">一元加，减和逻辑非</td>
</tr>
<tr>
<td style="text-align:center"><strong>^ ***</strong></td>
<td style="text-align:left">求幂</td>
</tr>
<tr>
<td style="text-align:center"><strong>++ &ndash;</strong></td>
<td style="text-align:left">增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td style="text-align:center"><em>其他运算符</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"><strong>$</strong></td>
<td style="text-align:left">字段引用</td>
</tr>
<tr>
<td style="text-align:center"><strong>空格</strong></td>
<td style="text-align:left">字符串链接符</td>
</tr>
<tr>
<td style="text-align:center"><strong>?</strong>:</td>
<td style="text-align:left">三目运算符</td>
</tr>
<tr>
<td style="text-align:center"><strong>In</strong></td>
<td style="text-align:left">数组中是否存在某键值</td>
</tr>
</tbody>
</table>
<h3 id="内置变量">内置变量</h3>
<table>
<thead>
<tr>
<th><strong>变量名</strong></th>
<th><strong>属性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>$0</strong></td>
<td>当前记录</td>
</tr>
<tr>
<td><strong>1</strong> <strong>n</strong></td>
<td>当前记录的第 n 个字段</td>
</tr>
<tr>
<td><strong>FS</strong></td>
<td>输入字段分隔符 默认是空格</td>
</tr>
<tr>
<td><strong>RS</strong></td>
<td>输入记录分割符 默认为换行符</td>
</tr>
<tr>
<td><strong>NF</strong></td>
<td>当前记录中的字段个数，就是有多少列</td>
</tr>
<tr>
<td><strong>NR</strong></td>
<td>已经读出的记录数，就是行号，从 1 开始</td>
</tr>
<tr>
<td><strong>OFS</strong></td>
<td>输出字段分隔符 默认也是空格</td>
</tr>
<tr>
<td><strong>ORS</strong></td>
<td>输出的记录分隔符 默认为换行符</td>
</tr>
</tbody>
</table>
<h3 id="特殊模式">特殊模式</h3>
<table>
<thead>
<tr>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>BEGIN</td>
<td>awk 将在读取任何输入行之前立即执行BEGIN 中指定的动作</td>
</tr>
<tr>
<td>END</td>
<td>awk 将在它正式退出前执行 END中指定的动作</td>
</tr>
</tbody>
</table>
<h3 id="用法">用法</h3>
<ul>
<li>
<p>去掉空白：<code>awk 'NF' file</code></p>
</li>
<li>
<p>统计行数： <code>awk 'END{print NR}' file</code> (END)</p>
</li>
<li>
<p>偶数行：<code>awk 'NR%2==0 {print $n}' file</code></p>
</li>
<li>
<p>奇数行：<code>awk 'a=!a' file</code></p>
</li>
<li>
<p>指定分隔符： <code>awk -F &quot;:&quot; '{print $1}' file</code></p>
</li>
<li>
<p>使用正则： <code> awk '/^tecmint.com/ { counter+=1 ; printf &quot;%s\n&quot;, counter ; }' file</code></p>
</li>
<li>
<p>打印多列：<code>awk -F &quot;:&quot; '{print $1 $2 .. $(NF-1) $NF}' /etc/passwd</code></p>
</li>
<li>
<p>多分隔符的用法：<code>echo i am a protester,myqq is 1112222|awk  -F '[, ]' '{print $4 &quot; &quot; $7}'</code></p>
</li>
<li>
<p>多个分隔符使用正则：<code>awk -F&quot;/|=&quot; '{print $3, $5, $NF}' file</code></p>
</li>
<li>
<p>使用<code>[]</code>作为分隔符：<code>awk -F '[][]' '{print $3;}' data</code> (这里<code>[</code> <code>]</code> 分别占用两列 2个<code>$</code>)</p>
</li>
<li>
<p>获取以 <code>[]</code>内的值： <code>awk -F '[][*:]' '{print $8}'</code></p>
</li>
</ul>
<pre><code>echo &quot;[Remote_ip:10.41.58.88] [Remote_user:-] [Querytime:12/Nov/2021:15:50:11 +0800] [Request_url:POST /zeusweb-1/index.php?r=task/ws&amp;ws=1 HTTP/1.1] [Request_status:200] [Request_byte_B:1080] [Request_time_s:4.375] [Http_referer:-] [Http_agent:PHP-SOAP/5.4.25]&quot;|awk -F '[][*:]' '{print $8}'
</code></pre>
<pre><code>也可以使用 `awk -F '[][*:]' '{print $8}'`
</code></pre>
<pre><code>[ Remote_ip:10.41.58.88 ] [ Remote_user: - ] [ Querytime : 12/Nov/2021:15:50:11 +0800 ]
^ ^^^^^^^^^ ^^^^^^^^^^^  ^  ^^^^^^^^^^^  ^  ^  ^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^
1  2        3      4   5        6  7  8        9                  10    
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>长期总结 - Linux网络命令合集</title>
      <link>https://www.oomkill.com/2021/01/linux-network-command/</link>
      <pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/01/linux-network-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>作为系统管理员或程序员，经常需要诊断分析和解决网络问题，而配置、监控与保护网络有助于发现问题并在事情范围扩大前得意解决，并且网络的性能与安全也是管理与诊断网络的重要部分。本文将总结常用与Linux网络管理的命令与使用示例，保持长期更新与更正。</p>
<h2 id="ip">IP</h2>
<p><code>iproute2</code> 包含网络、路由、ARP缓存等的管理与配置的<code>ip</code>命令，用来取代传统的 <code>ifconfig</code> 与 <code>route</code>；<code>ip</code> 使用第二个参数，指定在对象执行的操作（例如，<code>add</code> <code>delete</code> <code>show</code>）。</p>
<p>ip 命令是配置网络接口的强大工具，任何 Linux 系统管理员都应该知道。它用于启动或关闭接口、分配和删除地址和路由、管理 ARP 缓存等等。</p>
<p><code>ip</code> 常用的子命令有：</p>
<ul>
<li><code>link</code> (<code>l</code>)  网络接口管理</li>
<li><code>address</code> (<code>a</code>)  IP地址管理</li>
<li><code>route</code> (<code>r</code>)  路由表管理</li>
<li><code>neigh</code> (<code>n</code>)  arp表管理</li>
</ul>
<blockquote>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>iproute2</code>  ；<code>apt install iproute2</code></li>
<li>CentOS/Fedora: <code>iproute2</code> ；<code>yum install -y iproute2</code></li>
<li>Apline：<code>iproute2 </code> ；<code>apk add iproute2</code></li>
</ul>
</blockquote>
<h3 id="ip-link">ip link</h3>
<p><code>ip link</code> 用于管理和显示网络接口</p>
<h3 id="获取网络接口信息ip-link-show">获取网络接口信息ip link show</h3>
<p>查看特定设备信息</p>
<pre><code class="language-bash">ip link show dev [device]
</code></pre>
<p>查看所有网络接口的统计信息（如传输或丢弃的数据包，错误等等）：</p>
<pre><code class="language-bash">ip -s link
</code></pre>
<p>查看单个网络接口的类似信息：</p>
<pre><code class="language-bash">ip -s link ls [interface]
</code></pre>
<p>例如</p>
<pre><code>$ ip -s link ls eth0
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq state UP mode DEFAULT group default qlen 1000
    link/ether da:78:c8:7a:fb:26 brd ff:ff:ff:ff:ff:ff
    RX: bytes  packets  errors  dropped overrun mcast   
    38626072259 324723879 0       347316  0       0       
    TX: bytes  packets  errors  dropped carrier collsns 
    13404948080 6829250  0       0       0       0       
</code></pre>
<p>如果需要显示更多的详情，可以再添加一个 <code>-s</code></p>
<pre><code class="language-bash">ip -s -s link ls [interface]
</code></pre>
<p>仅查看启动（运行）的接口列表</p>
<pre><code class="language-bash">ip link ls up
</code></pre>
<h3 id="修改网络接口信息-ip-link-set">修改网络接口信息 ip link set</h3>
<p>查看 <code>ip link</code> 的帮助</p>
<pre><code class="language-bash">ip link help
</code></pre>
<p>启动/关闭网络接口</p>
<pre><code class="language-bash">ip link set [interface] up/down
</code></pre>
<p><code>ip link</code> 可以修改设备传输队列的长度</p>
<pre><code class="language-bash">ip link set txqueuelen [number] dev [interface]
</code></pre>
<p>设置 <strong>MTU</strong> (Maximum Transmission Unit) 来提高网络性能</p>
<pre><code class="language-bash">ip link set mtu [number] dev [interface]
</code></pre>
<p>###查看与管理IP地址 ip addr</p>
<p>显示所有设备</p>
<pre><code class="language-bash">ip addr 
</code></pre>
<p>列出网络接口与IP地址</p>
<pre><code class="language-bash">ip addr show
</code></pre>
<p>查看单个网络设备的信息</p>
<pre><code class="language-bash">ip addr show dev [interface]
</code></pre>
<p>列出 IPv4/IPv6 地址</p>
<pre><code class="language-bash">ip -4 addr
ip -6 addr
</code></pre>
<p>在Linux中添加网络地址</p>
<pre><code class="language-bash">ip addr add [ip_address] dev [interface]
</code></pre>
<p>添加广播地址</p>
<pre><code class="language-bash">ip addr add brd [ip_address] dev [interface]
</code></pre>
<p>删除接口上的网络地址</p>
<pre><code class="language-bash">ip addr del [ip_address] dev [interface]
</code></pre>
<h3 id="管理路由表-ip-route">管理路由表 ip route</h3>
<h3 id="显示路由表-ip-route-list">显示路由表 ip route list</h3>
<pre><code class="language-bash">ip route
ip route list
</code></pre>
<p>选择范围；上述命令列出内核内所有路由条目，如果想要缩小范围可以使用选择器 SELECTOR</p>
<p>语法：<code>ip route list SELECTOR</code></p>
<p><strong>SELECTOR</strong>:</p>
<ul>
<li>
<p><strong>root</strong>：[ local | main | default | all | NUMBER ]</p>
</li>
<li>
<p><strong>match</strong>：</p>
<p>[ match PREFIX ]</p>
</li>
</ul>
<pre><code class="language-bash"> ip route list match 10
</code></pre>
<ul>
<li>
<p><strong>exact</strong>： [ exact PREFIX ]</p>
</li>
<li>
<p><strong>TABLE</strong></p>
<p>[ table TABLE_ID ] [ local | main | default | all | NUMBER ]</p>
</li>
</ul>
<pre><code class="language-bash"> ip route list table local
 
 broadcast 127.0.0.0 dev lo proto kernel scope link src 127.0.0.1 
 local 127.0.0.0/8 dev lo proto kernel scope host src 127.0.0.1 
 local 127.0.0.1 dev lo proto kernel scope host src 127.0.0.1 
 broadcast 127.255.255.255 dev lo proto kernel scope link src 127.0.0.1 
 broadcast 195.133.10.0 dev eth0 proto kernel scope link src 195.133.11.43 
 local 195.133.11.43 dev eth0 proto kernel scope host src 195.133.11.43 
 broadcast 195.133.11.255 dev eth0 proto kernel scope link src 195.133.11.43 
</code></pre>
<ul>
<li>
<p><strong>PROTO</strong></p>
<p>[ proto RTPROTO ] [ kernel | boot | static | NUMBER ]</p>
</li>
</ul>
<pre><code> ip route list proto static
</code></pre>
<ul>
<li>
<p><strong>TYPE</strong></p>
<p>[ type TYPE ] { unicast | local | broadcast | multicast | throw |unreachable | prohibit | blackhole | nat }</p>
</li>
</ul>
<pre><code> ip route list type multicast
</code></pre>
<ul>
<li>
<p><strong>SCOPE</strong></p>
<p>[ scope SCOPE ] [ host | link | global | NUMBER ]</p>
</li>
</ul>
<pre><code> ip route list scope link
 
 169.254.0.0/16 dev eth0 metric 1002 
 172.16.0.0/20 dev eth0 proto kernel src 172.16.0.2 
</code></pre>
<h3 id="修改路由表-ip-route-adddel">修改路由表 ip route add/del</h3>
<p>在指定设备上添加路由条目</p>
<pre><code class="language-bash">ip route add [ip_address] dev [interface]
</code></pre>
<p>通过网关添加新路由</p>
<pre><code class="language-bash">ip route add [ip_address] via [gatewayIP]
</code></pre>
<p>通过本地网关为<strong>所有</strong>地址添加默认路由</p>
<pre><code class="language-bash">ip route add default [ip_address] dev [device]

ip route add default [network/mask] via [gatewayIP]
</code></pre>
<p>删除已经存在的路由表</p>
<pre><code class="language-bash">ip route del [ip_address]
ip route del default
ip route del [ip_address] dev [interface]
</code></pre>
<h3 id="arp地址表管理--ip-neighbor">ARP地址表管理  ip neighbor</h3>
<h3 id="显示arp-条目-ip-neigh-show">显示arp 条目 ip neigh show</h3>
<p>显示系统中设备的MAC地址及其状态。设备存在的状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>REACHABLE</strong></td>
<td>在超时过期之前有效且可访问的条目</td>
</tr>
<tr>
<td><strong>PERMANENT</strong></td>
<td>管理员才能删除的永久条目</td>
</tr>
<tr>
<td><strong>STALE</strong></td>
<td>有效但无法访问的条目；为了检查它的状态，内核在第一次传输时检查</td>
</tr>
</tbody>
</table>
<p>例如</p>
<pre><code class="language-bash">ip neigh show

192.168.10.1 dev eth0 lladdr 00:1f:ce:72:bd:8c REACHABLE
46.17.40.155 dev eth0 lladdr c4:71:fe:f1:9f:3f STALE
2a00:b700:3::1 dev eth0 lladdr 00:1f:ce:72:bd:8c router STALE
fe80::f0c5:a5ff:fee8:2aa4 dev eth0 lladdr f2:c5:a5:e8:2a:a4 router STALE
fe80::a48a:1eff:fe35:c2f7 dev eth0 lladdr a6:8a:1e:35:c2:f7 router STALE
fe80::4c4d:b3ff:fe44:fd58 dev eth0 lladdr 4e:4d:b3:44:fd:58 router STALE
fe80::4c33:dfff:fe92:9f2f dev eth0 lladdr 4e:33:df:92:9f:2f router STALE
fe80::21f:ceff:fe72:bd8c dev eth0 lladdr 00:1f:ce:72:bd:8c router STALE
</code></pre>
<h3 id="修改arp条目-ip-neigh-adddel">修改arp条目 ip neigh add/del</h3>
<pre><code class="language-bash">ip neigh add [ip_address] dev [interface]

ip neigh del [ip_address] dev [interface]
</code></pre>
<h2 id="traceroute">traceroute</h2>
<p><code>traceroute</code> 可以追踪数据传输是如何从本地传输到远程的。一个典型的例子是网页的访问。在互联网上加载一个网页需要数据流经一个网络和许多路由器。<code>traceroute</code> 可以显示所采用的路由以及网络上路由器的IP和主机名。它可以应用于排查网络延迟或诊断网络问题。</p>
<blockquote>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>traceroute</code>  ；<code>apt install traceroute -y</code></li>
<li>CentOS/Fedora: <code>traceroute</code> ；<code>yum install -y traceroute</code></li>
<li>Apline：<code>busybox </code> ；<code>apk add busybox</code></li>
</ul>
</blockquote>
<h3 id="追踪网络主机的路由-traceroute-host">追踪网络主机的路由 traceroute host</h3>
<pre><code class="language-bash">traceroute baidu.com

traceroute to baidu.com (220.181.38.148), 30 hops max, 60 byte packets
 1  * 9.31.61.129 (9.31.61.129)  1.795 ms *
 2  9.31.123.98 (9.31.123.98)  0.907 ms  1.179 ms  1.416 ms
 3  10.196.18.109 (10.196.18.109)  0.866 ms 10.196.18.125 (10.196.18.125)  1.085 ms *
 4  10.162.33.5 (10.162.33.5)  1.297 ms 10.200.16.169 (10.200.16.169)  0.774 ms 10.196.92.109 (10.196.92.109)  1.218 ms
 5  10.162.32.145 (10.162.32.145)  1.539 ms  1.431 ms 10.162.32.149 (10.162.32.149)  1.310 ms
 6  * * *
 7  58.63.249.45 (58.63.249.45)  7.320 ms * 121.14.50.25 (121.14.50.25)  7.859 ms
 8  * * 113.96.4.121 (113.96.4.121)  4.887 ms
 9  202.97.22.149 (202.97.22.149)  32.481 ms 202.97.22.153 (202.97.22.153)  32.676 ms
10  36.110.245.206 (36.110.245.206)  36.928 ms 36.110.247.54 (36.110.247.54)  37.593 ms 36.110.245.82 (36.110.245.82)  41.254 ms
11  36.110.245.161 (36.110.245.161)  33.749 ms *  37.905 ms
12  * * *
13  * * 220.181.182.170 (220.181.182.170)  42.998 ms
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  * * *
25  * * *
26  * * *
27  * * *
28  * * *
29  * * *
30  * * *
</code></pre>
<p>第一行显示要访问的主机名和ip、traceroute将尝试到主机的最大跃点数以及要发送的字节数据包的大小。</p>
<p>每行列出到达目的地的一个跳跃点。给出主机名与主机名的ip，然后是数据包到达主机并返回发起计算机所需的时间。默认情况下，<code>traceroute</code> 为每个主机发送三个数据包，因此列出了三个响应时间。</p>
<p>星号 <code>*</code> 表示丢失的数据包。这意味着网络中断、大量流量导致网络拥塞或防火墙丢弃流量。</p>
<h3 id="追踪ipv6协议">追踪IPv6协议</h3>
<pre><code class="language-bash">traceroute -6 ipv6.google.com
</code></pre>
<h3 id="忽略主机名与ip的映射">忽略主机名与IP的映射</h3>
<p>使用-n选项在traceroute中禁用IP地址映射。</p>
<pre><code class="language-bash">traceroute -n qq.com

traceroute to qq.com (183.3.226.35), 30 hops max, 60 byte packets
 1  9.31.61.129  0.908 ms  1.159 ms  1.537 ms
 2  9.31.122.210  1.061 ms  0.837 ms  1.421 ms
</code></pre>
<h3 id="设置相应等待时间">设置相应等待时间</h3>
<p>使用 <code>-w </code> 选项在<code>traceroute</code> 中配置响应等待时间，支持指定等待对探测的响应的时间（秒为单位）。</p>
<pre><code class="language-bash">traceroute -w 1 -n qq.com
</code></pre>
<h3 id="使用特定的网络接口">使用特定的网络接口</h3>
<p>使用-i选项设置traceroute应使用的网络接口，如果未设置，则根据路由表选择接口。</p>
<pre><code class="language-bash">traceroute -w 1 -n -i eth0 qq.com
</code></pre>
<h2 id="ping">ping</h2>
<p>Ping是一种简单、广泛使用的跨平台网络工具，用于测试主机是否可以在Internet协议（IP）网络上访问。它的工作原理是向目标主机发送网络控制消息协议<strong>Internet Control Message Protocol</strong> (<strong>ICMP</strong>) <strong>ECHO_REQUEST</strong>，目标节点等待并回复 <strong>ECHO_RESPONSE</strong>。</p>
<p>可以使用<code>ping</code> 测试两节点间的网络通信，可以做到：</p>
<ul>
<li>目标主机是否可用，</li>
<li>测量数据包到达目标主机并返回计算机所需的时间（与目标主机通信的往返时间（rtt）），以及数据包丢失的百分比。</li>
</ul>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>iputils-ping</code>  ；<code>apt install iputils-ping</code></li>
<li>CentOS/Fedora: <code>iputils</code> ；<code>yum install -y iputils</code></li>
<li>Apline：<code>iputils </code> ；<code>apk add iputils</code></li>
</ul>
</blockquote>
<p>使用参数</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-c</td>
<td>指定发送<strong>ECHO_REQUEST</strong>的请求数</td>
</tr>
<tr>
<td style="text-align:center">-i</td>
<td>设置包与包之间的间隔 <code>ping -i 3 -c 5 www.google.com</code></td>
</tr>
<tr>
<td style="text-align:center">-f</td>
<td>flood ping，检测高负载下的响应，需要有root权限</td>
</tr>
<tr>
<td style="text-align:center">-b</td>
<td>允许ping一个广播地址</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td>限制ping遍历的网络跳跃数（TTL <strong>Time-to-live</strong>），收到数据包的每个路由器从计数中至少减去 1，如果大于 0，路由器会将数据包转发到下一跳，否则它会丢弃它并将 ICMP 响应返回。</td>
</tr>
<tr>
<td style="text-align:center">-s</td>
<td>设置ping时的数据包大小（单位 bytes），这将导致提供的总数据包大小加上ICMP头的8个额外字节。</td>
</tr>
<tr>
<td style="text-align:center">-l</td>
<td>发送预加载数据包（先发不等待回复的数据包），大于3需要root权限</td>
</tr>
<tr>
<td style="text-align:center">-W</td>
<td>设置等待相应时间，单位秒</td>
</tr>
<tr>
<td style="text-align:center">-w</td>
<td>设置超时时间，超时退出，单位秒</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td>debug模式</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td>显示详细输出</td>
</tr>
<tr>
<td style="text-align:center">-A</td>
<td>更快的在两节点间包往返的时间，非特权用户最小为200ms</td>
</tr>
</tbody>
</table>
<h2 id="hping">hping</h2>
<p>hping一个具有可嵌入tcl脚本功能的 <code>TCP/IP</code>包伪造工具。，主要用于创建或生成网络数据包以测试网络、服务或系统性能。 hping 是由不同实体开发的旧工具，并以 <code>hping2</code> 或 <code>hping3</code> 等新版本命名。 在大多数情况下，您可以使用操作系统提供的命令，可以是 hping 或 hping2 或 hping3。 hping 名称源自 ping 命令名称。<code>hping3</code> 是另一种用于扫描网络的工具。它在kali linux中默认是DOS攻击软件之一。</p>
<p>hping支持TCP、UDP、ICMP、raw-IP等协议用于不同的用例。通过使用hping，可以创建具有不同选项的不同协议包。hping主要可以用作。</p>
<ul>
<li>创建原始IP数据包</li>
<li>生成指定数量的数据包</li>
<li>设置包发送间隔</li>
<li>指定传输网络接口</li>
<li>创建和生成TCP数据包</li>
<li>创建和生成UDP数据包</li>
<li>创建和生成IP数据包</li>
<li>创建和生成ICMP数据包</li>
<li>设置MTU值</li>
<li>设置碎片并创建碎片或未碎片的数据包</li>
<li>设置数据包的有效负载或数据大小</li>
</ul>
<p>hping的常用场景</p>
<ul>
<li>模拟DOS和DDOS攻击</li>
<li>测试防火墙和TCP、UDP、IP等协议的防火墙配置</li>
<li>TCP和UDP端口扫描</li>
<li>测试网络设备的配置，如碎片、MTU等。</li>
<li>用于列出中间主机的高级跟踪路由</li>
<li>远程操作系统指纹识别和检测</li>
<li>远程正常运行时间决策</li>
<li>TCP/IP协议实现与栈测试审计</li>
</ul>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>hping3</code>  ；<code>apt install hping3</code></li>
<li>CentOS/Fedora: <code>hping3</code> ；<code>yum install epel-release &amp;&amp; yum install -y hping3</code></li>
<li>Apline：<code>hping3 </code> ；<code>apk add hping3 --update-cache --repository http://dl-cdn.alpinelinux.org/alpine/edge/testing</code></li>
</ul>
</blockquote>
<h3 id="参数说明">参数说明</h3>
<p><strong>基础参数</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数选项</th>
<th style="text-align:left">参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-c --count [count]</code></td>
<td style="text-align:left">发送数据包的次数 关于countreached_timeout 可以在hping2.h里编辑</td>
</tr>
<tr>
<td style="text-align:left"><code>-i --interval  </code></td>
<td style="text-align:left">每个包发送间隔时间(单位是毫秒) 缺省时间是1秒,此功能在增加传输率上很重要。<br> <code>-i 1  </code>  为1s  <br><code>-i u1</code> 为1us （微秒） 即每秒发送1000000包</td>
</tr>
<tr>
<td style="text-align:left"><code>--fast</code></td>
<td style="text-align:left">为 <code> -i u10000</code> 的别名，即1秒发送10个包</td>
</tr>
<tr>
<td style="text-align:left"><code>--faster</code></td>
<td style="text-align:left">为 <code>-i u1</code> 的别名，但实际上发送的包取决于计算机的速度</td>
</tr>
<tr>
<td style="text-align:left"><code> --flood</code></td>
<td style="text-align:left">尽可能快速的发送包，不关注收到的恢复，要比 <code>-i u0</code> 快</td>
</tr>
<tr>
<td style="text-align:left"><code>-I --interface [interface name]</code></td>
<td style="text-align:left">指定默认的路由接口，在linux中，hping3使用默认路由接口。<br/>可以使用 <code>-I</code> 接网络接口的完整名称，如 <code>eth0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-q -quiet </code></td>
<td style="text-align:left">安静输出。除了启动时和完成时的摘要信息外，不输出任何内容。</td>
</tr>
<tr>
<td style="text-align:left"><code>-n -nmeric</code></td>
<td style="text-align:left">数字化输出主机地址</td>
</tr>
</tbody>
</table>
<p><strong>协议选项</strong></p>
<p>默认情况下，hping使用的为tcp协议</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-0 --rawip</code></td>
<td>原始IP模式，此模式下，hping3将发送IP头。</td>
</tr>
<tr>
<td><code>-1 --icmp</code></td>
<td>ICMP模式，默认情况下hping3将发送ICMP回显请求。</td>
</tr>
<tr>
<td><code>-2 --udp</code></td>
<td>UDP模式，默认情况下，hping3将向目标主机的0端口发送UDP</td>
</tr>
<tr>
<td><code>-8 --scan</code></td>
<td>端口扫描，在该模式下，需要提供一组端口，如 <code>1,2,3</code> 端口组以 <code>,</code> 分隔<br>端口范围：<code>start-end</code>  如 <code>1000-2000</code> <br>特殊字符：<code>all</code> 表示所有端口；<code>know</code> ：包含 <code>/etc/services</code> 中的所有端口<br>组合写法：<code>hping --scan 1-1000,8888,known -S www.baidu.com</code></td>
</tr>
<tr>
<td><code> -9 --listen signature</code></td>
<td>监听模式，此模式下 <code>hping3</code>  等待包含签名的数据包并从签名端转储到数据包的结尾处。</td>
</tr>
</tbody>
</table>
<p><strong>IP相关选项</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a --spoof hostname</code></td>
<td>此选项可以伪造源IP地址，可确保目标不会获得真实IP地址，必然性的响应将被发送到伪造的地址处。</td>
</tr>
<tr>
<td><code>--rand-source</code></td>
<td>此选项开启随机源模式。hping将发送带有随机源地址的数据包。</td>
</tr>
<tr>
<td><code>--rand-dest</code></td>
<td>此选项开启随机目标模式。hping将数据包发送到随机目标地址<br/>如，当使用随机目标地址时，可以使用<code>x</code> 作为范围，所有出现的 <code>x</code> 都将呗替换为0-255之间的随机数。如<code>10.0.0.x</code>。可以使用<code>--debug</code> 选项查看生成的随机地址。<br/>注意：使用此选项，hping无法检测数据包的正确传出接口，应使用 <code>-I </code>选项指定网络接口。</td>
</tr>
<tr>
<td><code>-t --ttl</code></td>
<td>此选项可以设置传出数据包的TTL（生存时间）</td>
</tr>
<tr>
<td><code>-N id</code></td>
<td>设置IP字段的随机值</td>
</tr>
<tr>
<td><code>-H --ipproto</code></td>
<td>在RAW IP模式中设置IP协议</td>
</tr>
<tr>
<td><code> -r --rel</code></td>
<td>ip id等增量</td>
</tr>
<tr>
<td><code>-m –mtu</code></td>
<td>设置虚拟最大传输单元</td>
</tr>
</tbody>
</table>
<p><strong>icmp选项</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-C --icmptype type</code></td>
<td>设置icmp类型，默认为icmp echo reques。</td>
</tr>
<tr>
<td><code>--icmp-ipver</code></td>
<td>设设置包含在ICMP数据中的IP头的IP版本，默认值为4。</td>
</tr>
<tr>
<td><code>--icmp-ipproto</code></td>
<td>设置包含在ICMP数据中的IP头的IP协议，默认为TCP。</td>
</tr>
</tbody>
</table>
<p><strong>TCP/UDP选项</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-s --baseport [src port]</code></td>
<td>随机源端口</td>
</tr>
<tr>
<td><code>-p --destport [dest port]</code></td>
<td>设置目标端口<br><code>+</code> 目标端口将随着收到的每个回复而增加<br><code>++</code> 目标端口每发送数据包都会增加</td>
</tr>
<tr>
<td>&ndash;keep</td>
<td>保持源端口不边</td>
</tr>
<tr>
<td>-w &ndash;win</td>
<td>设置tcp窗口大小，默认64</td>
</tr>
<tr>
<td>-F &ndash;fin</td>
<td>设置 tcp fin标记</td>
</tr>
<tr>
<td>-S &ndash;syn</td>
<td>设置 tcp SYN标记</td>
</tr>
<tr>
<td>-R &ndash;rst</td>
<td>设置 tcp rst标记</td>
</tr>
<tr>
<td>-P &ndash;push</td>
<td>设置 tcp PUSH标记</td>
</tr>
<tr>
<td>-A &ndash;ack</td>
<td>设置 tcp ACK标记</td>
</tr>
<tr>
<td>-U &ndash;urg</td>
<td>设置 tcp URG标记</td>
</tr>
<tr>
<td>-X &ndash;xmas</td>
<td>设置 tcp Xmas标记</td>
</tr>
<tr>
<td>-Y &ndash;ymas</td>
<td>设置 tcp Ymas标记</td>
</tr>
</tbody>
</table>
<p><strong>常用参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d --data</code></td>
<td>设置数据包主体大小。 <code>使用 --data 40</code> hping将在 protocol_header 增加40 字节。</td>
</tr>
<tr>
<td><code>-E --file [filename]</code></td>
<td>使用文件名内容填充数据包的数据</td>
</tr>
<tr>
<td><code> -j --dump</code></td>
<td>以16进制导出数据包</td>
</tr>
<tr>
<td><code>-J --print</code></td>
<td>导出可打印的数据包</td>
</tr>
<tr>
<td><code>-u --end</code></td>
<td>如果使用 ``&ndash;file filename` 选项，何时为EOF。</td>
</tr>
<tr>
<td><code>-T --traceroute</code></td>
<td>traceroute 模式。此选项将在接收ttl来尝试追踪。</td>
</tr>
<tr>
<td><code>--tr-keep-ttl</code></td>
<td>保持ttl的固定，用于监视某一跳</td>
</tr>
<tr>
<td><code>–tr-stop</code></td>
<td>traceroute 下收到第一个不是ICMP时退出</td>
</tr>
<tr>
<td>&hellip;.</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>输出格式</strong></p>
<p>hping的一个标准的TCP/UDP格式如下，UDP字段含义与TCP的相同。</p>
<pre><code class="language-bash"># tcp
len=46 ip=192.168.1.1 flags=RA DF seq=0 ttl=255 id=0 win=0 rtt=0.4 ms

# udp
len=46 ip=192.168.1.1 seq=0 ttl=64 id=0 rtt=6.0 ms
</code></pre>
<ul>
<li>len：len是从数据链路层捕获的数据的大小（字节），不包括数据链路头大小。</li>
<li>ip：  ip 为请求的ip</li>
<li>flags：flags为TCP的标记，如
<ul>
<li>R  RESET</li>
<li>S SYN</li>
<li>A  ACK</li>
<li>F FIN</li>
<li>P PUSH</li>
<li>U URGENT</li>
<li>X 不标准的 0x40</li>
<li>Y 不标准的 0x80</li>
</ul>
</li>
<li>seq：seq是数据包的序列号，使用TCP/UDP数据包的源端口获得</li>
<li>id  是IP ID字段。</li>
<li>win  TCP 窗口大小</li>
<li>rtt   往返时间 （round trip time），单位毫秒</li>
<li>以下是使用-V参数后的字段
<ul>
<li>tos 是IP标头的服务类型字段。</li>
<li>iplen ip的总长度</li>
<li>seq 和 ack 是TCP标头中的序列号和32位确认号</li>
<li>是TCP标头校验和值。</li>
<li>urp TCP紧急指针值。</li>
</ul>
</li>
</ul>
<p><strong>ICMP的输出格式</strong></p>
<pre><code class="language-bash">ICMP Port Unreachable from ip=192.168.1.1 name=nano.marmoc.net
</code></pre>
<p>在此格式中，ip 为 ICMP 错误的 IP 地址，name为解析的名称或者为UNKNOWN，而其他的参数含义与TCP/UDP大致相同。</p>
<h3 id="端口扫描">端口扫描</h3>
<p>hping可以自由地创建原始IP、TCP、UDP和ICMP数据包。可以利用此功能生成 <code>TCP SYN</code> 扫描。<code>TCP-SYN</code> 扫描是最简单的将数据包发送到主机/IP端口的方法。这里 扫描的为<code>110.242.68.4:80</code></p>
<p>启动经典的扫描的最简单方法是将TCP-SYN数据包发送到主机/ip上的端口。下面的命令将扫描IP 192.168.8.223上的端口80。从输出中，可以看到 <code>flags=SA</code> SYN和ACK标记，代表一个开放端口。</p>
<pre><code class="language-bash">hping3 -S 110.242.68.4 -p 80 -c 2
</code></pre>
<p>扫描一个范围的端口可以使用 <code>++</code></p>
<pre><code class="language-bash">hping3 -S 110.242.68.4 -p ++80
</code></pre>
<p>也可以使用如下方式</p>
<pre><code class="language-bash">hping3 -8 80-86 -S 110.242.68.4 

Scanning 110.242.68.4 (110.242.68.4), port 80-86
7 ports to scan, use -V to see all the replies
+----+-----------+---------+---+-----+-----+-----+
|port| serv name |  flags  |ttl| id  | win | len |
+----+-----------+---------+---+-----+-----+-----+
   80 http       : .S..A... 128 60936 64240    46
All replies received. Done.
Not responding ports: (81 ) (82 xfer) (83 mit-ml-dev) (84 ctf) (85 ) (86 mfcobol) 
</code></pre>
<h3 id="通过hping3跟踪路由到指定端口">通过Hping3跟踪路由到指定端口：</h3>
<p>hping3支持一个很实用功能，可以追踪路由到一个指出的端口，查看你的数据包被阻塞的地方。</p>
<pre><code class="language-bash">hping3 --traceroute -p 80 -V -1 www.google.com

using eth0, addr: 195.133.11.43, MTU: 1500
HPING www.google.com (eth0 142.250.150.104): icmp mode set, 28 headers + 0 data bytes
hop=1 TTL 0 during transit from ip=195.133.10.1 name=gateway   
hop=1 hoprtt=3.1 ms
hop=2 TTL 0 during transit from ip=10.11.12.37 name=UNKNOWN   
hop=2 hoprtt=10.0 ms
hop=3 TTL 0 during transit from ip=62.140.243.62 name=msk-m9-b1-ae30-vlan449.fiord.net
hop=3 hoprtt=1.9 ms
hop=4 TTL 0 during transit from ip=62.140.239.113 name=msk-m9-b6-ae1-vlan12.fiord.net
hop=4 hoprtt=9.8 ms
hop=5 TTL 0 during transit from ip=72.14.222.198 name=UNKNOWN   
hop=5 hoprtt=4.2 ms
hop=6 TTL 0 during transit from ip=108.170.250.33 name=UNKNOWN   
hop=6 hoprtt=3.8 ms
hop=7 TTL 0 during transit from ip=108.170.250.51 name=UNKNOWN   
hop=7 hoprtt=2.5 ms
hop=8 TTL 0 during transit from ip=142.251.49.158 name=UNKNOWN   
hop=8 hoprtt=34.7 ms
hop=9 TTL 0 during transit from ip=108.170.235.204 name=UNKNOWN   
hop=9 hoprtt=18.2 ms
hop=10 TTL 0 during transit from ip=142.250.209.35 name=UNKNOWN   
hop=10 hoprtt=17.1 ms
....
</code></pre>
<h3 id="不同类型的icmp">不同类型的ICMP</h3>
<pre><code class="language-bash">hping3 -c 5 -V -1 -C 17 110.242.68.4 

using eth0, addr: 10.0.0.4, MTU: 1500
HPING 110.242.68.4 (eth0 110.242.68.4): icmp mode set, 28 headers + 0 data bytes

--- 110.242.68.4 hping statistic ---
5 packets transmitted, 0 packets received, 100% packet loss
round-trip min/avg/max = 0.0/0.0/0.0 ms
</code></pre>
<p>通过hping3进行TCP FIN扫描</p>
<p>在TCP连接中，FIN标志用于开始请求关闭连接。万一没有得到答复，那说明端口是开放的。通常防火墙会再次发送Rst+ack数据包，以指示该端口已关闭。</p>
<h3 id="通过hping3-进行ack扫描">通过hping3 进行ACK扫描</h3>
<p>有些情况下，主机可能禁止PING ICMP，此时使用ACK扫描可以用于检查主机是否处于活动状态。如果主机活跃，会相应RST标记，在hping中是为 <code>flags=R</code>。</p>
<pre><code class="language-bash">hping3 -c 2 -V -p 80 -A 110.242.68.4 

using eth0, addr: 10.0.0.4, MTU: 1500
HPING 110.242.68.4 (eth0 110.242.68.4): A set, 40 headers + 0 data bytes
len=46 ip=110.242.68.4 ttl=128 id=2391 tos=0 iplen=40
sport=80 flags=R seq=0 win=32767 rtt=0.6 ms
seq=1165126080 ack=0 sum=c0ba urp=0
</code></pre>
<h3 id="udp扫描">UDP扫描</h3>
<p>使用参数 <code>-2</code> 可以让hping工作于UDP模式，可以进行UDP扫描</p>
<pre><code class="language-bash">hping3 -2 8.8.4.4 -V -p 53 -c 10
</code></pre>
<h3 id="操作系统识别">操作系统识别</h3>
<p>使用-Q或-seqnum可以让<code>hping</code> 收集了ISN。</p>
<pre><code class="language-bash">hping3 127.0.0.1 -Q -p 22 -V -S

using lo, addr: 127.0.0.1, MTU: 65536
HPING 127.0.0.1 (lo 127.0.0.1): S set, 40 headers + 0 data bytes
 893247485 +893247485
2568100167 +1674852682
2600543427 +32443260
</code></pre>
<h3 id="内容探测">内容探测</h3>
<p>可以使用hping的监听模式，来抓取通过网络接口的所有流量，以及捕获对应的内容。例如抓取通过谷歌搜索的流量包</p>
<pre><code class="language-bash">hping3 -9 &quot;www.google.com&quot; --beep -I eth0hping2 listen mode[main] memlockall(): SuccessWarning: can't disable memory paging!Accept: */*.hk/url?sa=p&amp;hl=zh-CN&amp;pref=hkredirect&amp;pval=yes&amp;q=http://www.google.com.hk/&amp;ust=1624605433464983&amp;usg=AOvVaw2THxd5w15lxgX3_KA19GWLCache-Control: privateContent-Type: text/html; charset=UTF-8P3P: CP=&quot;This is not a P3P policy! See g.co/p3phelp for more info.&quot;Date: Fri, 25 Jun 2021 07:16:43 GMTServer: gwsContent-Length: 370X-XSS-Protection: 0X-Frame-Options: SAMEORIGINSet-Cookie: 1P_JAR=2021-06-25-07; expires=Sun, 25-Jul-2021 07:16:43 GMT; path=/; domain=.google.com; SecureSet-Cookie: NID=217=PdQLBtU-tTavgvb4BW9ouB3nAr1OKNK6I_kn9u2Qa2eTgLA_qLyGv2G_2t2G_PRNVrKu2SOEm-e7ED17ljnx3uFBweBjQWOyRvHrJ6jhC5_J3yaBK0r8mikUrqHNjDez5F3rCleFQDurBEfnqECDFXNkvvO_-Wn4ahGJeid01TM; expires=Sat, 25-Dec-2021 07:16:43 GMT; path=/; domain=.google.com; HttpOnly&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;302 Moved&lt;/H1&gt;The document has moved&lt;A HREF=&quot;http://www.google.com.hk/url?sa=p&amp;amp;hl=zh-CN&amp;amp;pref=hkredirect&amp;amp;pval=yes&amp;amp;q=http://www.google.com.hk/&amp;amp;ust=1624605433464983&amp;amp;usg=AOvVaw2THxd5w15lxgX3_KA19GWL&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;.hk/&amp;ust=1624605433464983&amp;usg=AOvVaw2THxd5w15lxgX3_KA19GWL HTTP/1.1User-Agent: curl/7.29.0Host: www.google.com.hkAccept: */*.hk/Cache-Control: privateContent-Type: text/html; charset=UTF-8P3P: CP=&quot;This is not a P3P policy! See g.co/p3phelp for more info.&quot;Date: Fri, 25 Jun 2021 07:16:43 GMTServer: gwsContent-Length: 222X-XSS-Protection: 0Set-Cookie: 1P_JAR=2021-06-25-07; e
</code></pre>
<h3 id="网络后门">网络后门</h3>
<p>可以通过hping3的监听模式，创建一个简单的后门(backdoor)，通过管道来执行脚本</p>
<pre><code class="language-bash">hping3 -I eth1 -9 secret | /bin/shhping3 -R 192.168.1.100 -e secret -E commands_file -d 100 -c 1
</code></pre>
<h2 id="nslookup">nslookup</h2>
<p><em><strong>nslookup</strong></em>（name server lookup）用于在Linux中执行DNS查找的工具。用于显示DNS详细信息，例如计算机的IP地址、域的MX记录或域的NS服务器。</p>
<p>nslookup 可以在两种模式下运行：交互式和非交互式。交互模式可以查询名称服务器以获取有关各种主机和域的信息或打印域中的主机列表。非交互模式仅打印主机或域的名称和请求的信息。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>knot-dnsutils</code>  ；<code>apt install knot-dnsutils</code></li>
<li>CentOS/Fedora: <code>bind-utils</code> | <code>dnsutils</code> ；<code>yum install -y bind-utils</code></li>
<li>Apline：<code>bind-tools </code> ；<code>apk add bind-tools</code></li>
</ul>
</blockquote>
<h3 id="简单查询">简单查询</h3>
<p>nslookup后跟域名将显示域名的“A记录”（IP地址）,nslookup命令的默认输出比dig命令的默认输出相对整洁些。</p>
<pre><code class="language-bash">nslookup redhat.com
</code></pre>
<p>执行反向DNS查找：</p>
<pre><code class="language-bash">nslookup 208.117.229.88
</code></pre>
<h3 id="查询mx记录">查询MX记录</h3>
<p>MX（ Mail Exchange ）记录将域名映射到该域的邮件服务器列表。MX记录表明发到 <code>@qq.com</code> 的所有邮件都应该路由到该域中的邮件服务器。</p>
<pre><code class="language-bash">nslookup -query=mx qq.com

Server:         183.60.83.19
Address:        183.60.83.19#53

Non-authoritative answer:
qq.com  mail exchanger = 20 mx2.qq.com.
qq.com  mail exchanger = 30 mx1.qq.com.
qq.com  mail exchanger = 10 mx3.qq.com.

Authoritative answers can be found from:
</code></pre>
<p>Authoritative Answer与Non-Authoritative Answer</p>
<p>可以注意到注意到上面输出中的关键字 <code>Authoritative</code> 和 <code>Non-Authoritative Answer</code>。任何来自DNS服务器的答复都称为<code>Authoritative Answer</code>，该服务器具有域可用的完整区域文件信息。在许多情况下，DNS服务器将不具备给定域的完整区域文件信息。相反，它维护一个缓存文件，该文件包含过去执行的所有查询的结果，并已获得权威响应。当给出一个DNS查询时，它搜索缓存文件，并以 <code>Non-Authoritative Answer</code> 的形式返回可用的信息。</p>
<h3 id="查询ns记录">查询NS记录</h3>
<p>NS ( Name Server ) 记录将域名映射到该域的授权DNS服务器列表。它将输出与给定域关联的名称服务。</p>
<pre><code class="language-bash">nslookup -type=ns qq.comServer:         183.60.83.19Address:        183.60.83.19#53Non-authoritative answer:qq.com  nameserver = ns1.qq.com.qq.com  nameserver = ns2.qq.com.qq.com  nameserver = ns3.qq.com.qq.com  nameserver = ns4.qq.com.Authoritative answers can be found from:
</code></pre>
<h3 id="查询soa记录">查询SOA记录</h3>
<p>SOA ( start of authority )记录\，提供关于域的权威信息、域管理员的电子邮件地址、域序列号等。</p>
<pre><code class="language-bash">nslookup -type=soa qq.com

Server:         183.60.83.19
Address:        183.60.83.19#53

Non-authoritative answer:
qq.com
        origin = ns1.qq.com
        mail addr = webmaster.qq.com
        serial = 1330914143
        refresh = 3600
        retry = 300
        expire = 86400
        minimum = 300

Authoritative answers can be found from:
</code></pre>
<ul>
<li>mail addr–指定域管理员的邮件地址</li>
<li>serial 一种版本编号系统。标准惯例是使用 <code>YYYYMMYNN</code> 格式 <code>2012-07-16.01</code>如果在同一天进行了多个编辑，则将递增）</li>
<li>refresh 指定从DNS服务何时轮询主DNS以查看序列号是否已增加（以秒为单位）。如果增加，从DNS服务器将发出复制新区域文件的新请求。</li>
<li>retry 指定与主DNS重新连接的间隔</li>
<li>expire 指定辅助DNS保持缓存区域文件有效的时间</li>
<li>minimum 指定从DNS应缓存区域文件的时间</li>
</ul>
<h3 id="查看可用的dns记录">查看可用的DNS记录</h3>
<pre><code class="language-bash">nslookup -type=any qq.com

Server:         183.60.83.19
Address:        183.60.83.19#53

Non-authoritative answer:
Name:   qq.com
Address: 61.129.7.47
Name:   qq.com
Address: 183.3.226.35
Name:   qq.com
Address: 203.205.254.157
Name:   qq.com
Address: 123.151.137.18
qq.com  mail exchanger = 10 mx3.qq.com.
qq.com  mail exchanger = 20 mx2.qq.com.
qq.com  mail exchanger = 30 mx1.qq.com.

Authoritative answers can be found from:
</code></pre>
<h3 id="使用指定dns查询">使用指定DNS查询</h3>
<p>可以指定特定的DNS来解析域名，而不是使用默认DNS进行查询。</p>
<pre><code class="language-bash">nslookup www.qq.com 8.8.8.8

Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
www.qq.com      canonical name = news.qq.com.edgekey.net.
news.qq.com.edgekey.net canonical name = e6156.dscf.akamaiedge.net.
Name:   e6156.dscf.akamaiedge.net
Address: 23.219.132.75
Name:   e6156.dscf.akamaiedge.net
Address: 2600:1417:76:494::180c
Name:   e6156.dscf.akamaiedge.net
Address: 2600:1417:76:480::180c
</code></pre>
<h3 id="使用特殊的dns端口">使用特殊的dns端口</h3>
<p>默认情况下，DNS使用端口号为53。可以使用-port选项指定端口号。</p>
<pre><code class="language-bash">nslookup -port 56 qq.com
</code></pre>
<h3 id="设置超时时间">设置超时时间</h3>
<p>可以使用 <code>-timeout</code> 选项来指定超时时间</p>
<pre><code class="language-bash">nslookup -timeout=10 qq.com
</code></pre>
<h3 id="启用调试模式">启用调试模式</h3>
<p><code>-debug</code> 选项打开/关闭调试</p>
<pre><code class="language-bash">nslookup -debug qq.com

Server:         183.60.83.19
Address:        183.60.83.19#53

------------
    QUESTIONS:
        qq.com, type = A, class = IN
    ANSWERS:
    -&gt;  qq.com
        internet address = 183.3.226.35
        ttl = 92
    -&gt;  qq.com
        internet address = 203.205.254.157
        ttl = 92
    -&gt;  qq.com
        internet address = 61.129.7.47
        ttl = 92
    -&gt;  qq.com
        internet address = 123.151.137.18
        ttl = 92
    AUTHORITY RECORDS:
    ADDITIONAL RECORDS:
------------
Non-authoritative answer:
Name:   qq.com
Address: 183.3.226.35
Name:   qq.com
Address: 203.205.254.157
Name:   qq.com
Address: 61.129.7.47
Name:   qq.com
Address: 123.151.137.18
------------
    QUESTIONS:
        qq.com, type = AAAA, class = IN
    ANSWERS:
    AUTHORITY RECORDS:
    -&gt;  qq.com
        origin = ns1.qq.com
        mail addr = webmaster.qq.com
        serial = 1330914143
        refresh = 3600
        retry = 300
        expire = 86400
        minimum = 300
        ttl = 296
    ADDITIONAL RECORDS:
------------
</code></pre>
<h3 id="dig">dig</h3>
<p><em><strong>dig</strong></em>（Domain Information Groper) 执行DNS查找。默认情况下，dig查询通过 resolver ( <code>/etc/resolv.conf</code> ) 中列出的DNS地址，除非指定特定的name server。</p>
<h3 id="语法">语法</h3>
<pre><code class="language-bash">dig @server name type
</code></pre>
<h3 id="解析ip地址">解析IP地址</h3>
<p><code>dig</code> 通常不带参数地用于获取提供的DNS名称的IP地址。默认使用系统提供的DNS服务器用于DNS解析。</p>
<pre><code class="language-bash">dig www.qq.com

; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; www.qq.com
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 40004
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0

;; QUESTION SECTION:
;www.qq.com.                    IN      A

;; ANSWER SECTION:
www.qq.com.             132     IN      CNAME   ins-r23tsuuf.ias.tencent-cloud.net.
ins-r23tsuuf.ias.tencent-cloud.net. 60 IN A     109.244.236.76
ins-r23tsuuf.ias.tencent-cloud.net. 60 IN A     109.244.236.65

;; Query time: 11 msec
;; SERVER: 183.60.83.19#53(183.60.83.19)
;; WHEN: Tue Jun 22 21:39:33 CST 2021
;; MSG SIZE  rcvd: 108
</code></pre>
<p><strong>dig命令输出包括以下部分</strong>：</p>
<ul>
<li><code>HEADER</code>：显示dig命令的版本号、dig命令使用的全局选项，以及一些附加的Header信息。</li>
<li><code>QUESTION SECTION</code>：显示dig像DNSserver发出的请求。即你请求的域名。这里使用dig命令获取<code>qq.com</code>使用的默认类型（A记录）</li>
<li><code>ANSWER SECTION</code>：显示从DNS接收到的应答。将显示<code>qq.com</code> 的A记录</li>
<li><code>ADDITIONAL SECTION</code>：显示<code>ADDITIONAL SECTION</code> 中列出的DNS服务器的ip地址。</li>
<li>底部的Stats部分显示一些dig命令统计信息，包括执行此查询所用的时间</li>
</ul>
<h3 id="仅显示应答部分">仅显示应答部分</h3>
<p>在大多数情况下，我们只需要查看dig的 <code>ANSWER SECTION</code>。可以仅打印该部分。</p>
<ul>
<li><code>+nocomments</code> 不显示注释行</li>
<li><code>+noauthority</code>  不显示<code>authority</code>部分</li>
<li><code>+noadditional</code>   不显示 <code>additional</code> 部分</li>
<li><code>+nostats</code>  不显示统计信息 <code>stats</code></li>
<li><code>+noanswer</code> 关掉<code>ANSWER</code>  部分，这里一般为想要的结果</li>
</ul>
<pre><code class="language-bash">dig www.qq.com \
    +nocomments \
    +noquestion \
    +noauthority \
    +noadditional \
    +nostats

; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; www.qq.com +nocomments +noquestion +noauthority +noadditional +nostats
;; global options: +cmd
www.qq.com.             180     IN      CNAME   ins-r23tsuuf.ias.tencent-cloud.net.
ins-r23tsuuf.ias.tencent-cloud.net. 31 IN A     109.244.236.65
ins-r23tsuuf.ias.tencent-cloud.net. 31 IN A     109.244.236.76
</code></pre>
<p>也可以使用 <code>+noal</code> 禁用所有不需要的部分，当然也会关掉 <code>answer</code> ，然后<code>+answer</code> 只显示 <code>answer</code>部分，这样看起来简洁些。</p>
<pre><code class="language-bash">dig www.qq.com \
    +noall \
    +answer
</code></pre>
<h3 id="查询mx记录-1">查询MX记录</h3>
<p>将MX作为参数，可以查询mx记录，可以使用 <code>-t</code> 增加类型</p>
<pre><code class="language-bash">dig qq.com  MX +noall +answer

; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; qq.com MX +noall +answer
;; global options: +cmd
qq.com.                 4969    IN      MX      10 mx3.qq.com.
qq.com.                 4969    IN      MX      20 mx2.qq.com.
qq.com.                 4969    IN      MX      30 mx1.qq.com.
</code></pre>
<h3 id="查询ns记录-1">查询NS记录</h3>
<pre><code class="language-bash">dig qq.com NS +noall +answer
</code></pre>
<h3 id="查询所有记录">查询所有记录</h3>
<p>查看所有记录类型（A、MX、NS等），可以使用ANY作为类型。</p>
<pre><code class="language-bash">dig qq.com ANY +noall +answer

; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; qq.com ANY +noall +answer
;; global options: +cmd
qq.com.                 83      IN      A       183.3.226.35
qq.com.                 83      IN      A       203.205.254.157
qq.com.                 83      IN      A       123.151.137.18
qq.com.                 83      IN      A       61.129.7.47
</code></pre>
<h3 id="仅查看记录的ip">仅查看记录的IP</h3>
<p>有些场景下，仅需要域名的ip地址（即a记录），可以使用 <code> +short</code> 选项。</p>
<pre><code class="language-bash">dig qq.com +short
123.151.137.18
203.205.254.157
183.3.226.35
61.129.7.47
</code></pre>
<p><code> +short</code>  也可指定类型</p>
<pre><code class="language-bash">dig qq.com a +short

111.30.144.71
112.53.26.232

dig qq.com mx +short

10 mx3.qq.com.
20 mx2.qq.com.
30 mx1.qq.com.
</code></pre>
<h3 id="反向查找">反向查找</h3>
<p>可以使用<code>dig-x</code> 进行ip地址反向查找DNS，场景：如果只有一个外部ip地址，并且希望知道属于它的网站时。当然过了CDN的域名，只会显示对应CNAME</p>
<pre><code class="language-bash">dig -x 203.205.254.157 +short 
</code></pre>
<h3 id="使用指定dns来进行查询">使用指定DNS来进行查询</h3>
<p>默认情况下，dig 使用 <code>/etc/resolv.conf</code> 文件中定义的DNS。如果要使用其他DNS执行查询，使用 <code>@dnsserver</code>。</p>
<pre><code class="language-bash">dig @8.8.8.8 www.qq.com +short

ins-r23tsuuf.ias.tencent-cloud.net.
109.244.236.76
109.244.236.65
</code></pre>
<h3 id="批量查询">批量查询</h3>
<p>进行批量查询时可以不用通过shell循环查询了，dig提供了批量查询的功能。使用<code>dig -f</code> 从文件内进行批量DNS查询。</p>
<pre><code class="language-bash">echo www.qq.com &gt; dns.txt
echo www.baidu.com &gt;&gt; dns.txt

dig -f dns.txt +noall +answer

www.baidu.com.          678     IN      CNAME   www.a.shifen.com.
www.a.shifen.com.       106     IN      A       14.215.177.39
www.a.shifen.com.       106     IN      A       14.215.177.38
www.qq.com.             60      IN      CNAME   ins-r23tsuuf.ias.tencent-cloud.net.
ins-r23tsuuf.ias.tencent-cloud.net. 60 IN A     109.244.236.65
ins-r23tsuuf.ias.tencent-cloud.net. 60 IN A     109.244.236.76
</code></pre>
<p>也可以在命令行直接根多个域名即可，这样查询结果相比于shell循环查询会简洁很多。</p>
<pre><code class="language-bash">dig qq.com mx +noall +answer baidu.org ns +noall +answer

; &lt;&lt;&gt;&gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.3 &lt;&lt;&gt;&gt; qq.com mx +noall +answer baidu.org ns +noall +answer
;; global options: +cmd
qq.com.                 4223    IN      MX      10 mx3.qq.com.
qq.com.                 4223    IN      MX      20 mx2.qq.com.
qq.com.                 4223    IN      MX      30 mx1.qq.com.
baidu.org.              300     IN      NS      ns4.brandshelter.net.
baidu.org.              300     IN      NS      ns3.brandshelter.info.
baidu.org.              300     IN      NS      ns2.brandshelter.de.
baidu.org.              300     IN      NS      ns5.brandshelter.us.
baidu.org.              300     IN      NS      ns1.brandshelter.com.
</code></pre>
<h3 id="设置dig默认选项">设置dig默认选项</h3>
<p>如别名 <code>alias</code> 一样，在查询中不想输入过多的 <code>+noall +answer</code> 之类，可以在 <code>$HOME/.digrc </code> 设置dig 的默认参数，这样只需和平时一样使用 <code>dig domain</code> 即可。</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt;${HOME}/.digrc+noall +answerEOFdig www.qq.comwww.qq.com.             247     IN      CNAME   ins-r23tsuuf.ias.tencent-cloud.net.ins-r23tsuuf.ias.tencent-cloud.net. 67 IN A     109.244.236.76ins-r23tsuuf.ias.tencent-cloud.net. 67 IN A     109.244.236.6
</code></pre>
<h2 id="curl">curl</h2>
<p><em><strong>curl</strong></em> 是Linux命令行工具，可以使用任何可支持的协议（如HTTP、FTP、IMAP、POP3、SCP、SFTP、SMTP、TFTP、TELNET、LDAP或FILE）在服务器之间传输数据。</p>
<p>在Linux下，curl是由 <code>libcurl</code> 提供驱动封装的cli客户端，在 <code>libcurl</code> 驱动下，curl可以一次传输多个文件。而PHP中的cURL函数，也是基于libcurl驱动的。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>curl</code>； <code>apt install curl</code></li>
<li>CentOS/Fedora: <code>curl</code>  ； <code>yum install -y curl</code></li>
<li>Apline：<code>curl</code> | <code>wget</code> ； <code>apk add --no-cache curl</code></li>
</ul>
</blockquote>
<h3 id="curl常用参数">cURL常用参数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-i</td>
<td style="text-align:left">默认隐藏响应头，此选项打印响应头与</td>
</tr>
<tr>
<td style="text-align:center">-I/&ndash;head</td>
<td style="text-align:left">仅显示响应头</td>
</tr>
<tr>
<td style="text-align:center">-o</td>
<td style="text-align:left">将相应内容保存指定路径下</td>
</tr>
<tr>
<td style="text-align:center">-O</td>
<td style="text-align:left">将相应内容保存在当前工作目录下</td>
</tr>
<tr>
<td style="text-align:center">-C</td>
<td style="text-align:left">断点续传，在 crtl + c终端后，可以从中断后部分开始</td>
</tr>
<tr>
<td style="text-align:center">-v</td>
<td style="text-align:left">显示请求头与响应头</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:left">使用代理</td>
</tr>
<tr>
<td style="text-align:center">-X</td>
<td style="text-align:left">指定请求方法，POST GET PUT DELETE等</td>
</tr>
<tr>
<td style="text-align:center">-d</td>
<td style="text-align:left">如GET/POST/PUT/DELETE 需要传的表单参数，如JSON格式</td>
</tr>
<tr>
<td style="text-align:center">-u username:password</td>
<td style="text-align:left">当使用ftp有用户名可以使用-u，ftp允许匿名用户访问可以忽略</td>
</tr>
<tr>
<td style="text-align:center">–-limit-rate 2000B</td>
<td style="text-align:left">限速</td>
</tr>
<tr>
<td style="text-align:center">-T/&ndash;upload-file &lt;file&gt;</td>
<td style="text-align:left">上传一个文件</td>
</tr>
<tr>
<td style="text-align:center">-c/&ndash;cookie-jar &lt;file name&gt;</td>
<td style="text-align:left">将cookie下载到文件内</td>
</tr>
<tr>
<td style="text-align:center">-k/&ndash;insecure</td>
<td style="text-align:left">允许执行不安全的ssl连接，即调过SSL检测</td>
</tr>
<tr>
<td style="text-align:center"><code>--header 'Host: targetapplication.com'</code></td>
<td style="text-align:left">使用请求头</td>
</tr>
<tr>
<td style="text-align:center">-L/&ndash;location</td>
<td style="text-align:left">接受服务端redirect的请求</td>
</tr>
<tr>
<td style="text-align:center">-F</td>
<td style="text-align:left">上传二进制文件</td>
</tr>
</tbody>
</table>
<h3 id="限制下载速率">限制下载速率</h3>
<pre><code class="language-bash">curl --limit-rate 100K http://yourdomain.com/yourfile.tar.gz -O
</code></pre>
<h3 id="使用代理访问">使用代理访问</h3>
<pre><code class="language-bash">curl --proxy yourproxy:port https://yoururl.com
</code></pre>
<h3 id="限速访问">限速访问</h3>
<pre><code class="language-bash">curl www.baidu.com  --limit-rate 1k
</code></pre>
<h3 id="存储cookie和使用cookie">存储cookie和使用cookie</h3>
<pre><code>$ curl --cookie-jar cnncookies.txt https://www.baidu.com/index.html -O -s -v
* About to connect() to www.baidu.com port 443 (#0)
*   Trying 14.215.177.39...
* Connected to www.baidu.com (14.215.177.39) port 443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
*   CAfile: /etc/pki/tls/certs/ca-bundle.crt
  CApath: none
* SSL connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate:
*       subject: CN=baidu.com,O=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot;,OU=service operation department,L=beijing,ST=beijing,C=CN
*       start date: Apr 02 07:04:58 2020 GMT
*       expire date: Jul 26 05:31:02 2021 GMT
*       common name: baidu.com
*       issuer: CN=GlobalSign Organization Validation CA - SHA256 - G2,O=GlobalSign nv-sa,C=BE
&gt; GET /index.html HTTP/1.1
&gt; User-Agent: curl/7.29.0
&gt; Host: www.baidu.com
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Accept-Ranges: bytes
&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
&lt; Connection: keep-alive
&lt; Content-Length: 2443
&lt; Content-Type: text/html
&lt; Date: Wed, 26 May 2021 12:14:41 GMT
&lt; Etag: &quot;58860402-98b&quot;
&lt; Last-Modified: Mon, 23 Jan 2017 13:24:18 GMT
&lt; Pragma: no-cache
&lt; Server: bfe/1.0.8.18
* Added cookie BDORZ=&quot;27315&quot; for domain baidu.com, path /, expire 1622117681
&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
&lt; 
{ [data not shown]
* Connection #0 to host www.baidu.com left intact
</code></pre>
<pre><code># Netscape HTTP Cookie File# http://curl.haxx.se/docs/http-cookies.html# This file was generated by libcurl! Edit at your own risk..baidu.com      TRUE    /       FALSE   1622117681      BDORZ   27315
</code></pre>
<pre><code>$ curl --cookie cnncookies.txt https://www.baidu.com -s -v -o /dev/null
* About to connect() to www.baidu.com port 443 (#0)
*   Trying 14.215.177.39...
* Connected to www.baidu.com (14.215.177.39) port 443 (#0)
* Initializing NSS with certpath: sql:/etc/pki/nssdb
*   CAfile: /etc/pki/tls/certs/ca-bundle.crt
  CApath: none
* SSL connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate:
*       subject: CN=baidu.com,O=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot;,OU=service operation department,L=beijing,ST=beijing,C=CN
*       start date: Apr 02 07:04:58 2020 GMT
*       expire date: Jul 26 05:31:02 2021 GMT
*       common name: baidu.com
*       issuer: CN=GlobalSign Organization Validation CA - SHA256 - G2,O=GlobalSign nv-sa,C=BE
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.29.0
&gt; Host: www.baidu.com
&gt; Accept: */*
&gt; Cookie: BDORZ=27315
&gt; 
&lt; HTTP/1.1 200 OK
&lt; Accept-Ranges: bytes
&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
&lt; Connection: keep-alive
&lt; Content-Length: 2443
&lt; Content-Type: text/html
&lt; Date: Wed, 26 May 2021 12:23:27 GMT
&lt; Etag: &quot;58860402-98b&quot;
&lt; Last-Modified: Mon, 23 Jan 2017 13:24:18 GMT
&lt; Pragma: no-cache
&lt; Server: bfe/1.0.8.18
* Replaced cookie BDORZ=&quot;27315&quot; for domain baidu.com, path /, expire 1622118207
&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/  # 这里可以看到设置的cookie
&lt; 
{ [data not shown]
* Connection #0 to host www.baidu.com left intact
</code></pre>
<h3 id="使用代理">使用代理</h3>
<pre><code class="language-bash">curl -x socks5://127.0.0.1:10808 https://www.google.com
</code></pre>
<h3 id="使用applicationx-www-form-urlencoded表单类型">使用application/x-www-form-urlencoded表单类型</h3>
<p>这里使用的为<code>application/x-www-form-urlencoded</code></p>
<pre><code class="language-bash">curl -d &quot;option=value&amp;something=anothervalue&quot; -X POST https://{hostname}/
</code></pre>
<h3 id="使用json格式作为body">使用json格式作为body</h3>
<pre><code class="language-bash">curl  -H &quot;Content-Type: application/json&quot; -X POST https://host.com/ \
-d '  {   &quot;option&quot;: &quot;value&quot;,    &quot;something&quot;: &quot;anothervalue&quot; }'
</code></pre>
<h3 id="使用curl-上传文件">使用curl 上传文件</h3>
<pre><code class="language-bash">curl {host}/api/v1/upimg -F &quot;file=@/Users/fungleo/Downloads/401.png&quot; \
-H &quot;token: 222&quot; -v
</code></pre>
<p>也可以指定<code>MIME</code>类型。如：</p>
<pre><code class="language-bash">curl -F 'file=@photo.png;type=image/png' https://{host}/api/v1/upimg
</code></pre>
<h3 id="curl输出的格式变量">curl输出的格式变量</h3>
<p>curl -w参数提供了一些格式变量，可以达到紧紧获取某些数据</p>
<h3 id="仅获取http状态码">仅获取http状态码</h3>
<pre><code class="language-bash">curl -w %{http_code} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获取整个请求的时间">获取整个请求的时间</h3>
<p>获取整个请求的耗时，单位秒，显示单位 毫秒</p>
<pre><code class="language-bash">curl -w %{time_total} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获取域名解析时间">获取域名解析时间</h3>
<pre><code class="language-bash">curl -w %{time_namelookup} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获取tcp连接耗时">获取TCP连接耗时</h3>
<pre><code class="language-bash">curl -w %{time_connect} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获取sslssh握手到远程主机耗时">获取SSL/SSH握手到远程主机耗时</h3>
<pre><code class="language-bash">curl -w %{time_appconnect} https://www.baidu.com -o /dev/null -s -v
</code></pre>
<h3 id="获取所有重定向的耗时">获取所有重定向的耗时</h3>
<p>这里是从查找、连接、传输整个事务的完成到开始传送数据之前的耗时</p>
<pre><code class="language-bash">curl -w %{time_redirect} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获得下载的总字节数">获得下载的总字节数</h3>
<p>这里是http相应的body长度，而不是加上头部的大小</p>
<pre><code class="language-bash">curl -w %{size_download} www.baidu.com -o /dev/null -s
</code></pre>
<pre><code>$ curl -w %{size_download} www.baidu.com -o /dev/null -s
2381
</code></pre>
<h3 id="获得请求体送字节数">获得请求体送字节数</h3>
<pre><code class="language-bash">curl -w %{size_request} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获得传输中的连接数">获得传输中的连接数</h3>
<pre><code class="language-bash">curl -w %{num_connects} www.baidu.com -o /dev/null -s
</code></pre>
<h3 id="获得重定向次数">获得重定向次数</h3>
<pre><code class="language-bash">curl -w %{num_redirects} www.360buy.com -o /dev/null -s  -L
</code></pre>
<h3 id="获得ssl验证结果">获得SSL验证结果</h3>
<p>0 表示是成功的</p>
<pre><code class="language-bash">curl -w %{ssl_verify_result} https://www.baidu.com -o /dev/null -s -L
</code></pre>
<h3 id="获得重定向的地址">获得重定向的地址</h3>
<p>当没有指定<code>-L</code>时，会返回被重定向后的地址</p>
<pre><code class="language-bash">curl -w %{redirect_url} https://www.360buy.com -o /dev/null -s 
</code></pre>
<h3 id="获得上传和下载速度">获得上传和下载速度</h3>
<pre><code class="language-bash">curl -w %{speed_download} https://www.360buy.com -o /dev/null -s
curl -w %{speed_upload} https://www.360buy.com -o /dev/null -s
</code></pre>
<h3 id="根据自己需要拼接特定格式">根据自己需要拼接特定格式</h3>
<pre><code class="language-bash">curl -w &quot;总共请求时长：%{time_total}\n总跳转次数：%{num_redirects}\n&quot; \
www.360buy.com -o /dev/null -s

总共请求时长：1.338总跳转次数：3
</code></pre>
<h2 id="wget">wget</h2>
<p><em><strong>wget</strong></em> 用于从web下载文件的命令行程序。wget，可以使用 <code>HTTP</code>、<code>HTTPS</code>和 <code>FTP</code> 协议下载文件。wget还允许下载多个文件、断点续传、限速、递归下载、后台下载、镜像网站等等。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>wget</code> ； <code>apt install wget</code></li>
<li>CentOS/Fedora: <code>wget</code>  ； <code>yum install -y wget</code></li>
<li>Apline： <code>wget</code> ；  <code>apk add --no-cache wget</code></li>
</ul>
</blockquote>
<h3 id="简单使用">简单使用</h3>
<p>使用wget最简单的方法是为它提供通过HTTP下载的文件的位置。如，下载文件。</p>
<pre><code class="language-bash">wget http://website.com/files/file.zip
</code></pre>
<p>该操作会将文件下载到工作目录中。</p>
<h3 id="下载文件并保存为指定名称">下载文件并保存为指定名称</h3>
<pre><code class="language-bash">wget –O [file_name] [URL]
</code></pre>
<h3 id="将文件下载到指定目录">将文件下载到指定目录</h3>
<p>默认情况下，wget下载的文件保存在用户所在工作目录中。使用 <code>–P</code> 可以将文件保存到指定路径。</p>
<pre><code class="language-bash">wget –P [wanted_directory] [URL]
</code></pre>
<h3 id="设置下载速度">设置下载速度</h3>
<p>在下载时可以设置下载时最大使用带宽，这样就不会使用主机全部的可用带宽。下载速度以 <code>k</code> 和 <code>m</code> 定义单位。</p>
<pre><code class="language-bash">wget --limit-rate [wanted_speed] [URL]

wget --limit-rate 1m http://us.download.nvidia.com/tesla/396.37/nvidia-diag-driver-local-repo-ubuntu1710-396.37_1.0-1_amd64.deb 
</code></pre>
<h3 id="断点续传">断点续传</h3>
<p>如果在下载时取消，wget提供了可以在中断前停止的地方继续下载。当下载文件时连接丢失时，这个非常有用。</p>
<pre><code class="language-bash">wget –c [URL]
</code></pre>
<h3 id="下载多个文件">下载多个文件</h3>
<p>wget也提供了下载多个文件的方法：</p>
<p>方法1：将需要下载的文件地址保存在文件中 使用 <code>-i</code> 指定文件，每个URL 单独占一行</p>
<pre><code class="language-bash">wget –i [file_name]
</code></pre>
<h3 id="下载网页网站镜像">下载网页（网站镜像）</h3>
<p>使用 <code>–m</code> 下载URL中包含的所有连接，结果会保存为一个文件夹</p>
<pre><code class="language-bash">wget –m [URL]
</code></pre>
<h3 id="ftp下载">FTP下载</h3>
<p>wget也可以下载FTP文件，当需要认证时，可以指定FTP的用户名和密码，然后接FTP地址：</p>
<pre><code class="language-bash">wget --ftp-user=[ftp_username] --ftp-password=[ftp_password] ftp://...
</code></pre>
<h3 id="后台下载">后台下载</h3>
<p>当下载文件很大时，wget也支持后台下载文件，在网络不稳定命令行断开时很实用。</p>
<pre><code class="language-bash">wget –b [URL]
</code></pre>
<p>可以使用命令 <code>tail –f wget –log </code> 来检查下载状态</p>
<h3 id="中断重试次数">中断重试次数</h3>
<p>当网络中断后，wget也支持设置在网络中断后尝试下载文件的次数：</p>
<pre><code class="language-bash">wget --tries=[number_of_tries] [URL]
</code></pre>
<h3 id="忽略证书验证">忽略证书验证</h3>
<p>默认情况下，wget会验证服务端SSL/TLS证书是否有效。如果识别到无效的证书，它将拒绝下载。当在访问自签名证书时，可以使用<code>--no-check-certificate</code> 忽略验证</p>
<pre><code class="language-bash">wget --no-check-certificate [URL]
</code></pre>
<h3 id="自定义user-agent">自定义User-Agent</h3>
<p>当服务端阻止了特定的 <code>User-Agent </code> 时，可以进行自定义 <code>User-Agent</code> 设置。</p>
<pre><code class="language-bash">wget --user-agent=”User Agent Here” “[URL]”
</code></pre>
<h3 id="实用技巧-下载内容到标准输出stdout">实用技巧-下载内容到标准输出stdout</h3>
<p>如在下载一个tar包时，一般都是wget 后 在tar 解压到对应目录，可以使用 <code>-O -</code> 将其下载到标准输出，<code>-q</code> 静默方式，通过管道直接解压到对应的路径下。</p>
<pre><code class="language-bash">wget -q -O - &quot;http://wordpress.org/latest.tar.gz&quot; | tar -xzf - -C /var/www
</code></pre>
<h2 id="ss">ss</h2>
<p><em><strong>ss</strong></em> (socket statistics) 命令行工具，用于在Linux系统上显示与网络套接字相关的信息。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li><strong>ss</strong></li>
<li>Ubuntu/Debian:  <code>iproute2</code>   ；<code>apt install iproute2</code></li>
<li>CentOS/Fedora: <code>iproute</code>  ；<code>yum install -y iproute</code></li>
<li>Apline：<code>iproute</code> ；<code>apk add --no-cache iproute</code></li>
</ul>
</blockquote>
<h3 id="查看所有连接">查看所有连接</h3>
<p>没有任何选项的ss命令只列出所有连接。</p>
<h3 id="查看listening-与-non-listening-ports">查看Listening 与 Non-listening Ports</h3>
<pre><code class="language-bash">ss -a
</code></pre>
<h3 id="查看监听-套接字列表">查看监听 套接字列表</h3>
<p>这里列出所有监听套接字，不关其是服务监听还是客户端请求占用</p>
<pre><code class="language-bash">ss -l
</code></pre>
<h3 id="查看所有tcp连接">查看所有TCP连接</h3>
<p>这里只所有的tcp连接， 包含客户端与服务端</p>
<pre><code class="language-bash">ss -t
</code></pre>
<h3 id="查看所有监听类型的tcp连接">查看所有监听类型的tcp连接</h3>
<pre><code class="language-bash">ss -lt
</code></pre>
<h3 id="查看所有udp连接">查看所有udp连接</h3>
<pre><code class="language-bash">ss -ua
</code></pre>
<h3 id="查看监听类型的udp连接">查看监听类型的UDP连接</h3>
<pre><code class="language-bash">ss -lu
</code></pre>
<h3 id="显示socket的pid进程id">显示socket的pid进程id</h3>
<pre><code class="language-bash">ss -p
</code></pre>
<h3 id="显示连接摘要信息">显示连接摘要信息</h3>
<pre><code class="language-bash">ss -s
</code></pre>
<h3 id="显示ipv6或ipv4-连接">显示ipv6或ipv4 连接</h3>
<pre><code class="language-bash">ss -4
ss -6
</code></pre>
<h3 id="筛选连接">筛选连接</h3>
<p>语法</p>
<pre><code class="language-bash">ss [ OPTIONS ] [ STATE-FILTER ] [ ADDRESS-FILTER ]
</code></pre>
<p>ss命令还提供了筛选方法，过滤套接字端口或地址。例如，要显示具有ssh服务的源端口与目标端口（即监听与客户端连接）。</p>
<pre><code> ss -at '( dport = :22 or sport = :22 )'
</code></pre>
<p>也可以通过服务名称进行过滤</p>
<pre><code class="language-bash">ss -at '( dport = :ssh or sport = :ssh )'
</code></pre>
<p>仅显示所有处于 <code>established</code> 状态的Ipv4 tcp套接字。</p>
<pre><code class="language-bash">ss -t4 state established -n

Recv-Q Send-Q   Local Address:Port    Peer Address:Port   
0      0        172.16.0.2:22         61.50.248.5:22005   
0      0        172.16.0.2:42930      169.254.0.55:5574    
0      0        172.16.0.2:22         61.50.248.5:22008   
0      0        172.16.0.2:22         61.50.248.5:22003   
0      0        172.16.0.2:40652      94.130.12.30:443     
0      36       172.16.0.2:22         61.50.248.5:22012   
0      0        172.16.0.2:22         61.50.248.5:22004   
</code></pre>
<p>列出状态为time wait的套接字</p>
<pre><code class="language-bash">ss -t4 state time-wait -n
</code></pre>
<p>这里状态可以为下面的任意一种</p>
<blockquote>
<ul>
<li>established</li>
<li>syn-sent</li>
<li>syn-recv</li>
<li>fin-wait-1</li>
<li>fin-wait-2</li>
<li>time-wait</li>
<li>closed</li>
<li>close-wait</li>
<li>last-ack</li>
<li>closing</li>
<li>all  上面所有状态</li>
<li>connected  除listen和closed之外的所有状态</li>
<li>synchronized  除syn-sent之外的所有连接状态</li>
<li>显示状态，这些被维护为mini sockets，即 <code>time-wait </code> 与 <code>syn-recv</code></li>
<li>big 与bucket选项相反</li>
</ul>
</blockquote>
<p>过滤地址</p>
<pre><code class="language-bash">ss -nt dst 74.125.236.178
</code></pre>
<p>还可以过滤网段</p>
<pre><code class="language-bash">ss -nt dst 74.125.236.178/16
</code></pre>
<p>ip和端口的组合</p>
<pre><code class="language-bash">ss -nt dst 74.125.236.178:80
</code></pre>
<p>源地址为127.0.0.1，且源端口大于5000</p>
<pre><code class="language-bash">ss -nt src 127.0.0.1 sport gt :5000
</code></pre>
<p>源端口为25的smtp套接字</p>
<pre><code class="language-bash">ss -ntlp sport eq :smtp
</code></pre>
<p>端口号大于25</p>
<pre><code class="language-bash">ss -nt sport gt :1024
</code></pre>
<p>远程端口小于100的套接字</p>
<pre><code class="language-bash">ss -nt dport \&lt; :100
</code></pre>
<p>连接到远程80端口的</p>
<pre><code class="language-bash">ss -nt state connected dport = :80
</code></pre>
<h3 id="不解析主机名">不解析主机名</h3>
<p>可以通过 <code>-n</code> 选项阻止ss 将ip解析为主机名，来达到更快地获得输出，但这也无法进行到端口号的解析。</p>
<pre><code class="language-bash">ss -at '( dport = :22 or sport = :22 )'

State      Recv-Q Send-Q     Local Address:Port       Peer Address:Port                
LISTEN     0      128             *:ssh                     *:*                    
ESTAB      0      0          172.16.0.2:ssh           111.206.214.55:49374                
ESTAB      0      0          172.16.0.2:ssh           61.50.248.5:optohost005          
ESTAB      0      36         172.16.0.2:ssh           61.50.248.5:22008                
ESTAB      0      0          172.16.0.2:ssh           61.50.248.5:optohost003          
ESTAB      0      0          172.16.0.2:ssh           61.50.248.5:optohost004          
LISTEN     0      128            [::]:ssh                 [::]:*                    


ss -at '( dport = :22 or sport = :22 )' -n
State      Recv-Q Send-Q   Local Address:Port         Peer Address:Port              
LISTEN     0      128           *:22                    *:*                  
ESTAB      0      0        172.16.0.2:22              111.206.214.55:49374              
ESTAB      0      0        172.16.0.2:22              61.50.248.5:22005              
ESTAB      0      36       172.16.0.2:22              61.50.248.5:22008              
ESTAB      0      0        172.16.0.2:22              61.50.248.5:22003              
ESTAB      0      0        172.16.0.2:22              61.50.248.5:22004              
LISTEN     0      128            [::]:22                    [::]:*      
</code></pre>
<h3 id="仅显示监听套接字">仅显示监听套接字</h3>
<pre><code class="language-bash">ss -ltn
</code></pre>
<p>要列出所有侦听的udp连接，请将t替换为u</p>
<pre><code class="language-bash">ss -lun
</code></pre>
<h3 id="显示时间信息">显示时间信息</h3>
<p>可以使用 <code>-o</code> 选项，来获得每个连接的时间信息。通过timer得知</p>
<pre><code class="language-bash">ss -tn -o

State      Recv-Q Send-Q     Local Address:Port    Peer Address:Port              
ESTAB      0      0          172.16.0.2:22         61.50.248.5:22005   timer:(keepalive,40min,0)
ESTAB      0      0          172.16.0.2:42930      169.254.0.55:5574               
ESTAB      0      0          172.16.0.2:22         61.50.248.5:22008   timer:(keepalive,64min,0)
ESTAB      0      0          172.16.0.2:44900      169.254.0.55:80     timer:(keepalive,13sec,0)
ESTAB      0      0          172.16.0.2:22         61.50.248.5:22003   timer:(keepalive,40min,0)
ESTAB      0      36         172.16.0.2:22         61.50.248.5:22012   timer:(on,347ms,0)
ESTAB      0      0          172.16.0.2:39316      94.130.12.30:443    timer:(keepalive,50sec,0)
ESTAB      0      0          172.16.0.2:22         61.50.248.5:22004   timer:(keepalive,40min,0)
</code></pre>
<h3 id="netstat">netstat</h3>
<p><em><strong>netstat</strong></em> (network statistics) 命令行工具，用于监视传入和传出的网络连接，以及查看路由表、接口统计等。netstat在所有类似Unix的操作系统上都可用，在Windows操作系统上也可用，是最基本的网络服务调试工具。</p>
<p>不过，现在<code>netstat</code> 命令早已被弃用，取而代之的是 <code>iproute</code> 套件中的 <code>ss</code>。ss 比起 <code>netstat</code>，<code>ss</code> 能够显示有关网络连接的详细信息，并且速度更快。<code>netstat</code> 从 <code>/proc</code> 文件收集信息，当有大量连接要打印时，<code>netstat</code> 效率很低。而<code>ss</code> 是直接从内核空间获取信息。并且<code>ss</code>命令在使用起来与<code>netstat </code>非常相似，用户几乎可以无缝切换。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>
<p><strong>ss</strong></p>
</li>
<li>
<p>Ubuntu/Debian:  <code>iproute2</code>   ；<code>apt install iproute2</code></p>
</li>
<li>
<p>CentOS/Fedora: <code>iproute</code>  ；<code>yum install -y iproute</code></p>
</li>
<li>
<p>Apline：<code>iproute</code> ；<code>apk add --no-cache iproute</code></p>
</li>
<li>
<p><strong>netstat</strong></p>
</li>
<li>
<p>Ubuntu/Debian:  <code>net-tools</code>   ；<code>apt install net-tools</code></p>
</li>
<li>
<p>CentOS/Fedora: <code>net-tools</code>  ；<code>yum install -y net-tools</code></p>
</li>
<li>
<p>Apline：<code>net-tools</code> ；<code>apk add --no-cache net-tools</code></p>
</li>
</ul>
</blockquote>
<ul>
<li>列出所有tcp与udp的连接的所有端口 <code>netstat -a</code></li>
<li>仅列出tcp (<strong>Transmission Control Protocol</strong>)  端口的连接 <code>netstat -at</code></li>
<li>仅列出udp (<strong>User Datagram Protocol</strong> )   端口的连接 <code>netstat -au</code></li>
<li>列出所有活动监听端口连接 <code>netstat -l</code></li>
<li>列出TCP监听端口 <code>netstat -lt</code></li>
<li>列出udp监听端口 <code>netstat -lu</code></li>
<li>列出unix socket 监听端口 <code>netstat -lx</code></li>
<li>显示统计信息 <code>netstat -s</code></li>
<li>显示tcp的统计信息 <code>netstat -st</code></li>
<li>显示udp的统计信息 <code>netstat -su</code></li>
<li>显示服务名与PID号 <code>netstat -tp</code></li>
<li>显示混杂模式，类似<code>watch</code> 每5s 刷新 <code>netstat -ac 5 | grep tcp</code></li>
<li>显示内核路由表，类似<code> route -n</code> 命令；<code>netstat -r</code></li>
<li>显示网络接口数据包事务，包括传输和接收MTU大小的数据包。 <code>netstat -i</code></li>
<li>显示内核接口表，类似 <code>ifconfig</code> 命令。 <code>netstat -ie</code></li>
<li>显示IPv4和IPv6的广播信息。<code>netstat -g</code></li>
<li>混杂模式，间隔时间打印netstat命令的信息 <code>netstat -c [second] -ltnp</code></li>
<li>显示原始网络信息统计 <code>netstat --statistics --raw</code></li>
</ul>
<h2 id="lsof">lsof</h2>
<p><em><strong>lsof</strong></em> (LiSt Open Files)，主要用来找出哪个进程打开了哪些文件。众所周知，Linux是一个基于文件的操作系统（管道、套接字、目录、设备等）。使用lsof也可以排查一些网络问题。如未关闭的文件不能被移动或删除，网络端口使用的文件等，都可以通过lsof快速定位。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>lsof</code>  ；<code>apt install lsof</code></li>
<li>CentOS/Fedora: <code>lsof</code> ；<code>yum install -y lsof</code></li>
<li>Apline：<code>lsof </code> ；<code>apk add lsof --no-cache</code></li>
</ul>
</blockquote>
<h3 id="列出所有打开的文件">列出所有打开的文件</h3>
<p>不带任何参数的情况下运行lsof，可以列出所有打开的文件</p>
<pre><code class="language-bash">lsof
</code></pre>
<h3 id="列出用户进程使用的文件">列出用户进程使用的文件</h3>
<p>lsof 可以查看特定用户进程使用的哪些文件，使用<code>-u</code></p>
<pre><code class="language-bash">lsof -u root
</code></pre>
<h3 id="根据网络地址查找文件">根据网络地址查找文件</h3>
<pre><code class="language-bash">lsof -i 4
</code></pre>
<h3 id="按照程序名称列出所打卡的文件">按照程序名称列出所打卡的文件</h3>
<p>这里不必使用完整的程序名，会列出所有以 name开头的进程应用使用的文件</p>
<pre><code class="language-bash">lsof -u nginx
</code></pre>
<h3 id="列出进程使用的文件">列出进程使用的文件</h3>
<p>使用 <code>-p [pid]</code> k可以显示进程打开的文件，可以通过 <code>^</code> 来排除特定的PID。</p>
<pre><code class="language-bash">lsof -p [pid]
lsof -p [^pid]
</code></pre>
<h3 id="找到使用文件的进程">找到使用文件的进程</h3>
<p>使用 <code>-t</code> 餐食可以找到哪些进程使用了该文件</p>
<pre><code class="language-bash">lsof -t [file_name]
</code></pre>
<h3 id="列出目录中所有打开的文件">列出目录中所有打开的文件</h3>
<p><code>+D</code> 餐食可以对目录的所有打开实例（包括它包含的所有文件和目录）进行搜索。</p>
<pre><code class="language-bash">lsof +D [dir]
</code></pre>
<h3 id="列出网络文件">列出网络文件</h3>
<p><code>-i</code> 侦听特定端口号的进程或应用程序，如检查了哪个程序进程正在使用端口80。</p>
<pre><code class="language-bash">lsof -i:80  
</code></pre>
<p>还可以根据端口范围进程查找</p>
<pre><code class="language-bash">lsof -i:1-1024
</code></pre>
<h3 id="根据网络连接类型来查找文件">根据网络连接类型来查找文件</h3>
<p>lsof还可以根据连接的类型列出文件。例如，TCP使用的文件</p>
<pre><code class="language-bash">lsof -i tcp
</code></pre>
<h3 id="拿到进程的父进程id">拿到进程的父进程ID</h3>
<p><code>lsof -R</code> 可以拿到进程的父进程IP输出中列出父进程标识（PPID Parent Process IDentification）。</p>
<pre><code class="language-bash">lsof -p [] -R
</code></pre>
<h3 id="查看用户的网络连接">查看用户的网络连接</h3>
<p>结合使用 <code>-i</code> 和 <code>-u</code> 命令行选项，我们可以搜索Linux用户的所有网络连接。可以按照需要检查一个被黑客攻击的系统，如我们检查用户root的所有网络活动：</p>
<pre><code class="language-bash">lsof -a -i -u root
</code></pre>
<h3 id="列出所有内存映射文件">列出所有内存映射文件</h3>
<pre><code class="language-bash">lsof -d mem
</code></pre>
<h2 id="route">route</h2>
<p>在Linux中，route命令用于处理IP/内核路由表。主要用于通过网络接口建立到主机/IP的静态路由。它用于显示或更新IP/内核路由表。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>net-tools</code>  ；<code>apt install net-tools</code></li>
<li>CentOS/Fedora: <code>net-tools</code> ；<code>yum install -y net-tools</code></li>
<li>Apline：<code>net-tools </code> ；<code>apk add net-tools --no-cache</code></li>
</ul>
</blockquote>
<p>route命令不加任何参数，默认情况下将显示内核路由表条目的详细信息。当包在这个路由IP范围内发送时，通过ARP协议找到目的地的MAC地址，包将被发送到MAC地址。</p>
<p>当在路由条目中找不到对应的路由信息，数据包将被转发到默认网关，该网关决定该数据包的进一步路由。</p>
<p>route命令不加参数，会在输出时显示为主机名，这时解析会影响性能。可以使用 <code>-n</code> 选项请求不显示主机名。</p>
<pre><code class="language-bash">route -n
</code></pre>
<h3 id="添加默认网关">添加默认网关</h3>
<p>可以使用 <code>route add</code> 命令添加一个默认网关。</p>
<pre><code class="language-bash">route add default gw 10.0.0.1
</code></pre>
<h3 id="添加一条路由">添加一条路由</h3>
<p>这里添加一条，将通过10.0.0.0/24的流量由eth0设备通过 添加一条路由，如下所示。</p>
<pre><code class="language-bash">route add -net 10.0.0.0 netmask 255.255.255.0 dev eth0
</code></pre>
<p>-net 目标网络</p>
<p>dev 将规则和设备关联在一起</p>
<p><strong>添加一个目标主机</strong></p>
<pre><code class="language-bash">route add -host 12.123.0.10 gw 192.168.1.1 enp0s3
</code></pre>
<h3 id="列出内核路由表信息">列出内核路由表信息</h3>
<p>内核维护了路由缓存以更快地路由数据包。可以使用 <code>-C</code> 来打印内核的路由缓存信息。</p>
<pre><code class="language-bash">route -Cn

Kernel IP routing cache
Source          Destination     Gateway         Flags Metric Ref    Use Iface
10.0.0.4        10.0.0.1        10.0.0.1              0      1        0 eth0
10.0.0.1        10.0.0.4        10.0.0.4        il    0      0       44 lo
10.0.0.1        10.0.0.255      10.0.0.255      ibl   0      0        7 lo
</code></pre>
<h3 id="拒绝路由到特定的主机">拒绝路由到特定的主机</h3>
<p>有些场景下，可能需要拒绝数据包路由到特定的主机/网络。</p>
<pre><code class="language-bash">route add -host 192.168.1.51 reject
</code></pre>
<p>可以看到路由已经不会路由该流量了</p>
<pre><code class="language-bash">ping 10.0.0.2
connect: No route to host
</code></pre>
<p>如果需要拒绝整个网络可以这样</p>
<pre><code class="language-bash">route add -net 192.168.1.0 netmask 255.255.255.0 reject
</code></pre>
<h3 id="删除一条路由">删除一条路由</h3>
<pre><code># 删除默认路由
route del default
# 删除刚才添加的拒绝路由
route del -host 10.0.0.2 reject
</code></pre>
<h2 id="ncat--netcatnc--nmap">ncat &amp; netcat(nc) &amp; nmap</h2>
<p>netcat（简称nc）是一款功能强大的网络命令行工具，用于在Linux中执行与TCP、UDP或UNIX域套接字相关的任何操作。netcat可以用于端口扫描、端口重定向，作为端口监听器（用于传入连接）；它还可以用来打开远程连接和其他许多事情。此外，还可以将其用作访问目标服务器的后门。netcat还因此被称为TCP/IP的“瑞士军刀”。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>netcat</code>   ；<code>apt install netcat</code></li>
<li>CentOS/Fedora: <code>nc</code>  ；<code>yum install -y nc</code></li>
<li>Apline：<code>netcat-openbsd</code> ；<code>apk add --no-cache netcat-openbsd</code></li>
</ul>
</blockquote>
<h3 id="端口扫描-1">端口扫描</h3>
<p>netcat可以用于端口扫描：了解哪些端口是开放的，并且在目标机器上运行服务。它可以扫描单一或多个开防的端口。如示例，<code>-z</code> 选项将nc设置为只扫描监听守护进程，而不实际向它们发送任何数据。<code>-v</code> 选项启用详细模式，<code>-w</code> 为无法建立连接时超时时间。</p>
<pre><code class="language-bash">nc -v -w 10 -z 195.133.11.43 22

Ncat: Version 7.50 ( https://nmap.org/ncat )
Ncat: Connected to 195.133.11.43:22.
Ncat: 0 bytes sent, 0 bytes received in 0.25 seconds.
</code></pre>
<p>也可以扫描一个范围</p>
<pre><code class="language-bash">nc -v -n -z -w 1 127.0.0.1 1-1000
</code></pre>
<h3 id="在服务器间传送文件">在服务器间传送文件</h3>
<p>netcat可以在两台服务器之间传输文件，这两个系统都必须安装nc。例如，要将ISO映像文件从一台计算机复制到另一台计算机并监视传输进度（使用pv），请在发送方/接收端上运行以下命令。</p>
<p>将以<code>netcat</code> 的监听模式 <code>-l</code>。</p>
<pre><code class="language-bash">tar -zcf - debian-10.0.0-amd64-xfce-CD-1.iso  | pv | nc -l -p 3000 -q 5
</code></pre>
<p>在接受端运行命令</p>
<pre><code class="language-bash">nc 192.168.1.4 3000 | pv | tar -zxf -
</code></pre>
<h3 id="使用netcat实现一个命令行聊天服务器">使用netcat实现一个命令行聊天服务器</h3>
<p>可以使 <code>netcat</code> 创建一个简单的命令行消息服务器，前提条件是nc必须安装在两个系统上。在服务端，运行命令来创建监听端口5555的聊天服务器。</p>
<pre><code class="language-bash">nc -l -vv -p 5000
</code></pre>
<p>在客户端上，运行命令连接到服务端进行聊天会话。</p>
<pre><code class="language-bash">nc {ip} 5000
</code></pre>
<h3 id="使用nc创建一个web服务器">使用nc创建一个web服务器</h3>
<p>使用nc <code>-l</code> 选项可以创建一个基础的不安全的web服务器，需要一个静态html文件。然后可以通过 <code>while</code> 保持netcat命令不退出。正常情况下，netcat在连接断开时退出。</p>
<pre><code class="language-bash">while : ; do ( echo -ne &quot;HTTP/1.1 200 OK\r\n&quot; ; cat 1.html; ) | nc -l -p 8080 ; done
</code></pre>
<pre><code>$ while : ; do ( echo -ne &quot;HTTP/1.1 200 OK\r\n&quot; ; cat 1.html; ) | nc -l -p 8080 ; done
GET / HTTP/1.1
Host: ip:8080
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6
</code></pre>
<h3 id="网络故障排查">网络故障排查</h3>
<p>netcat 主要常用的一个方面时排查网络连接故障，可以使用 <code>netcat</code> 来验证服务器正在发送哪些数据以响应客户端发出的命令。</p>
<p>使用命令的可以输出包括web服务器发送的标头，这些标头可用于故障排除。也可以使用 <code>curl</code> 等命令进行同样的操作。</p>
<pre><code class="language-bash">printf &quot;GET / HTTP/1.0\r\n\r\n&quot; | nc baidu.com 80

HTTP/1.1 200 OK
Date: Mon, 28 Jun 2021 12:16:55 GMT
Server: Apache
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
ETag: &quot;51-47cf7e6ee8400&quot;
Accept-Ranges: bytes
Content-Length: 81
Cache-Control: max-age=86400
Expires: Tue, 29 Jun 2021 12:16:55 GMT
Connection: Close
Content-Type: text/html

&lt;html&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&gt;
&lt;/html&gt;
</code></pre>
<h3 id="查找端口上运行的服务">查找端口上运行的服务</h3>
<p>使用 <code>netcat</code> 可以获取服务监听端口的信息，单一般情况下，仅常见公共服务会这样，一些服务并不会相应对应的应用名称。。<code>-n</code> 标志表示禁用DNS或服务查找。</p>
<pre><code class="language-bash">nc -v -n 195.133.11.43 22
Ncat: Version 7.50 ( https://nmap.org/ncat )
Ncat: Connected to 195.133.11.43:22.
SSH-2.0-OpenSSH_7.4
</code></pre>
<h3 id="网络后门-1">网络后门</h3>
<p>一般情况下，黑客将 <code>netcat</code> 当作网络后门来运行，通过反弹式shell以获取远程命令。要充当后门。<code>-e</code>  在目标系统上运行的命令。</p>
<p>如监听一个端口，并将所有传入的输入传递给bash命令，结果将传送于客户端。</p>
<pre><code># linux
nc -l -p -v 3001  -e /bin/bash

# windows
nc -l -p 3001  -e cmd.exe
</code></pre>
<h3 id="检查一个udp端口">检查一个udp端口</h3>
<p><code>-z</code>：无法进行<code>I/O</code> ，仅报告连接状态</p>
<p><code>-u</code>：使用udp协议</p>
<pre><code class="language-bash">nc -vz -u 
</code></pre>
<h2 id="tcpdump-supa-href11asup">tcpdump <sup><a href="#1">[1]</a></sup></h2>
<p>tcpdump网络嗅探器，将强大和简单结合到一个单一的命令行界面中，能够将网络中的报文抓取，输出到屏幕或者记录到文件中。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>tcpdump</code> ；<code>apt-get install -y tcpdump</code></li>
<li>CentOS/Fedora: <code>tcpdump</code> ；<code>yum install -y tcpdump</code></li>
<li>Apline：<code>tcpdump </code> ；<code>apk add tcpdump --no-cache</code></li>
</ul>
</blockquote>
<p>查看指定接口上的所有通讯</p>
<p>语法</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i [interface]  </td>
<td>接口名</td>
</tr>
<tr>
<td>-p</td>
<td><code>--no-promiscuous-mode</code> 抓包内容为非混杂模式下的包</td>
</tr>
<tr>
<td>-w [flle]</td>
<td>保存原始的包到文件中</td>
</tr>
<tr>
<td>-n</td>
<td>不转换IP为DNS名称</td>
</tr>
<tr>
<td>-N</td>
<td>将端口解析为数字格式而不是服务名</td>
</tr>
<tr>
<td>-A</td>
<td>以 <em><strong>ASCII</strong></em> 格式打印内容（不包含标头）</td>
</tr>
<tr>
<td>-XX</td>
<td>打印数据为==数据包的标头==与以十六进制和 <em><strong>ASCII</strong></em> 格式打印数据包的数据。</td>
</tr>
<tr>
<td>-v/-vv/-vvv</td>
<td>详细信息；<code>-v</code>, <code>-vv</code> 将打印更多信息</td>
</tr>
<tr>
<td>-r</td>
<td>读取文件而不是实时抓包</td>
</tr>
</tbody>
</table>
<p><strong>关键字</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>type</strong></td>
<td><code>host</code>, <code>net</code>, <code>port</code>, <code>portrange</code></td>
</tr>
<tr>
<td><strong>direction</strong></td>
<td><code>src</code>, <code>dst</code>, <code>src or dst</code> , <code>src and ds</code></td>
</tr>
<tr>
<td><strong>protocol</strong></td>
<td><code>ether</code>, <code>ip</code>, <code>arp</code>, <code>tcp</code>, <code>udp</code>, <code>wlan</code></td>
</tr>
</tbody>
</table>
<h3 id="捕获所有网络接口">捕获所有网络接口</h3>
<pre><code class="language-bash">tcpdump -D
</code></pre>
<h3 id="按ip查找流量">按IP查找流量</h3>
<p>最常见的查询之一 <code>host</code>，可以看到来往于 <code>1.1.1.1</code> 的流量。</p>
<pre><code class="language-bash">tcpdump host 1.1.1.1
</code></pre>
<h3 id="按源目的-地址过滤">按源/目的 地址过滤</h3>
<p>如果只想查看来自/向某方向流量，可以使用 <code>src</code> 和 <code>dst</code>。</p>
<pre><code class="language-bash">tcpdump src|dst 1.1.1.1
</code></pre>
<h3 id="通过网络查找数据包">通过网络查找数据包</h3>
<p>使用 <code>net</code> 选项，来要查找出/入某个网络或子网的数据包。</p>
<pre><code class="language-bash">tcpdump net 1.2.3.0/24
</code></pre>
<h3 id="使用十六进制输出数据包内容">使用十六进制输出数据包内容</h3>
<p><code>hex</code> 可以以16进制输出包的内容</p>
<pre><code class="language-bash">tcpdump -c 1 -X icmp
</code></pre>
<h3 id="查看特定端口的流量">查看特定端口的流量</h3>
<p>使用 <code>port</code> 选项来查找特定的端口流量。</p>
<pre><code class="language-bash">tcpdump port 3389
tcpdump src port 1025
</code></pre>
<h3 id="查找端口范围的流量">查找端口范围的流量</h3>
<pre><code class="language-bash">tcpdump portrange 21-23
</code></pre>
<h3 id="过滤包的大小">过滤包的大小</h3>
<p>如果需要查找特定大小的数据包，可以使用以下选项。你可以使用 <code>less</code>，<code>greater</code>。</p>
<pre><code class="language-bash">tcpdump less 32
tcpdump greater 64
tcpdump &lt;= 128
</code></pre>
<h3 id="捕获流量输出为文件">捕获流量输出为文件</h3>
<p><code>-w</code>  可以将数据包捕获保存到一个文件中以便将来进行分析。这些文件称为<code>PCAP</code>（PEE-cap）文件，它们可以由不同的工具处理，包括 <code>Wireshark</code> 。</p>
<pre><code class="language-bash">tcpdump port 80 -w capture_file
</code></pre>
<h3 id="组合条件">组合条件</h3>
<p>tcpdump也可以结合逻辑运算符进行组合条件查询</p>
<ul>
<li>
<p><strong>AND</strong>
<em><code>and</code></em> or <code>&amp;&amp;</code></p>
</li>
<li>
<p><strong>OR</strong>
<em><code>or</code></em> or <code>||</code></p>
</li>
<li>
<p><strong>EXCEPT</strong>
<em><code>not</code></em> or <code>!</code></p>
</li>
</ul>
<pre><code class="language-bash">tcpdump -i eth0 -nn host 220.181.57.216 and 10.0.0.1  # 主机之间的通讯
tcpdump -i eth0 -nn host 220.181.57.216 or 10.0.0.1
# 获取10.0.0.1与 10.0.0.9或 10.0.0.1 与10.0.0.3之间的通讯
tcpdump -i eth0 -nn host 10.0.0.1 and \(10.0.0.9 or 10.0.0.3\)
</code></pre>
<h3 id="原始输出">原始输出</h3>
<p>并显示人类可读的内容进行输出包（不包含内容）。</p>
<pre><code class="language-tcpdump">tcpdump -ttnnvvS -i eth0 
</code></pre>
<h3 id="ip到端口">IP到端口</h3>
<p>让我们查找从某个IP到端口任何主机的某个端口所有流量。</p>
<pre><code class="language-bash">tcpdump -nnvvS src 10.5.2.3 and dst port 3389
</code></pre>
<h3 id="去除特定流量">去除特定流量</h3>
<p>可以将指定的流量排除，如这显示所有到192.168.0.2的 非ICMP的流量。</p>
<pre><code class="language-bash">tcpdump dst 192.168.0.2 and src net and not icmp
</code></pre>
<p>来自非指定端口的流量，如，显示来自不是SSH流量的主机的所有流量。</p>
<pre><code class="language-bash">tcpdump -vv src mars and not dst port 22
</code></pre>
<h3 id="选项分组">选项分组</h3>
<p>在构建复杂查询时，必须使用单引号 <code>'</code>。单引号用于忽略特殊符号 <code>()</code> ，以便于使用其他表达式（如host, port, net等）进行分组。</p>
<pre><code class="language-###">tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
</code></pre>
<h3 id="过滤tcp标记位">过滤TCP标记位</h3>
<p>TCP RST</p>
<p>The filters below find these various packets because tcp[13] looks at offset 13 in the TCP header, the number represents the location within the byte, and the !=0 means that the flag in question is set to 1, i.e. it’s on.</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 4!=0'
tcpdump 'tcp[tcpflags] == tcp-rst'
</code></pre>
<p>TCP SYN</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 2!=0'
tcpdump 'tcp[tcpflags] == tcp-syn'
</code></pre>
<p>同时忽略SYN和ACK标志的数据包</p>
<pre><code class="language-bash">tcpdump 'tcp[13]=18'
</code></pre>
<p>TCP URG</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 32!=0'
tcpdump 'tcp[tcpflags] == tcp-urg'
</code></pre>
<p>TCP ACK</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 16!=0'
tcpdump 'tcp[tcpflags] == tcp-ack'
</code></pre>
<p>TCP PSH</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 8!=0'
tcpdump 'tcp[tcpflags] == tcp-push'
</code></pre>
<p>TCP FIN</p>
<pre><code class="language-bash">tcpdump 'tcp[13] &amp; 1!=0'
tcpdump 'tcp[tcpflags] == tcp-fin'
</code></pre>
<h3 id="查找http包">查找http包</h3>
<p>查找 <code>user-agent</code> 信息</p>
<pre><code class="language-bash">tcpdump -vvAls0 | grep 'User-Agent:'
</code></pre>
<p>查找只是 <code>GET</code> 请求的流量</p>
<pre><code class="language-bash">tcpdump -vvAls0 | grep 'GET'
</code></pre>
<p>查找http客户端IP</p>
<pre><code class="language-bash">tcpdump -vvAls0 | grep 'Host:'
</code></pre>
<p>查询客户端cookie</p>
<pre><code class="language-bash">tcpdump -vvAls0 | grep 'Set-Cookie|Host:|Cookie:'
</code></pre>
<h3 id="查找dns流量">查找DNS流量</h3>
<pre><code class="language-bash">tcpdump -vvAs0 port 53
</code></pre>
<h3 id="查找对应流量的明文密码">查找对应流量的明文密码</h3>
<pre><code class="language-bash">tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -lA | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd= |password=|pass:|user:|username:|password:|login:|pass |user '
</code></pre>
<h3 id="arp">arp</h3>
<p>ARP “地址解析协议” (<code>Address Resolution Protoco</code>)，是一种将IP地址映射到局域网上物理MAC地址的协议。</p>
<p><strong>为什么我们需要MAC地址？</strong></p>
<p>任何本地通信都将使用MAC地址，而不是IP地址。当一台计算机想在不同的网络上与另一台计算机通信时，将使用IP地址。IP地址就像你的邮寄收货地址，而MAC地址就像你的名字。在TCP/IP网络上，每台计算机都被分配IP地址，一些本地服务器的IP地址也被分配给网络客户主机。因此其在第2层（数据链路层）和第3层（网络层）之间工作。</p>
<p>在一个本地网络中，客户主机尝试在连接另外一个主机时（这里为同一网络，即同一广播域中），首先客户端会检查ARP缓存表（缓存IP于MAC的关系）。而 <code>arp</code> 命令可以管理系统的arp缓存表。它允许完全转储ARP缓存。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>net-tools</code>   ；<code>apt install net-tools</code></li>
<li>CentOS/Fedora: <code>net-tools</code>  ；<code>yum install -y net-tools</code></li>
<li>Apline：<code>net-tools</code> ；<code>apk add --no-cache net-tools</code></li>
</ul>
</blockquote>
<h3 id="查看arp条目">查看arp条目</h3>
<p><code>arp</code> 命令在没有任何选项的情况下将显示arp缓存表的内容。</p>
<pre><code class="language-bash">arp

Address                  HWtype  HWaddress           Flags Mask            Iface
correspond.fsddsfk.cn    ether   c4:71:fe:f1:9f:3f   C                     eth0
gateway                  ether   00:1f:ce:72:bd:8c   C                     eth0
</code></pre>
<h3 id="显示一个特定的arp条目">显示一个特定的arp条目</h3>
<p>当arp缓存表很大不利于查看，并且仅需要拿到特定IP的条目的话，可以在 <code>-a</code> 后加具体IP地址来获取一个特定的条目。</p>
<pre><code class="language-bash">arp -a 46.17.40.155
correspond.faaaaa.cn (10.17.40.1) at c4:71:fe:f1:9f:3f [ether] on eth0
</code></pre>
<h3 id="显示指定接口的arp缓存表">显示指定接口的arp缓存表</h3>
<p>如果仅希望显示一个接口的arp条目，可以通过 <code>arp</code> 命令 <code>-i</code>选项后跟接口名称。</p>
<pre><code class="language-bash">arp -i bond0

Address                HWtype  HWaddress           Flags Mask            Iface
usartdb02.exmpl.c      ether   17:a9:9b:f5:1a:7e   C                     bond0
usartdb02.exmpl.c      ether   f8:db:77:f2:5a:a2   C                     bond0
</code></pre>
<h3 id="删除一个arp条目">删除一个arp条目</h3>
<p>从arp缓存表中删除一个ip条目，可以使用 <code>arp</code> 命令-d选项，后跟IP地址。当一旦执行arp命令，ARP缓存表就会被刷新。</p>
<pre><code class="language-bash">arp -d 192.168.188.2
</code></pre>
<h3 id="向arp缓存添加一个条目">向arp缓存添加一个条目</h3>
<p>永久添加一个条目到arp缓存中，使用 <code>-s</code> 选项，需要指定IP地址和MAC地址外，还需要指定将条目添加到哪个接口。如：</p>
<pre><code class="language-bash">arp -s 192.168.188.133 -i eth0 00:0c:29:f6:1d:81
</code></pre>
<h3 id="清空arp缓存表">清空arp缓存表</h3>
<p>某些场景下，需要清空arp缓存，而 <code>arp</code> 命令并没有清空缓存表的操作，这时可以使用 <code>ip neigh</code>   而且<code>ip-route2</code> 最小化安装；基础容器等场景下也会存在。</p>
<pre><code class="language-bash">ip neigh flush dev eth0s
</code></pre>
<h3 id="显示格式">显示格式</h3>
<p>使用 <code>-e</code> 选项以linux标准格式输出arp缓存表</p>
<p>其输出格式中，ARP缓存表中的每个完整条目都将被标记为 <code>C</code> Complete entry。<code>M</code> （Permanent entry）表示永久条目；<code>P</code> （Published entry.）表示已发布条目标记。</p>
<pre><code class="language-bash">arp -ae

Address                  HWtype  HWaddress           Flags Mask            Iface
correspond.fsddsfk.cn    ether   c4:71:fe:fe:9f:2f   C                     eth0

arp -aen

Address                  HWtype  HWaddress           Flags Mask            Iface
36.17.40.111             ether   c4:71:fe:fe:9f:2f   C                     eth0
</code></pre>
<h2 id="arp-scan">arp-scan</h2>
<p>网络扫描是渗透测试的步骤之一。有不同的和流行的工具来扫描网络线masscan，nmap等。Arp扫描。</p>
<p><code>arp-scan</code> 是专门设计用来扫描二层（网络层）的mac, arp数据包的工具（也可称为<code>ARP Sweep</code> 或 <code>MAC Scanner</code> ）；是一个非常快速的ARP包扫描程序，它可以显示子网中所有活动的IPv4设备。由于ARP是不可路由的，这种类型的扫描仪只能在本地LAN（本地子网或网段）上工作。</p>
<p><code>arp-scan</code> 显示所有活动设备，即使它们有防火墙。设备不能像躲避Ping一样躲避ARP包。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>arp-scan</code>   ；<code>apt install arp-scan</code></li>
<li>CentOS/Fedora: <code>arp-scan</code> (epel)  ；<code>yum install -y arp-scan</code></li>
<li>Apline：<code>arp-scan</code> ；<code>apk add --no-cache arp-scan</code></li>
</ul>
</blockquote>
<h3 id="扫描本地网络">扫描本地网络</h3>
<p><code>arp-scan</code> 的最基本使用方法是扫描本地网络，使用<code>-l</code> 或 <code>--localnet</code> 可以扫描整个本地网络，但需要root权限</p>
<pre><code class="language-bash">arp-scan  --localnet

Interface: eth0, type: EN10MB, MAC: da:78:c8:7a:fb:26, IPv4: 195.133.11.43
Starting arp-scan 1.9.7 with 512 hosts (https://github.com/royhills/arp-scan)
195.133.10.1    00:1f:ce:72:bd:8c       QTECH LLC
195.133.10.2    56:85:8e:2b:cf:11       (Unknown: locally administered)
195.133.10.5    de:58:c6:5b:b5:c2       (Unknown: locally administered)
195.133.10.7    de:ed:ae:4b:7a:c8       (Unknown: locally administered)
195.133.10.6    d2:a6:f4:4c:f0:4b       (Unknown: locally administered)
</code></pre>
<h3 id="设置源mac">设置源mac</h3>
<p>在apr扫描的过程中，会使用现有的mac地址进行请求，这样会留下网络痕迹，<code>arp-scan</code> 提供了修改源mac的功能。使用 <code>--destaddr</code> 或 <code>-T</code> 。</p>
<p>###指定特殊vlan</p>
<p>在网络设备中，一个接口可以实现多个网络，这使用了虚拟局域网VLAN（Virtual Local Area Network）的多路复用协议。如果接口是 <code>trunk</code> ，意味接口承载多个VLAN，我们可能需要指定VLAN id，可以使用 <code>--vlan</code> 或 <code>-Q</code>指定vlan id</p>
<pre><code class="language-bash">arp-scan -i eth0 -Q 10
</code></pre>
<h3 id="发现网络冲突">发现网络冲突</h3>
<p><code>arp-scan</code> 也可用于发现IP冲突与识别设备等操，只需一个命令 <code>arp scan -l</code>。可以通过 <code>-i</code> 指定端口。</p>
<p>这里 <code>192.168.1.39</code> 冲突，因为出现了两次并且指定了不同的mac地址。</p>
<pre><code class="language-bash">arp-scan –I eth0 -l

192.168.1.10   00:1b:a9:63:a2:4c       BROTHER INDUSTRIES, LTD.
192.168.1.30   00:1e:8f:58:ec:49       CANON INC.
192.168.1.33   00:25:4b:1b:10:20       Apple, Inc
192.168.1.37   10:9a:dd:55:d7:95       Apple Inc
192.168.1.38   20:c9:d0:27:8d:56       (Unknown)
192.168.1.39   d4:85:64:4d:35:be       Hewlett Packard
192.168.1.39   00:0b:46:e4:8e:6d       Cisco (DUP: 2)
192.168.1.40   90:2b:34:18:59:c0       (Unknown)
</code></pre>
<h2 id="ethtool">ethtool</h2>
<p><code>ethtool</code> 命令用于 显示, 配置以太网设备。可以在Linux中使用此工具更改网卡速度, 自动协商, LAN唤醒设置, 双工模式。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian:  <code>ethtool</code>   ；<code>apt install ethtool</code></li>
<li>CentOS/Fedora: <code>ethtool</code> (epel)  ；<code>yum install -y ethtool</code></li>
<li>Apline：<code>ethtool</code> ；<code>apk add --no-cache ethtool</code></li>
</ul>
</blockquote>
<h3 id="列出以太网设备属性">列出以太网设备属性</h3>
<pre><code class="language-bash">ethtool eth0

Settings for eth0:
        Supported ports: [ ]
        Supported link modes:   Not reported
        Supported pause frame use: No
        Supports auto-negotiation: No
        Supported FEC modes: Not reported
        Advertised link modes:  Not reported
        Advertised pause frame use: No
        Advertised auto-negotiation: No
        Advertised FEC modes: Not reported
        Speed: Unknown!
        Duplex: Unknown! (255)
        Port: Other
        PHYAD: 0
        Transceiver: internal
        Auto-negotiation: off
        Link detected: yes
</code></pre>
<h3 id="查看网络接口于容器内接口的对应关系">查看网络接口于容器内接口的对应关系</h3>
<p>可以通过ethtool查看容器的网卡对，通过<code>-S</code> 加接口设备名，<code>-S</code> 为统计信息</p>
<p>在宿主机上 使用命令查看，其中<code>peer_ifindex: 767</code> 对应容器内 <code>ip link</code> 的编号</p>
<pre><code class="language-bash">ethtool -S veth45562ed 
</code></pre>
<p>容器内</p>
<pre><code>$ ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
767: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff
</code></pre>
<h2 id="nsenter">nsenter</h2>
<p>nsenter是一款可以进入进程的名称空间中。例如，如果一个容器以非 root 用户身份运行，而使用 <code>docker exec</code> 进入其中后，但该容器没有安装 <code>sudo</code> 或未 <code>netstat</code> ，并且您想查看其当前的网络属性，如开放端口，这种场景下将如何做到这一点？<em><strong>nsenter</strong></em> 就是用来解决这个问题的。</p>
<p><strong>nsenter</strong> (<em>namespace enter</em>) 可以在容器的宿主机上使用 <em>nsenter</em> 命令进入容器的命名空间，以容器视角使用宿主机上的相应网络命令进行操作。==当然需要拥有 <em>root</em> 权限==</p>
<blockquote>
<p><strong>各系统下的安装</strong> <sup><a href="#4">[4]</a></sup></p>
<ul>
<li>Ubuntu/Debian: <code>util-linux</code>  ；<code>apt-get install -y util-linux</code></li>
<li>CentOS/Fedora: <code>util-linux</code> ；<code>yum install -y util-linux</code></li>
<li>Apline：<code>util-linux</code> ；<code>apk add util-linux --no-cache</code></li>
</ul>
</blockquote>
<p><em>nsenter</em> 的使用语法为，<code>nsenter -t pid -n &lt;commond&gt;</code>，<code>-t</code> 接 进程ID号，<code>-n</code> 表示进入名称空间内，<code>&lt;commond&gt;</code> 为执行的命令。更多的内容可以参考 <sup><a href="#3">[3]</a></sup></p>
<p>实例：如我们有一个Pod进程ID为30858，进入该Pod名称空间内执行 <code>ifconfig</code> ，如下列所示</p>
<pre><code class="language-bash">$ ps -ef|grep tail
root      17636  62887  0 20:19 pts/2    00:00:00 grep --color=auto tail
root      30858  30838  0 15:55 ?        00:00:01 tail -f

$ nsenter -t 30858 -n ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1480
        inet 192.168.1.213  netmask 255.255.255.0  broadcast 192.168.1.255
        ether 5e:d5:98:af:dc:6b  txqueuelen 0  (Ethernet)
        RX packets 92  bytes 9100 (8.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 92  bytes 8422 (8.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 5  bytes 448 (448.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5  bytes 448 (448.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

net1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 10.1.0.201  netmask 255.255.255.0  broadcast 10.1.0.255
        ether b2:79:f9:dd:2a:10  txqueuelen 0  (Ethernet)
        RX packets 228  bytes 21272 (20.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 216  bytes 20272 (19.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<h3 id="如何定位pod名称空间">如何定位Pod名称空间</h3>
<p>首先需要确定Pod所在的节点名称</p>
<pre><code class="language-bash">$ kubectl get pods -owide |awk '{print $1,$7}'
NAME NODE
netbox-85865d5556-hfg6v master-machine
netbox-85865d5556-vlgr4 node01
</code></pre>
<p>如果Pod不在当前节点还需要用IP登录则还需要查看IP（可选）</p>
<pre><code class="language-bash">$ kubectl get pods -owide |awk '{print $1,$6,$7}'
NAME IP NODE
netbox-85865d5556-hfg6v 192.168.1.213 master-machine
netbox-85865d5556-vlgr4 192.168.0.4 node01
</code></pre>
<p>接下来，登录节点，获取容器lD，如下列所示，每个pod默认有一个 <em>pause</em> 容器，其他为用户yaml文件中定义的容器，理论上所有容器共享相同的网络命名空间，排查时可任选一个容器。</p>
<pre><code class="language-bash">$ docker ps |grep netbox-85865d5556-hfg6v
6f8c58377aae   f78dd05f11ff                                                    &quot;tail -f&quot;                45 hours ago   Up 45 hours             k8s_netbox_netbox-85865d5556-hfg6v_default_4a8e2da8-05d1-4c81-97a7-3d76343a323a_0
b9c732ee457e   registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1   &quot;/pause&quot;                 45 hours ago   Up 45 hours             k8s_POD_netbox-85865d5556-hfg6v_default_4a8e2da8-05d1-4c81-97a7-3d76343a323a_0
</code></pre>
<p>接下来获得获取容器在节点系统中对应的进程号，如下所示</p>
<pre><code class="language-bash">$ docker inspect --format &quot;{{ .State.Pid }}&quot; 6f8c58377aae
30858
</code></pre>
<p>最后就可以通过 <em>nsenter</em> 进入容器网络空间执行命令了</p>
<h2 id="paping">paping</h2>
<p><strong>paping</strong> 命令可对目标地址指定端口以TCP协议进行连续ping，通过这种特性可以弥补 <em>ping</em> ICMP协议，以及 <em>nmap</em> , <em>telnet</em> 只能进行一次操作的的不足；通常情况下会用于测试端口连通性和丢包率</p>
<p>paping download：<a href="https://code.google.com/archive/p/paping/" target="_blank"
   rel="noopener nofollow noreferrer" >paping</a></p>
<p><em>paping</em> 还需要安装以下依赖，这取决于你安装的 <em>paping</em> 版本</p>
<ul>
<li>RedHat/CentOS：<code>yum install -y libstdc++.i686 glibc.i686</code></li>
<li>Ubuntu/Debian：最小化安装无需依赖</li>
</ul>
<pre><code class="language-bash">$ paping -h
paping v1.5.5 - Copyright (c) 2011 Mike Lovell

Syntax: paping [options] destination

Options:
 -?, --help     display usage
 -p, --port N   set TCP port N (required)
     --nocolor  Disable color output
 -t, --timeout  timeout in milliseconds (default 1000)
 -c, --count N  set number of checks to N
</code></pre>
<h2 id="mtr">mtr</h2>
<p><strong>mtr</strong> 是一个跨平台的网络诊断工具，将 <strong>traceroute</strong> 和 <strong>ping</strong> 的功能结合到一个工具。与 <em>traceroute</em> 不同的是 <em>mtr</em> 显示的信息比起 <em>traceroute</em> 更加丰富：通过 <em>mtr</em> 可以确定网络的条数，并且可以同时打印响应百分比以及网络中各跳跃点的响应时间。</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>mtr</code>  ；<code>apt-get install -y mtr</code></li>
<li>CentOS/Fedora: <code>mtr</code> ；<code>yum install -y mtr</code></li>
<li>Apline：<code>mtr</code> ；<code>apk add mtr --no-cache</code></li>
</ul>
</blockquote>
<h3 id="简单的使用示例">简单的使用示例</h3>
<p>最简单的示例，就是后接域名或IP，这将跟踪整个路由</p>
<pre><code class="language-bash">$ mtr google.com

Start: Thu Jun 28 12:10:13 2018
HOST: TecMint                     Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.0.1                0.0%     5    0.3   0.3   0.3   0.4   0.0
  2.|-- 5.5.5.211                  0.0%     5    0.7   0.9   0.7   1.3   0.0
  3.|-- 209.snat-111-91-120.hns.n 80.0%     5    7.1   7.1   7.1   7.1   0.0
  4.|-- 72.14.194.226              0.0%     5    1.9   2.9   1.9   4.4   1.1
  5.|-- 108.170.248.161            0.0%     5    2.9   3.5   2.0   4.3   0.7
  6.|-- 216.239.62.237             0.0%     5    3.0   6.2   2.9  18.3   6.7
  7.|-- bom05s12-in-f14.1e100.net  0.0%     5    2.1   2.4   2.0   3.8   0.5
</code></pre>
<p><code>-n</code> 强制 <em>mtr</em> 打印 IP地址而不是主机名</p>
<pre><code class="language-bash">$ mtr -n google.com

Start: Thu Jun 28 12:12:58 2018
HOST: TecMint                     Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.0.1                0.0%     5    0.3   0.3   0.3   0.4   0.0
  2.|-- 5.5.5.211                  0.0%     5    0.9   0.9   0.8   1.1   0.0
  3.|-- ???                       100.0     5    0.0   0.0   0.0   0.0   0.0
  4.|-- 72.14.194.226              0.0%     5    2.0   2.0   1.9   2.0   0.0
  5.|-- 108.170.248.161            0.0%     5    2.3   2.3   2.2   2.4   0.0
  6.|-- 216.239.62.237             0.0%     5    3.0   3.2   3.0   3.3   0.0
  7.|-- 172.217.160.174            0.0%     5    3.7   3.6   2.0   5.3   1.4
</code></pre>
<p><code>-b</code> 同时显示IP地址与主机名</p>
<pre><code class="language-bash">$ mtr -b google.com

Start: Thu Jun 28 12:14:36 2018
HOST: TecMint                     Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- 192.168.0.1                0.0%     5    0.3   0.3   0.3   0.4   0.0
  2.|-- 5.5.5.211                  0.0%     5    0.7   0.8   0.6   1.0   0.0
  3.|-- 209.snat-111-91-120.hns.n  0.0%     5    1.4   1.6   1.3   2.1   0.0
  4.|-- 72.14.194.226              0.0%     5    1.8   2.1   1.8   2.6   0.0
  5.|-- 108.170.248.209            0.0%     5    2.0   1.9   1.8   2.0   0.0
  6.|-- 216.239.56.115             0.0%     5    2.4   2.7   2.4   2.9   0.0
  7.|-- bom07s15-in-f14.1e100.net  0.0%     5    3.7   2.2   1.7   3.7   0.9
</code></pre>
<p><code>-c</code> 跟一个具体的值，这将限制 <em>mtr</em> ping的次数，到达次数后会退出</p>
<pre><code class="language-bash">$ mtr -c5 google.com
</code></pre>
<p>如果需要指定次数，并且在退出后保存这些数据，使用 <code>-r</code> flag</p>
<pre><code class="language-bash">$ mtr -r -c 5 google.com &gt;  1
$ cat 1
Start: Sun Aug 21 22:06:49 2022
HOST: xxxxx.xxxxx.xxxx.xxxx Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- gateway                    0.0%     5    0.6 146.8   0.6 420.2 191.4
  2.|-- 212.xx.21.241              0.0%     5    0.4   1.0   0.4   2.3   0.5
  3.|-- 188.xxx.106.124            0.0%     5    0.7   1.1   0.7   2.1   0.5
  4.|-- ???                       100.0     5    0.0   0.0   0.0   0.0   0.0
  5.|-- 72.14.209.89               0.0%     5   43.2  43.3  43.1  43.3   0.0
  6.|-- 108.xxx.250.33             0.0%     5   43.2  43.1  43.1  43.2   0.0
  7.|-- 108.xxx.250.34             0.0%     5   43.7  43.6  43.5  43.7   0.0
  8.|-- 142.xxx.238.82             0.0%     5   60.6  60.9  60.6  61.2   0.0
  9.|-- 142.xxx.238.64             0.0%     5   59.7  67.5  59.3  89.8  13.2
 10.|-- 142.xxx.37.81              0.0%     5   62.7  62.9  62.6  63.5   0.0
 11.|-- 142.xxx.229.85             0.0%     5   61.0  60.9  60.7  61.3   0.0
 12.|-- xx-in-f14.1e100.net  0.0%     5   59.0  58.9  58.9  59.0   0.0
</code></pre>
<p>默认使用的是 ICMP 协议 <code>-i</code> ，可以指定 <code>-u</code>,  <code>-t</code> 使用其他协议</p>
<pre><code class="language-bash">mtr --tcp google.com
</code></pre>
<p><code>-m</code> 指定最大的跳数</p>
<pre><code class="language-bash">mtr -m 35 216.58.223.78
</code></pre>
<p><code>-s</code> 指定包的大小</p>
<h3 id="mtr输出的数据">mtr输出的数据</h3>
<table>
<thead>
<tr>
<th>colum</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>last</td>
<td>最近一次的探测延迟值</td>
</tr>
<tr>
<td>avg</td>
<td>探测延迟的平均值</td>
</tr>
<tr>
<td>best</td>
<td>探测延迟的最小值</td>
</tr>
<tr>
<td>wrst</td>
<td>探测延迟的最大值</td>
</tr>
<tr>
<td>stdev</td>
<td>标准偏差。越大说明相应节点越不稳定</td>
</tr>
</tbody>
</table>
<h3 id="丢包判断">丢包判断</h3>
<p>任一节点的 <code>Loss%</code>（丢包率）如果不为零，则说明这一跳网络可能存在问题。导致相应节点丢包的原因通常有两种。</p>
<ul>
<li>运营商基于安全或性能需求，人为限制了节点的ICMP发送速率，导致丢包。</li>
<li>节点确实存在异常，导致丢包。可以结合异常节点及其后续节点的丢包情况，来判定丢包原因。</li>
</ul>
<blockquote>
<p>Notes:</p>
<ul>
<li>如果随后节点均没有丢包，则通常说明异常节点丢包是由于运营商策略限制所致。可以忽略相关丢包。</li>
<li>如果随后节点也出现丢包，则通常说明节点确实存在网络异常，导致丢包。对于这种情况，如果异常节点及其后续节点连续出现丢包，而且各节点的丢包率不同，则通常以最后几跳的丢包率为准。如链路测试在第5, 6, 7跳均出现了丢包。最终丢包情况以第7跳作为参考。</li>
</ul>
</blockquote>
<h3 id="延迟判断">延迟判断</h3>
<p>由于链路抖动或其它因素的影响，节点的 <em>Best</em> 和 <em>Worst</em> 值可能相差很大。而 <em>Avg</em>（平均值）统计了自链路测试以来所有探测的平均值，所以能更好的反应出相应节点的网络质量。而 <em>StDev</em>（标准偏差值）越高，则说明数据包在相应节点的延时值越不相同（越离散）。所以标准偏差值可用于协助判断 <em>Avg</em> 是否真实反应了相应节点的网络质量。例如，如果标准偏差很大，说明数据包的延迟是不确定的。可能某些数据包延迟很小（例如：25ms），而另一些延迟却很大（例如：350ms），但最终得到的平均延迟反而可能是正常的。所以此时 <em>Avg</em> 并不能很好的反应出实际的网络质量情况。</p>
<p>这就需要结合如下情况进行判断：</p>
<ul>
<li>如果 <em>StDev</em> 很高，则同步观察相应节点的 <em>Best</em> 和 <em>wrst</em>，来判断相应节点是否存在异常。</li>
<li>如果<em>StDev</em> 不高，则通过Avg来判断相应节点是否存在异常。</li>
</ul>
<h2 id="brctl-supa-href55asup">brctl <sup><a href="#5">[5]</a></sup></h2>
<p><em><strong>brctl</strong></em> 是用于创建和操作 Linux Bridge 的命令行工具，</p>
<blockquote>
<p><strong>各系统下的安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>bridge-utils</code>  ；<code>apt-get install -y bridge-utils</code></li>
<li>CentOS/Fedora: <code> bridge-utils</code> ；<code>yum install -y bridge-utils</code></li>
<li>Apline：<code>bridge-utils</code> ；<code>apk add bridge-utils --no-cache</code></li>
</ul>
</blockquote>
<h3 id="显示所有启用的网桥的设备">显示所有启用的网桥的设备</h3>
<p>使用 <code>brctl show</code> 查看当前节点可用的 bridge</p>
<pre><code class="language-bash">$ brctl show
bridge name bridge id STP enabled interfaces
br0 8000.000d3a8a7868 no eth1
vnet0
virbr0 8000.5254005098ae yes virbr0-nic
</code></pre>
<h3 id="创建网桥">创建网桥</h3>
<p>使用 <code>brctl addbr &lt;name&gt;</code> 可以创建出一个Linux Bridge</p>
<pre><code class="language-bash">brctl addbr dev
</code></pre>
<h3 id="在网桥上添加接口">在网桥上添加接口</h3>
<p>使用 <code>brctl addif &lt;bridge_name&gt; &lt;interface_name&gt;</code> 可以在一个已经存在的 bridge 上添加一个接口</p>
<pre><code class="language-bash">$ brctl addif br0 eth1
</code></pre>
<p>指定多个 <code>&lt;interface_name&gt;</code>  会向网桥上添加多个接口</p>
<pre><code class="language-bash">$ brctl addif br0 enp0s3 enp1s3
</code></pre>
<h3 id="删除网桥">删除网桥</h3>
<p>使用 <code>brctl delbr &lt;bridge_name&gt;</code> 可以删除一个网桥</p>
<pre><code class="language-bash">$ brctl delbr br0
</code></pre>
<h3 id="检查网桥-stf-信息">检查网桥 STF 信息</h3>
<p>使用 <code>brctl showstp &lt;bridge_name&gt;</code> 可以查看网桥的STF信息</p>
<pre><code class="language-bash">$ brctl showstp br0
br0
bridge id 8000.000000000000
designated root 8000.000000000000
root port 0 path cost 0
max age 20.00 bridge max age 20.00
hello time 2.00 bridge hello time 2.00
forward delay 15.00 bridge forward delay 15.00
ageing time 300.00
hello timer 0.00 tcn timer 0.00
topology change timer 0.00 gc timer 0.00
flags
</code></pre>
<h3 id="从网桥上删除接口">从网桥上删除接口</h3>
<p>使用 <code>brctl delif &lt;bridge_name&gt; &lt;interface_name&gt;</code> 可以从网桥上删除接口。</p>
<pre><code class="language-bash">$ brctl delif br0 enp0s3
</code></pre>
<h3 id="开启关闭生成树协议">开启/关闭生成树协议</h3>
<p>使用 <code>brctl stp &lt;bridge_name&gt; on/off</code> 可以选择开启或关闭生成树协议</p>
<pre><code class="language-bash">$ brctl stp br0 off
$ brctl stp br0 on
</code></pre>
<h3 id="查看网桥上学到的mac地址">查看网桥上学到的MAC地址</h3>
<p>使用 <code>brctl showmacs &lt;bridge_name&gt;</code> 可以查看网桥上学到的所有设备的MAC地址。</p>
<pre><code class="language-bash">$ brctl showmacs br0
port no mac addr                is local?       ageing timer
1       00:74:16:87:14:de       yes                0.00
</code></pre>
<h3 id="修改stp值">修改STP值</h3>
<p>如果需要修改 STP 参数值，可以通过 <code>brctl setageing &lt;bridge_name&gt; &lt;value&gt;</code> 来修改</p>
<pre><code class="language-bash">$ brctl setageing br0 100
</code></pre>
<h2 id="bridge-supa-href66asup">bridge <sup><a href="#6">[6]</a></sup></h2>
<p><em><strong>bridge</strong></em> 是一款用于展示和操作网桥地址和设备的命令，通常情况下</p>
<blockquote>
<p><strong>各系统下的包名与安装</strong></p>
<ul>
<li>Ubuntu/Debian: <code>iproute2</code>  ；<code>apt install iproute2</code></li>
<li>CentOS/Fedora: <code>iproute2</code> ；<code>yum install -y iproute2</code></li>
<li>Apline：<code>iproute2 </code> ；<code>apk add iproute2</code></li>
</ul>
</blockquote>
<p>bridge 命令可以完成三种类型的配置管理：</p>
<ul>
<li>端口配置</li>
<li>FDB管理</li>
<li>VLAN 配置</li>
</ul>
<p>大多数人都会使用 <em><strong>brctl</strong></em> 命令替代，而 <em><strong>bridge</strong></em> 通常只是来完成 <em><strong>FDB</strong></em> (forwarding database management ) 的相关操作。。也可以使用 <em><strong>bridge</strong></em> 命令创建和删除VLAN。</p>
<h3 id="bridge-vs-brct-supa-href77asup">bridge vs brct <sup><a href="#7">[7]</a></sup></h3>
<center>BRIDGE MANAGEMENT</center>
<table>
<thead>
<tr>
<th>动作</th>
<th>BRCTL</th>
<th>BRIDGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建bridge</td>
<td><code>brctl addbr &lt;bridge&gt;</code></td>
<td></td>
</tr>
<tr>
<td>删除bridge</td>
<td><code>brctl delbr &lt;bridge&gt;</code></td>
<td></td>
</tr>
<tr>
<td>为bridge添加接口</td>
<td><code>brctl addif &lt;bridge&gt; &lt;ifname&gt;</code></td>
<td></td>
</tr>
<tr>
<td>删除bridge上的接口</td>
<td><code>brctl delbr &lt;bridge&gt;</code></td>
<td></td>
</tr>
</tbody>
</table>
<center>FDB MANAGEMENT</center>
<table>
<thead>
<tr>
<th>ACTION</th>
<th>BRCTL</th>
<th>BRIDGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>显示 FDB 中的 MAC 列表</td>
<td><code>brctl showmacs &lt;bridge&gt;</code></td>
<td><code>bridge fdb show</code></td>
</tr>
<tr>
<td>设置 FDB 条目老化时间</td>
<td><code>brctl setageingtime  &lt;bridge&gt; &lt;time&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置 FDB 垃圾回收间隔</td>
<td><code>brctl setgcint &lt;brname&gt; &lt;time&gt;</code></td>
<td></td>
</tr>
<tr>
<td>添加FDB 条目(add)</td>
<td></td>
<td><code>bridge fdb add dev &lt;interface&gt; [dst, vni, port, via]</code></td>
</tr>
<tr>
<td>追加FDB条目(append)</td>
<td></td>
<td><code>bridge fdb append  (parameters same as for fdb add)</code></td>
</tr>
<tr>
<td>删除 FDB 条目</td>
<td></td>
<td><code>bridge fdb delete (parameters same as for fdb add)</code></td>
</tr>
</tbody>
</table>
<center>STP MANAGEMENT</center>
<table>
<thead>
<tr>
<th>ACTION</th>
<th>BRCTL</th>
<th>BRIDGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开/关闭 STP</td>
<td><code>brctl stp &lt;bridge&gt; &lt;state&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置网桥优先级</td>
<td><code>brctl setbridgeprio &lt;bridge&gt; &lt;priority&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置网桥转发延迟</td>
<td><code>brctl setfd &lt;bridge&gt; &lt;time&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置bridge  “hello”时间</td>
<td><code>brctl sethello &lt;bridge&gt; &lt;time&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置网桥最大消息年龄</td>
<td><code>brctl setmaxage &lt;bridge&gt; &lt;time&gt;</code></td>
<td></td>
</tr>
<tr>
<td>设置桥上端口开销</td>
<td><code>brctl setpathcost &lt;bridge&gt; &lt;port&gt; &lt;cost&gt;</code></td>
<td><code>bridge link set dev &lt;port&gt; cost &lt;cost&gt;</code></td>
</tr>
<tr>
<td>设置网桥端口优先级</td>
<td><code>brctl setportprio &lt;bridge&gt; &lt;port&gt; &lt;priority&gt;</code></td>
<td><code>bridge link set dev &lt;port&gt; priority &lt;priority&gt;</code></td>
</tr>
<tr>
<td>是否应端口处理 STP BDPU</td>
<td></td>
<td><code>bridge link set dev &lt;port &gt; guard [on, off]</code></td>
</tr>
<tr>
<td>网桥是否应该在接收到的端口上发送流量</td>
<td></td>
<td><code>bridge link set dev &lt;port&gt; hairpin [on,off]</code></td>
</tr>
<tr>
<td>在端口上启用/禁用 fastleave 选项</td>
<td></td>
<td><code>bridge link set dev &lt;port&gt; fastleave [on,off]</code></td>
</tr>
<tr>
<td>设置 STP 端口状态</td>
<td></td>
<td><code>bridge link set dev &lt;port&gt; state &lt;state&gt;</code></td>
</tr>
</tbody>
</table>
<center>VLAN MANAGEMENT</center>
<table>
<thead>
<tr>
<th>ACTION</th>
<th>BRCTL</th>
<th>BRIDGE</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建新的 VLAN 过滤器条目</td>
<td></td>
<td>bridge vlan add dev <dev> [vid, pvid, untagged, self, master]</td>
</tr>
<tr>
<td>删除 VLAN 过滤器条目</td>
<td></td>
<td>bridge vlan delete dev <dev> (parameters same as for vlan add)</td>
</tr>
<tr>
<td>列出 VLAN 配置</td>
<td></td>
<td>bridge vlan show</td>
</tr>
</tbody>
</table>
<h2 id="reference">Reference</h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://danielmiessler.com/study/tcpdump/" target="_blank"
   rel="noopener nofollow noreferrer" >tcpdump</a></p>
<p><sup id="2">[2]</sup> <a href="https://www.redhat.com/sysadmin/linux-mtr-command" target="_blank"
   rel="noopener nofollow noreferrer" >linux mtr command</a></p>
<p><sup id="3">[3]</sup> <a href="https://man7.org/linux/man-pages/man1/nsenter.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >man nsenter</a></p>
<p><sup id="4">[4]</sup> <a href="https://laramatic.com/how-to-install-nsenter-in-debian-ubuntu-alpine-arch-kali-CentOS-fedora-raspbian-and-macos/" target="_blank"
   rel="noopener nofollow noreferrer" >How to install nsenter</a></p>
<p><sup id="5">[5]</sup> <a href="https://www.cyberithub.com/10-best-linux-brctl-command-examples-for-ethernet-network-bridge/" target="_blank"
   rel="noopener nofollow noreferrer" >examples for ethernet network bridge</a></p>
<p><sup id="6">[6]</sup> <a href="https://man7.org/linux/man-pages/man8/bridge.8.html" target="_blank"
   rel="noopener nofollow noreferrer" >man bridge</a></p>
<p><sup id="7">[7]</sup> <a href="https://sgros-students.blogspot.com/2013/11/comparison-of-brctl-and-bridge-commands.html" target="_blank"
   rel="noopener nofollow noreferrer" >comparison of brctl and bridge</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>awesome git command</title>
      <link>https://www.oomkill.com/2020/11/awesome-git-command/</link>
      <pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/awesome-git-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="tag">Tag</h2>
<table>
<thead>
<tr>
<th>command</th>
<th>describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git tag</td>
<td>列出所有tag</td>
</tr>
<tr>
<td>git tag -l v1.*</td>
<td>列出符合条件的tag（筛选作用）</td>
</tr>
<tr>
<td>git tag [tag_name]</td>
<td>创建轻量tag（无-m标注信息）</td>
</tr>
<tr>
<td>git push REMOTE TAG</td>
<td>推送一个tag到远端</td>
</tr>
<tr>
<td>git push origin &ndash;tags*</td>
<td>推送所有本地tag到远程</td>
</tr>
<tr>
<td>git push origin :refs/tags/[REMOTE TAG]<br>git push &ndash;delete REMOTE TAG</td>
<td>删除远程指定tag</td>
</tr>
<tr>
<td>git fetch origin [remote_tag_name]</td>
<td>拉取远程指定tag</td>
</tr>
<tr>
<td>git show [tag_name]</td>
<td>显示指定tag详细信息</td>
</tr>
<tr>
<td>git push origin [local_tag_name]</td>
<td>推送指定本地tag到远程</td>
</tr>
<tr>
<td>git tag NEW_TAG OLD_TAG<br>git tag -d OLD_TAG</td>
<td>重命名本地tag</td>
</tr>
<tr>
<td>git tag -d [local_tag_name]</td>
<td>删除本地指定tag</td>
</tr>
<tr>
<td>git ls-remote &ndash;tags origin</td>
<td>查询远程tags</td>
</tr>
<tr>
<td>git tag -a [tag_name]</td>
<td>创建含注解的tag</td>
</tr>
<tr>
<td>git fetch origin [remote_tag_name]<br/>git checkout  [remote_tag_name] <br/>git branch</td>
<td>checkout远端tag到本地</td>
</tr>
</tbody>
</table>
<h2 id="checking">Checking</h2>
<p>检查工作目录与暂存区的状态</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git status</td>
<td style="text-align:left">查看在你上次提交之后是否有对文件进行再次修改</td>
</tr>
<tr>
<td>git status -s</td>
<td style="text-align:left">获得简短的输出结果</td>
</tr>
<tr>
<td>git diff</td>
<td style="text-align:left">用于比较文件间差异</td>
</tr>
<tr>
<td>git diff &ndash;cached <br>git diff &ndash;staged</td>
<td style="text-align:left">显示<strong>暂存</strong>区(已add但未commit文件)和<strong>最后一次</strong>commit(HEAD)之间的所有不相同文件的增删改</td>
</tr>
<tr>
<td>git diff HEAD</td>
<td style="text-align:left"><strong>工作目录</strong>(已track但未add文件)和<strong>暂存区</strong>(已add但未commit文件)与最后一次commit之间的的所有不相同文件的增删改</td>
</tr>
<tr>
<td>git diff &lt;branch1&gt; &lt;branch2&gt;                          </td>
<td style="text-align:left">比较两个分支上最后 commit 的内容的差别</td>
</tr>
</tbody>
</table>
<h2 id="log">Log</h2>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git diff branch1 branch2 &ndash;stat </td>
<td style="text-align:left">显示出所有有差异的文件（无内容）</td>
</tr>
<tr>
<td>git log &lt;b1&gt;..&lt;b2&gt;</td>
<td style="text-align:left">查看 b1 中的 log 比 b2 中的 log 多提交了哪些内容</td>
</tr>
<tr>
<td>git log &ndash;oneline</td>
<td style="text-align:left">以 &lt;commit_id&gt;  &lt;comment&gt; 为一行来显示</td>
</tr>
<tr>
<td>git log -S &lt;&lsquo;LoginViewController&rsquo;&gt;</td>
<td style="text-align:left">log 的输出将添加火删除对应字符串</td>
</tr>
<tr>
<td>git log &ndash;all &ndash;grep=&lt;&lsquo;0117&rsquo;&gt;</td>
<td style="text-align:left">log 的输出将过滤出与对应字符串相关的commit</td>
</tr>
</tbody>
</table>
<h2 id="checkout">Checkout</h2>
<p>checkout 是指不同tag或分支间的切换行为</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git checkout TAG</td>
<td style="text-align:left">切换至一个tag</td>
</tr>
<tr>
<td>git checkout -b BRANCH TAG</td>
<td style="text-align:left">创建一个新分支，并切换至这个tag</td>
</tr>
<tr>
<td>git checkout BRANCH</td>
<td style="text-align:left">切换至一个分支</td>
</tr>
<tr>
<td>git checkout -m BRANCH</td>
<td style="text-align:left">在切换分支时如有冲突则合并</td>
</tr>
<tr>
<td>git checkout COMMIT_HASH</td>
<td style="text-align:left">切换至一个commit</td>
</tr>
<tr>
<td>git checkout -b BRANCH HEAD~4 <br>git checkout -b BRANCH COMMIT_HASH</td>
<td style="text-align:left">切换并创建为新分支</td>
</tr>
<tr>
<td>git checkout COMMIT &ndash; FILE_PATH          </td>
<td style="text-align:left">将 FILE_PATH 指定的文件恢复为当前分支的最新版本（仅未add）</td>
</tr>
</tbody>
</table>
<h2 id="remote">Remote</h2>
<p>remote 子命令用于管理repositories</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git remote</td>
<td style="text-align:left">List all remote</td>
</tr>
<tr>
<td>git remote rename OLD_REMOTE NEW_REMOTE</td>
<td style="text-align:left">Rename remote</td>
</tr>
<tr>
<td>git remote prune REMOTE</td>
<td style="text-align:left">Remove stale remote tracking branches</td>
</tr>
</tbody>
</table>
<h2 id="branch">Branch</h2>
<p>branch 用于管理分支</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git branch</td>
<td style="text-align:left">List all branches</td>
</tr>
<tr>
<td>git checkout -b BRANCH</td>
<td style="text-align:left">Create the branch on your local machine and switch in this branch</td>
</tr>
<tr>
<td>git branch BRANCH COMMIT_HASH    </td>
<td style="text-align:left">Create branch from commit</td>
</tr>
<tr>
<td>git push REMOTE BRANCH</td>
<td style="text-align:left">Push the branch to remote</td>
</tr>
<tr>
<td>git branch -m OLD_BRANCH NEW_BRANCH      </td>
<td style="text-align:left">Rename other branch</td>
</tr>
<tr>
<td>git branch -m NEW_BRANCH</td>
<td style="text-align:left">Rename current branch</td>
</tr>
<tr>
<td><em># Rename branch locally</em><br>git branch -m OLD_BRANCH NEW_BRANCH <br><br/><em># Delete the old branch</em><br>git push origin :OLD_BRANCH<br><br><em># Push the new branch, set local branch to track the new remote</em><br>git push &ndash;set-upstream REMOTE NEW_BRANCH</td>
<td style="text-align:left">Rename remote branch</td>
</tr>
<tr>
<td>git branch -D BRANCH<br>git push REMOTE :BRANCH</td>
<td style="text-align:left">Delete a branch locally and remote</td>
</tr>
<tr>
<td>git branch | grep -v &ldquo;master&rdquo; | xargs git branch -D</td>
<td style="text-align:left">Delete all local branches but master</td>
</tr>
</tbody>
</table>
<h2 id="commit">Commit</h2>
<p>Record changes to the repository</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git reset &ndash;hard HEAD~1</td>
<td style="text-align:left">Undo last commit</td>
</tr>
<tr>
<td>git rebase -i HEAD~5<br>git reset &ndash;soft HEAD~5<br>git add .<br>git commit -m &ldquo;Update&rdquo;<br>git push -f origin master</td>
<td style="text-align:left">Squash last n commits into one commit</td>
</tr>
<tr>
<td>git branch newbranch<br><br><em># Go back 3 commits. You will lose uncommitted work.1</em><br>git reset &ndash;hard HEAD~3<br><br/>git checkout newbranch</td>
<td style="text-align:left">Move last commits into new branch:</td>
</tr>
<tr>
<td>git rebase -i HEAD^^^<br>git add .<br>git rebase &ndash;continue</td>
<td style="text-align:left">Make changes to older commit</td>
</tr>
</tbody>
</table>
<h2 id="merge">Merge</h2>
<p>Join two or more development histories together</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git checkout BRANCH<br>git merge &ndash;no-ff BASE_BRANCH</td>
<td style="text-align:left">Merge commits from master into feature branch</td>
</tr>
<tr>
<td>git merge BRANCH</td>
<td style="text-align:left">Current branch merge to BRANCH branch</td>
</tr>
<tr>
<td>git merge -m  “Merge from Dev”</td>
<td style="text-align:left">When merge branch add comment</td>
</tr>
<tr>
<td>git merge -s ours obsolete</td>
<td style="text-align:left">Merge obsolete branch to current branch using ours policy</td>
</tr>
<tr>
<td>git merge &ndash;no-commit maint</td>
<td style="text-align:left">Merge maint branch to current, than do not make new comment</td>
</tr>
</tbody>
</table>
<h2 id="cherry-pick">Cherry Pick</h2>
<p>Apply the changes introduced by some existing commits</p>
<pre><code class="language-bash">git cherry-pick COMMIT_HASH_A COMMIT_HASH_B
</code></pre>
<h2 id="revert">Revert</h2>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git revert HEAD</td>
<td style="text-align:left">Revert the previous commit</td>
</tr>
<tr>
<td>git revert &ndash;no-commit HEAD~3..</td>
<td style="text-align:left">Revert the changes from previous 3 commits without making commit</td>
</tr>
</tbody>
</table>
<h2 id="amend">Amend</h2>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git commit &ndash;amend</td>
<td style="text-align:left">Amend previous commit</td>
</tr>
<tr>
<td>git commit &ndash;amend &ndash;no-edit</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td>git commit &ndash;amend -m &ldquo;COMMIT_MESSAGE&rdquo;</td>
<td style="text-align:left">Changing git commit message</td>
</tr>
<tr>
<td>git commit &ndash;amend -m &ldquo;COMMIT_MESSAGE&rdquo;<br>git push &ndash;force REMOTE BRANCH</td>
<td style="text-align:left">Changing git commit message after push</td>
</tr>
</tbody>
</table>
<h2 id="reflog">Reflog</h2>
<p>reference log</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git reflog</td>
<td style="text-align:left">Show reflog</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">Get commit</td>
</tr>
</tbody>
</table>
<h2 id="rebase">Rebase</h2>
<p>Rebase the current branch onto another branch</p>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git rebase BASE_BRANCH</td>
<td style="text-align:left">Rebase the current branch onto another branch</td>
</tr>
<tr>
<td>git rebase &ndash;continue</td>
<td style="text-align:left">Continue rebase</td>
</tr>
<tr>
<td>git rebase &ndash;abort</td>
<td style="text-align:left">Abort rebase</td>
</tr>
</tbody>
</table>
<h1 id="tracking">Tracking</h1>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git clean</td>
<td style="text-align:left">Remove untracked files</td>
</tr>
<tr>
<td>git reset FILE_PATH</td>
<td style="text-align:left">Remove file from index</td>
</tr>
<tr>
<td>git reset</td>
<td style="text-align:left">Reset the index to match the most recent commit</td>
</tr>
<tr>
<td>git reset &ndash;hard</td>
<td style="text-align:left">Reset the index and the working directory to match the most recent commit</td>
</tr>
<tr>
<td>git rm file</td>
<td style="text-align:left">Remove files from the working tree and from the index</td>
</tr>
<tr>
<td>git ls-files</td>
<td style="text-align:left">Show information about files in the index and the working tree</td>
</tr>
<tr>
<td>git ls-files -d</td>
<td style="text-align:left">Show deleted files in the output.</td>
</tr>
<tr>
<td>git ls-files -m</td>
<td style="text-align:left">Show modified files in the output.</td>
</tr>
<tr>
<td>git ls-files -i</td>
<td style="text-align:left">Show only ignored files in the output.</td>
</tr>
<tr>
<td>git ls-files &ndash;no-empty-directory</td>
<td style="text-align:left">Do not list empty directories. Has no effect without &ndash;directory.</td>
</tr>
</tbody>
</table>
<h2 id="config">Config</h2>
<table>
<thead>
<tr>
<th>command</th>
<th style="text-align:left">describe</th>
</tr>
</thead>
<tbody>
<tr>
<td>git config -l</td>
<td style="text-align:left">list all git config</td>
</tr>
<tr>
<td>git config &ndash;global [key] &ldquo;[value]&rdquo;</td>
<td style="text-align:left">set global configuation</td>
</tr>
<tr>
<td>git config [key] &ldquo;[value]&rdquo;</td>
<td style="text-align:left">set current repositories configuation</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em><strong>Reference</strong></em>：</p>
<p><a href="https://github.com/onmyway133/awesome-git-commands" target="_blank"
   rel="noopener nofollow noreferrer" >awesome-git-commands</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>长期总结 - Linux日志查询命令</title>
      <link>https://www.oomkill.com/2016/08/awesome-linux-log-command/</link>
      <pubDate>Fri, 12 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/08/awesome-linux-log-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="sed">sed</h2>
<p>语法</p>
<pre><code class="language-bash">sed  '/过滤的内容/处理的命令' 文件
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>注释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>n</td>
<td>取消sed默认的输出</td>
</tr>
<tr>
<td>i</td>
<td>替换文件内容</td>
</tr>
<tr>
<td>r</td>
<td>如果有特殊字符不用转义（正则）</td>
</tr>
<tr>
<td>g</td>
<td>全局替换</td>
</tr>
<tr>
<td>d</td>
<td>删除</td>
</tr>
<tr>
<td>p</td>
<td>print打印</td>
</tr>
</tbody>
</table>
<p># 为分隔符可以用其他符号替换（最好用$ @ /）替换内容中如果有分隔符，需要将分隔符替换为别的分隔符，如果不换可将内容转义  s 为search  g为globla全局替换，不加的话只替换一列</p>
<p><strong>打印</strong></p>
<pre><code class="language-bash">$ sed -n '2p' 3.txt
1

$ sed -n '1,20p' 3.txt
0
1
2
3
4
5
6

8
9
10
11
12
13
14
15
16
17
18
19
</code></pre>
<p><strong>问：已知一个文件内容为 aaa  bbb  ccc  lisi 请打印出不包含lisi的内容</strong></p>
<p>文件原内容</p>
<pre><code class="language-bash">$ cat 1.txt          
-bash: ech: command not found
-bash: ech: command not found
-bash: ech: command not found
dasda
aaa
bbb
ccc
ddd
eee
fff

ggg
</code></pre>
<p><strong>替换功能</strong>：</p>
<pre><code class="language-bash">$ sed -i 's#aaa#cylon#g' 1.txt

$ cat 1.txt                           
-bash: ech: command not found
-bash: ech: command not found
-bash: ech: command not found
dasda
cylon
bbb
ccc
ddd
eee
fff

ggg
</code></pre>
<p>默认不加参数会将文件原内容打印再将符合的内容打印</p>
<pre><code class="language-bash">$ sed '/aaa/p' 1.txt  
-bash: ech: command not found
-bash: ech: command not found
-bash: ech: command not found
dasda
aaa
aaa
bbb
ccc
ddd
eee
fff

ggg
</code></pre>
<p><strong>在指定文件中指定行插入数据</strong></p>
<pre><code class="language-bash">$ cat test.txt 
1
2
3
4
5

# $为行尾  a\为行后追加 i\为行前追加 c\为替换 不加$为行首
$ sed -i &quot;3a zhangsan&quot; test.txt   
$ cat test.txt 
1
2
3
zhangsan
4
</code></pre>
<p><strong>-n取消默认的输出</strong></p>
<pre><code class="language-bash">$ sed -n '/aaa/p' 1.txt 
aaa
</code></pre>
<p>将符合的内容删除后输出，并不操作文件</p>
<pre><code class="language-bash">$ sed  '/aaa/d' 1.txt    
-bash: ech: command not found
-bash: ech: command not found
-bash: ech: command not found
dasda
bbb
ccc
ddd
eee
fff

ggg
</code></pre>
<p>删除文件中一部分内容</p>
<pre><code class="language-bash"># 删除首行
sed '1d' nginx.conf

# 删除1-102行
sed '1,102d' nginx.conf

# 正则表达式
# 删除每行中 on
sed '/on/d' nginx.conf

# 删除偶数行删除偶数行
sed '0~2d' nginx.conf

# 删除奇数行
sed '1~2d' nginx.conf
</code></pre>
<h2 id="wc">wc</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>统计字节数</td>
</tr>
<tr>
<td>l</td>
<td>统计行数</td>
</tr>
<tr>
<td>m</td>
<td>统计字符数，不能与c一起用</td>
</tr>
<tr>
<td>w</td>
<td>统计字数，一个字被定义为由空白、跳格、或换行字符分割的字符串</td>
</tr>
<tr>
<td>L</td>
<td>打印最长行的字符数量</td>
</tr>
<tr>
<td>&ndash;help</td>
<td>帮助信息</td>
</tr>
<tr>
<td>&ndash;version</td>
<td>版本信息</td>
</tr>
</tbody>
</table>
<pre><code class="language-bash">$ cat -n a.html
     1  000
     2  111
     3  222
     4  333
     5  444
     6  555
     7  666
     8  777
     9  888
    10  999
    11  aaa
    12  bbb
    13  ccc
    14  ddd
    15  eee
    16

$ wc -c a.html
61 a.html

$ wc -l a.html
16 a.html

$ wc -w a.html
15 a.html

$ wc -L a.html
3 a.html
</code></pre>
<h2 id="sort-">sort ★★★★</h2>
<p>将文件进行排序，并将排序结果标准输出。sort命令既可以从特定的文件，也可以从stdin中获取输入</p>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>注释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>忽略每行前面开始出的空格字符；</td>
</tr>
<tr>
<td>-c</td>
<td>检查文件是否已经按照顺序排序；</td>
</tr>
<tr>
<td>-d</td>
<td>排序时，处理英文字母、数字及空格字符外，忽略其他的字符；</td>
</tr>
<tr>
<td>-f</td>
<td>排序时，将小写字母视为大写字母；</td>
</tr>
<tr>
<td>-n</td>
<td>依照数值的大小排序</td>
</tr>
<tr>
<td>-r</td>
<td>以相反的顺序来排序</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong>：sort将 文件/文本 的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。</p>
<pre><code class="language-bash">$ cat sort.txt 
aaa:10:1.1 
ccc:30:3.3 
ddd:40:4.4 
bbb:20:2.2 
eee:50:5.5 
eee:50:5.5 

$ sort sort.txt 
aaa:10:1.1 
bbb:20:2.2 
ccc:30:3.3 
ddd:40:4.4 
eee:50:5.5 
eee:50:5.5 
</code></pre>
<p>忽略相同行使用-u选项或者uniq：</p>
<pre><code class="language-bash">$ cat sort.txt 
aaa:10:1.1 
ccc:30:3.3 
ddd:40:4.4 
bbb:20:2.2 
eee:50:5.5 
eee:50:5.5 

$ sort -u sort.txt 
aaa:10:1.1 
bbb:20:2.2 
ccc:30:3.3 
ddd:40:4.4 
eee:50:5.5

# 
$ uniq sort.txt 
aaa:10:1.1 
ccc:30:3.3 
ddd:40:4.4 
bbb:20:2.2 
eee:50:5.5 
</code></pre>
<p>sort的-n、-r、-k、-t选项的使用：</p>
<pre><code class="language-bash">$ cat sort.txt 
AAA:BB:CC 
aaa:30:1.6 
ccc:50:3.3 
ddd:20:4.2 
bbb:10:2.5 
eee:40:5.4 
eee:60:5.1 
# 将BB列按照数字从小到大顺序排列 

$ sort -nk 2 -t: sort.txt 
AAA:BB:CC 
bbb:10:2.5 
ddd:20:4.2 
aaa:30:1.6 
eee:40:5.4 
ccc:50:3.3 
eee:60:5.1 
# 将CC列数字从大到小顺序排列

$ sort -nrk 3 -t: sort.txt 
eee:40:5.4 
eee:60:5.1 
ddd:20:4.2 
ccc:50:3.3 
bbb:10:2.5 
aaa:30:1.6 
AAA:BB:CC 
# -n是按照数字大小排序，-r是以相反顺序，-k是指定需要排序的栏位，-t指定栏位分隔符为冒号
</code></pre>
<h2 id="uniq">uniq</h2>
<p>用于报告或忽略文件中的重复行，一般与sort命令结合使用</p>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>注释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>在每行前面显示改行重复的次数</td>
</tr>
<tr>
<td>-d</td>
<td>仅打印重复出现的行</td>
</tr>
<tr>
<td>-u</td>
<td>仅打印不重复的行</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong>：删除重复行</p>
<pre><code class="language-bash">$ uniq a.txt     
a
b
c
d
e
f
g
h
i
g
k
</code></pre>
<p>在文件中找出重复的行：</p>
<pre><code class="language-bash">sort file.txt | uniq -d
</code></pre>
<p>查找重复次数</p>
<pre><code class="language-bash">$ uniq -c a.txt 
      5 a
      1 b
      2 c
      2 d
      1 e
      1 f
      1 g
      3 h
      2 i
      1 g
      1 k

$ uniq -d a.txt  
a
c
d
h
i

$ uniq -u a.txt  
b
e
f
g
g
k
</code></pre>
<h2 id="cut">cut</h2>
<p>用来显示行中的指定部分，删除文件中指定字段。cut经常用来显示文件的内容</p>
<table>
<thead>
<tr>
<th>参数选项</th>
<th>注释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</td>
</tr>
<tr>
<td>-c</td>
<td>以字符为单位进行分割</td>
</tr>
<tr>
<td>-f</td>
<td>与-d一起使用，取第几列</td>
</tr>
<tr>
<td>-d</td>
<td>指定分隔符</td>
</tr>
</tbody>
</table>
<p><strong>实例</strong></p>
<pre><code class="language-bash">$ cat 1.log
i am a protester myqq is 1112222

$ cut -d &quot; &quot; -f4,7 1.log   
protester 1112222
</code></pre>
<ol>
<li>以字节取，我们想去who命令的第三个字节</li>
</ol>
<pre><code class="language-bash">$ who
root     pts/0        2010-02-02 04:09 (192.168.88.1)
root     pts/1        2010-02-02 08:34 (192.168.88.1)
lc       pts/2        2010-02-02 08:44 (192.168.88.1)

$ who|cut -b 3
o
o
</code></pre>
<ol start="2">
<li>取第1、2、3和第23个字节</li>
</ol>
<pre><code class="language-bash">$  who|cut -b 1-3,23
roo2
roo2
lc 2
</code></pre>
<ol start="3">
<li>如果取中文的话，-c 与 -b就有差异了，-c取的是字节，而-b取得是8位2进制来计算输出的是乱码或空</li>
</ol>
<pre><code class="language-bash">$ cat a.txt 
星期一
星期二
星期三
星期四
星期五
星期六
星期日

$ cut -b 3 a.txt
�
�

$ cut a.txt -c 3
一
二
三
四
五
六
日
</code></pre>
<h2 id="grep">grep</h2>
<p><em><strong>Global search Regular Expression(RE) and Print out the line</strong></em>，全面搜索正则表达式并把行打印出来；是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>过滤，将想要的和不想要的去除</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==-E==</td>
<td>同egrep同时过滤多个字符串，使grep可以使用正则表达式</td>
</tr>
<tr>
<td>-v</td>
<td>翻转查找，查找除了匹配到结果之外的信息</td>
</tr>
<tr>
<td>-B <strong>Num</strong></td>
<td>除了显示匹配的一行之外，并显示该行之前的num行</td>
</tr>
<tr>
<td>-A <strong>Num</strong></td>
<td>除了显示匹配的一行之外，并显示改行之后的num行</td>
</tr>
<tr>
<td>-C <strong>Num</strong></td>
<td>除了显示匹配的一行之外，并显示改行之前后各num行</td>
</tr>
<tr>
<td>-o</td>
<td>输出匹配字符，而不是默认的整行输出</td>
</tr>
<tr>
<td>-i</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>-n</td>
<td>讲匹配出的结果在文件所在的行号打印</td>
</tr>
<tr>
<td>-c</td>
<td>打印匹配到的行数</td>
</tr>
<tr>
<td>-H</td>
<td>在匹配到符合行之前打印文件名</td>
</tr>
<tr>
<td>&ndash;color=auto</td>
<td>给匹配倒的字符串加颜色（不是整行。关键字高亮显示）</td>
</tr>
</tbody>
</table>
<p>实例</p>
<ol>
<li>显示/etc/services 下3306和1521 端口信息</li>
</ol>
<pre><code class="language-bash">$ grep -E &quot;3306|1521&quot; /etc/services 
mysql           3306/tcp                        # MySQL
mysql           3306/udp                        # MySQL
ncube-lm        1521/tcp                # nCube License Manager
ncube-lm        1521/udp                # nCube License Manager
</code></pre>
<ol start="2">
<li>过滤出文件内指定字符串</li>
</ol>
<pre><code class="language-bash">$ cat text.txt
zhangsan
lisi
oldbl

$ grep &quot;lisi&quot; text.txt
lisi
</code></pre>
<ol start="3">
<li>排除指定字符</li>
</ol>
<pre><code class="language-bash">$ grep -v &quot;lisi&quot; text.txt
zhangsan
oldbl

$ grep  -n &quot;555&quot; a.html
6:555
</code></pre>
<ol start="4">
<li>一个文件有100行，只看20~30行</li>
</ol>
<pre><code class="language-bash"># 方法1
$ grep 30 -B 10 test.txt
20
21
22
23
24
25
26
27
28
29
30

# 方法2
$ head -30 3.txt|tail -11
20
21
22
23
24
25
26
27
28
29
30
</code></pre>
<ol start="5">
<li>列出文件名</li>
</ol>
<pre><code class="language-bash">$ grep -H root /etc/passwd 
/etc/passwd:root:x:0:0:root:/root:/bin/bash
/etc/passwd:operator:x:11:0:operator:/root:/sbin/nologin
</code></pre>
<h2 id="日志查询中常用命令">日志查询中常用命令</h2>
<p><strong>打印一段时间的日志</strong></p>
<pre><code class="language-bash">sed -n '/2019-12-28 11:26/,/2019-12-28 12:13/p' nohup.out
</code></pre>
<p><strong>输出日志文件中的某个日期中的ERROR的行</strong></p>
<pre><code class="language-bash">sed -n '/^2016-06-21.*ERROR/p' nohup.out
</code></pre>
<p><strong>统计http相应状态码</strong></p>
<pre><code class="language-bash">cat looklinix.com_access.log | cut -d '&quot;' -f3 | cut -d ' ' -f2 | sort | uniq -c | sort
</code></pre>
<p>使用awk</p>
<pre><code class="language-bash">awk '{print $9}' looklinix.com_access.log | sort | uniq -c | sort
</code></pre>
<p><strong>列出404的接口</strong></p>
<pre><code class="language-bash">awk '($9 ~ /404/)' looklinix.com_access.log | awk '{print $7}' | sort | uniq -c | sort -r
</code></pre>
<p><strong>检查404请求来自哪里</strong></p>
<pre><code class="language-bash">awk -F \&quot; '($2 ~ &quot;/survey/report/na&quot;){print $1}' looklinix.com_access.log | awk '{print $1}' | sort | uniq -c | sort –r
</code></pre>
<p><strong>查询x 分钟内访问最多的前 10 个IP</strong></p>
<p>day hour minutes</p>
<pre><code class="language-bash">awk -vDate=`date -d'now-30 minutes' +[%d/%b/%Y:%H:%M:%S` '$4 &gt; Date {print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 10
</code></pre>
<p><strong>查询请求URL数量排行</strong></p>
<pre><code class="language-bash">awk '{print $7}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 50
</code></pre>
<p><strong>统计所有的IP请求量</strong></p>
<pre><code class="language-bash">awk '{print $1}' access.log | sort -n | uniq | wc -l
</code></pre>
<p><strong>统计某一时间段的IP请求量</strong></p>
<pre><code class="language-bash">grep &quot;07/Apr/2017:0[4-5]&quot; access.log | awk '{print $1}' | sort | uniq -c| sort -nr | wc -l  
</code></pre>
<p><strong>统计IP请求数量大于一个值的排行</strong></p>
<pre><code class="language-bash">awk '{print $1}' access.log | sort -n |uniq -c |awk '{if($1 &gt;100) print $0}'|sort -rn
</code></pre>
<p><strong>列出请求时间超过3s的接口</strong></p>
<pre><code class="language-bash">cat access.log|awk '($NF &gt; 3){print $7}'|sort -n|uniq -c|sort -nr|head -20
</code></pre>
<p><strong>获取每分钟的请求数量并输出成csv文件</strong></p>
<pre><code class="language-bash">cat access.log | awk '{print substr($4,14,5)}' | uniq -c | awk '{print $2&quot;,&quot;$1}' &gt; access.csv
</code></pre>
<p><strong>查看搜索引擎爬虫</strong></p>
<pre><code class="language-bash"># 百度爬虫 降序
cat access.log | grep &quot;Baiduspider&quot; | awk '{print $7}' | sort | uniq -c | sort -r

# 谷歌爬虫降序
cat access.log | grep &quot;Googlebot&quot; | awk '{print $7}' | sort | uniq -c | sort -r

# 谷歌爬虫404的次数
grep 'Googlebot' access.log |grep '404' | wc -l
</code></pre>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
