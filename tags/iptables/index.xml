<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>iptables on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/iptables/</link>
    <description>Recent content in iptables on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 23 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/iptables/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Uranus installation</title>
      <link>https://www.oomkill.com/2024/08/uranus-installation/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/08/uranus-installation/</guid>
      <description>What is an Uranus?</description>
      <content:encoded><![CDATA[<h2 id="what-is-an-uranus">What is an Uranus?</h2>
<p>Uranus is a Linux firewalld central controller. In Greek mythology,  Uranus king of gods. The firewall gateway is the Uranus for iptables.</p>
<h2 id="prerequisites">Prerequisites</h2>
<h3 id="hardware-requirements">Hardware requirements</h3>
<p>We recommend these hardware requirements for production systems or for  development systems that are designed to demonstrate production use  cases:</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
<th>Minimum requirements</th>
<th>Recommended</th>
</tr>
</thead>
<tbody>
<tr>
<td>Per instance</td>
<td>You can install on one node but many features require at least one node.</td>
<td>1 instance</td>
<td>&gt; 1 instances</td>
</tr>
<tr>
<td>RAM per instance</td>
<td>Defining your RAM size must be part of the capacity planning for your Uranus usage.</td>
<td>512 Mb</td>
<td>&gt;= 1GB</td>
</tr>
<tr>
<td>Persistent Storage</td>
<td>The amount of storage space for each node.</td>
<td>1 GB</td>
<td>&gt;= 10GB</td>
</tr>
</tbody>
</table>
<h3 id="software-requirements">Software requirements</h3>
<table>
<thead>
<tr>
<th>Item</th>
<th>Description</th>
<th>Recommended</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS / Platform</td>
<td>Linux, Kubernetes</td>
<td>Debian 11<br />Centos 7</td>
</tr>
<tr>
<td>Firewalld</td>
<td>0.6.3<br />0.9.2</td>
<td>Centos 7 default version<br />Debian 11 default version</td>
</tr>
</tbody>
</table>
<h2 id="build-and-run-uranus">Build and run Uranus</h2>
<h3 id="setup-an-uranus-with-binary-mode">Setup an Uranus with Binary mode</h3>
<h4 id="build-and-run-uranus-backend">Build and run Uranus backend</h4>
<pre><code class="language-bash">git clone https://github.com/cylonchau/firewalld-gateway.git
</code></pre>
<p>Compile</p>
<pre><code class="language-bash">cd firewalld-gateway &amp;&amp; make build
</code></pre>
<p>Frist time you need migrate database</p>
<pre><code class="language-bash"># currently sql-driver support sqlite or mysql
./_output/firewalld-gateway --migration --sql-driver=sqlite  --config firewalld-gateway.toml -v 10
</code></pre>
<p>Inital API Doc</p>
<pre><code class="language-bash">swag init -g cmd/main.go --output ./docs/  --packageName docs
</code></pre>
<p>Run Uranus</p>
<pre><code class="language-bash">./_output/firewalld-gateway --sql-driver=sqlite  --config firewalld-gateway.toml -v 5
</code></pre>
<h4 id="setup-uranus-frontend">Setup Uranus frontend</h4>
<p>Install Nginx</p>
<pre><code class="language-bash">yum install nginx -y
# or
apt install nginx -y
</code></pre>
<p>Configure nginx</p>
<pre><code class="language-bash">cd /etc/nginx/ &amp;&amp; \
mv nginx.conf nginx.conf.default
grep -Ev '^$|#' nginx.conf.default &gt; nginx.conf &amp;&amp; \
sed -i '/include/i \    include /etc/nginx/conf.d/*.conf;' nginx.conf &amp;&amp; \
cd conf.d
</code></pre>
<p>Create fw.conf in conf.d directory</p>
<pre><code class="language-bash">cat &lt;&lt;EOF &gt; fw.conf
server {
     listen 80;
     root /var/run/dist;

     location / {
       try_files \$uri \$uri/ @router;
       index index.html;
     }
     location ~ /fw/(?&lt;section&gt;.*) {
        proxy_pass http://10.0.0.1:2952/fw/\$section\$is_args\$args;
        proxy_set_header X-Forwarded-Host \$server_name;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Server \$host;
        proxy_set_header X-Forwarded-Scheme \$scheme;
        proxy_set_header X-Forwarded-URI \$request_uri;
        proxy_set_header X-Real-IP       \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
    location ~ /security/(?&lt;section&gt;.*) {
        proxy_pass http://10.0.0.1:2952/security/\$section\$is_args\$args;
        proxy_set_header X-Forwarded-Host \$server_name;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Server \$host;
        proxy_set_header X-Forwarded-Scheme \$scheme;
        proxy_set_header X-Forwarded-URI \$request_uri;
        proxy_set_header X-Real-IP       \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
    
    location ~ /sso/(?&lt;section&gt;.*) {
        proxy_pass http://10.0.0.1:2952/sso/\$section\$is_args\$args;
        proxy_set_header X-Forwarded-Host \$server_name;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Server \$host;
        proxy_set_header X-Forwarded-Scheme \$scheme;
        proxy_set_header X-Forwarded-URI \$request_uri;
        proxy_set_header X-Real-IP       \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
    
    location /ping {
       proxy_pass http://10.0.0.1:2952/ping;
       proxy_set_header X-Forwarded-Port \$server_port;
       proxy_set_header X-Forwarded-Server \$host;
       proxy_set_header X-Forwarded-Scheme \$scheme;
       proxy_set_header X-Forwarded-URI \$request_uri;
       proxy_set_header X-Real-IP       \$remote_addr;
       proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
EOF
</code></pre>
<p>Copy dist directory to /var/run/</p>
<pre><code class="language-bash">mv dist /var/run/
</code></pre>
<p>Start nginx</p>
<pre><code class="language-bash">systemctl start nginx
</code></pre>
<h3 id="setup-an-uranus-with-docker">Setup an Uranus with Docker</h3>
<h4 id="build-docker-image">build docker image</h4>
<pre><code class="language-bash">git clone https://github.com/cylonchau/firewalld-gateway.git
</code></pre>
<p>Build image</p>
<pre><code class="language-bash">docker build -t cylonchau/uranus:v0.0.5 .
</code></pre>
<p>Run</p>
<pre><code class="language-bash">docker run -d --rm --name uranus -p 2953:2953 cylonchau/uranus:v0.0.5
</code></pre>
<blockquote>
<p>Notes: this mode default using sqlite, so if you want use external database, please change config file, then build image</p>
</blockquote>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240824133756059.png" alt="image-20240824133756059" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="setup-firewalld">Setup firewalld</h2>
<h3 id="download">Download</h3>
<p>Default, we provide 2 version firewalld variant version</p>
<ul>
<li>Centos 7 or Centos 6</li>
<li>Debian 11</li>
</ul>
<p>You can download  and install those firewalld vesion in you Linux</p>
<p><a href="https://github.com/cylonchau/firewalld/releases" target="_blank"
   rel="noopener nofollow noreferrer" >https://github.com/cylonchau/firewalld/releases</a></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240824135429530.png" alt="image-20240824135429530" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="install">Install</h3>
<p>Centos 7</p>
<pre><code class="language-bash">rpm -e python-firewall-0.6.3-11 --nodeps &amp;&amp;
rpm -ivh  python-firewall-0.6.3-4.el7.noarch.rpm
</code></pre>
<p>Debian 11</p>
<pre><code class="language-bash">dpkg -r python3-firewall &amp;&amp; \
dpkg -i python3-firewall_0.9.3-2_amd64.deb
</code></pre>
<h3 id="configure">Configure</h3>
<h4 id="enable-dbug-remote-mode">Enable dbug remote mode</h4>
<h5 id="centos">Centos</h5>
<p>Edit /etc/dbus-1/system.conf</p>
<pre><code class="language-xml">&lt;!--
This configuration file is no longer required and may be removed.

In older versions of dbus, this file defined the behaviour of the well-known
system bus. That behaviour is now determined by
/usr/share/dbus-1/system.conf, which should not be edited.

For local configuration changes, create a file
system-local.conf or files matching system.d/*.conf in the same directory
as this one, with a &lt;busconfig&gt; element containing configuration directives.
These directives can override D-Bus or OS defaults.

For upstream or distribution-wide defaults that can be overridden
by a local sysadmin, create files matching
/usr/share/dbus-1/system.d/*.conf instead.
--&gt;
&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&quot;
 &quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
&lt;listen&gt;tcp:host=10.0.0.3,bind=*,port=55556,family=ipv4&lt;/listen&gt;
&lt;listen&gt;unix:tmpdir=/tmp&lt;/listen&gt;

&lt;!-- Add this part --&gt;
&lt;policy context=&quot;default&quot;&gt;
    &lt;allow user=&quot;root&quot; /&gt;
    &lt;allow own=&quot;com.github.cylonchau.Uranus&quot; /&gt; &lt;!-- allow uranus resiger to dbus-daemon --&gt;
    &lt;!-- if requseter is com.github.cylonchau.Uranus and request path is /org/fedoraproject/FirewallD1, then allow  --&gt;
    &lt;allow receive_sender=&quot;com.github.cylonchau.Uranus&quot; receive_path=&quot;/org/fedoraproject/FirewallD1&quot; /&gt;
&lt;/policy&gt;
  &lt;auth&gt;ANONYMOUS&lt;/auth&gt;
  &lt;allow_anonymous/&gt;
&lt;/busconfig&gt;
</code></pre>
<h4 id="enable-dbus-tcp-port">Enable dbus tcp port</h4>
<p>Edit /usr/lib/systemd/system/dbus.socket</p>
<pre><code class="language-conf">[Unit]
Description=D-Bus System Message Bus Socket

[Socket]
ListenStream=/var/run/dbus/system_bus_socket
ListenStream=55556 # &lt;- Add this
</code></pre>
<p>Reload service</p>
<pre><code class="language-bash">systemctl reload firewalld
</code></pre>
<h5 id="debian">Debian</h5>
<p>Edit /etc/dbus-1/system.conf</p>
<pre><code class="language-xml">&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&quot;
 &quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
&lt;listen&gt;tcp:host=10.0.0.3,bind=*,port=55556,family=ipv4&lt;/listen&gt;
&lt;listen&gt;unix:tmpdir=/tmp&lt;/listen&gt;

&lt;!-- Add this part --&gt;
&lt;policy context=&quot;default&quot;&gt;
    &lt;allow user=&quot;root&quot; /&gt;
    &lt;allow own=&quot;com.github.cylonchau.Uranus&quot; /&gt; &lt;!-- allow uranus resiger to dbus-daemon --&gt;
    &lt;!-- if requseter is com.github.cylonchau.Uranus and request path is /org/fedoraproject/FirewallD1, then allow  --&gt;
    &lt;allow receive_sender=&quot;com.github.cylonchau.Uranus&quot; receive_path=&quot;/org/fedoraproject/FirewallD1&quot; /&gt;
&lt;/policy&gt;

  &lt;auth&gt;ANONYMOUS&lt;/auth&gt;
  &lt;allow_anonymous/&gt;
&lt;/busconfig&gt;
</code></pre>
<p>Edit /usr/lib/systemd/system/dbus.socket</p>
<pre><code class="language-conf">[Unit]
Description=D-Bus System Message Bus Socket

# Add this part
[Socket]
ListenStream=/var/run/dbus/system_bus_socket
ListenStream=55556
</code></pre>
<h3 id="add-managed-firewalld-linux-host-to-uranus">Add managed firewalld Linux host to Uranus</h3>
<p>Add host</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240824135127317.png" alt="image-20240824135127317" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240824135141503.png" alt="image-20240824135141503" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>firewalld去除polkit验证</title>
      <link>https://www.oomkill.com/2023/04/firewalld-without-polkit/</link>
      <pubDate>Wed, 19 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/04/firewalld-without-polkit/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="为什么去除polkit验证">为什么去除polkit验证</h2>
<p>在2021年询问过firewalld项目组，firewalld在dbus通讯时，会进行两部认证 <code>policy kit</code> 和 <code>UID checking</code>，正是因为这种情况，使得firewalld不能够通过TCP/IP连接，如果你需要连接，因为存在  <code>UID checking</code> ，这时会因为没有UID会报错。</p>
<blockquote>
<p>firewalld needs to do some authorization on the dbus request. It currently tries two ways, in order of preference:</p>
<ol>
<li>policy kit</li>
<li>UID checking</li>
</ol>
<p>Neither of these are available over a TCP/IP dbus connection. <sup><a id="1">[1]</a></sup></p>
</blockquote>
<h2 id="如何去除polkit">如何去除polkit</h2>
<p>首选需要确定你的firewalld版本，例如Centos7系列，那么你的 firewalld 版本为 0.6.3，那么你需要修改的包为 <code>python-firewall-0.6.3</code>, 在 debian11 上 firewalld版本默认为 0.9.3，那么需要关注的版本为：<code>python3-firewall_0.9.3</code></p>
<p>在确定版本后直接从github仓库进行拉去修改就可以</p>
<pre><code class="language-bash">git fetch v0.9.3
git checkout v0.9.3
</code></pre>
<p>对于 python-firewall-0.6.3 来说。直接注释掉 <code>slip.dbus.polkit.require_auth</code> 就可以了</p>
<pre><code class="language-python">@slip.dbus.polkit.require_auth(config.dbus.PK_ACTION_POLICIES_INFO)
@dbus_service_method(config.dbus.DBUS_INTERFACE_POLICIES, in_signature='',
                     out_signature='as')
</code></pre>
<p>而对于新一些版本的场景下，可以在github上看到，他们移除了对 python-slip 的依赖，这将对去除polkit认证的步骤则有些许调整 <sup><a id="2">[2]</a></sup>:</p>
<ol>
<li>
<p>首先需要完全移除修饰器 <code>polkit.require_auth</code></p>
</li>
<li>
<p>完全移除修饰器 <code>@slip.dbus.polkit.enable_proxy</code></p>
</li>
<li>
<p>由于对 <code>slip.dbus</code> 去除，那么需要注释掉 <code>import slip.dbus*</code></p>
</li>
<li>
<p>此时修改firewall server，去除基于slip的mainloop，改为旧版本形式</p>
<pre><code class="language-python">mainloop = GLib.MainLoop()
		slip.dbus.service.set_mainloop(mainloop)
        mainloop.run()
# 修改为
mainloop = GLib.MainLoop()
        mainloop.run()
</code></pre>
</li>
<li>
<p>为了兼容命令 <code>firewall-cmd</code> ，还需要将 FirewallClient 中使用 <code>slip.dbus.xxx</code> 的内容修改为 <code>dbus.xxx</code></p>
<pre><code class="language-python">try:
    self.bus = slip.dbus.SystemBus()
    # 修改为
    self.bus = dbus.SystemBus()
except dbus.exceptions.DBusException as e:
    raise FirewallError(errors.DBUS_ERROR,
                        e.get_dbus_message())
else:
    print(&quot;Not using slip.dbus&quot;)
</code></pre>
</li>
<li>
<p>最后一步，根据你的发行版本进行打包安装即可</p>
</li>
</ol>
<hr>
<blockquote>
<p>Tips：Redhat系列官方提供了rpm打包文件直接用就可以</p>
</blockquote>
<hr>
<p>debian control文件为：</p>
<pre><code class="language-conf">Package: python3-firewall
Version: 0.9.3
Architecture: amd64
Description: python3-firewall
Maintainer: Cylon Chau &lt;cylonchau@outlook.com&gt;
Section: comm
Homepage: https://github.com/cylonchau/firewalld
</code></pre>
<p>debian构建目录为根据原生包目录格式进行后见即可</p>
<h2 id="dbus配置">dbus配置</h2>
<p>debian 系列 dbus 配置与 redhat 系列有略微差别，配置文件目录为</p>
<ul>
<li>主配置文件需要自行控制权限，必须为：<code>/etc/dbus-1/system.d/org.freedesktop.PackageKit.conf</code></li>
<li>其他配置可以根据redhat 系列进行调整即可</li>
</ul>
<p><strong>最后感谢firewalld团队，issue回复超级快</strong>，如果你需要像使用阿里云安全组使用firewalld管理你公司的大量linux 防火墙，可以试试我的项目 github.com/cylonchau/firewalld-gateway，这是一个firewlld控制器，可以管理大量的firewalld主机</p>
<h2 id="reference">Reference</h2>
<p><sup id="1">[1]</sup> <a href="https://github.com/firewalld/firewalld/issues/851" target="_blank"
   rel="noopener nofollow noreferrer" ><em>firewalld issue 851</em></a></p>
<p><sup id="2">[2]</sup> <a href="https://github.com/firewalld/firewalld/pull/793" target="_blank"
   rel="noopener nofollow noreferrer" ><em>firewalld issue 793 drop dependency python-slip</em></a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ipset性能测试</title>
      <link>https://www.oomkill.com/2022/11/ipset-preformance/</link>
      <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/11/ipset-preformance/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="测试方法">测试方法</h2>
<p>基于使用场景，最后⽣成的规则会是按照 ip 或者 <code>ip:port</code> 来进行过滤，测试时将使用10万条 <code>iptables</code> 规则来模拟对性能的压力；为了最大化测试压力情况，10万条 <code>iptables</code> 规则将都是==不会匹配==机房流量，通俗来讲，就是链式匹配会进行所有匹配并最后以无匹配告终。</p>
<p>网络负载的模拟将使用同机房 <code>scp</code> 来模拟，并按照下述条件进行匹配：</p>
<ul>
<li>查看正常的拷贝速度，cpu负载等</li>
<li>我们建⽴10万条的普通 <code>iptables</code> 规则，查看规则建立速度，拷贝速度，CPU负载，CPU主要耗时操作等</li>
<li>我们建⽴10万的 <code>ipset</code> ，并把普通的 <code>iptables</code> 规则转为结合 <code>ipset</code> 的规则，查看规则建立速度，拷贝速度，CPU负载，CPU主要耗时等。</li>
</ul>
<h2 id="实验开始">实验开始</h2>
<p><strong>步骤一</strong>：在同机房的⼀个机器构造⼀个大文件</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104233138861.png" alt="image-20221104233138861" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>同机房拷贝</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104233643372.png" alt="image-20221104233643372" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>观察网卡速度，CPU，系统主要耗时操作的等，此场景将在<code>iptables</code> 规则为空的情况下进行观察</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104234017089.png" alt="image-20221104234017089" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104234322789.png" alt="image-20221104234322789" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>sar</code> 观测网卡速度</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104233834434.png" alt="image-20221104233834434" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>top</code> 观察CPU负载</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104234452841.png" alt="image-20221104234452841" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>perf top -G</code> 观察CPU占用</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104234724668.png" alt="image-20221104234724668" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>步骤二</strong>：创建10万条iptables，观察⽹卡速度、cpu、系统主要耗时操作的等，会发现cpu利⽤率⼤部分被ipt占⽤，拷⻉速度下降到不到⼗分之⼀</p>
<pre><code class="language-bash">#!/bin/bash

echo *filter
for ((i=1;i&lt;=$1;i++))
do
	echo -I INPUT -S $i -j ACCEPT
done
echo COMMIT
</code></pre>
<p>执行脚本</p>
<pre><code class="language-bash">$ time ./mkrule.sh 100000 | sudo iptables-restore
</code></pre>
<p>观察添加规则后的⽹卡速度，CPU，系统主要耗时操作的等</p>
<p>使用 <code>sar</code> 观测网卡速度</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104235306056.png" alt="image-20221104235306056" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>top</code> 观察CPU负载</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104235441887.png" alt="image-20221104235441887" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>perf top -G</code> 观察CPU占用</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221104235624488.png" alt="image-20221104235624488" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>步骤三</strong>：使用ipset替换iptables</p>
<p>此时改为使⽤ <code>ipset</code> ⽅式观察网卡卡速度，CPU，系统主要耗时操作的等，会发现跟没有规则没有明显变化。ipset的内存量不到2M。初步估计内存使⽤量 = $hashsize \times 16 + 存⼊数 \times (4～32之间)$</p>
<pre><code class="language-bash">#!/bin/bash

#ipset create whitelist hash:ip maxelem 1000000 -exist
#ipset flush whitelist
echo ' creae whitelist hash:ip family inet hashsize 65536 maxelem 100000000'

for ((i=1;i&lt;=$1;i++))
do	
	#ipset add whitelist $i
	echo add whitelist $i
done
# iptables -I INPUT -m set --match-set whitelisti src -j ACCEPT
</code></pre>
<p>执行脚本</p>
<pre><code class="language-bash">$ time ./mkset.sh 100000 | sudo ipset restore
$ sudo iptables -Ln
$ sudo iptables -I INPUT -m set --match-set whitelisti src -j ACCEPT
</code></pre>
<p>观察添加规则后的⽹卡速度，CPU，系统主要耗时操作的等</p>
<p>使用 <code>sar</code> 观测网卡速度</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221105000318616.png" alt="image-20221105000318616" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>top</code> 观察CPU负载</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221105000454342.png" alt="image-20221105000454342" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用 <code>perf top -G</code> 观察CPU占用</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221105000630330.png" alt="image-20221105000630330" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-bash">$ sudo ipset list | head
Name: whitelist
Type: hash:ip
Header: family inet hashsize 65536 maxelem 100000000
Size in memory: 1891208
References: 1
</code></pre>
<p>总结：ipset对于CPU和内存的影响很小，在大量规则场景下符合预期</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用firewalld dbus接口配置iptables</title>
      <link>https://www.oomkill.com/2021/11/firewalld-dbus-interface/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/11/firewalld-dbus-interface/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>firewalld，一个基于动态区的iptables/nftables守护程序，自2009年左右开始开发，CentOS7基于 <code>firewalld-0.6.3</code> ， 发布于2018年10月11日。主要的开发人员是托马斯·沃纳，他目前为红帽公司工作。这是因为为Federal 18 的默认防火墙机制， 随后在 Rhel7 和 Centos 7 中使用。</p>
<p>firewalld比旧的 iptable 机制有许多优势。值得注意的是，它解决了 iptable 要求每次更改时重新启动防火墙的问题，从而中断了任何状态连接。它还提供了丰富的 D-Bus 方法、信号和属性。</p>
<p>这里并不是从firewalld操作使用方式来介绍firewalld的改名，想反，是介绍firewalld D-Bus API来检索信息或更改设置。</p>
<p>firewalld被配置为系统 D-Bus 服务，注意看 systemd file中的&quot; <code>Type=dbus</code> &ldquo;参数。</p>
<pre><code>$ cat /usr/lib/systemd/system/firewalld.service
[Unit]
Description=firewalld - dynamic firewall daemon
Before=network-pre.target
Wants=network-pre.target
After=dbus.service
After=polkit.service
Conflicts=iptables.service ip6tables.service ebtables.service ipset.service
Documentation=man:firewalld(1)

[Service]
EnvironmentFile=-/etc/sysconfig/firewalld
ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS
ExecReload=/bin/kill -HUP $MAINPID
# supress to log debug and error output also to /var/log/messages
StandardOutput=null
StandardError=null
Type=dbus
BusName=org.fedoraproject.FirewallD1
KillMode=mixed

[Install]
WantedBy=multi-user.target
Alias=dbus-org.fedoraproject.FirewallD1.service
</code></pre>
<p>实际上，手动运行 <code>/usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid --debug</code> 效果是一样的，这里的注册是通过dbus 高级API操作的。</p>
<p>此时由于已经了解到了，firewalld 服务 是基于D-Bus接口的，所以需要找到对应的 dbus interface</p>
<pre><code>dbus-send --system --dest=org.freedesktop.DBus \
	--type=method_call --print-reply \
	/org/freedesktop/DBus org.freedesktop.DBus.ListNames | grep FirewallD
</code></pre>
<p><code>org.fedoraproject.FirewallD1</code> 这个就是firewalld注册的dbus interface了。</p>
<p><code>dbus-send</code> 命令可以向 D-Bus消息总线发送消息并显示该消息的返回结果。有两个众所周知的消息总线：system bus（<code>Option -System</code>） 和每个用户session bus（ <code>-session</code>）。使用 <code>firewall-cmd</code> 也是通过 dbus interface 进行交互的。在使用<code>dbus-send</code> 时，必须指定其对应的消息接口 <code> -dest</code>，该参数是连接到对应总线上的接口名称，以将消息发送到对应的dbus firewalld-server进行对应iptables规则的翻译。</p>
<p>现在有了dbus接口，需要了解改接口支持的方法 <code>methods</code>，属性 <code>properties </code>，信号<code>signals </code> 等信息。</p>
<pre><code>dbus-send --system --dest=org.fedoraproject.FirewallD1 --print-reply \
	/org/fedoraproject/FirewallD1 \
	org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<p>通过上述输出列出了通过防火墙 D-Bus 接口提供的所有方法、单一和属性。这是基于D-Bus DTD 的输出格式。所有 dbus服务都需要实现 <code>org.freedesktop.DBus.Introspectable.Introspect </code> 方法。</p>
<p>知道了 方法 属性 信号，就可以直接对firewalld进行一个操作了。现在开始第一个例子。获取默认zone。</p>
<pre><code>$ firewall-cmd --get-default-zone

dbus-send --system --dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \ 
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.getDefaultZone
</code></pre>
<p><strong>通过dbus接口来检索区域列表</strong></p>
<pre><code>$ firewall-cmd --get-zones

dbus-send --system \
	--dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \ 
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.zone.getZones
</code></pre>
<p><strong>最常用的命令：查看当前zone所有策略</strong></p>
<pre><code>$ firewall-cmd --zone=public --list-all

dbus-send --system \
	--dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.getZoneSettings string:&quot;public&quot;
</code></pre>
<p><strong>获得inerface的properties</strong></p>
<p>其实这里在命令行根本用不到，但是在封装时却会可以用到。</p>
<pre><code>dbus-send --system \
	--print-reply --dest=org.fedoraproject.FirewallD1 \
	/org/fedoraproject/FirewallD1 \
	org.freedesktop.DBus.Properties.GetAll string:&quot;org.fedoraproject.FirewallD1&quot;
</code></pre>
<p>还可以通过其他的接口来查看对应的属性值</p>
<pre><code>dbus-send --system --print-reply 
--dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;version&quot;


$ dbus-send --system --print-reply \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;interface_version&quot;


$ dbus-send --system --print-reply \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;state&quot;

$ dbus-send --system --print-reply=literal \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;state&quot;
</code></pre>
<h3 id="查询规则">查询规则</h3>
<p><strong>查询接口</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1 \
    --print-reply \
    --type=method_call \
    /org/fedoraproject/FirewallD1 \
    org.fedoraproject.FirewallD1.zone.getZoneOfInterface \
    string:&quot;eth0&quot;
</code></pre>
<p><strong>创建一个新zone</strong></p>
<pre><code>dbus-send --session \
    --dest=org.freedesktop.DBus \
    --type=method_call \
    --print-reply /org/freedesktop/DBus  \
    org.fedoraproject.FirewallD1.config.addZone \
    string:&quot;testapi&quot;
</code></pre>
<p><strong>获得一个zone的所有规则（<code>zonesettings</code>）</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1  \
    --type=method_call \
    --print-reply /org/fedoraproject/FirewallD1  \
    org.fedoraproject.FirewallD1.getZoneSettings \
    string:&quot;public&quot;
</code></pre>
<p><strong>添加一个port</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1 \
    --print-reply --type=method_call \
    /org/fedoraproject/FirewallD1 \
    org.fedoraproject.FirewallD1.zone.addPort \
    string:&quot;public&quot; \
    string:&quot;81&quot; \
    string:&quot;tcp&quot; \
    uint64:300 
</code></pre>
<p>对应设置firewalld 面板所有属性的命令</p>
<pre><code>firewall-cmd --zone=public --change-interface=eth0

firewall-cmd --zone=public --add-masquerade
firewall-cmd --zone=public --add-forward-port=port=1122:proto=tcp:toport=22:toaddr=192.168.100.3
firewall-cmd --zone=public --add-forward-port=port=1122:proto=tcp:toport=22:toaddr=10.0.0.3

firewall-cmd --add-protocol=tcp
firewall-cmd --add-protocol=udp

firewall-cmd --add-icmp-blocks=icmp
firewall-cmd --set-target=DROP

firewall-cmd --add-icmp-block=redirect
firewall-cmd --add-icmp-block=network-unknown

firewall-cmd --add-source-port=80/tcp
firewall-cmd --add-source-port=100/tcp

firewall-cmd --add-source=10.0.0.1
firewall-cmd --add-source=10.0.0.2

firewall-cmd --add-rich-rule='rule family=ipv4 source address=192.168.1.101/32 service name=telnet limit value=1/m accept'

firewall-cmd --add-icmp-block-inversion

firewall-cmd --new-zone=123 --permanen
</code></pre>
<h3 id="执行远程命令">执行远程命令</h3>
<p>dbus接口支持远程命令的，通过dbus-send发送时，根据配置dbus的监听来完成远程的操作</p>
<pre><code>DBUS_SESSION_BUS_ADDRESS=tcp:host=10.0.0.3,port=55557 
</code></pre>
<p>根据上述，参考加上官方文档，了解如何通过D-Bus接口操作FirewallD，虽然此处是使用了 <code>dbus-send</code>，但是也可以通过 qt 或者 其他的来管理 基于 dbus api的应用了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>firewalld</title>
      <link>https://www.oomkill.com/2017/03/firewalld/</link>
      <pubDate>Thu, 02 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2017/03/firewalld/</guid>
      <description></description>
      <content:encoded><![CDATA[<h3 id="1-firewalld的配置文件">1 firewalld的配置文件</h3>
<p>以xml格式为主</p>
<pre><code class="language-bash">/etc/firewalld/
/usr/lib/firewalld/
</code></pre>
<p>使用时的规则是这样的：当需要一个文件时firewalld会首先到第一个目录中查找，如果找到直接使用，否则会继续到第二个目录中查找。</p>
<h4 id="11-配置文件结构">1.1 配置文件结构</h4>
<p>firewalld的配置文件主要有两个文件和三个目录</p>
<p>文件：firewalld.conf、lockdown-whitelist.xml</p>
<p>目录：zone services icmptypes</p>
<h4 id="12-firewalldconf">1.2 firewalld.conf</h4>
<p>firewalld的主配置文件，不过非常简单，只有五个配置项</p>
<p>defaultzone：默认使用的zone默认public</p>
<p>minimalmark：标记最小值</p>
<p>cleanUpOnExit：退出当前firewalld后是否清除防火墙规则，默认值为yes;</p>
<p>zones</p>
<p>保存zone配置文件</p>
<p>services</p>
<p>保存service配置文件</p>
<p>icmptypes</p>
<p>保存和icmp类型相关的配置文件</p>
<h3 id="2-firewall操作">2 firewall操作</h3>
<h4 id="21-查看firewalld状态">2.1 查看firewalld状态</h4>
<pre><code class="language-bash">$ firewall-cmd --state
not running

$ systemctl start firewalld

$ firewall-cmd --state
running
</code></pre>
<h4 id="22-不改变状态的条件下重新加载防火墙">2.2 不改变状态的条件下重新加载防火墙</h4>
<pre><code class="language-bash">firewall-cmd --reload
</code></pre>
<blockquote>
<p><strong>获取支持的区域列表</strong></p>
</blockquote>
<pre><code class="language-bash">firewall-cmd --get-zone
</code></pre>
<blockquote>
<p><strong>获得所有支持的服务</strong></p>
</blockquote>
<pre><code class="language-bash">$ firewall-cmd --get-services
RH-Satellite-6 amanda-client bacula bacula-client dhcp dhcpv6 dhcpv6-client dns ftp high-availability http https imaps ipp ipp-client ipsec kerberos kpasswd ldap ldaps libvirt libvirt-tls mdns mountd ms-wbt mysql nfs ntp openvpn pmcd pmproxypmwebapi pmwebapis pop3s postgresql proxy-dhcp radius redis rpc-bind samba samba-client smtp ssh telnet tftp tftp-clienttransmission-client vnc-server wbem-https
</code></pre>
<blockquote>
<p><strong>获取所有支持的ICMP类型</strong></p>
</blockquote>
<pre><code class="language-bash">$ firewall-cmd --get-icmptypes
destination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded
</code></pre>
<h3 id="3-firewall-cmd的基础操作">3 firewall-cmd的基础操作</h3>
<h4 id="31-设置并获得默认区域">3.1 设置并获得默认区域</h4>
<pre><code class="language-bash">$ firewall-cmd --set-default-zone=public
success
$ firewall-cmd --get-default-zone
public
</code></pre>
<h4 id="32-在不改变条件下重载防火墙">3.2 在不改变条件下重载防火墙</h4>
<pre><code class="language-bash">$ firewall-cmd --reload
success
</code></pre>
<blockquote>
<p><strong>获得所有支持区域</strong></p>
</blockquote>
<pre><code class="language-bash">$ firewall-cmd --get-services
RH-Satellite-6 amanda-client bacula bacula-client dhcp dhcpv6 dhcpv6-client dns ftp high-availability http https imaps ipp ipp-client ipsec kerberos kpasswd ldap ldaps libvirt libvirt-tls mdns mountd ms-wbt mysql nfs ntp openvpn pmcd pmproxypmwebapi pmwebapis pop3s postgresql proxy-dhcp radius redis rpc-bind samba samba-client smtp ssh telnet tftp tftp-clienttransmission-client vnc-server wbem-https
</code></pre>
<blockquote>
<p><strong>列出全部启用区域的信息</strong></p>
</blockquote>
<pre><code class="language-bash">$ firewall-cmd --list-all-zones
block
  interfaces:
  sources:
  services:
  ports:
  masquerade: no
  forward-ports:
  icmp-blocks:
  rich rules:

dmz
  interfaces:
  sources:
  services: ssh
  ports:
  masquerade: no
  forward-ports:
  icmp-blocks:
  rich rules:
...
...
</code></pre>
<h4 id="33-获得活动区域">3.3 获得活动区域</h4>
<pre><code class="language-bash">$ firewall-cmd --get-active-zones
public
  interfaces: eth0
</code></pre>
<h4 id="34-禁止掉ssh服务">3.4 禁止掉ssh服务</h4>
<pre><code class="language-bash">firewall-cmd --zone=public --remove-service=ssh
</code></pre>
<h4 id="35-允许某个服务生效">3.5 允许某个服务生效</h4>
<pre><code class="language-bash">firewall-cmd --zone=public --add-service=ssh
</code></pre>
<p>永久添加  <code>--permanent </code></p>
<h4 id="36-允许某个服务在一个时间段内生效">3.6 允许某个服务在一个时间段内生效</h4>
<pre><code class="language-bash">$ firewall-cmd --add-service=ssh --timeout=60
success
$ firewall-cmd --list-all
drop (default, active)
  interfaces: eth0
  sources:
  services: ssh
  ports:
  masquerade: yes
  forward-ports:
  icmp-blocks:
  rich rules:
</code></pre>
<pre><code class="language-bash">$ firewall-cmd --list-all
drop (default, active)
  interfaces: eth0
  sources:
  services:
  ports:
  masquerade: yes
  forward-ports:
  icmp-blocks:
  rich rules:
</code></pre>
<h4 id="37-查询某个区域是否开启某项服务">3.7 查询某个区域是否开启某项服务</h4>
<pre><code class="language-bash">$ firewall-cmd --zone=public --query-service=ssh
no
$ firewall-cmd --zone=home --query-service=ssh
yes
</code></pre>
<h4 id="38-启动区域端口协议组合">3.8 启动区域端口协议组合</h4>
<p>此举将启用端口和协议的组合。端口可以是一个单独的端口 或者是一个端口范围 - 。协议可以是 tcp 或udp。</p>
<pre><code class="language-bash">$ firewall-cmd --zone=public --add-port=80/tcp
success
</code></pre>
<pre><code class="language-bash">$ firewall-cmd --zone=public --add-port=10000-20000/tcp
success
</code></pre>
<pre><code class="language-bash">$ firewall-cmd --zone=public --list-all
public
  interfaces:
  sources:
  services: dhcpv6-client
  ports: 80/tcp 10000-20000/tcp
  masquerade: yes
  forward-ports:
  icmp-blocks:
  rich rules:
</code></pre>
<h4 id="39-禁用端口和协议组合">3.9 禁用端口和协议组合</h4>
<pre><code class="language-bash">$ 

success
$ firewall-cmd --zone=public --list-all
public
  interfaces:
  sources:
  services: dhcpv6-client
  ports: 80/tcp
  masquerade: yes
  forward-ports:
  icmp-blocks:
  rich rules:
</code></pre>
<h4 id="310-启动ip伪装功能">3.10 启动IP伪装功能</h4>
<p>此举启用区域的伪装功能。私有网络的地址将被隐藏并映射到一个公有IP。这是地址转换的一种形式，常用于路由。由于内核的限制，伪装功能仅可用于IPv4。</p>
<pre><code class="language-bash">$ firewall-cmd --add-masquerade --zone=home
success
</code></pre>
<h4 id="311-禁用ip伪装">3.11 禁用ip伪装</h4>
<pre><code class="language-bash">firewall-cmd -- -masquerade --zone=home
</code></pre>
<p>在区域中启用端口转发或映射</p>
<p>语法：</p>
<pre><code class="language-bash">firewall-cmd [--zone=] --add-forward-port=port=[-]:proto= { :toport=[-] | :toaddr=| :toport=[-]:toaddr=}
</code></pre>
<pre><code class="language-bash">$ firewall-cmd --add-forward-port=port=9999:proto=tcp:toaddr=192.168.2.82:toport=80
success
</code></pre>
<p><a href="http://www.sa-log.com/282.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.sa-log.com/282.html</a></p>
<p><a href="http://www.fedora.hk/linux/yumwei/show_15.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.fedora.hk/linux/yumwei/show_15.html</a></p>
<p><a href="https://yq.aliyun.com/ziliao/94786" target="_blank"
   rel="noopener nofollow noreferrer" >https://yq.aliyun.com/ziliao/94786</a></p>
<p>启用区域的ICMP阻塞功能</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch1 iptables介绍</title>
      <link>https://www.oomkill.com/2016/10/ch1-iptables-introduction/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch1-iptables-introduction/</guid>
      <description></description>
      <content:encoded><![CDATA[<h3 id="1-防火墙实战">1 防火墙实战</h3>
<p><strong>关闭两项功能</strong>：</p>
<ol>
<li>selinux（生产中也是关闭的），ids入侵检测，MD5指纹将。系统所有核心文件全部做指纹识别，将指纹留下，将来出问题，一看就知道那个文件被改过。</li>
<li> iptables（生产中看情况，内网关闭，外网打开），大并发的情况，不能开iptables，影响性能。
使用防火墙就不如不使用防火墙，不使用防火墙的前提是不给外网ip，工作中要少给外网服务器ip，这样防火墙使用率较低，防火墙使用也很消耗资源</li>
</ol>
<p><strong>安全优化</strong>：</p>
<ol>
<li>尽可能不给服务器配置外网IP。可以通过代理转发或者通过防火墙映射。</li>
<li>并发不是特别大情况再外网IP的环境，要开启iptables防火墙</li>
</ol>
<p><a href="http://edu.51cto.com/course/course_id-772.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://edu.51cto.com/course/course_id-772.html</a></p>
<p><strong>学好iptables基础</strong>：</p>
<ol>
<li> OSI7层模型以及不同层对应那些协议？</li>
<li> TCP/IP三次握手，四次断开的过程，TCP HEADER。</li>
<li> 常用的服务端口要了如指掌。</li>
</ol>
<h4 id="11-iptables防火墙简介">1.1 iptables防火墙简介</h4>
<p>Netfilter/iptables(以下简称iptables)是unix/linux自带的一款优秀且开放源代码的完全自由的基于包过滤的防火墙工具，它的功能十分强大，使用非常灵活，可以对流入和流出的服务器数据包进行很精细的控制。特别是他可以在一台非常低的硬件配置下跑的非常好（赛扬500MHZ 64M内存的情况部署网关防火墙）提供400人的上网服务四号==不逊色企业级专业路由器防火墙==。iptables+zebra+squid</p>
<p>iptables是linux2.4及2.6内核中集成的服务。其功能与安全性比其老一辈ipwadin ipchains强大的多（长江水后浪推前浪），iptables主要工作在OSI七层的二、三、四层，如果重新编译内核，iptables也可以支持7层控制（squid代理+iptables）。</p>
<h4 id="12-iptables名词和术语">1.2 iptables名词和术语</h4>
<p>容器：包含或者说属于关系</p>
<p><strong>什么是容器？</strong></p>
<p>​	在iptables里，就是用老描述这种包含或者说属于的关系</p>
<p><strong>什么是Netfilter/iptables?</strong></p>
<p>​	Netfilter是表（tables）的容器</p>
<p><strong>什么是表（tables）？</strong></p>
<p>​	表是链的容器，所有的链（chains）都属于其对应的表。</p>
<p><strong>什么是链（chains）？</strong></p>
<p>​	链（chains）是规则的容器</p>
<p><strong>什么是规则（policy）</strong></p>
<p>​	iptables一系列过滤信息的规范和具体方法条款</p>
<center><b>iptables抽象和实际比喻对比表</b></center>
| Netfilter | tables     | chains       | policy               |
| --------- | ---------- | ------------ | -------------------- |
| 一栋楼    | 楼里的房子 | 房子里的柜子 | 柜子里衣服的摆放规则 |
<h4 id="13-iptables工作流程">1.3 iptables工作流程</h4>
<p>iptables是采用数据包过滤机制工作的，所以他会对请求的数据包包头数据进行分析，并根据我们预先设定的规则进行匹配来决定是否可以进入主机。</p>
<p>数据包的流向是从左向右的!</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20200728221029808.png" alt="image-20200728221029808" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>iptables工作小结</strong>：</p>
<pre><code>防火墙是一层层过滤的。实际是按照配置规则的顺序从上到下，从前到后进行过滤的。
如果匹配上规则，即明确表明是阻止还是通过，此时数据包就不在向下匹配新规则了。
如果所有规则中没有明确表明是阻止还是通过这个数据包，也就是没有匹配上规则，向下进行匹配，知道匹配默认规则得到明确的阻止还是通过。
防火墙的默认规则是对应链的所有的规则执行完才会执行的。
</code></pre>
<hr>
<p><strong>提示</strong>：</p>
<p>iptables防火墙规则的执行顺序默认从前到后（从上到下）依次执行，遇到匹配的规则就不在继续向下检查，只有遇到不匹配的规则才会继续向下进行匹配。</p>
<hr>
<p>重点：<font color="#f8070d" size=2>匹配上了拒绝规则也是匹配</font>，这点要多注意。</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dport 3306 -j DROP
iptables -A INPUT -p tcp --dport 3306 -j ACCEPT

$ iptables -nL
Chain INPUT (policy ACCEPT) 
DROP       tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:3306 
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:3306 

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited 

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination   
</code></pre>
<p>此时 ``telnet10.0.0.148 3306<code>是不通的，原因就是telnet请求已匹配上了拒绝规则</code>iptables -A INPUT -p tcp &ndash;dport 3306 -j DROP<code>,因此，不会在找下面的规则匹配了。如果希望</code>telnet 10.0.0.148 3306 <code>连通，可以吧ACCEPT规则中的-A改为-I，即 </code>iptables -I INPUT -p tcp &ndash;dport 3306 -j ACCEPT` 把允许规则放于INPUT链第一行生效</p>
<p>==默认规则是所有的规则执行完才会执行的==。</p>
<h4 id="14--iptables表tables和链chains">1.4  iptables表（tables）和链（chains）</h4>
<p>默认情况下，iptables根据功能和表的定义划分包含三个表，filter nat mangle，其每个表有包含不同的操作链（chains）。</p>
<p><strong>下面的表格展示了表和链的对应关系</strong></p>
<div style="text-align:center">
<table>
       <tr   >
        <td style="text-align:center; " rowspan="2" bgcolor='#aaa9a9'><strong>表</strong></td>
        <td  style="text-align:center; " colspan="5" bgcolor='#aaa9a9' ><strong>链（chains）</strong></td>
    </tr>
     <tr>
        <td height="30px" width="100px">INPUT</td>
       <td height="30px" width="130px">FORWARD</td>
       <td height="30px" width="130px">OUTPUT</td>
       <td height="30px" width="130px">PREROUTING</td>
       <td height="30px" width="130px">POSTROUTING</td>
    </tr>
    <tr>
      <td height="30px" width="80px">Filter</td>
      <td height="30px" width="50px" style="background:#2E8B57"></td>
      <td height="30px" width="50px" style="background:#2E8B57"></td>
      <td height="30px" width="50px" style="background:#2E8B57"></td>
      <td height="30px" width="50px" style="background:#A9A9A9"></td>
      <td height="30px" width="50px" style="background:#A9A9A9"></td>
  </tr>
    <tr>
      <td height="30px" width="50px">NAT</td>
      <td height="30px" width="50px" style="background:#A9A9A9" ></td>
      <td height="30px" width="50px" style="background:#A9A9A9" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
    </tr>
      <tr>
       <td height="30px" width="50px">Mangle</td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
      <td height="30px" width="50px" style="background:#2E8B57" ></td>
    </tr>
      <tr>
       <td height="30px" width="30px" colspan="6" >注：绿色表示有， 灰色表示无</td>
    </tr>
</table>  
</div>  
**提示：所有链名要大写**
<table align='center' style="border:1px solid #fff;">
   <tr  align='center' style="border:1px solid #fff;" >
       <td height="50px" width="100px" style="text-align:center;" ><strong>表名</strong></td>
        <td  style="text-align:center; "><strong>作用</strong></td>
    </tr>
     <tr>
       <tr  >
        <td style="text-align:center; ">filter</td>
        <td  >强调主要和主机自身有关，真正负责主机防火墙功能的（过滤流入流出主机的数据包）。filter表是iptables默认使用的表。这个表定义了三个链（chains）。<strong>企业工作场景：主机防火墙。</strong></td>
    </tr>
     <tr>
        <td height="50px" width="50px" style="text-align:center; " >nat</td>
       <td  height="50px">负责网络地址转换，即来源与目的IP地址和port的转换。应用：和主机本身无关。<strong>一般用于局域网共享上网或者特殊的端口转换服务相关。</strong><br><br>
NAT功能一般企业工作场景<br>
1. 用于做企业路由（zebra）或网关（iptables），共享上网（POSTROUTING）<br>
2. 做内部外部IP地址一对一映射（dmz），硬件防火墙映射IP到内部服务器，ftp服务，（PREROUTING）<br>
3. web，单个端口的映射，直接映射80端口（PREROUTING）。这个表示定义了三个链（chains），nat功能就相当于网络的acl控制。和网络交换机acl类似。</td>
    </tr>
    <tr>
        <td height="50px" width="50px" style="text-align:center; ">Mangle</td>
       <td  height="50px">主要负责修改数据包中特殊的路由标记，如TTL，TOS，NARK等。这个表定义了5个链</td>
    </tr>
</table>  
<table align='center' style="border:1px solid #fff;">
   <tr  align='center' style="border:1px solid #fff;" >
       <td height="50px" width="150px" style="text-align:center; " ><strong>链名</strong></td>
        <td  style="text-align:center; "><strong>作用</strong></td>
    </tr>
     <tr>
       <tr  >
        <td style="text-align:center; " height="50px" width="50px" >INPUT</td>
        <td  >负责过滤所有目标地址是本机地址的数据包。通俗的讲，就是过滤进入主机的数据包</td>
    </tr>
     <tr>
        <td  style="text-align:center; " >FORWAED</td>
       <td >负责转发流经主机的数据包。起转发的作用，和NAT关系很大，后面会详细讲LVS NAT模式。</td>
    </tr>
    <tr>
        <td style="text-align:center; ">PREROUTING</td>
       <td >在<strong>数据包到达防火墙时进行路由判断之前执行的规则</strong>，作用是改变数据包的目的地址、目的端口等。（通俗比喻，就是收信时，根据规则重写收件人的地址，这看上去很不地道啊！）
例如：把公网IP：124.42.60.113映射到居于玩分10.0.0.19服务器上。如果是web服务，可以把80端转为局域网的服务器上9000端口。</td>
    </tr>
   <tr>
        <td style="text-align:center; ">POSTROUTING</td>
       <td >在数据包离开防火墙时进行路由判断之后执行的规则，作用改变数据包的源地址、源端口等。（通俗比喻，就是寄信时，写好发件人的地址，要让人家回信时能后有地址可回。）例如：我们在现在的笔记本和虚拟机都是10.0.0.0/24，就是楚王的时候被我们企业路由器把源地址改成了公网地址了。<strong>生产应用：局域网共享上网。</strong></td>
    </tr>
</table>  
<p>由于这个表与特殊标记相关，一般情况下，我们用不到这个mangle表，这里就不做详细介绍了。给初学者的建议：新手学习时最好抓住一个主线向前学，能够跑通路就好，不一定要面面俱到，不然很容易陷进去，而苦恼，甚至失去学习的兴趣</p>
<h4 id="15--iptables表和链的流程图">1.5  iptables表和链的流程图</h4>
<p>下面这张图清晰的描绘了netfilter对包的处理流程</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025001126693.png" alt="image-20221025001126693" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>为了更好的学习将上图简化为如下</strong></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025002458322.png" alt="image-20221025002458322" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center><strong>图1-1 iptables简化流程图</strong></center>
强调：上图可以看作地铁1 2号线来
<p>1号线：主要是NAT功能，</p>
<p>​	<strong>企业案例</strong>：</p>
<p>​		1. 局域网上网共享（路由和网关），使用NAT的POSTROUTING链</p>
<p>​		2. 外部IP和端口映射为内部IP和端口（DMZ功能），使用NAT的PREROUTING链。</p>
<p>2号线：主要是FILTER功能，即防火墙功能 FILTER INPUT FORWARD</p>
<p>​	<strong>企业案例</strong>：</p>
<p>​		主要应用就是主机服务器防火墙，使用FILTER的INPUT链</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch2 iptables命令帮助信息</title>
      <link>https://www.oomkill.com/2016/10/ch2-iptables-command/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch2-iptables-command/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="2-iptables命令帮助信息">2 iptables命令帮助信息</h2>
<p>有问题查帮助，下面是很全的帮助信息（必须拿下它）</p>
<pre><code class="language-bash">$ iptables -h
</code></pre>
<pre><code class="language-bash">$ iptables -nL
# INPUT链 	ACCEPT默认允许决策              
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED 
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           state NEW tcp dpt:22 
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited 

Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
REJECT     all  --  0.0.0.0/0            0.0.0.0/0           reject-with icmp-host-prohibited 

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination  
</code></pre>
<h3 id="21-启动和查看iptables状态">2.1 启动和查看iptables状态</h3>
<pre><code class="language-bash">/etc/init.d/iptables start
systemctl start iptables
</code></pre>
<blockquote>
<p><strong>实例演示1</strong>：</p>
</blockquote>
<pre><code class="language-bash">$ /etc/init.d/iptables status
表格：filter
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1 ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED 
2ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
num  target     prot opt source               destination         
$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED 
</code></pre>
<hr>
<p><strong>提示：如果遇到下面的无法启动IPTABLES的情况</strong></p>
<hr>
<pre><code class="language-bash">$ /etc/init.d/iptables start
$ /etc/init.d/iptables start
$ /etc/init.d/iptables status
Firewall is stopped
</code></pre>
<hr>
<p><strong>解决：setup -&gt; Firewall Configuration -&gt; enable</strong></p>
<hr>
<p><strong>Iptables默认加载的内核模块</strong></p>
<pre><code class="language-bash">$ lsmod|egrep &quot;nat|filter&quot;   
iptable_filter          2793  1 
ip_tables              17831  1 iptable_filter
</code></pre>
<p><strong>加载如下模块到linux内核</strong></p>
<pre><code class="language-bash">modprobe ip_tables \
modprobe iptable_filter \
modprobe iptable_nat \
modprobe ip_conntrack \
modprobe ip_conntrack_ftp \
modprobe ip_nat_ftp \
modprobe ipt_state
</code></pre>
<h3 id="22-iptables参数">2.2 iptables参数</h3>
<table>
<thead>
<tr>
<th><strong>参数选项</strong></th>
<th><strong>注释说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>-n <em>num</em></td>
<td>数字</td>
</tr>
<tr>
<td>-L</td>
<td>列表</td>
</tr>
<tr>
<td>-F</td>
<td>清除所有规则，不会处理默认的规则</td>
</tr>
<tr>
<td>-X</td>
<td>删除用户自定义的链</td>
</tr>
<tr>
<td>-Z</td>
<td>链的计数器清零</td>
</tr>
<tr>
<td>-t</td>
<td>指定表</td>
</tr>
<tr>
<td>-A</td>
<td>添加协议</td>
</tr>
<tr>
<td>-p</td>
<td>协议（all tcp udp Icmp）默认为all</td>
</tr>
<tr>
<td>&ndash;dport</td>
<td>目的端口</td>
</tr>
<tr>
<td>&ndash;sport</td>
<td>源端口</td>
</tr>
<tr>
<td>-j</td>
<td>处理的行为（ACCEPT接受 DROP丢弃 REJECT拒绝）</td>
</tr>
<tr>
<td>-D</td>
<td>删除规则</td>
</tr>
<tr>
<td>-A</td>
<td>添加规则到指定链的结尾</td>
</tr>
<tr>
<td>-I</td>
<td>添加规则到指定链的开头</td>
</tr>
<tr>
<td>-s</td>
<td>指定源地址</td>
</tr>
<tr>
<td>&ndash;line-numbers</td>
<td>显示序号</td>
</tr>
<tr>
<td>-i <em>&lt;网络接口&gt;</em></td>
<td>指定数据包进入本机的网络接口。</td>
</tr>
<tr>
<td>-o <em>&lt;网络接口&gt;</em></td>
<td>指定数据包要离开本机所使用的网络接口。</td>
</tr>
</tbody>
</table>
<h3 id="23-清除默认规则">2.3 清除默认规则</h3>
<ul>
<li><code>iptables -F</code> 清除所有规则，不会处理默认的规则</li>
<li><code>iptables -X</code> 删除用户自定义的链</li>
<li><code>iptables -Z</code> 链的计数器清零</li>
</ul>
<p><strong>实例演示2</strong>：</p>
<pre><code class="language-bash">iptables -F == iptables --flush
iptables -X == iptables --delete-chain
iptables -Z
</code></pre>
<blockquote>
<p><strong>禁止规则</strong></p>
</blockquote>
<p><strong>1.禁止ssh端口</strong></p>
<p>(1) 找出当前机器SSH端口</p>
<pre><code class="language-bash">$ netstat -lntup|grep ssh
tcp     0      0 192.168.1.5:52113       0.0.0.0:*         LISTEN      1053/sshd 
</code></pre>
<p>(2) 禁止掉当前SSH端口，这里是52113</p>
<pre><code class="language-bash">iptables -t [table] -[AD] chain rule-specification [options]
</code></pre>
<p><strong>具体命令</strong></p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dport 52113 -j DROP
iptables -tfilter -A INPUT -p tcp --dport 52113 -j DROP	
</code></pre>
<p>注：</p>
<pre><code class="language-txt">1.  iptables默认用的就是filter表，因此，以上两条命令等价。
2.  其中INPUT DROP要大写
3.  --jump  -j target target for rule（may load target extension）基本处理行为：ACCEPT（接受）、DROP（丢弃）、REJECT（拒绝）。比较：DROP好于REJECT（不要给reject，拒绝会给对方信息，透漏信息了）
</code></pre>
<p>命令行执行的规则，仅仅在内存里临时生效。</p>
<pre><code class="language-bash">$ iptables -A INPUT -p tcp --dport 52113 -j DROP 
$ 
ÐÅºÅµÆ³¬Ê±Ê
</code></pre>
<p>打台球：如果对方告诉你不去，REJECT（拒绝），如果对方没反应，DROP（丢弃）。</p>
<p>(3) 恢复刚才断掉的SSH连接</p>
<pre><code class="language-txt">1.  去机房重启系统或者登陆服务器删除刚才的禁止规则。
2.  让机房人员重启服务器或让机房人员拿用户密码登陆进去。
3.  通过服务器的远程管理卡管理（推荐）。
4.  先写一个定时任务，每5分钟就停止防火墙。
5.  测试环境测试号，写成脚本，批量执行。
</code></pre>
<p>我们恢复的办法，登陆虚拟终端页面删除掉刚才的规则。当然也可执行iptables -F， iptables stop等。
练习：禁止用户访问80端口或3306端口：</p>
<pre><code class="language-bash">iptables -t filter -A INPUT -p tcp --dport 80 -j DROP
$ telnet 192.168.1.5 80
Trying 192.168.1.5...
Connected to 192.168.1.5.
Escape character is '^]'.
^CConnection closed by foreign host.
$ telnet 192.168.1.5 80
Trying 192.168.1.5...

$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80 
</code></pre>
<p>使用-I和-A的顺序，防火墙的过滤根据规则顺序的。</p>
<ul>
<li>
<p><code>-A</code> 是添加规则到指定链的结尾，最后一条。</p>
</li>
<li>
<p><code>-I</code> 是添加规则到指定链的结尾，第一条。</p>
</li>
</ul>
<pre><code class="language-bash">$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination   
</code></pre>
<pre><code class="language-bash">$ iptables -A INPUT -p tcp -s 192.168.1.1 --dport 80 -j DROP
$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  192.168.1.1          0.0.0.0/0           tcp dpt:80 
</code></pre>
<p><strong>查看规则序号</strong>：</p>
<pre><code class="language-bash">iptables -L -n --line-numbers
$ iptables -L -n --line-numbers                             
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       tcp  --  192.168.1.1          0.0.0.0/0           tcp dpt:80 
2    DROP       tcp  --  192.168.1.2          0.0.0.0/0           tcp dpt:80 
Chain FORWARD (policy ACCEPT)

</code></pre>
<p>指定位置插入规则：插入到第二行</p>
<pre><code class="language-bash">$ iptables -I INPUT 2 -p tcp -s 192.168.1.3 --dport 80 -j DROP 
$ iptables -L -n --line-numbers                               
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       tcp  --  192.168.1.1          0.0.0.0/0           tcp dpt:80 
2    DROP       tcp  --  192.168.1.3          0.0.0.0/0           tcp dpt:80 
3    DROP       tcp  --  192.168.1.2          0.0.0.0/0           tcp dpt:80 
Chain FORWARD (policy ACCEPT)
</code></pre>
<p>通过序号删除规则，删除上述第2条规则</p>
<pre><code class="language-bash">$ iptables -D INPUT 2 == delete from iptables where id=2
$ iptables -L -n --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       tcp  --  192.168.1.1          0.0.0.0/0           tcp dpt:80 
2    DROP       tcp  --  192.168.1.2          0.0.0.0/0           tcp dpt:80 
Chain FORWARD (policy ACCEPT)
</code></pre>
<p><strong>小结：总结删除规则的方法</strong>：</p>
<pre><code>1.   iptables -D INPUT -P tcp --dport 8080 -J DROP
2.   iptables -F 删除所有规则
3.   /etc/init.d/iptables restart （用iptables命令行配置的命令都是临时生效）
4.   iptables -D INPUT 序列号
</code></pre>
<p><strong>基于客户端源地址网段控制，禁止10.0.0.0网段连入</strong></p>
<pre><code class="language-bash">iptables -t filter -A INPUT -i eth0 -s 10.0.0.0/24 -J DROP
iptables -A INPUT -i eth0 -s 10.0.0.0/24 -J DROP
</code></pre>
<p>注：iptables默认用的就是filter表，因此以上两条命令等价。
执行以上命令可以发现，我这里已经无法远程连接了。
登陆虚拟机，删除刚才禁止的来源地址为10网段的命令。
<code>iptables -D INPUT -i eth0 -s 10.0.0.0/24 -J DROP</code> (完整策略规则删除)
<code>iptables -D INPUT 1</code>（根据策略在链中的序号删，每条链都是各自从1编号）。</p>
<pre><code class="language-bash">$ iptables -nL --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       tcp  --  192.168.1.5          0.0.0.0/0           tcp dpt:80 
2    DROP       tcp  --  192.168.1.4          0.0.0.0/0           tcp dpt:80 
3    DROP       tcp  --  192.168.1.2          0.0.0.0/0           tcp dpt:80 

Chain FORWARD (policy ACCEPT)
n      
$ iptables -D INPUT 1
$ iptables -nL --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    DROP       tcp  --  192.168.1.4          0.0.0.0/0           tcp dpt:80 
2    DROP       tcp  --  192.168.1.2          0.0.0.0/0           tcp dpt:80 

Chain FORWARD (policy ACCEPT)   
</code></pre>
<blockquote>
<p><strong>还可以通过“！”来取反</strong></p>
</blockquote>
<pre><code class="language-bash"># 只有 192.168.1.1才可访问80端口 ！放在选项的前面而不是参数的前面
iptables -I INPUT -p tcp ! -s 192.168.1.1 --dport 80 -j DROP
</code></pre>
<p>测试配置拒绝规则也是匹配：下面的测试有两个要点：非的作用，匹配拒绝也是匹配。</p>
<p>centos5版本</p>
<pre><code class="language-bash">iptables -I INPUT -p tcp -s ! 192.168.1.1 --dport 80 -j DROP
</code></pre>
<p>centos6.4高版本：</p>
<pre><code class="language-bash">$ iptables -t filter -A INPUT -i eth0 -s ! 10.0.0.115 -j DROP
Using intrapositioned negation (`--option ! this`) is deprecated in favor of extrapositioned (`! --option this`).
# 解决方案： iptables -t filter -A INPUT -i eth0 -s ! 10.0.0.115 -j DROP
</code></pre>
<blockquote>
<p><strong>测试非”！“</strong></p>
</blockquote>
<p>1.源地址不是10.0.0.101单个IP的禁止链接</p>
<pre><code>iptables -t filter -I INPUT -i eth0 ! -s 10.0.0.101 -j DROP
iptables -A INPUT -p all -i eth0 ! -s 10.0.0.106 -j DROP # p(udp tcp icmp all)
# 不让主机ping通
iptables -t filter -I INPUT -p icmp --icmp-type 8 -i eth0 -s ! 192.168.2.83 -j DROP

# ssh 断开链接
$ iptables -t filter -I INPUT -i eth0 ! -s 192.168.2.83 -j DROP
$ 
ÐÅºÅµÆ³¬Ê±Ê
# ping 不通
C:\Users\Company&gt;ping 192.168.2.83
正在 Ping 192.168.2.83 具有 32 字节的数据:
请求超时。
请求超时。
请求超时。
192.168.2.83 的 Ping 统计信息:
数据包: 已发送 = 4，已接收 = 0，丢失 = 4 (100% 丢失)，
</code></pre>
<p>2.原地址不是192.168.2.0/24的网段禁止连接</p>
<pre><code class="language-bash"> iptables -t filter -I INPUT -i eth0 -s ! 192.168.2.0/24 -j DROP  ==  
 iptables -t filter -I INPUT -i eth0 -s 192.168.2.0/24 -j ACCECT # 工作场景
</code></pre>
<p>第一节讲了linux优化，更改root和和ssh端口</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dport 52113 ! -s 192.168.2.0/24 -J DROP
</code></pre>
<p>在默认规则为允许的情况下，上述可以封堵ssh访问。</p>
<blockquote>
<p><strong>企业工作中解决这个问题</strong>：</p>
</blockquote>
<pre><code>1.  vpn服务（拨号拨到VPN上，然后以VPN的内网地址区访问内部的机器地址）。
2.  前端对外提供服务器的机器SSH端口都做禁止外部IP访问限制，可以开启后端或者不对外提供服务的机器，保留SSH服务（更改root和SSH端口）。然后，我们平时就先连接此机器没在去连其他机器。
3.  流量特别大的外网机器不要开防火墙，会影响性能，购买硬件防火墙。
</code></pre>
<p>封掉3306端口</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dorp 3306 -j DROP
</code></pre>
<p>匹配指定的协议</p>
<pre><code class="language-bash">iptables -A INPUT -P tcp 		# 如果不指定-p，默认就是all
</code></pre>
<p>匹配指定协议外的所有协议</p>
<pre><code class="language-bash">iptables -A INPUT -p ! tcp
iptables -I INPUT ! -p tcp -s 192.168.2.83 -j DROP
</code></pre>
<p>匹配网段</p>
<pre><code class="language-bash">iptables -A INPUT -s 10.0.0.0/24
iptables -A INPUT ! -s 10.0.0.0/24
</code></pre>
<p>匹配单一端口</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp ! --sport 22
iptables -A INPUT -p tcp ! --dport 22 -s 10.0.0.20 -j DROP
</code></pre>
<p>匹配端口范围</p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --sport 22:80
iptables -I INPUT -p tcp --dport 21,22,23,24 # 错误语法
iptables -I INPUT -p tcp -m multiport --dport 18:80 -j DROP
iptables -I INPUT -p tcp --dport 21:23 -j DROP # 最佳
</code></pre>
<blockquote>
<p><strong>实例1：测试匹配端口范围</strong></p>
</blockquote>
<pre><code class="language-bash">iptables -F
$ iptables -t filter -A INPUT -p tcp --dport 20:100 -j DROP
C:\Users\Company&gt;telnet 192.168.2.83 80
正在连接192.168.2.83...无法打开到主机的连接。 在端口 80: 连接失败
$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpts:20:100 
</code></pre>
<p>测试结果</p>
<ol>
<li>ssh52113端口终端直接断掉</li>
<li>telnet连接80不通</li>
</ol>
<pre><code class="language-bash">$ iptables -t filter -A INPUT -p tcp --dport 50000:60000 -j DROP     
$ 
ÐÅºÅµÆ³¬Ê±Ê
</code></pre>
<blockquote>
<p><strong>实例2:列举端口</strong></p>
</blockquote>
<pre><code class="language-bash">$ iptables -t filter -A INPUT -p tcp -m multiport --dport 80,90,100 -j DROP
$ iptables -nL
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       tcp  --  0.0.0.0/0            0.0.0.0/0           multiport dports 80,90,100 
</code></pre>
<p>测试结果：telnet连接80不通</p>
<pre><code class="language-bash">$ telnet 192.168.1.5 80
正在连接192.168.1.5...无法打开到主机的连接。 在端口 80: 连接失败
</code></pre>
<blockquote>
<p><strong>匹配ICMC类型</strong></p>
</blockquote>
<p><code>iptables -A INPUT -p icmp --icmp-type 8</code></p>
<p>例：<code>iptables -A INPUT -p icmp --icmp-type 8 -j DROP</code></p>
<pre><code class="language-bash">iptables -A INPUT -p icmp -m icmp --icmp-type any -j ACCEPT
 	iptables -A FORWARD -s 192.168.1.0/24 -p icmp -m icmp --icmp-type any -j ACCEPT
# 在工作中默认是拒绝状态，用什么开什么，只有内网允许ping
</code></pre>
<blockquote>
<p><strong>匹配指定的网络接口</strong></p>
</blockquote>
<pre><code class="language-bash">iptables -A INPUT -i eth0
iptables -A FORWARD -o eth0
</code></pre>
<p><strong>记忆方法</strong>：</p>
<p>in-interface -i input name</p>
<p>in-interface -o output name</p>
<p><strong>匹配网络状态</strong></p>
<ul>
<li>
<p>-m state &ndash;state</p>
</li>
<li>
<p>NEW：已经或将启动洗呢连接</p>
</li>
<li>
<p>ESTABLISHED：已经建立的连接</p>
</li>
<li>
<p>RELATED：正在启动的新连接</p>
</li>
<li>
<p>INVALID：非法或无法识别的</p>
</li>
<li>
<p>FTP服务是特殊的，需要配状态连接。</p>
</li>
</ul>
<p>允许关联的状态包通过（web服务不要使用ftp）</p>
<pre><code class="language-bash">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
</code></pre>
<p>比喻：看电影出去WC或者接个电话，回来也得允许进去。</p>
<p>限制指定时间包的允许通过数量及并发数 <code>-m limit --limit n/{second/minute/hour/day}</code></p>
<p><strong>指定时间内的请求速率“n”为速率，后面为时间分别为：秒时分</strong></p>
<p><code>--limit-burst [n]</code>: 在同一时间内允许通过的请求“n”为数字，不指定默认为5</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch3 iptables配置防火墙</title>
      <link>https://www.oomkill.com/2016/10/ch3-iptables-configuration/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch3-iptables-configuration/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>生产环境配置主机防火墙有两种模式：</p>
<p>逛公园及看电影两种模式：</p>
<p>逛公园：默认随便出进，对非法的分子进行拒绝。企业应用：企业配置上网网关路由。</p>
<p>看电影：默认没有票进不去。花钱买票才能看电影。企业应用：服务器主机防火墙。</p>
<p>很显然：第二种更严格，更安全。</p>
<p>逛公园及看电影两种模式本事就是防火墙的默认规则是允许还是拒绝。</p>
<p><strong>1.清理当前所有规则和计数器</strong></p>
<pre><code class="language-bash">iptables -F
iptables -Z
iptables -X
</code></pre>
<p><strong>2.配置允许SSH登陆端口进入</strong></p>
<pre><code class="language-bash">iptables -A INPUT -p tcp --dport 52113 -j ACCEPT
iptables -A INPUT -p tcp -s 192.168.1.0/30 -j ACCEPT
</code></pre>
<hr>
<p>提示：此步骤是为了防止执行下面的步骤，把自己关在外面，除非你在本地处理，这部可以不做。</p>
<hr>
<p><strong>3.设置允许本机lo通讯规则</strong></p>
<pre><code class="language-bash">iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT # output加不加都行，在工作环境上是加的
</code></pre>
<p><strong>4.设置默认的防火墙禁止和允许规则</strong></p>
<pre><code class="language-bash"> iptables -P INPUT DROP
 iptables -P FORWARD DROP
 iptables -P OUTPUT ACCEPT
</code></pre>
<p>一般情况下OUTPUT我们不要drop，像电影院一样，电影已经看完了，中间不想看就回家了，你不可能说不行不能走，所以一般出去没人管，进来才收票，OUTPUT一般不设置，但是不设置也有风险，企业流量暴涨，由于服务器中病毒外发流量。</p>
<p><strong>查看结果</strong></p>
<pre><code class="language-bash">$ iptables -nL
Chain INPUT (policy DROP)
target     prot opt source               destination         
ACCEPT     tcp  --  192.168.1.0/27       0.0.0.0/0           tcp dpt:52113 
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           

Chain FORWARD (policy DROP)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0 
</code></pre>
<p><strong>5.开启网段信任</strong></p>
<p>允许IDC LAN/WAN和办公网ip的访问，及对外合作机构访问</p>
<p>办公室固定IP段，IDC机房内网网段，其他机房内网网段，IDC机房外网网段</p>
<p>例：</p>
<pre><code>iptables -A INPUT -p all -s 192.168.1.0/27 -j ACCEPT
</code></pre>
<hr>
<p><strong>安全提示</strong>：要细化到掩码最小，租用阿里云攻击同网段案例</p>
<hr>
<p><strong>6.允许icmp类型协议通过</strong></p>
<pre><code class="language-bash">iptables -A INPUT -p icmp -m icmp --icmp-type any -j ACCEPT
</code></pre>
<hr>
<p>注： 如果不想开，就不执行此行命令。如果对内网开，对外不开就用下面方式。</p>
<hr>
<pre><code class="language-bash">iptables -A INPUT -p icmp -s 10.0.0.0/24 -m icmp --icmp-type any -j ACCEPT
</code></pre>
<p><strong>8.允许关联的状态包通过（web服务不要使用FTP）</strong></p>
<p>通过其他服务器扫描我们配置的防火墙：</p>
<pre><code class="language-bash">$  nmap 192.168.1.5 -p 1-65535 # 时间很长
Starting Nmap 5.51 ( http://nmap.org ) at 2016-10-31 01:24 CST
Nmap scan report for 192.168.1.5
Host is up (0.00024s latency).
Not shown: 65533 filtered ports
PORT      STATE SERVICE
80/tcp    open  http
52113/tcp open  unknown
MAC Address: 00:0C:29:BE:2D:75 (VMware)

Nmap done: 1 IP address (1 host up) scanned in 117.86 seconds
</code></pre>
<p><em>在命令行操作的每一条命令都是在内存里 ，没有写入磁盘里，重启服务就丢了</em></p>
<p>在上面的命令行配置中所有的命令结果仅仅存在放于内存中，重启服务就会丢失。因此，我们有必要保存成配置文件。
法一：</p>
<pre><code class="language-sh">$ /etc/init.d/iptables save
iptables：将防火墙规则保存到 /etc/sysconfig/iptables：[确定]
$ cat /etc/sysconfig/iptables
# Generated by iptables-save v1.4.7 on Tue Nov 15 02:50:43 2016
*filter
:INPUT DROP [133073:5855518]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [202:14432]
-A INPUT -s 192.168.1.0/27 -p tcp -m tcp --dport 52113 -j ACCEPT 
-A INPUT -p icmp -m icmp --icmp-type any -j ACCEPT 
-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT 
-A OUTPUT -o lo -j ACCEPT 
COMMIT
# Completed on Tue Nov 15 02:50:43 2016
</code></pre>
<p>法二：</p>
<pre><code class="language-shell">$ iptables-save &gt;/etc/sysconfig/iptables
</code></pre>
<hr>
<blockquote>
<p><font color=#fe0101 size=2>提示：<code>/etc/sysconfig/iptables</code>为iptables的默认配置文件路径</font></p>
<p><font color=#fe0101 size=2>提示：第一次保存可以覆盖，以后保存只能追加</font></p>
</blockquote>
<hr>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch4 生产环境如何维护iptables</title>
      <link>https://www.oomkill.com/2016/10/ch4-iptables-p/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch4-iptables-p/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>生产中，一般第一次添加规则命令行或者脚本加入然后一次性保存成文件，然后可以改配置文件管理：</p>
<pre><code class="language-bash">$  cat /etc/sysconfig/iptables
# Generated by iptables-save v1.4.7 on Wed Nov 23 09:18:12 2016
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [115:13341]
-A INPUT -p tcp -m tcp --dport 52113 -j ACCEPT 
COMMIT
# Completed on Wed Nov 23 09:18:12 2016
</code></pre>
<p>生产维护：</p>
<p>⑴ 确定规则</p>
<pre><code class="language-sh">vim /etc/sysconfig/iptables
# 加入想要的规则：例如：
-A INPUT -p tcp -m tcp --dport 873 -j ACCEPT
/etc/init.d/iptables reload
# 或者修改配置的同时命令行再执行，也是永久生效
</code></pre>
<p>⑵  命令行试错，没问题了，然后放配置文件。这时不需要重启了。</p>
<p>封IP，第一行封。10.0.0.115 这个机器攻击我们服务器或者在BBS里发垃圾帖子。</p>
<p>手工封IP：</p>
<pre><code class="language-sh">iptables -I INPUT -s 10.0.0.115 -j DROP # 范围大，外部攻击者。
iptables -I INPUT -p tcp -s 10.0.0.106 --dport 80 -j DROP # 细，范围小 内部
</code></pre>
<p>自动封IP：分析web或应用日志或者网络连接状态封掉垃圾IP</p>
<p>详见：shell笔记</p>
<pre><code class="language-sh">#!/bin/sh

IPT=/sbin/iptables
# remove any existing rules
$IPT -F
$IPT -X
$IPT -Z
#setting default firewall policy
$IP

#setting forloopback interface
$IPT -A INPUT -i lo -j ACCEPT
$IPT -A OUTPUT -o lo -j ACCEPT

# source address spoofing and other bad addresses
$IPT -A INPUT -i eth0 -s 192.168.2.0/24 -j DROP
$IPT -A INPUT -i eth0 -s 0.0.0.0/8 -j DROP

#prevent all stealth scans and tcp state flags
$IPT -A INPUT -p tcp --tcp-flags ALL ALL -j DROP
#All of the bits are cleared
$IPT -A INPUT -p tcp --tcp-flags ALL NONE -j DROP
$IPT -A INPUT -p tcp --tcp-flags ALL,FIN,URG,PSH -j DROP

#SYN and RST are both set
$IPT -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
#SYN and FIN are both set
$IPT -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

# FIN is the only bit set ,whitout the expected accompanying ACK
$IPT -A INPUT -p tcp --tcp-flags ACK,FIN FIN -j DROP
# PSH is the only bit set ,whitout the expected accompanying ACK
$IPT -A INPUT -p tcp --tcp-flags ACK,PSH PSH -j DROP
# URG is the only bit set ,whitout the expected accompanying ACK
$IPT -A INPUT -p tcp --tcp-flags ACK,URG URG -j DROP

#setting access rules
#one,ip access rules,allow, all the ips of
$IPT -A INPUT -s 10.0.10.0/24 -p tcp --dport 5666 -j ACCEPT
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 5666 -j ACCEPT
#db
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 3306 -j ACCEPT
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 3307 -j ACCEPT
#ssh difference from other servers here
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 52113 -j ACCEPT
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 22 -j ACCEPT
#http
$IPT -A INPUT -p tcp --dport 80 -j ACCEPT
#snmp
$IPT -A INPUT -s 10.0.0.0/24 -p UDP --dport 161 -j ACCEPT
#rsync
$IPT -A INPUT -s 10.0.0.0/24 -p tcp --dport 873 -j ACCEPT
$IPT -A INPUT -s 10.0.10.0/24 -p tcp --dport 873 -j ACCEPT
#icmp
$IPT -A INPUT -p icmp -m icmp --icmp-type any -j ACCEPT
#others RELATED
$IPT -A INPUT  -m state --state ESTABLISHED,RELATED -j ACCEPT
$IPT -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
#setting default firewall rules
$IPT -P OUTPUT ACCEPT
$IPT --policy FORWARD DROP
$IPT --policy INPUT DROP
</code></pre>
<p>技巧：具备外网IP的服务器上不对外的服务最好要做源地址限制。</p>
<p>    对外提供服务，不能做源地址限制，例如：80端口。</p>
<p><font style="background:#bafe01;" size=2>问题：企业硬件防火墙和IPTABLES防火墙是否要同时用。</font></p>
<p>解决：可以同时用。</p>
<p>举例：</p>
<p>    企业硬件防火墙一般放在网关位置，相当于大厦的保安。</p>
<p>    但是，楼道里的每个屋子还是需要有人或者锁门的（iptables）</p>
<p><font style="background:#bafe01;" size=2>问题：IDC机房部署了硬件防火墙，我们的服务器可以不开防火墙吗？</font></p>
<p>​	解答：绝对不可以！大厦有保安，你的办公室就不锁门么？</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch5 配置网关及服务器地址映射</title>
      <link>https://www.oomkill.com/2016/10/ch5-iptables-nat/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch5-iptables-nat/</guid>
      <description></description>
      <content:encoded><![CDATA[<h3 id="1-办公室路由网关架构图">1 办公室路由网关架构图</h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025002730248.png" alt="image-20221025002730248" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>对应实际企业办公上网场景逻辑图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025002851351.png" alt="image-20221025002851351" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="2实验环境配置需求前期准备">2.实验环境配置需求前期准备</h3>
<h4 id="21-服务器网关b需要准备如下条件">2.1 服务器网关B需要准备如下条件</h4>
<blockquote>
<blockquote>
<ol>
<li>物理条件是具备上网卡，建议eth0外网地址（这里是192.168.1.5,gw 192.168.1.2），ech1内网地址（这里是172.168.1.10，<font style="background:#bafe01;" size=2>内网卡不配GW</font >。</li>
<li>确保服务器网关B要可以上网（B上网才能代理别的机器上网）。可以通过ping baidu.com或外网IP测试。</li>
<li>内核文件/etc/sysctl.conf里开启转发功能。在服务器网关B192.168.1.5机器上开启路由转发功能。编辑/etc/sysctl.conf修改内容为net.ipv4.ip_forward = 1，然后执行sysctl -p使修改生效</li>
<li>iptables的filter表的FORWARD链允许转发</li>
<li>不要filter防火墙功能，共享上网，因此最好暂停防火墙测试/etc/init.d/tables stop</li>
</ol>
</blockquote>
</blockquote>
<h4 id="22-加载iptables内核模块">2.2 加载iptables内核模块</h4>
<p>配置网关需要iptables的nat表，PREROUTING，POSTROUTING。</p>
<p><em><strong>(1)载入iptables内核模块，执行并放入rc.local</strong></em></p>
<pre><code class="language-bash">modprobe ip_tables \
modprobe iptable_filter \
modprobe iptable_nat \
modprobe ip_conntrack \
modprobe ip_conntrack_ftp \
modprobe ip_nat_ftp \
modprobe ipt_state
</code></pre>
<pre><code class="language-bash">$ lsmod|egrep ^ip 
iptable_nat             6051  0 
iptable_filter          2793  0 
</code></pre>
<h4 id="23-局域网的机器">2.3 局域网的机器：</h4>
<blockquote>
<blockquote>
<ol>
<li>局域网的机器有一块网卡即可，确保局域网的机器C，默认网关这只了网关服务器B的eth1内网卡IP（172.168l.1.10）。把主机C的gateway设置为B的内网卡192的网卡ip即172.168l.1.10。</li>
<li>检查手段：</li>
<li>分别ping网关服务器B的内外网卡IP，都应该是通的就对了.</li>
<li>出公网检查除了PING网站域名外，也要ping下外网ip，排除DNS故障。不通</li>
<li>ping 10.0.0.254网关也是不通的。</li>
</ol>
</blockquote>
</blockquote>
<p>如上，请准备两台虚拟机B和C，其中B要有双网卡。B的内网卡的网段和C的网段一样。</p>
<p><em><strong>网关B：假设192.168.1.0/24为外部IP，172.168.1.0/24为内部IP</strong></em></p>
<p>eth0:192.168.1.5   IPADDR=192.168.1.5</p>
<p>gw:192.168.1.2	GATEWAY=192.168.1.2</p>
<p>eth1 	eth1:172.168.1.10</p>
<p><font style="background:#bafe01;" size=2>gw：不配</font></p>
<p>内部服务器C：</p>
<p>eth0：172.168.1.11 	IPADDR=172.168.1.11</p>
<p>gw：172.168.1.10（网关B的内网卡IP）		GATEWAY=172.168.1.10</p>
<p>准备结果：</p>
<p><strong>B网关服务器配置</strong></p>
<pre><code class="language-bash">$ ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:31:E5:AF  
          inet addr:192.168.1.4  Bcast:192.168.1.255  Mask:255.255.255.0
 		......
eth1      Link encap:Ethernet  HWaddr 00:0C:29:31:E5:B9  
          inet addr:172.168.1.10  Bcast:172.168.1.255  Mask:255.255.255.0
# 路由
$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
172.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth1
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1003   0        0 eth1
0.0.0.0         192.168.1.2     0.0.0.0         UG    0      0        0 eth0
</code></pre>
<p><strong>C为内网PC或者服务器</strong></p>
<pre><code class="language-bash">$ ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:BE:2D:75  
          inet addr:172.168.1.11  Bcast:172.168.1.255  Mask:255.255.255.0
....
$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
172.168.1.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
0.0.0.0         172.168.1.10    0.0.0.0         UG    0      0        0 eth0
</code></pre>
<h3 id="3-先做一些测试记录">3 先做一些测试记录</h3>
<p>1.登陆C主机172.168.1.11看是否能访问外部页面（配好DNS）。如ping <a href="https://www.baidu.com" target="_blank"
   rel="noopener nofollow noreferrer" >www.baidu.com</a>。正确结果：当前情况不通 lamp为10 lnmp为11</p>
<pre><code class="language-bash">$ ping www.baidu.com
^C
$ ping 61.105.221.1
PING 61.105.221.1 (61.105.221.1) 56(84) bytes of data.
</code></pre>
<p>   2.在笔记本上分别测试telnet 172.168.1.10 22看是否能连通、结果:当前情况通。</p>
<pre><code class="language-bash">$ telnet 172.168.1.10 80
Trying 172.168.1.10...
Connected to 172.168.1.10.
Escape character is '^]'.	
$  telnet 172.168.1.10 80
Trying 172.168.1.10...
Connected to 172.168.1.10.
Escape character is '^]'
</code></pre>
<ol start="3">
<li>在笔记本上分别测试ping 172.168.1.11看是否能连通。结果当前情况通。</li>
<li>测试登陆172.168.1.10看是否能访问外部页面。如ping <a href="https://www.baidu.com" target="_blank"
   rel="noopener nofollow noreferrer" >www.baidu.com</a>结果当前情况通。</li>
<li>在笔记本上分别测试telnet C主机 172.168.1.11 22 结果当前情况不通。</li>
<li>在笔记本上分别测试ping 172.168.1.11看是否能连通。结果当前情况不通。</li>
</ol>
<h3 id="4-根据逻辑图实现如下要求">4 根据逻辑图实现如下要求</h3>
<h4 id="41-局域网共享上网项目案例">4.1 局域网共享上网项目案例</h4>
<p>1.实现c可经过b，通过A上因特网。
解答：提示2:注意主机防火墙功能的影响，可以尝试在GW上先/etc/init.d/iptables stop后在加命令</p>
<p>2.实际处理的局域网共享上网NAT命令
局域网共享的两条命令方法：</p>
<p><em><strong>方法1：适合于有固定ip外网地址的</strong>：</em></p>
<pre><code class="language-bash">iptables -t nat -A POSTROUTING -s 172.168.1.0/24 -o eth0 -j SNAT --to-source 192.168.1.4
</code></pre>
<blockquote>
<ol>
<li>-s 172.168.1.0/24办公室或IDC、内网网段。</li>
<li>-o eth0 为网关的外网卡接口。</li>
<li>-j SNAT &ndash;to-source 192.168.1.4是网关外网卡IP地址。</li>
</ol>
</blockquote>
<p><strong>方法2：适合变化外网地址（ADSL）</strong></p>
<pre><code class="language-bash">iptables -t nat -A POSTROUTING -s 172.168.1.0/24 -j MASQUERADE
</code></pre>
<p>测试结果</p>
<pre><code class="language-bash">$ ping www.baidu.com
PING www.a.shifen.com (58.217.200.112) 56(84) bytes of data.
64 bytes from 58.217.200.112: icmp_seq=1 ttl=127 time=32.1 ms

$ iptables -t nat -nL
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
SNAT       all  --  172.168.1.0/24       0.0.0.0/0           to:192.168.1.4 
</code></pre>
<p><strong>为什么要用POSTROUTING？</strong></p>
<p>企业共享上网：</p>
<p>1.办公网共享上网（网关要有外网IP，否则用路由（zebra））</p>
<p>2.IDC内网机器上网</p>
<p><em><strong>企业上网到底需要不需要linux网关？</strong></em></p>
<p>解答：</p>
<ol>
<li>如果企业里有企业级路由器的情况下，可以不需要上网网关。使用网关只是解决路由器无法解决的需求（例如：上网行为，IP及端口的映射，网关杀毒）。</li>
<li>IDC机房，大厦有固定IP的宽带，直接用网关解决上网及控制问题。</li>
</ol>
<h4 id="42-把外部ip地址及端口映射到内部服务器地址及端口和贡献上网环境一样">4.2 把外部IP地址及端口映射到内部服务器地址及端口（和贡献上网环境一样）</h4>
<p>在10段主机可以通过访问192.168.1.4:80，即可访问到192.168.1.8:9000 提供的web服务。也可SSH（192.168.1.4:222 &ndash;&gt; 192.168.1.8:52113）&lt;== PREROUTING</p>
<p><strong>C配置WEB服务器</strong></p>
<p>解答：</p>
<p>⑴ 在172.168.1.10开启http服务监听9000端口，然后在网关服务器B可以访问</p>
<p>⑵ 具体转换命令：</p>
<pre><code class="language-bash">iptables -t nat -A PREROUTING -d 192.168.1.5 -p tcp --dport 9000 -j DNAT --to-destination 172.168.1.11:80
# DNAT：目的地址转换，将将本地内部的地址映射到互联网地址
</code></pre>
<p><strong>测试结果</strong></p>
<p><em>清空NAT表的规则。</em></p>
<pre><code class="language-bash">iptables -t nat -F
</code></pre>
<p>这个时候访问83的9000端口是不能访问的</p>
<pre><code class="language-bash">iptables -t nat -A PREROUTING -d 192.168.2.83 -p tcp --dport 9000 -j DNAT --to-destination 172.168.1.11:80
</code></pre>
<p>这里看到访问192.168.1.5的9000端口就会映射到内网172.168.1.11的80上。</p>
<h4 id="ssh转发实验">ssh转发实验</h4>
<pre><code class="language-bash"># 网关A IP 192.168.2.83 内网IP 172.168.1.10
$ ifconfig
eth0      Link encap:Ethernet  HWaddr 00:0C:29:AF:21:4F  
          inet addr:192.168.2.83  Bcast:192.168.2.255  Mask:255.255.255.0
eth1      Link encap:Ethernet  HWaddr 00:50:56:20:37:C2  
          inet addr:172.168.1.10  Bcast:172.168.1.255  Mask:255.255.255.0
# 在网关上设置转发
iptables -t nat -I PREROUTING  -p tcp -m tcp --dport 9020 -j DNAT --to-destination 172.168.1.11:52113
# 用外网访问网关外网IP
$ ssh -p 9020 192.168.2.83
.....
root@192.168.2.83's password: 
Last login: Mon Dec 12 22:24:58 2016 from 192.168.2.84
$ ifconfig
          inet addr:172.168.1.11  Bcast:172.168.1.255  Mask:255.255.255.0
</code></pre>
<p>强调：有个网友说网关服务需要开启80服务，但不需要对外服务？</p>
<p>测试结果：网关开启httpd:80后。</p>
<p>此时，来自80端口的请求转发依然会转发到后端的服务器。但是iptables nat规则删除后，此时就到达了http服务的80端口所以显示的是默认页面。</p>
<p><strong>企业应用场景</strong>：</p>
<ol>
<li>把访问外网IP及读研口的请求映射到内网某个服务器及端口（企业内部）。</li>
<li>硬件防火墙，把访问LVS/nginx外网VIP及80端口的请求映射到IDC负载均衡器内部IP及端口上（IDC机房的操作）</li>
</ol>
<p><strong>iptables企业常用案例</strong>：</p>
<ol>
<li>lnux主机防火墙（表FILTER INPUT链）</li>
<li>局域网机器共享上网（表：NAT POSTROUTING链）</li>
</ol>
<pre><code class="language-bash">iptables -t nat -A POSTROUTING -s 172.168.1.0/24 -o eth0 -j SNAT --to-source 192.168.1.5
</code></pre>
<ol start="3">
<li>外部地址和端口，映射为内部地址和端口（表：NAT PREROUTING）</li>
</ol>
<pre><code class="language-bash">iptables -t nat -A PREROUTING -d 192.168.1.5 -p tcp --dport 80 -j DNAT --to-destination 172.168.1.11:9000
</code></pre>
<h4 id="43-实现192段外网ip和172段内网ip一对一映射">4.3 实现192段外网IP和172段内网IP一对一映射</h4>
<p>网关IP：eth0:192.168.1.5 ech1:172.168.1.10</p>
<p>首先在路由网关上绑定接口外网ip，可以是别名的方式。</p>
<pre><code class="language-bash"># 访问外网IP就映射到0.8
-A PREROUTING -d 124.42.34.112 -j DNAT --to-destination 10.0.0.8
# 出网时候改回去
-A POSTROUTING -s 10.0.0.8 -j SNAT --to-destination 124.42.34.112
# 当局域网使用外网IP访问这台机器，会出现问题，只要是局域网访问这个地址，冲定向到网关，防止可能环路
-A POSTROUTING -s 10.0.0.0/255.255.240.0 -d 124.42.34.112 -j SNAT --to-source 10.0.0.254
</code></pre>
<h4 id="44-实现192段机器和10段机器互相访问">4.4 实现192段机器和10段机器互相访问</h4>
<p><a href="http://v.youku.com/v_show/id_XNTAyMjAwMzI0.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://v.youku.com/v_show/id_XNTAyMjAwMzI0.html</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch6 iptables生产应用场景</title>
      <link>https://www.oomkill.com/2016/10/ch6-iptables-application/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch6-iptables-application/</guid>
      <description></description>
      <content:encoded><![CDATA[<blockquote>
<p>1、局域网共享上网（适合做企业内部局域网上网网关，以及IDC机房内网的上网网关 nat POSTROUTING）</p>
</blockquote>
<blockquote>
<p>2、服务器防火墙功能（适合IDC机房具有外网IP服务器，主要是filter INPUT的控制）</p>
</blockquote>
<blockquote>
<p>3、把外部IP及端口映射到局域网内部（可以一对一IP映射，也可针对某一个端口映射。）</p>
<p>也可能是IDC把网站的外网VIP级网站端口映射到负载均衡器上（硬件防火墙）（NAT PREROUTING）</p>
</blockquote>
<blockquote>
<p>4、办公路由器+网关功能（zebra路由+iptables过滤及NAT+squid正向透明代理80+ntop/iftop/iptaf流量查看+tc/cbq流量控制限速）。</p>
</blockquote>
<blockquote>
<p>5、邮件的网关。</p>
</blockquote>
<p><font style="background:#bafe01;" size=2>问题2：的生产环境应用：用于没有外网地址的内网服务器，映射为公网IP后对外提供服务，也包括端口的映射</font></p>
<p><font style="background:#bafe01;" size=2>问题3：IP一对一映射</font>
用于没有外网地址的内网服务器，映射为公网IP后对外提供服务，例如：ftp服务要一对一IP映射。</p>
<p>共享上网封IP的方法：</p>
<pre><code class="language-bash">/sbin/iptables -I FROWAED -s 10.0.0.26 -j　DROP
/sbin/iptables ${deal} FROWARD -m mac --mac -source ${strIpMac} -j DROP
</code></pre>
<h4 id="映射多个外网ip上网">映射多个外网IP上网</h4>
<pre><code class="language-bash">iptables -t nat -A POSTROUTING -s 10.0.1.0/255.255.240.0 -o eth0 -j SNAT --to-source 124.42.60.11-124.42.60.16
iptables -t nat -A POSTROUTING -s 172.168.1.0/255.255.255.0 -o eth0 -j SNAT --to=source 124.42.60.60-124.42.60.63
</code></pre>
<p>问题：公司内网主机多的时候，访问网站容易被封。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch7 关于iptables的内核参数</title>
      <link>https://www.oomkill.com/2016/10/ch7-iptables-kernel-parameter/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2016/10/ch7-iptables-kernel-parameter/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>调整内核参数文件/etc/sysctl.conf，以下是我们生产环境的某个服务器的配置：</p>
<pre><code class="language-bash"># 表示如果套接字由本端要求关闭，这个檀树决定了他保持在FIN-WAIT-2状态的时间。
net.ipv4.tcp_fin_timeout = 2
# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。
net.ipv4.tcp_tw_reuse = 1
# 表示开启TCP连接中TIME-WAIT socket的快速收回，默认为0，表示关闭
net.ipv4.tcp_tw_recycle = 1
提示：以上两个参数为了防止生产环境下 time_wait过多设置的。
############################################################
# 表示开启SYN Cookie。当出现SYN等带队列溢出时，启动cookie来处理，可防范少量SYN攻击，默认为0表示关闭
net.ipv4.tcp_syncookies = 1
# 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是两小时，改为20分钟 单位秒
net.ipv4.tcp_keepalive_time = 1200
# 表示对用向外连接的端口范围。缺省情况下很小。
net.ipv4.ip_local_port_range = 4000  65000
# 表示SYN队列的长度，默认为1024，加大队列长度为8192，可容纳更过等待连接的网络连接数。
net.ipv4.tcp_max_syn_backlog = 16384
# 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清楚并打印警告信息。默认为180000，对于Apache Nginx等服务器来说可以调低一点，如：改为5000-30000，不同业务的服务器也可以给大一点，比如LVS，squid
以上几行的参数可以很好的减少TIME_WAIT套接字数量，但对于squid效果却不大。
net.ipv4.tcp_max_tw_buckets = 36000
net.ipv4.route.gc_timeout = 100
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_synack_retries = 1
# 以下参数是对iptables防火墙的优化，防火墙不会开提示，可以忽略不理。
net.nf_conntrack_max = 25000000
net.netfilter.nf_conntrack_max = 25000000
net.netfilter.nf_conntrack_tcp_timeout_established = 180
net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120
</code></pre>
<p>dmesg里面显示 <code>ip_contrack:table full</code>，``dropping packet.` 的错误提示，如何解决?</p>
<p>这有两个可能，一个是打开的端口太少至不够用，修改ip_conntrack文件为1024 65535。</p>
<p>还有一个原因是nat链接真的达到65535了。此时就把NAT映射表保持时间设置短一些。</p>
<p><strong>强调</strong>：如果并发比较大，或者日PV多的情况下，开启防火墙要注意，很可能导致网站访问缓慢。</p>
<p>大并发（并发1万，PV日3000万）要么购买硬件防火墙，要么不开iptables防火墙。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
