<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CS on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/cs/</link>
    <description>Recent content in CS on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>KNN算法</title>
      <link>https://www.oomkill.com/2022/06/knn/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/06/knn/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>K近邻值算法 <strong>KNN (K — Nearest Neighbors)</strong> 是一种机器学习中的分类算法；K-NN是一种<strong>非参数</strong>的<strong>惰性学习算法</strong>。非参数意味着没有对基础数据分布的假设，即模型结构是从数据集确定的。</p>
<p>它被称为<strong>惰性算法</strong>的原因是，因为它**不需要任何训练数据点来生成模型。**所有训练数据都用于测试阶段，这使得训练更快，测试阶段更慢且成本更高。</p>
<h2 id="如何工作">如何工作</h2>
<p>KNN 算法是通过计算新对象与训练数据集中所有对象之间的距离，对新实例进行分类或回归预测。然后选择训练数据集中距离最小的 K 个示例，并通过平均结果进行预测。</p>
<p>如图所示：一个未分类的数据（红色）和所有其他已分类的数据（黄色和紫色），每个数据都属于一个类别。因此，计算未分类数据与所有其他数据的距离，以了解哪些距离最小，因此当K= 3 （或K= 6 ）最接近的数据并检查出现最多的类，如下图所示，与新数据最接近的数据是在第一个圆圈内（圆圈内）的数据，在这个圆圈内还有 3 个其他数据（已经用黄色分类），我们将检查其中的主要类别，会被归类为紫色，因为有2个紫色球，1个黄色球。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221021234452066.png" alt="image-20221021234452066"  /></p>
<h3 id="knn算法要执行的步骤">KNN算法要执行的步骤</h3>
<ul>
<li>将数据分为训练数据和测试数据</li>
<li>选择一个值 K</li>
<li>确定要使用的距离算法</li>
<li>从需要分类的测试数据中选择一个样本，计算到它的 n 个训练样本的距离。</li>
<li>对获得的距离进行排序并取 k最近的数据样本。</li>
<li>根据 k 个邻居的多数票将测试类分配给该类。</li>
</ul>
<h3 id="影响knn算法性能的因素">影响KNN算法性能的因素</h3>
<ul>
<li>
<p>用于确定最近邻居的<strong>距离</strong>的算法</p>
</li>
<li>
<p>用于从 K 近邻派生分类的决策规则</p>
</li>
<li>
<p>用于对新示例进行分类的邻居<strong>数</strong></p>
</li>
</ul>
<h2 id="如何计算距离">如何计算距离</h2>
<p>测量距离是KNN算法的核心，总结了问题域中两个对象之间的相对差异。比较常见的是，这两个对象是描述主题（例如人、汽车或房屋）或事件（例如购买、索赔或诊断）的数据行。</p>
<h3 id="汉明距离">汉明距离</h3>
<p>汉明距离（<code>Hamming Distance</code>）计算两个二进制向量之间的距离，也简称为二进制串 <code>binary strings</code> 或位串 <code>bitstrings </code>；换句话说，汉明距离是将一个字符串更改为另一个字符串所需的最小替换次数，或将一个字符串转换为另一个字符串的最小错误数。</p>
<p>示例：如一列具有类别 “红色”、“绿色” 和 “蓝色”，您可以将每个示例独热编码为一个位串，每列一个位。</p>
<blockquote>
<p>注：独热编码 one-hot encoding：将分类数据，转换成二进制向量表示，这个二进制向量用来表示一种特殊的bit（二进制位）组合，该字节里，仅容许单一bit为1，其他bit都必须为0</p>
<p>如：</p>
<table>
<thead>
<tr>
<th>apple</th>
<th>banana</th>
<th>pineapple</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>100 表示苹果，100就是苹果的二进制向量
010 表示香蕉，010就是香蕉的二进制向量</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">red = [1, 0, 0]
</span></span><span class="line"><span class="cl">green = [0, 1, 0]
</span></span><span class="line"><span class="cl">blue = [0, 0, 1]
</span></span></code></pre></td></tr></table>
</div>
</div><p>而red和green之间的距离就是<strong>两个等长bitstrings之间bit差</strong>（对应符号不同的位置）的总和或平均数，这就是汉明距离</p>
<ul>
<li>$Hamming Distance d(a, b)\ =\ sum(xi\ !=\ yi\ for\ xi,\ yi\ in\ zip(x, y))$</li>
</ul>
<p>上述的实现为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">hammingDistance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&#34;Undefined for sequences of unequal length.&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e1</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">row1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">hammingDistance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到字符串之间有两个差异，或者 6 个位位置中有 2 个不同，平均 (2/6) 约为 1/3 或 0.333。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">hamming</span>
</span></span><span class="line"><span class="cl"><span class="c1"># define data</span>
</span></span><span class="line"><span class="cl"><span class="n">row1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># calculate distance</span>
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">hamming</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="欧几里得距离">欧几里得距离</h3>
<p>欧几里得距离（<code>Euclidean distance</code>） 是计算两个点之间的距离。在计算具体的数值（例如浮点数或整数）的两行数据之间的距离时，您最有可能使用欧几里得距离。</p>
<p>欧几里得距离计算公式为两个向量之间的平方差之和的平方根。</p>
<p>$EuclideanDistance=\sqrt[]{\sum(a-b)^2}$</p>
<p>如果要执行数千或数百万次距离计算，通常会去除平方根运算以加快计算速度。修改后的结果分数将具有相同的相对比例，并且仍然可以在机器学习算法中有效地用于查找最相似的示例。</p>
<p>$EuclideanDistance = sum\ for\ i\ to\ N\ (v1[i]\ –\ v2[i])^2$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># calculating euclidean distance between vectors</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">euclidean</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># calculate euclidean distance</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">e1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># define data</span>
</span></span><span class="line"><span class="cl"><span class="n">row1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate distance</span>
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">euclidean</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="曼哈顿距离">曼哈顿距离</h3>
<p>曼哈顿距离（ <code>Manhattan distance</code> ）又被称作出租车几何学 <code>Taxicab geometry</code>；用于计算两个向量之间的距离。</p>
<p>对于描述网格上的对象（如棋盘或城市街区）的向量可能更有用。出租车在城市街区之间采取的最短路径（网格上的坐标）。</p>
<blockquote>
<p>粗略地说，欧几里得几何是中学常用的平面几何和立体几何 <a href="https://www.britannica.com/science/Euclidean-geometry/Plane-geometry">Plane geometry</a></p>
</blockquote>
<p>曼哈顿距离可以理解为：欧几里得空间的固定直角坐标系上两点所形成的线段对轴产生的投影的距离总和。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221021234505760.png" alt="image-20221021234505760"  /></p>
<p>图中： 红、蓝与黄线分别表示所有曼哈顿距离都拥有一样长度（12），绿线表示欧几里得距离 $6×\sqrt2 ≈ 8.48$</p>
<p>对于整数特征空间中的两个向量，应该计算曼哈顿距离而不是欧几里得距离</p>
<p>曼哈顿距离在二维平面的计算公式是，在X轴的亮点</p>
<p>$Manhattandistance\ d(x,y)=\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|$</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221021234535889.png" alt="image-20221021234535889"  /></p>
<p>如果所示，描述格子和格子之间的距离可以用曼哈顿距离，如国王移动到右下角的距离是？</p>
<p>$King=|6-8|+|6-1| = 7$</p>
<p>两个向量间的距离可以表示为 $MD\ =\ Σ|Ai – Bi|$</p>
<p>python中的公式可以表示为 ：<code>sum(abs(val1-val2) for val1, val2 in zip(a,b))</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cityblock</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate manhattan distance</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">manhattan_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># define data</span>
</span></span><span class="line"><span class="cl"><span class="n">row1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate distance</span>
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">manhattan_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">cityblock</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="闵可夫斯基距离">闵可夫斯基距离</h3>
<p>闵可夫斯基距离（<code>Minkowski distance</code>）并不是一种距离而是对是<strong>欧几里得距离</strong>和<strong>曼哈顿距离</strong>的概括，用来计算两个向量之间的距离。</p>
<p>闵可夫斯基增并添加了一个参数，称为“<strong>阶数</strong>”或 <code>p</code>：$d(x,y) = (\sum(|x-y|)^p)^\frac{1}{p}$</p>
<p>在python中的公式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="p">(</span><span class="nb">sum</span> <span class="k">for</span> <span class="n">i</span> <span class="n">to</span> <span class="n">N</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="err">–</span> <span class="n">v2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">^</span><span class="n">p</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>p</code> 是一个有序的参数，当 $p=1$ 时，计算的是曼哈顿距离。当 $p=2$ 时，计算的是欧几里得距离。</p>
<p>在实现使用距离度量的机器学习算法时，通常会使用闵可夫斯基距离，因为可以通过调整参数“ <em>p</em> ”控制用于向量的距离度量算法的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># calculating minkowski distance between vectors</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">minkowski_distance</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># calculate minkowski distance</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">minkowski_distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span><span class="o">**</span><span class="n">p</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># define data</span>
</span></span><span class="line"><span class="cl"><span class="n">row1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 手动实现的算法用来使用闵可夫斯基计算距离</span>
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">minkowski_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1为曼哈顿</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1为欧几里得</span>
</span></span><span class="line"><span class="cl"><span class="n">dist</span> <span class="o">=</span> <span class="n">minkowski_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用包 scipy.spatial来计算</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">minkowski_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">minkowski_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="knn算法实现">KNN算法实现</h2>
<h3 id="prerequisite">Prerequisite</h3>
<p>首先会用示例来实现KNN算法的每个步骤，并加以分析，然后将所有步骤关联在在一起，形成一个适用于真实数据集的实现。</p>
<p>KNN在实现起来主要有三个步骤：</p>
<ul>
<li>计算距离（这里选择欧几里得距离）</li>
<li>获得临近邻居</li>
<li>做出预测</li>
</ul>
<p>这三个步骤是KNN算法用以解决分类和回归预测建模问题的基础知识</p>
<h3 id="计算距离">计算距离</h3>
<p>第一步计算数据集中两行之间的距离。在数据集中的数据行主要由数字组成，计算两行或数字向量之间的距离的一种简单方法是画一条直线。这在 2D 或 3D 平面中都是很好地选择，并且可以很好地扩展到更高的维度。</p>
<p>这里使用的是比较流行的计算距离的算法，<strong>欧几里得距离</strong>来计算两个向量之间的直线距离。欧几里得距离的公式是，两个向量的平方差的平方根，$Euclidean\ Distance=\sqrt[]{\sum(a-b)^2}$ ；在python中可以表示为：<code>sqrt(sum i to N (x1 – x2)^2)</code> ；其中 <code>x1</code> 是第一行数据，<code>x2</code> 是第二行数据，<code>i</code>  表示特定列的索引，因为可能需要对所有行进行计算。</p>
<p>在欧几里得距离中，值越小，两条记录就越相似； 0 表示两条记录之间没有差异。</p>
<p>那么使用python实现一个计算欧几里得距离的算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">row2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>准备一部分测试数据，来对测试距离算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">X1</span>				<span class="n">X2</span>					<span class="n">Y</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.7810836</span>		<span class="mf">2.550537003</span>			<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.465489372</span>		<span class="mf">2.362125076</span>			<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.396561688</span>		<span class="mf">4.400293529</span>			<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.38807019</span>		<span class="mf">1.850220317</span>			<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.06407232</span>		<span class="mf">3.005305973</span>			<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">7.627531214</span>		<span class="mf">2.759262235</span>			<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">5.332441248</span>		<span class="mf">2.088626775</span>			<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">6.922596716</span>		<span class="mf">1.77106367</span>			<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">8.675418651</span>		<span class="o">-</span><span class="mf">0.242068655</span>		<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">7.673756466</span>		<span class="mf">3.508563011</span>			<span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么来测试这些数据，需要做到的是第一行与所有行之间的距离，对于第一行与自己的距离应该为<strong>0</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 欧几里得距离，计算两个向量间距离的算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">row2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># 平方差</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="c1"># 平方根</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.7810836</span><span class="p">,</span><span class="mf">2.550537003</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.465489372</span><span class="p">,</span><span class="mf">2.362125076</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.396561688</span><span class="p">,</span><span class="mf">4.400293529</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.38807019</span><span class="p">,</span><span class="mf">1.850220317</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.06407232</span><span class="p">,</span><span class="mf">3.005305973</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.627531214</span><span class="p">,</span><span class="mf">2.759262235</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.332441248</span><span class="p">,</span><span class="mf">2.088626775</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">6.922596716</span><span class="p">,</span><span class="mf">1.77106367</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">8.675418651</span><span class="p">,</span><span class="o">-</span><span class="mf">0.242068655</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.673756466</span><span class="p">,</span><span class="mf">3.508563011</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">row0</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">distance</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">row0</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="c1"># 0.0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1.3290173915275787</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1.9494646655653247</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1.5591439385540549</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 0.5356280721938492</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4.850940186986411</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2.592833759950511</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4.214227042632867</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 6.522409988228337</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4.985585382449795</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="获取最近邻居">获取最近邻居</h3>
<p>数据集中新数据的邻居是k个最接近的实例（行），这个实例由距离定义。现在诞生的问题：<strong>如何找到最近的邻居？以及怎么找到最近的邻居？</strong></p>
<ul>
<li>
<p>为了在数据集中找到 K 的邻居，首先必须计算数据集中每条记录与新数据之间的距离。</p>
</li>
<li>
<p>有了距离之后，必须按照 <strong>K</strong> 的距离对训练集中的所有实例排序。然后选择前 <strong>k</strong> 个作为最近的邻居。</p>
</li>
</ul>
<p>这里实现起来是通过将数据集中每条记录的距离作为一个元组来跟踪，通过对元组列表进行排序（距离降序），然后检索最近邻居。下面是一个实现这些步骤的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 找到最近的邻居</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">train_row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算出每一行的距离，把他添加到元组中</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">test_row</span><span class="p">,</span> <span class="n">train_row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_row</span><span class="p">,</span> <span class="n">dist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">knn</span><span class="p">:</span> <span class="n">knn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 根据元素哪个字段进行排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">neighbors</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是完整的示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 欧几里得距离，计算两个向量间距离的算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">row2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># 平方差</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="c1"># 平方根</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 找到最近的邻居</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">train_row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算出每一行的距离，把他添加到元组中</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">test_row</span><span class="p">,</span> <span class="n">train_row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_row</span><span class="p">,</span> <span class="n">dist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">knn</span><span class="p">:</span> <span class="n">knn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 根据元素哪个字段进行排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">neighbors</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.7810836</span><span class="p">,</span><span class="mf">2.550537003</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.465489372</span><span class="p">,</span><span class="mf">2.362125076</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.396561688</span><span class="p">,</span><span class="mf">4.400293529</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.38807019</span><span class="p">,</span><span class="mf">1.850220317</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.06407232</span><span class="p">,</span><span class="mf">3.005305973</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.627531214</span><span class="p">,</span><span class="mf">2.759262235</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.332441248</span><span class="p">,</span><span class="mf">2.088626775</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">6.922596716</span><span class="p">,</span><span class="mf">1.77106367</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">8.675418651</span><span class="p">,</span><span class="o">-</span><span class="mf">0.242068655</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.673756466</span><span class="p">,</span><span class="mf">3.508563011</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># [2.7810836, 2.550537003, 0]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [3.06407232, 3.005305973, 0]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># [1.465489372, 2.362125076, 0]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，运行后会将数据集中最相似的 3 条记录按相似度顺序打印。和预测的一样，第一个记录与其本身最相似，并且位于列表的顶部。</p>
<h3 id="预测结果">预测结果</h3>
<p>预测结果在这里指定是，通过分类拿到了最近的邻居的实例，对邻居进行分类，找到邻居中最大类别的一类，作为预测值。这里使用的是对邻居值执行 <code>max()</code> 来实现这一点，下面是实现方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 预测值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict_classification</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span> <span class="c1"># 拿到所属类的真实类别</span>
</span></span><span class="line"><span class="cl">    <span class="n">prediction</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_values</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">output_values</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>  <span class="c1">#算出邻居类别最大的数量</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prediction</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是完整的示例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 欧几里得距离，计算两个向量间距离的算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">row2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># 平方差</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="c1"># 平方根</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 找到最近的邻居</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">train_row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算出每一行的距离，把他添加到元组中</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">test_row</span><span class="p">,</span> <span class="n">train_row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_row</span><span class="p">,</span> <span class="n">dist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">knn</span><span class="p">:</span> <span class="n">knn</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 根据元素哪个字段进行排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">neighbors</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 预测值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict_classification</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span> <span class="c1"># 拿到所属类的真实类别</span>
</span></span><span class="line"><span class="cl">    <span class="n">prediction</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_values</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">output_values</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>  <span class="c1">#算出邻居类别最大的数量</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prediction</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.7810836</span><span class="p">,</span><span class="mf">2.550537003</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.465489372</span><span class="p">,</span><span class="mf">2.362125076</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.396561688</span><span class="p">,</span><span class="mf">4.400293529</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.38807019</span><span class="p">,</span><span class="mf">1.850220317</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.06407232</span><span class="p">,</span><span class="mf">3.005305973</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.627531214</span><span class="p">,</span><span class="mf">2.759262235</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.332441248</span><span class="p">,</span><span class="mf">2.088626775</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">6.922596716</span><span class="p">,</span><span class="mf">1.77106367</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">8.675418651</span><span class="p">,</span><span class="o">-</span><span class="mf">0.242068655</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.673756466</span><span class="p">,</span><span class="mf">3.508563011</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">    <span class="n">prediction</span> <span class="o">=</span> <span class="n">predict_classification</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">dataset</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expected </span><span class="si">%d</span><span class="s1">, Got </span><span class="si">%d</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prediction</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 0, Got 0.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 0, Got 0.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 0, Got 0.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 0, Got 0.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 0, Got 0.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 1, Got 1.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 1, Got 1.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 1, Got 1.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 1, Got 1.</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Expected 1, Got 1.</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行结果打印了预期分类与从数据集中 3 个相进邻居预测结果是一直的。</p>
<h2 id="鸢尾花种实例">鸢尾花种实例</h2>
<p>这里使用的是 <a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv">Iris Flower Species</a> 数据集。</p>
<p>鸢尾花数据集是根据鸢尾花的测量值预测花卉种类。这是一个多类分类问题。每个类的观察数量是平衡的。有 150 个观测值，有 4 个输入变量和 1 个输出变量。变量名称如下：</p>
<ul>
<li>萼片长度以厘米为单位。</li>
<li>萼片宽度以厘米为单位。</li>
<li>花瓣长度以厘米为单位。</li>
<li>花瓣宽度以厘米为单位。</li>
<li>真实类型</li>
</ul>
<p>更多的关于数据集的说明可以参考：<a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.names">Iris-databases数据集的说明</a></p>
<h3 id="prerequisite-1">Prerequisite</h3>
<p>实验的步骤大概分为如下：</p>
<ul>
<li>加载数据集并将数据转换为可用于均值和标准差计算的数字。将属性转为float，将类别转换为int。</li>
<li>使 5折的<strong>K</strong>折较差验证（<strong>K-Fold CV</strong>）评估该算法。</li>
</ul>
<h3 id="start">Start</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加载CSV</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">csv_reader</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span>
</span></span><span class="line"><span class="cl">            <span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dataset</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 转换所有的值为float方便运算</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 转换所有的类型为int</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lookup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># # k-folds CV函数进行划分</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">dataset_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">dataset_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 平均分成n_folds折数</span>
</span></span><span class="line"><span class="cl">    <span class="n">fold_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fold_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">index</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_copy</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="n">fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">dataset_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">dataset_split</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算精确度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">actual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 评估算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    评估算法，计算算法的精确度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param dataset: list, 数据集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param algorithm: function, 算法名
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param n_folds: int，折数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param args: 用于algorithm的参数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">folds</span> <span class="o">=</span> <span class="n">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span> <span class="c1"># 分成5折</span>
</span></span><span class="line"><span class="cl">    <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="c1"># 训练集不包含本身</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="p">[])</span>
</span></span><span class="line"><span class="cl">        <span class="n">test_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># 测试集</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">test_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">        <span class="n">predicted</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">scores</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 欧几里得距离，计算两个向量间距离的算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">euclidean_distance</span><span class="p">(</span><span class="n">row1</span><span class="p">,</span> <span class="n">row2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">distance</span> <span class="o">+=</span> <span class="p">(</span><span class="n">row1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">row2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 确定最邻近的邻居</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">train_row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distance</span><span class="p">(</span><span class="n">test_row</span><span class="p">,</span> <span class="n">train_row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">train_row</span><span class="p">,</span> <span class="n">dist</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tup</span><span class="p">:</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">neighbors</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 与临近值进行比较并预测</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict_classification</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    计算训练集train中所有元素到test_row的距离
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param test_row: list, 新的实例，也就是K
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param num_neighbors:int，需要多少个邻居
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">get_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test_row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">output_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="n">prediction</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_values</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">output_values</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">prediction</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># kNN Algorithm</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">k_nearest_neighbors</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span> <span class="o">=</span> <span class="n">predict_classification</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用KNN算法计算鸢尾花数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;iris.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 转换类型为int</span>
</span></span><span class="line"><span class="cl"><span class="n">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 评估算法</span>
</span></span><span class="line"><span class="cl"><span class="n">n_folds</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># 5折</span>
</span></span><span class="line"><span class="cl"><span class="n">num_neighbors</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1">#取5个邻居</span>
</span></span><span class="line"><span class="cl"><span class="n">scores</span> <span class="o">=</span> <span class="n">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">k_nearest_neighbors</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scores: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">%.3f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Scores: [96.66666666666667, 96.66666666666667, 100.0, 90.0, 100.0]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Mean Accuracy: 96.667%</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述是对整个数据集的预测百分比，也可以对对应的类的信息进行输出</p>
<p>首先在类别转换函数 <code>str_column_to_int</code> 中增加打印方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">] =&gt; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在定义一个新的实例，这个实例是用于预测的信息 <code>row = [5.7,2.9,4.2,1.3]</code> ; 然后修改需要预测的数据，进行预测</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 原来的整个数据集打分不需要了</span>
</span></span><span class="line"><span class="cl"><span class="c1"># scores = evaluate_algorithm(dataset, k_nearest_neighbors, n_folds, num_neighbors)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># print(&#39;Scores: %s&#39; % scores)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># print(&#39;Mean Accuracy: %.3f%%&#39; % (sum(scores)/float(len(scores))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 定义一个新数据</span>
</span></span><span class="line"><span class="cl"><span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.7</span><span class="p">,</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">4.2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">label</span> <span class="o">=</span> <span class="n">predict_classification</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data=</span><span class="si">%s</span><span class="s1">, Predicted: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Data=[5.7, 2.9, 4.2, 1.3], Predicted: 1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过预测，可以看出预测结果属于第 1 类，就知道该花为 <code>Iris-setosa</code> 。</p>
<blockquote>
<p>Reference</p>
<p><a href="https://machinelearningmastery.com/distance-measures-for-machine-learning/">distance measures</a></p>
<p><a href="https://machinelearningmastery.com/tutorial-to-implement-k-nearest-neighbors-in-python-from-scratch/">k nearest neighbors implement</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>决策边界算法</title>
      <link>https://www.oomkill.com/2022/06/decision-boundary/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/06/decision-boundary/</guid>
      <description></description>
      <content:encoded><![CDATA[<p><strong>决策边界</strong> (<code>decision boundary</code>)</p>
<p>支持向量机获取这些数据点并输出最能分离标签的超平面。这条线是<strong>决策边界</strong></p>
<p>决策平面 （ <code>decision surface</code> ），是将空间划分为不同的区域。位于决策平面一侧的数据被定义为与位于另一侧的数据属于不同的类别。决策面可以作为学习过程的结果创建或修改，它们经常用于机器学习、模式识别和分类系统。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/Using-Eq-18-as-decision-surface-for-classifying-with-two-overlapped-data-classes.png" alt="Using Eq. (18) as decision surface for classifying, with two overlapped data classes"  /></p>
<p>环境空间 ( <code>Ambient Space</code>)，围绕数学对象即对象本身的空间，如一维 <code>Line</code> ，可以独立研究，这种情况下L则是L；再例如将L作为二维空间 $R^2$ 的对象进行研究，这种情况下 <strong>L</strong> 的环境空间是 $R^2$。</p>
<p>超平面（<code>Hyperplane</code>）是一个子空间， N维空间的超平面是其具有维数的平面的子集。就其性质而言，它将空间分成两个半空间，其维度比其<strong>环境空间</strong>的维度小 <strong>1</strong>。如果空间是三维的，那么它的超平面就是二维维平面，而如果空间是 2 维的，那么它的超平面就是一维线。支持向量机 (SVM) 通过找到使两个类之间的边距最大化的超平面来执行分类。</p>
<p>法向量 （<code>Normal</code>） 是垂直于该平面、另一个向量的 90° 角倾斜</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/220px-Normal_vectors2.svg.png" alt="img"  /></p>
<h2 id="什么是支持向量">什么是支持向量</h2>
<p>支持向量 （<code>Support vectors</code>），靠近决策平面（超平面）的数据点。</p>
<p>如图所示，从一维平面来看，哪个是分离的超平面？</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220530222414946.png" alt="image-20220530222414946"  /></p>
<p>一般而言，会有很多种解决方法（超平面），支持向量机就是如何找到最佳方法的解决方案。</p>
<p>转置运算</p>
<p>矩阵的转置是原始矩阵的翻转版本，可以通过转换矩阵的行和列来转置矩阵。我们用 $A^T$ 表示矩阵 A 的转置。例如，$$A=\left[
\begin{matrix}
1 &amp; 2 &amp; 3 \
4 &amp; 5 &amp; 6 \
\end{matrix}
\right]$$ ；那么 A 的转置就为 $$A=\left[
\begin{matrix}
1 &amp; 4 \
2 &amp; 5 \
3 &amp; 6 \
\end{matrix}
\right]$$ ；</p>
<p>我们可以将向量的转置作为特例。由于 n 维向量 x 由 n×1 列矩阵表示：$$x=\left[
\begin{matrix}
x_1 \
x_2 \
x_3 \
&hellip;.  \
x_n \
\end{matrix}
\right]$$ ；那么 <strong>x</strong> 的转置（$x^T$）是一个 $1\times n$ 行矩阵 $$x^T=\left[
\begin{matrix}
x_1 &amp; x_2 &amp; x_3 &amp; &hellip; &amp; x_n \
\end{matrix}
\right]$$ 。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/200px-Matrix_transpose-16539874514953.gif" alt="img"  /></p>
<p>权重向量</p>
<p>$wx+b=0$  w：权重向量 x n维向量  $x_i=[1,2,3&hellip;n]$ $w_i=[1,2,3&hellip;n]$ 每个输入的值都乘以一个“权重” $w_i$。权重是表示计算输出时每个输入的重要性的值</p>
<p>权重决定了输入对输出的影响程度。 $Y=\sum(Weight \times input)+bias$ ；如果输入为 $[x_1,x_2\ &hellip; ,x_n]$ 权重是：$[w_1,w_2\ \ ,w_n]$</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/assets%252F-LvBP1svpACTB1R1x_U4%252F-LvI8vNq_N7u3RWVAPLk%252F-LvJSdcFXzoI-WW0L3w5%252Fimage.png" alt="img"  /></p>
<p>通过场景来理解</p>
<p>假设预估汽车的价格，汽车的价格取决于制造年份和行驶里程数。让我们假设汽车的年份越高，汽车价格越高。随后，汽车开得越多，汽车就越便宜。</p>
<p>这个例子应该可以帮助您了解汽车价格与制造年份之间存在正相关关系，而汽车价格与其行驶里程之间存在负关关系。因此，我们希望看到代表年份的特征的权重为正，代表里程的特征的权重为负。公式为：$car = (w_1x\ ear+w_2x\ miles)$</p>
<p>偏差 <strong>bais</strong> 是一个常数 <code>const</code> ，偏差用于将影响函数的结果向正或负方向移动。<code>bias</code> 会被被添加到 <strong>input</strong> 和 <strong>weight</strong> 的乘积中。偏差用于抵消结果。$x_1w_1+x_2w_2&hellip;x_nw_n+bias$</p>
<p>通过场景来理解</p>
<p>假设希望在输入为 0 时返回 2。由于权重和输入的乘积之和为 0，您将如何确保返回 2？<strong>此时可以添加2的bias</strong>。如果不包含偏差，只是对 <strong>input</strong> 和 <strong>weight</strong>  执行矩阵乘法。这将很容易导致过度拟合数据集。</p>
<blockquote>
<p><strong>过度拟合</strong>（overfitting）是指机器学习算模型在训练集上的误差和测试集上的误差之间差异过大。造成过度拟合的原因可能有多种．最常见的就是模型容量过高，模型过于复杂，换句话说是模型假设所包含的参数数量过多．如此一来，算法会将训练集中所包含的没有普遍性的一些特征也学习进来，结果降低了模型的泛化能力．</p>
</blockquote>
<p><a href="https://machine-learning.paperspace.com/wiki/weights-and-biases">https://machine-learning.paperspace.com/wiki/weights-and-biases</a></p>
<p>范数</p>
<p>向量的范数（<strong>norm</strong>）是它的长度 ，x的范数表示为 $\parallel x \parallel$；常用的范数为 P 范数，其中 P 是大于等于1的任何数，向量 <strong>x</strong>的 p 范数表示为 $\parallel x \parallel_p$ ；通常情况下向量 x 的 p 范数的计算公式为： $\parallel x \parallel_p = (x_1^p+x_2^p+x_3^p+ \ &hellip;\ x_n^p)^{1/p}$ ；公式可以简写为：$\parallel x \parallel_p =  (\sum_{i=1}^n\ x_i^p)^{1/p}$</p>
<p>曼哈顿距离</p>
<p>曼哈顿距离也被称为1-范数 <code>1-norm</code>，因为它测量的中两点之间的距离。假设：向量a，我们必须计算 1-范式 $\vec{a} = [2,3]$  ，在图像中表示（红色线部分表示向量a的1-范式）</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1PU0J-FJWvTj37huxQjWy8g.png" alt="1-norm"  /></p>
<p>通过公式来计算1-范式，可以将p替换为1，$\parallel a \parallel_1 = (x_1 + x_2) = (2+3)^1=5$</p>
<p>欧几里得范数</p>
<p>欧几里得范数又被称作2-范数 <code>2-norm</code> ，是范数中最常用的范数，欧几里得范数返回的是两点之间最短的距离，因此 $\vec{a}$ 的2-范式为 $\parallel x \parallel_2 = (2^2+3^2)^{\frac{1}{2}} = (4+9)^{\frac{1}{2}} = \sqrt{13}$ ；用图像表示为（红线部分表示2-范数，这是 $\vec{a}$ 表示的点到点之间的最低按距离）</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1tFNCvthlEe_ajinO4ngtEg.png" alt="2-norm"  /></p>
<p>无穷范数</p>
<p>无穷范数 <code>Infinity-norm</code> 是返回给定向量中的最大绝对值；$\vec{a}$ 的无穷范式为  $\parallel a \parallel_\infty = 3$ （公式求得是上述图中 $[2,3]$ 这个实例）。</p>
<p>例如，如果我们必须找到一个向量的无穷范数，比如 $\vec{b}$  ，$\vec{b} = [4,3,-1]$ ；那么  $\parallel b \parallel_\infty = 6$ （这里最大是4，但是返回的是一个绝对值所以是<strong>6</strong>）</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://medium.com/linear-algebra/part-18-norms-30a8b3739bb">norm</a></p>
<p><a href="https://machinelearningmastery.com/vector-norms-machine-learning/">vector norms</a></p>
</blockquote>
<p><strong>拉格朗日乘子法</strong></p>
<p><strong>拉格朗日乘子法</strong> <code>Lagrange multiplier</code>，是一种寻找受<a href="https://en.wikipedia.org/wiki/Constraint_(mathematics)">等式约束</a>的<a href="https://en.wikipedia.org/wiki/Function_(mathematics)">函数的局部</a><a href="https://en.wikipedia.org/wiki/Maxima_and_minima">最大值和最小值</a>的策略（即，必须满足一个或多个<a href="https://en.wikipedia.org/wiki/Equation">方程</a>必须完全满足所选<a href="https://en.wikipedia.org/wiki/Variable_(mathematics)">变量</a>值的条件）</p>
<p>设置超平面为 $wx+b=0$ ，其中 $w=[1,2,\ ..,\ n]$ ，w是 $n \times 1$ 维，n特征值的个数，x 训练的示例，b是bias，一个二维的超平面的特征为：$x=[x_1,x_2]$ ，$w=[w_1,w_2]$ ，b看做 wegiht $w_0$ ，</p>
<p>那么这个超平面的方程就为：$$
f(n)
\begin{cases}
w_1x_1+w_2x_2+w0 = 0\ \  超平面(决策边界)方程 \
w_1x_1+w_2x_2+w0 &gt; 0\ \ 超平面(决策边界)上部分 \
w_1x_1+w_2x_2+w0 &lt; 0\ \ 超平面(决策边界)下部分 \
\end{cases}
$$ ，那么在对公式进行分解，增加参数 <code>y</code> ，代表了对向量的分类，也就是说超平面两边的向量，这样公式为：$$
f(n)
\begin{cases}
w_1x_1+w_2x_2+w0 \ge 1\ \  当 y_i = +1 \
w_1x_1+w_2x_2+w0 \le 1\ \   当 y_i = -1 \
\end{cases}
$$</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>决策树</title>
      <link>https://www.oomkill.com/2022/06/decision-tree/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/06/decision-tree/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="熵和基尼指数">熵和基尼指数</h2>
<h3 id="信息增益">信息增益</h3>
<p>信息增益 <code>information gain</code> 是用于训练决策树的指标。具体来说，是指这些指标衡量<strong>拆分的质量</strong>。通俗来说是通过根据随机变量的给定值拆分数据集来衡量熵。</p>
<p>通过描述一个事件是否&quot;惊讶&quot;，通常低概率事件更令人惊讶，因此具有更大的信息量。而具有相同可能性的事件的概率分布更&quot;惊讶&quot;并且具有更大的熵。</p>
<p><strong>定义</strong>：熵 <strong>entropy</strong>是一组例子中<strong>杂质</strong>、<strong>无序</strong>或<strong>不确定性</strong>的度量。熵控制决策树如何决定<strong>拆分</strong>数据。它实际上影响了决策树如何绘制边界。</p>
<h3 id="熵">熵</h3>
<p>熵的计算公式为：$E=-\sum^i_{i=1}(p_i\times\log_2(p_i))$ ；$P_i$ 是类别 $i$ 的概率。我们来举一个例子来更好地理解熵及其计算。假设有一个由三种颜色组成的数据集，红色、紫色和黄色。如果我们的集合中有一个红色、三个紫色和四个黄色的观测值，我们的方程变为：$E=-(p_r \times \log_2(p_r) + p_p \times \log_2(p_p) + p_y \times \log_2(p_y)$</p>
<p>其中 $p_r$ 、$p_p$ 和 $p_y$ 分别是选择红色、紫色和黄色的概率。假设 $p_r=\frac{1}{8}$，$p_p=\frac{3}{8}$ ，$p_y=\frac{4}{8}$ 现在等式变为变为：</p>
<ul>
<li>$E=-(\frac{1}{8} \times \log_2(\frac{1}{8}) + \frac{3}{8} \times \log_2(\frac{3}{8}) + \frac{4}{8} \times \log_2(\frac{4}{8}))$</li>
<li>$0.125 \times log_2(0.125) + 0.375 \times log_2(0.375) + 0.5 \times log_2(0.375)$</li>
<li>$0.125 \times -3 + 0.375 \times -1.415 + 0.5 \times -1 = -0.375+-0.425 +-0.5 = 1.41$</li>
</ul>
<p>==当所有观测值都属于同一类时会发生什么？== 在这种情况下，熵将始终为零。$E=-(1log_21)=0$ ；这种情况下的数据集没有杂质，这就意味着没有数据集没有意义。又如果有两类数据集，一半是黄色，一半是紫色，那么熵为1，推导过程是：$E=−(\ (0.5\log_2(0.5))+(0.5\times \log_2(0.5))\ ) = 1$</p>
<h3 id="基尼指数">基尼指数</h3>
<p>基尼指数 <code>Gini index</code> 和熵 <code>entropy </code> 是计算信息增益的标准。决策树算法使用信息增益来拆分节点。</p>
<p>基尼指数计算特定变量在随机选择时被错误分类的概率程度以及基尼系数的变化。它适用于分类变量，提供“成功”或“失败”的结果，因此仅进行二元拆分（二叉树结构）。基尼指数在 0 和 1 之间变化，其中，1 表示元素在各个类别中的随机分布。基尼指数为 0.5 表示元素在某些类别中分布均匀。：</p>
<ul>
<li>0 表示为所有元素都与某个类相关联，或只存在一个类。</li>
<li>1 表示所有元素随机分布在各个类中，并且0.5 表示元素均匀分布到某些类中</li>
</ul>
<p>基尼指数公式：$1− \sum_n^{i=1}(p_i)^2$ ； $P_i$ 为分类到特定类别的概率。在构建决策树时，更愿意选择具有最小基尼指数的属性作为根节点。</p>
<p>通过实例了解公式</p>
<table>
<thead>
<tr>
<th><strong>Past Trend</strong></th>
<th><strong>Open Interest</strong></th>
<th><strong>Trading Volume</strong></th>
<th><strong>Return</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Positive</td>
<td>Low</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Negative</td>
<td>High</td>
<td>Low</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Positive</td>
<td>High</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Negative</td>
<td>Low</td>
<td>High</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>Low</td>
<td>Down</td>
</tr>
<tr>
<td>Negative</td>
<td>High</td>
<td>High</td>
<td>Down</td>
</tr>
<tr>
<td>Negative</td>
<td>Low</td>
<td>High</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>Low</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>High</td>
<td>High</td>
<td>Up</td>
</tr>
</tbody>
</table>
<p>计算基尼指数</p>
<p>已知条件</p>
<ul>
<li>
<p>$P(Past\ Trend=Positive) = \frac{6}{10}$</p>
</li>
<li>
<p>$P(Past\ Trend=Negative) = \frac{4}{10}$</p>
</li>
</ul>
<p>过去趋势基尼指数计算</p>
<p>如果过去趋势为正面，回报为上涨，概率为：$P(Past\ Trend=Positive\ &amp;\ Return=Up) = \frac{4}{6}$</p>
<p>如果过去趋势为正面，回报为下降，概率为：$P(Past\ Trend=Positive\ &amp;\ Return=Down) = \frac{2}{6}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Past\ Trend) = 1-(\frac{4}{6}^2+\frac{2}{6}^2) = 0.45$</li>
</ul>
<p>如果过去趋势为负面，回报为上涨，概率为：$P(Past\ Trend=Negative\ &amp;\ Return=Up) = 0$</p>
<p>如果过去趋势为负面，回报为下降，概率为：$P(Past\ Trend=Negative\ &amp;\ Return=Down) = \frac{4}{4}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Past\ Trend=Negative) = 1-(0^2+\frac{4}{4}^2) = 1-(0+1)=0$</li>
</ul>
<p>那么过去交易量的的基尼指数加权 = $\frac{6}{10} \times 0.45 + \frac{4}{10}\times 0 = 0.27$</p>
<p>未平仓量基尼指数计算</p>
<p>已知条件</p>
<ul>
<li>$P(Open\ Interest=High): \frac{4}{10}$</li>
<li>$P(Open\ Interest=Low): \frac{6}{10}$</li>
</ul>
<p>如果未平仓量为 <code>high</code> 并且回报为上涨，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Up)=\frac{2}{4}$</p>
<p>如果未平仓量为 <code>high</code> 并且回报为下降，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Down)=\frac{2}{4}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Open\ Interest=High) = 1-(\frac{2}{4}^2+\frac{2}{4}^2) = 0.5$</li>
</ul>
<p>如果未平仓量为 <code>low</code> 并且回报为上涨，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Up)=\frac{2}{6}$</p>
<p>如果未平仓量为 <code>low</code> 并且回报为下降，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Down)=\frac{4}{6}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Open\ Interest=Low) = 1-(\frac{2}{6}^2+\frac{4}{6}^2) = 0.45$</li>
</ul>
<p>那么未平仓量基尼指数加权 = $\frac{4}{10} \times 0.5 + \frac{6}{10}\times 0.45 = 0.47$</p>
<p>计算交易量基尼指数</p>
<p>已知条件</p>
<ul>
<li>$P(Trading\ Volume=High): \frac{7}{10}$</li>
<li>$P(Trading\ Volume=Low): \frac{3}{10}$</li>
</ul>
<p>如果交易量为 <code>high</code> 并且回报为上涨，概率为：$P(Trading\ Volume=High\ &amp;\ Return\ = Up)=\frac{4}{7}$</p>
<p>如果交易量为 <code>high</code> 并且回报为下降，概率为：$P(Trading\ Volume = High\ &amp;\ Return\ = Down)=\frac{3}{7}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Trading\ Volume=High) = 1-(\frac{4}{7}^2+\frac{3}{7}^2) = 0.49$</li>
</ul>
<p>如果交易量为 <code>low</code> 并且回报为上涨，概率为：$P(Trading\ Volume = Low\ &amp;\ Return\ = Up)=0$</p>
<p>如果交易量为 <code>low</code> 并且回报为下降，概率为：$P(Trading\ Volume = Low\ &amp;\ Return\ = Down)=\frac{3}{3}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Trading\ Volume=Low) = 1-(0^2+1^2) = 0$</li>
</ul>
<p>那么交易量基尼指数加权 = $\frac{7}{10} \times 0.49 + \frac{3}{10}\times 0 = 0.34$</p>
<p>最终计算出的基尼指数列表如下，在表中可以观察到“<strong>Past Trend</strong>”的基尼指数最低，因此它将被选为决策树的根节点。</p>
<table>
<thead>
<tr>
<th><strong>Attributes</strong></th>
<th><strong>Gini Index</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Past Trend</td>
<td>0.27</td>
</tr>
<tr>
<td>Open Interest</td>
<td>0.47</td>
</tr>
<tr>
<td>Trading Volume</td>
<td>0.34</td>
</tr>
</tbody>
</table>
<p>这里将重复的过程来确定决策树的子节点或分支。将通过计算”<strong>Past Trend</strong>“的“<strong>Positive</strong>”分支的基尼指数如下：</p>
<table>
<thead>
<tr>
<th><strong>Past Trend</strong></th>
<th><strong>Open Interest</strong></th>
<th><strong>Trading Volume</strong></th>
<th><strong>Return</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Positive</td>
<td>Low</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Positive</td>
<td>High</td>
<td>High</td>
<td>Up</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>Low</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>Low</td>
<td>Low</td>
<td>Down</td>
</tr>
<tr>
<td>Positive</td>
<td>High</td>
<td>High</td>
<td>Up</td>
</tr>
</tbody>
</table>
<p>针对过去正面趋势计算未平仓量的基尼指数</p>
<p>已知条件</p>
<ul>
<li>$P(Open\ Interest=High): \frac{2}{6}$</li>
<li>$P(Open\ Interest=Low): \frac{4}{6}$</li>
</ul>
<p>如果未平仓量为 <code>high</code> 并且回报为上涨，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Up)=\frac{2}{2}$</p>
<p>如果未平仓量为 <code>high</code> 并且回报为下降，概率为：$P(Open\ Interest = High\ &amp;\ Return\ = Down)=0$</p>
<ul>
<li>那么这个基尼指数为：$gini(Open\ Interest=High) = 1-(\frac{2}{2}^2+0^2) = 0$</li>
</ul>
<p>如果未平仓量为 <code>low</code> 并且回报为上涨，概率为：$P(Open\ Interest = Low\ &amp;\ Return\ = Up)=\frac{2}{4}$</p>
<p>如果未平仓量为 <code>low</code> 并且回报为下降，概率为：$P(Open\ Interest = Low\ &amp;\ Return\ = Down)=\frac{2}{4}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Open\ Interest=Low) = 1-(\frac{2}{4}^2+\frac{2}{4}^2) = 0.5$</li>
</ul>
<p>那么未平仓量基尼指数加权 = $\frac{2}{6} \times 0 + \frac{4}{6}\times 0.5 = 0.33$</p>
<p>计算交易量基尼指数</p>
<p>已知条件</p>
<ul>
<li>$P(Trading\ Volume=High): \frac{4}{6}$</li>
<li>$P(Trading\ Volume=Low): \frac{2}{6}$</li>
</ul>
<p>如果交易量为 <code>high</code> 并且回报为上涨，概率为：$P(Trading\ Volume=High\ &amp;\ Return\ = Up)=\frac{4}{4}$</p>
<p>如果交易量为 <code>high</code> 并且回报为下降，概率为：$P(Trading\ Volume = High\ &amp;\ Return\ = Down)=0$</p>
<ul>
<li>那么这个基尼指数为：$gini(Trading\ Volume=High) = 1-(\frac{4}{4}^2+0^2) = 0$</li>
</ul>
<p>如果交易量为 <code>low</code> 并且回报为上涨，概率为：$P(Trading\ Volume = Low\ &amp;\ Return\ = Up)=0$</p>
<p>如果交易量为 <code>low</code> 并且回报为下降，概率为：$P(Trading\ Volume = Low\ &amp;\ Return\ = Down)=\frac{2}{2}$</p>
<ul>
<li>那么这个基尼指数为：$gini(Trading\ Volume=Low) = 1-(0^2+\frac{2}{2}^2) = 0$</li>
</ul>
<p>那么交易量基尼指数加权 = $\frac{4}{6} \times 0 + \frac{2}{6}\times 0 = 0$</p>
<p>最终计算出的基尼指数列表如下，这里将使用“<strong>Trading Volume</strong>”进一步拆分节点，因为它具有最小的基尼指数。</p>
<table>
<thead>
<tr>
<th><strong>Attributes/Features</strong></th>
<th><strong>Gini Index</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Open Interest</td>
<td>0.33</td>
</tr>
<tr>
<td>Trading Volume</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>最终的模型就如图所示</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220602000050768.png" alt="image-20220602000050768"  /></p>
<h4 id="计算信息增益示例">计算信息增益示例</h4>
<p>我们可以根据属于一类数据的概率分布来考虑数据集的熵，例如，在二进制分类数据集的情况下为两个类。计算样本的熵如 $Entropy = -(P_0 \times log(P_0) + P_1 \times log(P_1)$ 。</p>
<p>两类的样本拆分为 <code>50/50</code> 的数据集将具最大熵（最惊讶），而拆分为 <code>10/90</code> 的不平衡数据集将具有较小的熵。可以通过在 Python 中计算这个不平衡数据集的熵的例子来证明这一点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 概率</span>
</span></span><span class="line"><span class="cl"><span class="n">class0</span> <span class="o">=</span> <span class="mi">10</span><span class="o">/</span><span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">class1</span> <span class="o">=</span> <span class="mi">90</span><span class="o">/</span><span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="c1"># entropy formula</span>
</span></span><span class="line"><span class="cl"><span class="n">entropy</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">class0</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class0</span><span class="p">)</span> <span class="o">+</span> <span class="n">class1</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># print the result</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">entropy</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行示例，可以看到用于二分类的数据集的熵小于 1 。也就是说，对来自数据集中的任意示例类进行编码所需的信息不到1。通过这种方式，熵可以用作数据集纯度的计算，例如类别分布的平衡程度。</p>
<p>熵为 0 位表示数据集包含一个类；1或更大位的熵表示平衡数据集的最大熵（取决于类别的数量），介于两者之间的值表示这些极端之间的水平。</p>
<h3 id="计算信息增益示例-1">计算信息增益示例</h3>
<p>要求：定义一个函数来根据属于 0 类和 1 类的样本的比率来计算一组样本的熵。</p>
<p>假设有一个20 个示例的数据集，13 个为0 类，7 个为1 类。我们可以计算该数据集的熵，它的熵小于 1 位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy for the split in the dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">class0</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class0</span><span class="p">)</span> <span class="o">+</span> <span class="n">class1</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># split of the main dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">class0</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">/</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">class1</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate entropy before the change</span>
</span></span><span class="line"><span class="cl"><span class="n">s_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dataset Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Dataset Entropy: 0.934 bits</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设按照 value1 分割数据集，有一组 8 个样本的数据集，7 个为第 0 类，1 个用于第 1 类。然后我们可以计算这组样本的熵。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy for the split in the dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">class0</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class0</span><span class="p">)</span> <span class="o">+</span> <span class="n">class1</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># split of the main dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class0</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate entropy before the change</span>
</span></span><span class="line"><span class="cl"><span class="n">s_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">s1_class0</span><span class="p">,</span> <span class="n">s1_class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dataset Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Dataset Entropy: 0.544 bits</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>假设现在按 value2 分割数据集；一组 12 个样本数据集，每组 6 个。我们希望这个组的熵为 1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy for the split in the dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">class0</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class0</span><span class="p">)</span> <span class="o">+</span> <span class="n">class1</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># split of the main dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class0</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class1</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate entropy before the change</span>
</span></span><span class="line"><span class="cl"><span class="n">s_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">s1_class0</span><span class="p">,</span> <span class="n">s1_class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dataset Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Dataset Entropy: 1.000 bits</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后，可以根据为变量的每个值创建的组和计算的熵来计算该变量的信息增益。例如：</p>
<p>第一个变量从数据集中产生一组 8 个样本，第二组在数据集中有12 个样本。在这种情况下，信息增益计算：</p>
<ul>
<li>$Entropy(Dataset) – (\frac{(Count(Group1)}{Count(Dataset)} \times Entropy(Group1) + \frac{Count(Group2)}{Count(Dataset)} \times Entropy(Group2)))$</li>
</ul>
<p>这里是因为在每个子节点重复这个分裂过程直到空叶节点。这意味着每个节点的样本都属于同一类。但是，这种情况下会导致具有许多节点使非常<strong>深的树</strong>，这很容易导致过度拟合。因此，我们通常希望通过设置树的最大深度来修剪树。IG就是我们想确定给定训练特征向的量集中的<strong>哪个属性最有用</strong>，那么上面的公式推理就为：</p>
<ul>
<li>$IG(D_p) = I(D_p) − \frac{N_{left}}{N_p}I(D_{left})−\frac{N_{right}}{N_p}I(D_{right})$
<ul>
<li>$IG(D_P)$：数据集的信息增益</li>
<li>$I(D)$：叶子的熵或基尼指数</li>
<li>$\frac{N}{N_P}$ ：页数据集占总数据集的比例</li>
</ul>
</li>
</ul>
<p>我们将使用它来决定<strong>决策树</strong> 节点中<strong>属性的顺序</strong>。该行为在python中表示为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log2</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy for the split in the dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">class0</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class0</span><span class="p">)</span> <span class="o">+</span> <span class="n">class1</span> <span class="o">*</span> <span class="n">log2</span><span class="p">(</span><span class="n">class1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># split of the main dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">class0</span> <span class="o">=</span> <span class="mi">13</span> <span class="o">/</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="n">class1</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate entropy before the change</span>
</span></span><span class="line"><span class="cl"><span class="n">s_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">class0</span><span class="p">,</span> <span class="n">class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dataset Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># split 1 (split via value1)</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class0</span> <span class="o">=</span> <span class="mi">7</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_class1</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy of the first group</span>
</span></span><span class="line"><span class="cl"><span class="n">s1_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">s1_class0</span><span class="p">,</span> <span class="n">s1_class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Group1 Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s1_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># split 2  (split via value2)</span>
</span></span><span class="line"><span class="cl"><span class="n">s2_class0</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="n">s2_class1</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">/</span> <span class="mi">12</span>
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the entropy of the second group</span>
</span></span><span class="line"><span class="cl"><span class="n">s2_entropy</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">s2_class0</span><span class="p">,</span> <span class="n">s2_class1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Group2 Entropy: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">s2_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># calculate the information gain</span>
</span></span><span class="line"><span class="cl"><span class="n">gain</span> <span class="o">=</span> <span class="n">s_entropy</span> <span class="o">-</span> <span class="p">(</span><span class="mi">8</span><span class="o">/</span><span class="mi">20</span> <span class="o">*</span> <span class="n">s1_entropy</span> <span class="o">+</span> <span class="mi">12</span><span class="o">/</span><span class="mi">20</span> <span class="o">*</span> <span class="n">s2_entropy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Information Gain: </span><span class="si">%.3f</span><span class="s1"> bits&#39;</span> <span class="o">%</span> <span class="n">gain</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Dataset Entropy: 0.934 bits</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Group1 Entropy: 0.544 bits</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Group2 Entropy: 1.000 bits</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Information Gain: 0.117 bits</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过实例，就可以很清楚的明白了，信息增益的概念：<strong>信息熵-条件熵</strong>，换句话来说就是==信息增益代表了在一个条件下，信息复杂度（不确定性）减少的程度==。</p>
<h2 id="python计算决策树实例">python计算决策树实例</h2>
<h3 id="基于基尼指数的决策树">基于基尼指数的决策树</h3>
<p>钞票数据集涉及根据从照片中采取的一系列措施来预测给定钞票是否是真实的。数据是取自真钞和伪钞样样本的图像中提取的。对于数字化，使用了通常用于印刷检查的工业相机，从图像中提取特征。</p>
<p>该数据集包含 1372 行和 5 个数值变量。这是一个二元分类的问题。</p>
<h4 id="基尼指数-1">基尼指数</h4>
<p>假设有两组数据，每组有 2 行。第一组的行都属于 0 类，第二组的行都属于 1 类，所以这是一个完美的拆分。</p>
<p>首先需要计算每个组中类的比例。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">proportion</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">class_value</span><span class="p">)</span> <span class="o">/</span> <span class="n">count</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个比例是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">group_1_class_0</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">group_1_class_1</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">group_2_class_0</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">group_2_class_1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为每个子节点计算 Gini index</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">gini_index</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportion</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">proportion</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">gini_index</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportion</span> <span class="o">*</span> <span class="n">proportion</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后对每组的基尼指数按组的大小加权，例如当前正在分组的所有样本。我们可以将此权重添加到组的基尼指数计算中，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">gini_index</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">proportion</span> <span class="o">*</span> <span class="n">proportion</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">group_size</span><span class="o">/</span><span class="n">total_samples</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在该案例中，每个组的基尼指数为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="mf">0.5</span> 
</span></span><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># 分类1的基尼指数</span>
</span></span><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="mf">0.5</span> 
</span></span><span class="line"><span class="cl"><span class="n">Gini</span><span class="p">(</span><span class="n">group_2</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># 分类2的基尼指数</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后在分割点的每个子节点上添加分数，以给出分割点的最终 Gini 分数，该分数可以与其他候选分割点进行比较。如该分割点的基尼系数为 $0.0 + 0.0$ 或完美的基尼系数 0.0。</p>
<p>编写一个 <code>gini_index()</code> 的函数，用于计算组列表和已知类值列表的基尼指数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;------------&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算所有样本的分割点，计算样本的总长度</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_instances</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算每个组的总基尼指数</span>
</span></span><span class="line"><span class="cl">    <span class="n">gini</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># avoid divide by zero</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># score the group based on the score for each class</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">class_val</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># row[-1] 代表每个样本的最后一个值，是否存在分类 class_val</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">class_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl">            <span class="n">score</span> <span class="o">+=</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 按照对应的样本分割点，加权重</span>
</span></span><span class="line"><span class="cl">        <span class="n">gini</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">score</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gini</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">gini_index</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">gini_index</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行该示例会打印两组的Gini index，最差情况的为 0.5，最少情况的指数为 0.0。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220602215655808.png" alt="image-20220602215655808"  /></p>
<h4 id="拆分">拆分</h4>
<h5 id="数据拆分">数据拆分</h5>
<p>拆分是由数据集中的一个属性和一个值组成。可以将其总结为要拆分的属性的索引和拆分该属性上的行的值。这只是索引数据行的有用简写。</p>
<p>创建拆分涉及三个部分，我们已经看过的第一个部分是计算基尼分数。剩下的两部分是：</p>
<ul>
<li>拆分数据集。</li>
<li>评估所有拆分。</li>
</ul>
<p>拆分数据是给定数据集索引和拆分值，将数据集拆分为两个行列表形成一个分类。具体是拆分数据集涉及遍历每一行，检查属性值是否低于或高于拆分值，并将其分别分配给左组或右组。当存在两个组时，可以按照基尼指数进行评估</p>
<p>编写一个**test_split()**函数，它实现了拆分。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="评估拆分的数据">评估拆分的数据</h5>
<p>给定一个数据集，必须检查每个属性上的每个值作为候选拆分，评估拆分的成本并找到我们可以进行的最佳拆分。一旦找到最佳值，就可以将其用作决策树中的节点。</p>
<p>这里使用 <code>dict</code> 作为决策树中的节点，因为这样可以按名称存储数据。选择最佳基尼指数并将其用作树的新节点。</p>
<p>每组数据都是其小数据集，其中仅包含通过拆分过程分配给左组或右组的那些行。可以想象我们如何在构建决策树时递归地再次拆分每个组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">class_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">groups</span> <span class="o">=</span> <span class="n">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">gini</span> <span class="o">=</span> <span class="n">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">gini</span> <span class="o">&lt;</span> <span class="n">b_score</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">gini</span><span class="p">,</span> <span class="n">groups</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span><span class="n">b_index</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">b_value</span><span class="p">,</span> <span class="s1">&#39;groups&#39;</span><span class="p">:</span><span class="n">b_groups</span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后准备一些测试数据集进行测试，其中 $Y$ 是测试集的分类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X1				X2				Y
</span></span><span class="line"><span class="cl">2.771244718		1.784783929		0
</span></span><span class="line"><span class="cl">1.728571309		1.169761413		0
</span></span><span class="line"><span class="cl">3.678319846		2.81281357		0
</span></span><span class="line"><span class="cl">3.961043357		2.61995032		0
</span></span><span class="line"><span class="cl">2.999208922		2.209014212		0
</span></span><span class="line"><span class="cl">7.497545867		3.162953546		1
</span></span><span class="line"><span class="cl">9.00220326		3.339047188		1
</span></span><span class="line"><span class="cl">7.444542326		0.476683375		1
</span></span><span class="line"><span class="cl">10.12493903		3.234550982		1
</span></span><span class="line"><span class="cl">6.642287351		3.319983761		1
</span></span></code></pre></td></tr></table>
</div>
</div><p>将上述代码整合为一起，运行该代码后会打印所有基尼指数，基尼指数为 0.0 或完美分割。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Split a dataset based on an attribute and an attribute value</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Calculate the Gini index for a split dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算两组数据集的总数每个种类的列表数量和</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_instances</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算每组的基尼值</span>
</span></span><span class="line"><span class="cl">    <span class="n">gini</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># avoid divide by zero</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># score the group based on the score for each class</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">class_val</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 拿出数据集中每行的类型，拆开是为了更好的了解结构</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># print(&#34;%f / %f = %f&#34; % (p.count(class_val), size, p.count(class_val) / size ))</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 这里计算的是当前的分类在总数据集中占比</span>
</span></span><span class="line"><span class="cl">            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">class_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl">            <span class="n">score</span> <span class="o">+=</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="c1"># gini index formula = 1 - sum(p_i^2)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算总的基尼指数，权重：当前分组占总数据集中的数量</span>
</span></span><span class="line"><span class="cl">        <span class="n">gini</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">score</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gini</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Select the best split point for a dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 最后分类不计算</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 根据每个值分类计算出最优基尼值，这个值就作为决策树的节点</span>
</span></span><span class="line"><span class="cl">            <span class="n">groups</span> <span class="o">=</span> <span class="n">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">gini</span> <span class="o">=</span> <span class="n">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;X</span><span class="si">%d</span><span class="s1"> &lt; </span><span class="si">%.3f</span><span class="s1"> Gini=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">gini</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">gini</span> <span class="o">&lt;</span> <span class="n">b_score</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">gini</span><span class="p">,</span> <span class="n">groups</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span><span class="n">b_index</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">b_value</span><span class="p">,</span> <span class="s1">&#39;groups&#39;</span><span class="p">:</span><span class="n">b_groups</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.771244718</span><span class="p">,</span><span class="mf">1.784783929</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">1.728571309</span><span class="p">,</span><span class="mf">1.169761413</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.678319846</span><span class="p">,</span><span class="mf">2.81281357</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.961043357</span><span class="p">,</span><span class="mf">2.61995032</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.999208922</span><span class="p">,</span><span class="mf">2.209014212</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.497545867</span><span class="p">,</span><span class="mf">3.162953546</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">9.00220326</span><span class="p">,</span><span class="mf">3.339047188</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.444542326</span><span class="p">,</span><span class="mf">0.476683375</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">10.12493903</span><span class="p">,</span><span class="mf">3.234550982</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">6.642287351</span><span class="p">,</span><span class="mf">3.319983761</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">split</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Split: [X</span><span class="si">%d</span><span class="s1"> &lt; </span><span class="si">%.3f</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">split</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">split</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过执行结果可以看出，<code>X1 &lt; 6.642 Gini=0.000 </code>基尼指数为 0.0 为完美分割。</p>
<h4 id="如何构建树">如何构建树</h4>
<p>构建树主要分为 3 个部分</p>
<ul>
<li>终端节点 <code>Terminal Nodes</code> 零度节点称为终端节点或叶节点</li>
<li>递归拆分</li>
<li>建造一棵树</li>
</ul>
<h5 id="终端节点">终端节点</h5>
<p>需要决定何时停止种植树，这里可以使用节点在训练数据集中负责的<strong>深度</strong>和<strong>行数</strong>来做到。</p>
<ul>
<li><strong>树的最大深度</strong>：从树的根节点开始的最大节点数。一旦达到树的最大深度，停止拆分新节点。</li>
<li><strong>最小节点</strong>：对一个节点的要训练的最小值。一旦达到或低于此最小值，则停止拆分和添加新节点。</li>
</ul>
<p>这两种方法将是构建树的过程时用户的指定参数。当在给定点停止增长时，该节点称为终端节点，用于进行最终预测。</p>
<p>编写一个函数<strong>to_terminal()</strong>，这个函数将为一组行选择一类。它返回行列表中最常见的输出值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">to_terminal</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">outcomes</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">outcomes</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="递归拆分">递归拆分</h5>
<p>构建决策树会在为每个节点创建的组上一遍又一遍地调用 <code>get_split()</code> 函数。</p>
<p>添加到现有节点的新节点称为子节点。一个节点可能有零个子节点（一个终端节点）、一个子节点或两个子节点，这里将在给定节点的字典表示中将子节点称为左和右。当一旦创建出一个节点，则通过再次调用相同的函数来递归地从拆分的每组数据以创建子节点。</p>
<p>下面需要实现这个过程（递归函数）。函数接受一个节点作为参数，以及节点中的最大深度、最小模式数、节点的当前深度。</p>
<p>调用的过程分步为。设置，传入根节点和深度1：</p>
<ul>
<li>首先，将拆分后的两组数据提取出来使用，当处理过这些组时，节点不再需要访问这些数据。</li>
<li>接下来，我们检查左或右两组是否为空，如果是，则使用我们拥有的记录创建一个终端节点。</li>
<li>不为空的情况下，检查是否达到了最大深度，如果是，则创建一个终端节点。</li>
<li>然后我们处理左子节点，如果行组太小，则创建一个终端节点，否则以深度优先的方式创建并添加左节点，直到在该分支上到达树的底部。最后再以相同的方式处理右侧。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 创建子拆分或者终端节点</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param node: </span><span class="si">{}</span><span class="s2">,分割好的的{&#39;index&#39;:b_index, &#39;value&#39;:b_value, &#39;groups&#39;:b_groups}
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param depth:int， 当前深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">del</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查两边的分割问题</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查最大的深度</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 处理左分支，数量要小于最小模式数为terminal node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 否则递归</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 处理左右支，数量要小于最小模式数为terminal node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="创建树">创建树</h5>
<p>构建一个树就是一个上面的步骤的合并，通过**split()**函数打分并确定树的根节点，然后通过递归来构建出整个树；下面代码是实现此过程的函数 <strong>build_tree()</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Build a decision tree</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">train</span><span class="p">)</span> <span class="c1"># 对整个数据集进行打分</span>
</span></span><span class="line"><span class="cl">    <span class="n">split</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="整合">整合</h5>
<p>将全部代码整合为一个</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Split a dataset based on an attribute and an attribute value</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Calculate the Gini index for a split dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算两组数据集的总数每个种类的列表数量和</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_instances</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算每组的基尼值</span>
</span></span><span class="line"><span class="cl">    <span class="n">gini</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># avoid divide by zero</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># score the group based on the score for each class</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">class_val</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 拿出数据集中每行的类型，拆开是为了更好的了解结构</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># print(&#34;%f / %f = %f&#34; % (p.count(class_val), size, p.count(class_val) / size ))</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 这里计算的是当前的分类在总数据集中占比</span>
</span></span><span class="line"><span class="cl">            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">class_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl">            <span class="n">score</span> <span class="o">+=</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="c1"># gini index formula = 1 - sum(p_i^2)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算总的基尼指数，权重：当前分组占总数据集中的数量</span>
</span></span><span class="line"><span class="cl">        <span class="n">gini</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">score</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gini</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Select the best split point for a dataset</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># 最后分类不计算</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 根据每个值分类计算出最优基尼值，这个值就作为决策树的节点</span>
</span></span><span class="line"><span class="cl">            <span class="n">groups</span> <span class="o">=</span> <span class="n">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">gini</span> <span class="o">=</span> <span class="n">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># print(&#39;X%d &lt; %.3f Gini=%.3f&#39; % ((index+1), row[index], gini))</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">gini</span> <span class="o">&lt;</span> <span class="n">b_score</span><span class="p">:</span> <span class="c1"># 拿到最小的gini index那列</span>
</span></span><span class="line"><span class="cl">                <span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">gini</span><span class="p">,</span> <span class="n">groups</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span><span class="n">b_index</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">b_value</span><span class="p">,</span> <span class="s1">&#39;groups&#39;</span><span class="p">:</span><span class="n">b_groups</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 创建子拆分或者终端节点</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param node: </span><span class="si">{}</span><span class="s2">,分割好的的{&#39;index&#39;:b_index, &#39;value&#39;:b_value, &#39;groups&#39;:b_groups}
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param depth:int， 当前深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">del</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查两边的分割问题</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 检查最大的深度</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 处理左分支，数量要小于最小模式数为terminal node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 否则递归</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 处理左右支，数量要小于最小模式数为terminal node</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Build a decision tree</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">train</span><span class="p">)</span> <span class="c1"># 对整个数据集进行打分</span>
</span></span><span class="line"><span class="cl">    <span class="n">split</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印树</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[X</span><span class="si">%d</span><span class="s1"> &lt; </span><span class="si">%.3f</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="p">(</span><span class="n">depth</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 递归打印左右</span>
</span></span><span class="line"><span class="cl">        <span class="n">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">depth</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span> <span class="c1"># 不是对象就是terminal node</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 创建一个terminal node</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">to_terminal</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">outcomes</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">outcomes</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.771244718</span><span class="p">,</span><span class="mf">1.784783929</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">1.728571309</span><span class="p">,</span><span class="mf">1.169761413</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.678319846</span><span class="p">,</span><span class="mf">2.81281357</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.961043357</span><span class="p">,</span><span class="mf">2.61995032</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.999208922</span><span class="p">,</span><span class="mf">2.209014212</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.497545867</span><span class="p">,</span><span class="mf">3.162953546</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">9.00220326</span><span class="p">,</span><span class="mf">3.339047188</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.444542326</span><span class="p">,</span><span class="mf">0.476683375</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">10.12493903</span><span class="p">,</span><span class="mf">3.234550982</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">6.642287351</span><span class="p">,</span><span class="mf">3.319983761</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">tree</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">print_tree</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到打印结果是一个类似二叉树的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[X1 &lt; 6.642]
</span></span><span class="line"><span class="cl"> [X1 &lt; 2.771]
</span></span><span class="line"><span class="cl">  [0]
</span></span><span class="line"><span class="cl">  [X1 &lt; 2.771]
</span></span><span class="line"><span class="cl">   [0]
</span></span><span class="line"><span class="cl">   [0]
</span></span><span class="line"><span class="cl"> [X1 &lt; 7.498]
</span></span><span class="line"><span class="cl">  [X1 &lt; 7.445]
</span></span><span class="line"><span class="cl">   [1]
</span></span><span class="line"><span class="cl">   [1]
</span></span><span class="line"><span class="cl">  [X1 &lt; 7.498]
</span></span><span class="line"><span class="cl">   [1]
</span></span><span class="line"><span class="cl">   [1]
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="预测">预测</h5>
<p>预测是预测数据是该向右还是向左，是作为对数据进行导航的方式。这里可以使用递归来实现，其中使用左侧或右侧子节点再次调用相同的预测，具体取决于拆分如何影响提供的数据。</p>
<p>我们必须检查子节点是否是要作为预测返回的终端值，或者它是否是包含要考虑的树的另一个级别的字典节点。</p>
<p>下面是实现此过程的函数 <strong>predict()</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Make a prediction with a decision tree</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面是一个使用硬编码决策树的示例，该决策树具有一个最好地分割数据的节点（决策树桩，这个就是gini index的最优质值）。通过对上面的测试数据集例来对每一行进行预测。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 如果gini index与对应属性的值小于则向左，</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span> <span class="c1"># 递归处理完整个树</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span><span class="p">:</span> <span class="c1"># 否则的话，则为右</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.771244718</span><span class="p">,</span><span class="mf">1.784783929</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.728571309</span><span class="p">,</span><span class="mf">1.169761413</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.678319846</span><span class="p">,</span><span class="mf">2.81281357</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.961043357</span><span class="p">,</span><span class="mf">2.61995032</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">2.999208922</span><span class="p">,</span><span class="mf">2.209014212</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.497545867</span><span class="p">,</span><span class="mf">3.162953546</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">9.00220326</span><span class="p">,</span><span class="mf">3.339047188</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.444542326</span><span class="p">,</span><span class="mf">0.476683375</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">10.12493903</span><span class="p">,</span><span class="mf">3.234550982</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">6.642287351</span><span class="p">,</span><span class="mf">3.319983761</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1">#  这是之前用于计算出最优的gini index</span>
</span></span><span class="line"><span class="cl"><span class="n">stump</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">6.642287351</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">prediction</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">stump</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Expected=</span><span class="si">%d</span><span class="s1">, Got=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">prediction</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过观察可以看出预测结果和实际结果一样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">Expected</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">Got</span><span class="o">=</span><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="套用真实数据集来测试">套用真实数据集来测试</h4>
<p>这里将使用 <code>CART</code> 算法对<a href="https://archive.ics.uci.edu/ml/datasets/banknote+authentication">银行钞票数据集</a>进行预测。大概的流程为：</p>
<ul>
<li>加载数据集并转换格式。</li>
<li>编写拆分算法与准确度计算算法；这里使用 5折的k折交叉验证（<code>k-fold cross validation</code>）用于评估算法</li>
<li>编写 CART 算法，从训练数据集，创建树，对测试数据集进行预测操作</li>
</ul>
<h5 id="什么是-k折交叉验证">什么是 K折交叉验证</h5>
<p>K折较差验证（<strong>K-Fold CV</strong>）是将给定的数据集分成<strong>K</strong>个部分，其中每个折叠在某时用作测试集。以 5 折（K=5）为例。这种情况下，数据集被分成5份。在第一次迭代中，第一份用于测试模型，其余用于训练模型。在第二次迭代中，第 2 份用作测试集，其余用作训练集。重复这个过程，直到 5 个折叠中的每个折叠都被用作测试集。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1IjKy-Zc9zVOHFzMw2GXaQw.png" alt="K-Fold CV"  /></p>
<p>下面来开始编写函数，函数的整个过程为</p>
<ul>
<li><code>evaluate_algorithm()</code> 作为最外层调用
<ul>
<li>使用五折交叉进行评估 <code>cross_validation_split()</code></li>
<li>使用决策树算法作为算法根据 <code>decision_tree()</code></li>
<li>构建树：<code>build_tree()</code>
<ul>
<li>拿到最优基尼指数作为叶子 <code>get_split()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 加载csv文件</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&#34;rt&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">lines</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将所有字段转换为float类型便于计算</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># k-folds CV函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 平均分位折数n_folds</span>
</span></span><span class="line"><span class="cl">	<span class="n">fold_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fold_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_copy</span><span class="p">))</span> <span class="c1"># 随机</span>
</span></span><span class="line"><span class="cl">			<span class="n">fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataset_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset_split</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算精确度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">actual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">			<span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Evaluate an algorithm using a cross validation split</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">folds</span> <span class="o">=</span> <span class="n">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="p">[])</span>
</span></span><span class="line"><span class="cl">		<span class="n">test_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">row_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">test_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">row_copy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">		<span class="n">predicted</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">scores</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 根据基尼指数划分value是应该在树的哪边？</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(),</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">value</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 基尼指数打分</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算数据集中的多组数据的总个数</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_instances</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算每组中的最优基尼指数</span>
</span></span><span class="line"><span class="cl">    <span class="n">gini</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">score</span> <span class="o">=</span> <span class="mf">0.0</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 总基尼指数</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">class_val</span> <span class="ow">in</span> <span class="n">classes</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 拿出数据集中每行的类型，拆开是为了更好的了解结构</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c1"># 计算的是当前的分类在总数据集中占比</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">p1</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">class_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">size</span>
</span></span><span class="line"><span class="cl">            <span class="n">score</span> <span class="o">+=</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算总的基尼指数，并根据相应大小增加权重。权重：当前分组占总数据集中的数量</span>
</span></span><span class="line"><span class="cl">        <span class="n">gini</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">score</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">n_instances</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gini</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 从数据集中获得基尼指数最佳的值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">class_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="mi">999</span><span class="p">,</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">groups</span> <span class="o">=</span> <span class="n">test_split</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">gini</span> <span class="o">=</span> <span class="n">gini_index</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">gini</span> <span class="o">&lt;</span> <span class="n">b_score</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="n">b_index</span><span class="p">,</span> <span class="n">b_value</span><span class="p">,</span> <span class="n">b_score</span><span class="p">,</span> <span class="n">b_groups</span> <span class="o">=</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">gini</span><span class="p">,</span> <span class="n">groups</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">{</span><span class="s1">&#39;index&#39;</span><span class="p">:</span><span class="n">b_index</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span><span class="n">b_value</span><span class="p">,</span> <span class="s1">&#39;groups&#39;</span><span class="p">:</span><span class="n">b_groups</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 创建终端节点</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">to_terminal</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">outcomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">outcomes</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">outcomes</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 创建子节点，为终端节点或子节点</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param node: </span><span class="si">{}</span><span class="s2">,分割好的的{&#39;index&#39;:b_index, &#39;value&#39;:b_value, &#39;groups&#39;:b_groups}
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param depth:int， 当前深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">del</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;groups&#39;</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># check for a no split</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="ow">not</span> <span class="n">left</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">right</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># check for max depth</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;=</span> <span class="n">max_depth</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># process left child</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># process right child</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">min_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_terminal</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 构建树</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">build_tree</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param max_depth: int, 最大深度
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param min_size:int，最小模式数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :ret
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">root</span> <span class="o">=</span> <span class="n">get_split</span><span class="p">(</span><span class="n">train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">split</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">root</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印树</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[X</span><span class="si">%d</span><span class="s1"> &lt; </span><span class="si">%.3f</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="p">(</span><span class="n">depth</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 递归打印左右</span>
</span></span><span class="line"><span class="cl">        <span class="n">print_tree</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">depth</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">node</span><span class="p">)))</span> <span class="c1"># 不是对象就是terminal node</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 预测，预测方式为当前基尼指数与最优基尼指数相比较，然后放入树两侧</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param node: </span><span class="si">{}</span><span class="s2"> 叶子值
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param row: </span><span class="si">{}</span><span class="s2">, 需要预测值
</span></span></span><span class="line"><span class="cl"><span class="s2">    :ret
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;index&#39;</span><span class="p">]]</span> <span class="o">&lt;</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">predict</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">],</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">decision_tree</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">tree</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">prediction</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Test CART on Bank Note dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 加载数据</span>
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;data_banknote_authentication.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 转换格式</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span></span><span class="line"><span class="cl">	<span class="n">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 评估算法</span>
</span></span><span class="line"><span class="cl"><span class="n">n_folds</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">max_depth</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">min_size</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="n">scores</span> <span class="o">=</span> <span class="n">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">decision_tree</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">min_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scores: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">%.3f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://www.bogotobogo.com/python/scikit-learn/scikt_machine_learning_Decision_Tree_Learning_Informatioin_Gain_IG_Impurity_Entropy_Gini_Classification_Error.php">Informatioin Gain</a></p>
<p><a href="https://machinelearningmastery.com/implement-decision-tree-algorithm-scratch-python/">implement decision tree algorithm</a></p>
<p><a href="https://machinelearningmastery.com/information-gain-and-mutual-information/">inplement information gain</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>逻辑回归</title>
      <link>https://www.oomkill.com/2022/06/logistic-regression/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/06/logistic-regression/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="overview">Overview</h2>
<p>逻辑回归通常用于分类算法，例如预测某事是 <code>true</code> 还是 <code>false</code>（二元分类）。例如，对电子邮件进行分类，该算法将使用电子邮件中的单词作为特征，并据此预测电子邮件是否为垃圾邮件。用数学来讲就是指，假设因变量是 Y，而自变量集是 X，那么逻辑回归将预测因变量 $P(Y=1)$ 作为自变量集 X 的函数。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1UgYbimgPXf6XXxMy2yqRLw.png" alt="img"  /></p>
<p>逻辑回归性能在线性分类中是最好的，其核心为基于样本属于某个类别的概率。这里的概率必须是连续的并且在 <code>(0, 1)</code> 之间（有界）。它依赖于阈值函数来做出称为 <code>Sigmoid</code> 或 <code>Logistic</code> 函数决定的。</p>
<p>学好逻辑回归，需要了解逻辑回归的概念、优势比 (<strong>OR</strong>) 、Logit 函数、Sigmoid 函数、 Logistic 函数及交叉熵或Log Loss</p>
<h2 id="prerequisite">Prerequisite</h2>
<h3 id="odds-ratio">odds ratio</h3>
<h4 id="explain">explain</h4>
<p>odds ratio是预测变量的影响。优势比取决于预测变量是分类变量还是连续变量。</p>
<ul>
<li>连续预测变量：$OR &gt; 1$ 表示，随着预测变量的增加，事件发生的可能性增加。$OR &lt; 1$ 表示随着预测变量的增加，事件发生的可能性较小。</li>
<li>分类预测变量：事件发生在预测变量的 2 个不同级别的几率；如 A,B，$OR &gt; 1$ 表示事件在 A 级别的可能性更大。$OR&lt;1$ 表示事件更低的可能是在A。</li>
</ul>
<p>例如，假设 X 是受影响的概率，Y 是不受影响的概率，则 $OR= \frac{X}{Y}$ ，那么 $OR = \frac{P}{(1-P)}$ ，P是事件的概率。</p>
<p>让概率的范围为 <code>[0,1]</code>  ，假设 $P(success)=0.8$ ，$Q(failure) = 0.2$ ；$OR$ 则是 成功概率和失败概率的比值，如：$O(success)=\frac{P}{Q} = \frac{0.8}{0.2} = 4$ , $O(failure)=\frac{Q}{P} = \frac{0.2}{0.8} = 0.25$ 。</p>
<h4 id="odds和probability-的区别">odds和probability 的区别</h4>
<ul>
<li>
<p><strong>probability</strong> 表示在多次实验中，看到改事件的几率，位于 <code>[0,1]</code> 之间</p>
</li>
<li>
<p><strong>odds</strong> 表示 $\frac{(事件发生的概率)}{(事件不会发生的概率)}$ 的比率，位于 <code>[0,∞]</code></p>
</li>
</ul>
<p>例如赛马，一匹马跑 100 场比赛，赢了 80 场，那么获胜的概率是 $\frac{80}{100} = 0.80 = 80%$ ，获胜的几率是 $\frac{80}{20}=4:1$</p>
<p><strong>总结</strong>：probability 和 odds 之间的主要区别：</p>
<ul>
<li>“odds”用于描述是否有可能发生事件。相反，probability决定了事件发生的可能性，即事件发生的频率。</li>
<li>odds以比例表示，probability以百分比形式或小数表示。</li>
<li>odds通常从 <code>0 ~ ∞</code> ，其中0定义事件发生的可能性，<code>∞</code> 表示发生的可能性。相反，probability 介于 <code>0~1</code>之间。因此，probability越接近于0，不发生的可能性就越大，越接近于1，发生的可能性就越高。</li>
</ul>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://sphweb.bumc.bu.edu/otlt/mph-modules/bs/bs704_confidence_intervals/BS704_Confidence_Intervals10.html">The Difference Between &ldquo;Probability&rdquo; and &ldquo;Odds&rdquo;</a></p>
</blockquote>
<h4 id="通过示例陈述公式">通过示例陈述公式</h4>
<p>假设一个体校的录取率中，10 个男生中有 7 个被录取，而10 个女生中有3个被录取。找出男生被录取的概率？</p>
<p>那么通过已知条件，设 P 为录取概率，Q则为未被录取的概率，那么</p>
<ul>
<li>男生被录取的概率为：
<ul>
<li>$P=\frac{7}{10} = 0.7$</li>
<li>$Q=1-0.7 = 0.3$</li>
</ul>
</li>
<li>女生被录取的概率为：
<ul>
<li>$P=\frac{3}{10}=0.3$</li>
<li>$Q=1-0.3=0.7$</li>
</ul>
</li>
<li>录取优势比：
<ul>
<li>$OR(boy)=\frac{0.7}{0.3}=2.33$</li>
<li>$OR(Gril) = \frac{0.3}{0.7}=0.42$</li>
</ul>
</li>
</ul>
<p>因此，一个男生被录取的几率为 $OR=\frac{2.33}{0.42}=5.44$</p>
<h3 id="logit-函数">Logit 函数</h3>
<p>logit函数是<code>Odd Ratio</code> 的对数 <strong>logarithm</strong> , 给出 <code>0~1</code> 范围内的输入，然后将它们转换为整个实数范围内的值。如：假设P，则 $\frac{P}{(1-P)}$ 为对应的OR；OR 的 logit 的公式为：$loggit(P) = log(odds) = log(\frac{P}{1-P})$.</p>
<p>以一辆汽车是否出售为例，1为出售，0为不出售，则等式 $P_i=B_0+B_1 * (Price_i) + \epsilon$</p>
<p>$ln(\frac{P}{1-P}) = \beta_0 + \beta_1X_1+\beta_2X_2&hellip; + \beta_nX_N$ ,对于简单的逻辑回归，有两个系数：</p>
<ul>
<li>$\beta_0$  截距 ：X 变量为 0 时的对数 odds ratio</li>
<li>$\beta_1$  斜率：odds ratio随X增加（或减少），1的变化</li>
</ul>
<p>例如：假设简单逻辑回归模型是 $Ln(odds) = -5.5 + 1.2*X$ ,那么 $\beta_0=-5.5$ ，$\beta_1 = 1.2$ ，意味着，X=0时，$odds\ ratio = 0$ ，X每增加一个单位 odds ration 增加 1.2（（X 增加2个单位odds ratio增加 2.4&hellip;.）</p>
<p><strong>求解</strong></p>
<p>通过上面的公式实际上不明白这些具体是什么，就可以通过求P来找到<strong>有结果的概率</strong>与<strong>截距</strong> $β_0$ 之间的关系，已知 $n=log_ab$ , $ a^n=b$ ，那么一个简单的逻辑回归公式为 $log(\frac{P}{1-P}) = \beta_0+\beta1X$ ，对这个公式进行推导：</p>
<ul>
<li>$\frac{P}{1-P} = e^{\beta_0+e^\beta1*X}$</li>
<li>$P = e^{\beta_0+e^\beta1<em>X} - Pe^{\beta_0+e^\beta1</em>X}$</li>
<li>$P(1+e^{\beta_0+e^\beta1<em>X}) = e^{\beta_0+e^\beta1</em>X}$</li>
<li>$P=\frac{e^{\beta_0+e^\beta1<em>X}}{1+e^{\beta_0+e^\beta1</em>X}}$</li>
</ul>
<p>当 $X=0$ ,则 $\beta_1*X$ 没意义，公式为：$P = frac{e^{β_0}}{(1+e^{β_0})}$ ，其中e是一个常数，python为 <code>math.e</code></p>
<p>如果单纯不算概率，只看截距符号，那么满足：</p>
<ul>
<li>如果截距为<strong>负号</strong>：则产生结果的概率将 &lt; 0.5。</li>
<li>如果截距为<strong>正号</strong>：那么产生结果的概率将 &gt; 0.5。</li>
<li>如果截距<strong>等于 0</strong>：那么得到结果的概率正好是 0.5。</li>
</ul>
<p>通过例子来说明这点：假设研究为抽烟对心脏健康的影响，下表显示了一个逻辑回归</p>
<table>
<thead>
<tr>
<th></th>
<th>Coefficient</th>
<th>Standard Error</th>
<th>p-value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Intercept</td>
<td>-1.93</td>
<td>0.13</td>
<td>&lt; 0.001</td>
</tr>
<tr>
<td>Smoking</td>
<td>0.38</td>
<td>0.17</td>
<td>0.03</td>
</tr>
</tbody>
</table>
<p>由表可知，截距为 -1.93，假设smoking系数为0，那么概率带入公式为：$P=\frac{e^{\beta_0}}{1+e^{\beta_0}} = P=\frac{e^{-1.93}}{1+e^{-1.93}} = 0.126$<code>(math.e ** -1.93)/(1+math.e  ** -1.93)</code></p>
<p>如果 Smoking是一个连续变量（每年的吸烟量），在这种情况下，<code>Smoking=0</code>  意味着每年使用0公斤烟草的人即不抽烟的人群；那么这个结果就为，不抽烟的人群在未来10年内心脏有问题几率为 0.126。</p>
<p>再如果是吸烟者应该怎么计算，假设，每年吸烟量为3kg，那么公式为：$P = \frac{e^{β0 + β_1X}}{(1+e^{β0 + β_1X})}$ ，在这里 X=3，那么 $P=\frac{e^{\beta_1+\beta_2X}}{(1-e^{\beta_1+\beta_2X})} = \frac{e^{-1.93+0.38<em>3}}{(1-e^{-1.93+0.38</em>3})} = 0.31$ ；即得出，每年3KG烟草消耗量10年后有心脏问题的概率是 31%</p>
<blockquote>
<p><a href="https://quantifyinghealth.com/interpret-logistic-regression-intercept/">interpret</a></p>
</blockquote>
<h3 id="sigmoid">sigmoid</h3>
<p>logit 函数的逆函数称Sigmoid 函数，sigmoid方程来源于 logit 为：$P=\frac{e^{log(odds)}}{(1-e^{log(odds)})} = \frac{1}{e^{-log(odds)+1}} = \frac{1}{1+e^{-z}}$ 。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/220px-Kernel_Machine.svg.png" alt="具有线性支持向量机决策边界的散点图（虚线）"  /></p>
<p>在python中，<code>np.exp</code> 是求 是求 $e^{x}$ 的值的函数。正好可以用在sigmod函数中，那么sigmoid可以写为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="交叉熵或对数损失">交叉熵或对数损失</h3>
<p>交叉熵 <strong>Cross-Entropy</strong>，通常用于量化两个概率分布之间的差异。用于逻辑回归，公式为：$H=\sum^{x=n}(P(x) \times log(q(x))$</p>
<h3 id="maximum-likelihood-estimation">Maximum Likelihood Estimation</h3>
<p>最大似然估计，<code>Maximum Likelihood Estimation</code>  <strong>MLE</strong>，是概率估算的一种解决方案。MLE在其中寻找一组参数，这些参数将影响数据样本 <em>X</em>  的联合概率的最佳拟合。</p>
<p>首先，定义一个称为 $\theta$ <em>theta</em> 的参数，该参数定义概率密度函数的选择和该分布的参数。它可能是一个数值向量，其值平滑变化并映射到不同的概率分布及其参数。在最大似然估计中，我们希望在给定特定概率分布及其参数的最大化情况下从联合概率分布中观察数据的概率，形式上表示为：$P(X|\theta)$ ，在这种情况下，条件概率通常使用分号 <strong>;</strong> 而不是竖线 <strong>|</strong>  ，因为 $\theta$ 不是随机变量，而是未知参数。表达为 $P(X;\theta)$ ,或 $P(x_1,x_2,\ &hellip;\ x_n;\theta)$ 。</p>
<p>这样产生的条件概率被称为在给定模型参数 （$\theta$）的情况下观察变量 $X$ 的概率，并使用符号 <strong>L</strong> 来 表示似然函数。例如：$L(X;\theta)$。而<strong>最大似然估计</strong>的目标是找到使似然函数最大化的一组参数 ( $\theta$ )，例如产生最大似然值，如：$max(L(X;\theta))$</p>
<p>鉴于上述提到的变量 $X$ 是由n个样本组成，可以将其定义为在给定概率分布参数 $\theta$ 的情况下，变量 $X$ 的联合概率,如这里数据样本为 $x_1,x_2,\ &hellip;\ ,x_n$ 的联合概率，同时表示为 $L(x_1,x2,\ &hellip;\ ,x_n;\theta)$</p>
<p>大多数情况下，求解似然方程很复杂。会使用对数似然作为一种解决方案。由于对数函数是单调递增的，因此对数似然和似然中的最优参数是相同的。因此定义条件最大似然估计为：$log(P(x_i ; h))$。</p>
<p>用逻辑回归模型替换<em>h</em>，需要假设一个概率分布。在逻辑回归的情况下，假设数据样本为二项式概率分布，其中每个示例都是二项式的一个结果。伯努利分布只有一个参数：成功结果的概率 P，那么为：</p>
<ul>
<li>$P(y=1)=P$</li>
<li>$P(y=0)=1-P$</li>
</ul>
<p>那么这个平均值为：$P(y=1)*1+P(y=0)<em>0$，给出P的值公式可以转换为：$P</em>1+(1-p)*0$；这种公式看似没有意义，那么通过一个小例子来了解下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 二项式似然函数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">likelihood</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">p</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># test for y=1</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.9</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y=</span><span class="si">%.1f</span><span class="s1">, p=</span><span class="si">%.1f</span><span class="s1">, likelihood: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span><span class="p">,</span> <span class="n">yhat</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y=</span><span class="si">%.1f</span><span class="s1">, p=</span><span class="si">%.1f</span><span class="s1">, likelihood: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># test for y=0</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span><span class="p">,</span> <span class="n">yhat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y=</span><span class="si">%.1f</span><span class="s1">, p=</span><span class="si">%.1f</span><span class="s1">, likelihood: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span><span class="p">,</span> <span class="n">yhat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.9</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;y=</span><span class="si">%.1f</span><span class="s1">, p=</span><span class="si">%.1f</span><span class="s1">, likelihood: </span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">likelihood</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># y=1.0, p=0.9, likelihood: 0.900</span>
</span></span><span class="line"><span class="cl"><span class="c1"># y=1.0, p=0.9, likelihood: 0.900</span>
</span></span><span class="line"><span class="cl"><span class="c1"># y=0.0, p=0.9, likelihood: 0.100</span>
</span></span><span class="line"><span class="cl"><span class="c1"># y=0.0, p=0.9, likelihood: 0.100</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行示例会为每个案例打印类别y 和预测概率p，其中每个案例的概率是否接近；这里也可以使用对数更新似然函数，$log(p) * y + log(1 – p) * (1 – y)$；最后可以根据数据集中实例求最大似然和最小似然</p>
<ul>
<li>$\sum^{i=1}_n log(p_i) * y_i + log(1 – p_i) * (1 – y_i)$</li>
<li>最小似然使用反转函数，使负对数自然作为最小似然。上面的公式前加 <code>-</code></li>
</ul>
<p>对于计算二项式分布的对数似然相当于计算二项式分布[交叉熵，其中<code>P(class)</code>表示第 class 项概率，<code>q()</code> 表示概率分布，$-(log(q(class0)) \times P(class0) + log(q(class1)) * P(class1))$</p>
<h2 id="lr算法实例">LR算法实例</h2>
<p>在研究如何从数据中估计模型的参数之前，我们需要了解逻辑回归准确计算的内容。</p>
<p>模型的线性部分（输入的加权和）计算成功事件的log-odds。</p>
<p>odds ratio：$\beta_0+\beta_1 \times x_1 + \beta_2 \times x_2\ &hellip;\ \beta_n \times x_n$ 该模型估计了每个级别的输入变量的log-odds。</p>
<p>由上面信息了解到，几率 <code>probability</code> 是输赢的比率 如 <code>1:10</code> ；<code>probability</code> 可以转换为 <code>odds ratio</code> 即成功概率除以不成功概率：$or=\frac{P}{1-P}$ ；计算or的对数，被称为log-odds是一种度量单位：$log(\frac{P}{1-P})$，而所求的即为 log-odds的逆函数，而在python中 <code>log</code> 函数是对数，求log的逆方法即 <code>exp</code> 返回n的x次方就是log的逆函数。</p>
<p>到这里已经和逻辑回归模型很接近了，对数函数公式可以简化为，$P=\frac{e^{log(odds)}}{(1-e^{log(odds)})}$ ，以上阐述了如何从log-odds转化为odds，然后在到逻辑回归模型。下面通过Python 中的示例来具体计算 <code>probability</code> 、<code>odds</code> 和 <code>log-odds</code> 之间的转换。假设将成功概率定义为 80% 或 0.8，然后将其转换为odds，然后再次转换为概率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">prob</span> <span class="o">=</span> <span class="mf">0.8</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probability </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">prob</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将 probability 转换为 odds</span>
</span></span><span class="line"><span class="cl"><span class="n">odds</span> <span class="o">=</span> <span class="n">prob</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prob</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Odds </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">odds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 将 odds 转换为 log-odds</span>
</span></span><span class="line"><span class="cl"><span class="n">logodds</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">odds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Log-Odds </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">logodds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 转换 log-odds 为  probability</span>
</span></span><span class="line"><span class="cl"><span class="n">prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">logodds</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Probability </span><span class="si">%.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">prob</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Probability 0.8</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Odds 4.0</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Log-Odds 1.4</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Probability 0.8</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过这个例子，可以看到odds被转换成大约 1.4 的log-odds，然后正确地转回 0.8 的成功概率。</p>
<h2 id="逻辑回归实现">逻辑回归实现</h2>
<p>首先将实现分为3个步骤：</p>
<ul>
<li>预测</li>
<li>评估系数</li>
<li>真实数据集预测</li>
</ul>
<h3 id="预测">预测</h3>
<p>编写一个预测函数，在评估随机梯度下降中的候选系数值时以及在模型最终确定测试数据或新数据进行预测时。</p>
<p>下面是预测**predict()**函数，它预测给定一组系数的行的输出值。第一个系数是截距，也称为偏差或 b0，它是独立的，不负责输入值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">p</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">yhat</span> <span class="o">+=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>准备一些测试数据，Y代表真实的类别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">X1</span>					<span class="n">X2</span>						<span class="n">Y</span>
</span></span><span class="line"><span class="cl"><span class="mf">2.7810836</span> 	<span class="mf">2.550537003</span>		<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.465489372</span>	<span class="mf">2.362125076</span>		<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.396561688</span>	<span class="mf">4.400293529</span>		<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">1.38807019</span>	<span class="mf">1.850220317</span>		<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">3.06407232</span>	<span class="mf">3.005305973</span>		<span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="mf">7.627531214</span>	<span class="mf">2.759262235</span>		<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">5.332441248</span>	<span class="mf">2.088626775</span>		<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">6.922596716</span>	<span class="mf">1.77106367</span>		<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">8.675418651</span>	<span class="o">-</span><span class="mf">0.242068655</span>	<span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="mf">7.673756466</span>	<span class="mf">3.508563011</span>		<span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里有两个输入值，和三个系数，系数是自定义的固定值，那么预测的公式就为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 系数为</span>
</span></span><span class="line"><span class="cl"><span class="n">coef</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.406605464</span><span class="p">,</span> <span class="mf">0.852573316</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.104746259</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">b0</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">X1</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">X2</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 套入公式（sigma）</span>
</span></span><span class="line"><span class="cl"><span class="n">y</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">e</span><span class="o">^</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="o">-</span><span class="mf">0.406605464</span> <span class="o">+</span> <span class="mf">0.852573316</span> <span class="o">*</span> <span class="n">X1</span> <span class="o">+</span> <span class="o">-</span><span class="mf">1.104746259</span> <span class="o">*</span> <span class="n">X2</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Make a prediction</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Make a prediction with coefficients</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">yhat</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">yhat</span> <span class="o">+=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">yhat</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># test predictions</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">2.7810836</span><span class="p">,</span><span class="mf">2.550537003</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.465489372</span><span class="p">,</span><span class="mf">2.362125076</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.396561688</span><span class="p">,</span><span class="mf">4.400293529</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.38807019</span><span class="p">,</span><span class="mf">1.850220317</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.06407232</span><span class="p">,</span><span class="mf">3.005305973</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.627531214</span><span class="p">,</span><span class="mf">2.759262235</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.332441248</span><span class="p">,</span><span class="mf">2.088626775</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">6.922596716</span><span class="p">,</span><span class="mf">1.77106367</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">8.675418651</span><span class="p">,</span><span class="o">-</span><span class="mf">0.242068655</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.673756466</span><span class="p">,</span><span class="mf">3.508563011</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">coef</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.406605464</span><span class="p">,</span> <span class="mf">0.852573316</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.104746259</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="n">yhat</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Expected=</span><span class="si">%.3f</span><span class="s2">, Predicted=</span><span class="si">%.3f</span><span class="s2"> [</span><span class="si">%d</span><span class="s2">]&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yhat</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">yhat</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="估计系数">估计系数</h3>
<p>这里可以使用我随机梯度下降来估计训练数据的系数值。随机梯度下降需要两个参数：</p>
<ul>
<li><strong>学习率</strong> Learning rate：用于限制每个系数每次更新时的修正量。</li>
<li><strong>Epochs</strong>：更新系数时遍历训练数据的次数。</li>
</ul>
<p>在每个epoch更新训练数据中每一行的每个系数。系数会根据模型产生的错误进行更新，误差为预期输出与预测值之间的差异。错误会随着epoch增加而减少</p>
<p>将每个都加权，并且这些系数以一致的方式进行更新，用公式可以表示为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">b1</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">b1</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">learning_rate</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">*</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="o">*</span> <span class="n">x1</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么整合一起为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 预测函数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">+=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">p</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">coefficients_sgd</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">coef</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="c1"># 初始一个系数，第一次为都为0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epoch</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_error</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 错误为预期值与实际值直接差异</span>
</span></span><span class="line"><span class="cl">            <span class="n">error</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum_error</span> <span class="o">+=</span> <span class="n">error</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 截距没有输入变量x，这里为row[0]</span>
</span></span><span class="line"><span class="cl">            <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">l_rate</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 其他系数更新</span>
</span></span><span class="line"><span class="cl">                <span class="n">coef</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">l_rate</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&gt;epoch=</span><span class="si">%d</span><span class="s1">, lrate=</span><span class="si">%.3f</span><span class="s1">, error=</span><span class="si">%.3f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">sum_error</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">coef</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Calculate coefficients</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">2.7810836</span><span class="p">,</span><span class="mf">2.550537003</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">1.465489372</span><span class="p">,</span><span class="mf">2.362125076</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.396561688</span><span class="p">,</span><span class="mf">4.400293529</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">1.38807019</span><span class="p">,</span><span class="mf">1.850220317</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.06407232</span><span class="p">,</span><span class="mf">3.005305973</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.627531214</span><span class="p">,</span><span class="mf">2.759262235</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">5.332441248</span><span class="p">,</span><span class="mf">2.088626775</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">6.922596716</span><span class="p">,</span><span class="mf">1.77106367</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">8.675418651</span><span class="p">,</span><span class="o">-</span><span class="mf">0.242068655</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.673756466</span><span class="p">,</span><span class="mf">3.508563011</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">l_rate</span> <span class="o">=</span> <span class="mf">0.3</span>
</span></span><span class="line"><span class="cl"><span class="n">n_epoch</span> <span class="o">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">coef</span> <span class="o">=</span> <span class="n">coefficients_sgd</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">coef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=92, lrate=0.300, error=0.024</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=93, lrate=0.300, error=0.024</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=94, lrate=0.300, error=0.024</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=95, lrate=0.300, error=0.023</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=96, lrate=0.300, error=0.023</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=97, lrate=0.300, error=0.023</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=98, lrate=0.300, error=0.023</span>
</span></span><span class="line"><span class="cl"><span class="c1"># &gt;epoch=99, lrate=0.300, error=0.022</span>
</span></span><span class="line"><span class="cl"><span class="c1">#[-0.8596443546618897, 1.5223825112460005, -2.218700210565016]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里跟踪了跟踪每个epoch误差平方的总和，以便我们可以在每个epoch中打印出error，实例中使用 0.3 学习率并训练100 个 epoch，每个epoch会打印出其误差平方，最终会打印总系数集</p>
<h3 id="套用真实数据集">套用真实数据集</h3>
<p><a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/pima-indians-diabetes.csv">糖尿病数据集</a> 是根据基本的医疗信息，预测印第安人5年内患糖尿病的情况。这是一个二元分类，阴性0与阳性1直接的关系。采用了二项式分布，也可以采用其他分布，如高斯等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Load a CSV file</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">csv_reader</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># Convert string column to float</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 找到最小和最大的</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">dataset_minmax</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">minmax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span></span><span class="line"><span class="cl">		<span class="n">col_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">value_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">col_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">value_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">col_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">minmax</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">value_min</span><span class="p">,</span> <span class="n">value_max</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">minmax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 归一化</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">normalize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">minmax</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">			<span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">minmax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">minmax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minmax</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="c1"># k-folds CV实现</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">fold_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fold_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_copy</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataset_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset_split</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算准确度百分比</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">actual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">			<span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用CV评估算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">folds</span> <span class="o">=</span> <span class="n">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">train_set</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="p">[])</span>
</span></span><span class="line"><span class="cl">		<span class="n">test_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">row_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">test_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">row_copy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
</span></span><span class="line"><span class="cl">		<span class="n">predicted</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">scores</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用系数进行预测</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">yhat</span> <span class="o">=</span> <span class="n">coefficients</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">yhat</span> <span class="o">+=</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">yhat</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 系数生成</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">coefficients_sgd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    生成系数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param train: list, 数据集，可以是训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param l_rate: float, 学习率
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param n_epoch:int，epoch，这里代表进行多少次迭代
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">coef</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span> <span class="c1"># 初始一个系数，第一次为都为0</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_epoch</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">sum_error</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 错误为预期值与实际值直接差异</span>
</span></span><span class="line"><span class="cl">            <span class="n">error</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span>
</span></span><span class="line"><span class="cl">            <span class="n">sum_error</span> <span class="o">+=</span> <span class="n">error</span><span class="o">**</span><span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 截距没有输入变量x，这里为row[0]</span>
</span></span><span class="line"><span class="cl">            <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">l_rate</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># 其他系数更新</span>
</span></span><span class="line"><span class="cl">                <span class="n">coef</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coef</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">l_rate</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># print(&#39;&gt;epoch=%d, lrate=%.3f, error=%.3f&#39; % (epoch, l_rate, sum_error))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">coef</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 随机梯度下降的逻辑回归算法</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">logistic_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">coef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefficients_sgd</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">coef</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">p</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 数据预处理</span>
</span></span><span class="line"><span class="cl"><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;pima-indians-diabetes.csv&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
</span></span><span class="line"><span class="cl">	<span class="n">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 做归一化</span>
</span></span><span class="line"><span class="cl"><span class="n">minmax</span> <span class="o">=</span> <span class="n">dataset_minmax</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">normalize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">minmax</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># evaluate algorithm</span>
</span></span><span class="line"><span class="cl"><span class="n">n_folds</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="n">l_rate</span> <span class="o">=</span> <span class="mf">0.1</span>
</span></span><span class="line"><span class="cl"><span class="n">n_epoch</span> <span class="o">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl"><span class="n">scores</span> <span class="o">=</span> <span class="n">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">logistic_regression</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="n">l_rate</span><span class="p">,</span> <span class="n">n_epoch</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scores: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">%.3f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 0.35294117647058826</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Scores: [73.8562091503268, 78.43137254901961, 81.69934640522875, 75.81699346405229, 75.81699346405229]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># Mean Accuracy: 77.124%</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述是对整个数据集的预测百分比，也可以对对应的类的信息进行输出</p>
<h2 id="reference-1">Reference</h2>
<blockquote>
<p><a href="https://towardsdatascience.com/probability-concepts-explained-maximum-likelihood-estimation-c7b4342fdbb1">Maximum likelihood estimation</a></p>
<p><a href="https://vitalflux.com/logistic-regression-sigmoid-function-python-code/">Sigmoid Function</a></p>
<p><a href="https://christophm.github.io/interpretable-ml-book/logistic.html">logistic</a></p>
<p><a href="https://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html#binary-logistic-regression">binary logistic regression</a></p>
<p><a href="https://machinelearningmastery.com/?s=Logistic+Regression&amp;post_type=post&amp;submit=Search">LR implementation</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>朴素贝叶斯算法</title>
      <link>https://www.oomkill.com/2022/06/naive-bayes/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/06/naive-bayes/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是naive-bayes">什么是naive bayes</h2>
<p>朴素贝叶斯 <code>naive bayes</code>，是一种概率类的机器学习算法，主要用于解决分类问题</p>
<p><strong>为什么被称为朴素贝叶斯？</strong></p>
<p>为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值</p>
<h2 id="贝叶斯定理">贝叶斯定理</h2>
<p>了解朴素贝叶斯之前，需要掌握一些概念才可继续</p>
<ul>
<li><strong>条件概率</strong> <code>Conditional probability</code>：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率</li>
<li><strong>联合概率</strong> <code>Joint Probability</code>：计算两个或多个事件同时发生的可能性</li>
<li><strong>边界概率</strong> <code>Marginal Probability</code>：事件发生的概率，与另一个变量的结果无关</li>
<li><strong>比例</strong> <code>Proportionality</code></li>
<li><strong>贝叶斯定理</strong> <code>Bayes' Theorem</code>：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率</li>
</ul>
<h3 id="边界概率">边界概率</h3>
<p>边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；</p>
<h3 id="联合概率">联合概率</h3>
<p>联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \cap B)$</p>
<p><strong>A</strong> 和 <strong>B</strong> 是两个不同的事件相同相交，$P(A \and B)$   $P(A,B)$ = <strong>A</strong> 和 <strong>B</strong> 的联合概率</p>
<p>概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。</p>
<p>如，从一副牌中抽到一张红牌的概率是 $\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。</p>
<p>而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\cap red) = \frac{2}{52} = \frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而<strong>6</strong>和<strong>红色</strong>是两个独立的概率，那么计算公式就为：$P(6 \cap red) = P(6) \times P(red) = \frac{4}{52} \times \frac{26}{52} = \frac{1}{26}$</p>
<p>在联合概率中 $ \cap $ 称为交集，是事件 <strong>A</strong> 与 事件 <strong>B</strong> 发生的概率的相交点，通过图来表示为：两个圆的相交点，即6和红色牌共同的部分</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220501235937229.png" alt="image-20220501235937229"  /></p>
<h3 id="条件概率">条件概率</h3>
<p>条件概率是指事件发生的可能性，基于先有事件的结果的发生乘后续事件概率来计算的，例如，申请大学的通过率为80%，宿舍仅提供给60%学生使用，那么这个人被大学录取并提供宿舍的概率是多少？</p>
<p>$P(accept\ and\ get\ dorm) = P(Accept|Dorm) = P(Accept) \times P(Dorm) = 0.8 \times 0.6 = 0.48$</p>
<p>条件概率将会考虑两个事件之间的关系，例如你被大学录取的概率， 以及为你提供宿舍的概率；<strong>条件概率中的关键点</strong>：</p>
<ul>
<li>另一个事件发生的情况下，这件事发生的几率</li>
<li>表示为，给定 <strong>B</strong> 的概率 <strong>A</strong> 发生的概率，用公式表示为：$P(A|B)$，其中 <strong>A</strong> 取决于 <strong>B</strong> 发生的概率</li>
</ul>
<h4 id="通过例子了解条件概率">通过例子了解条件概率</h4>
<p>上述大致上了解到了：<strong>条件概率取决于先前的结果</strong>，那么通过几个例子来熟悉条件概率</p>
<p><strong>例1</strong>：袋子里有红色，蓝色，绿色三颗玻璃球，每种被拿到的概率相等，那么摸到蓝色之后再摸到红色的条件概率是多少？</p>
<ul>
<li>这里需要先得到摸到蓝色的概率：$P(Blue) = \frac{1}{3}$ 因为只有三种可能性</li>
<li>现在还剩下两颗玻璃球 红色和蓝色，那么摸到红色的概率为：$P(Red) = \frac{1}{2}$ 因为只有两种可能性</li>
<li>那么已经摸到蓝色在摸到红色的概率为 $P(Red|Blue) = \frac{1}{3} \times \frac{1}{2} = \frac{1}{6}$</li>
</ul>
<p><strong>例2</strong>：色子摇出5的概率为 $\frac{1}{6}$ 那么在结果是奇数里摇出5 那么可能就是 $\frac{1}{3}$，而这个<strong>奇数</strong>就是另外的一个条件，因为只有3个奇数，其中一个是5，那么在奇数中，抛出5的概率就是 $\frac{1}{3}$。</p>
<p>通过上述信息可知，<strong>B</strong> 作为附带条件修饰 <strong>A</strong> 发生的概率，称为给定 <strong>B</strong> ，<strong>A</strong> 发生的条件，用$P(A|B)$ 表示。那么可以的出：</p>
<ul>
<li>给定A，B发生的概率为，A和B的发生概率排除掉A的概率，即</li>
<li>$P(B|A) = \frac{P(A \cap B)}{P(A)} $</li>
</ul>
<h4 id="联合概率和条件概率的区别">联合概率和条件概率的区别</h4>
<p><strong>条件概率</strong>是一个事件在另一个事件发生的情况下的概率：$P(X\ given\ Y)$  公式为： $P(X∣Y)$；即一个事件发生的概率取决于另一事件的发生；如：从一副牌中，假设你抽到一张红牌，那么抽到6的概率是 $\frac{1}{13}$；因为26张红牌中仅有两张为6，用公式表示：$P(6|red) = \frac{2}{26}$</p>
<p><strong>联合概率</strong>仅考虑两个事件发生的可能性，对比与条件概率可用于计算联合概率：$P(X \cap Y) = P(X|Y) \times P(Y)$</p>
<p>通过合并上述例子得到，同时抽到6和红色的概率为：$\frac{1}{26}$</p>
<h3 id="贝叶斯定理-1">贝叶斯定理</h3>
<p>贝叶斯定理是确定条件概率的数学公式。贝叶斯定理依赖于先验概率分布以计算后验概率。</p>
<h4 id="后验概率和先验概率">后验概率和先验概率</h4>
<ul>
<li>先验概率 <code>prior probability</code>：在收集新数据之前发送事件的概率</li>
<li>后验概率 <code>posterior probability</code>：得到新的数据来修正之前事件发生的概率；换句话说是<strong>后验概率是在事件 B 已经发生的情况下，事件 A 发生的概率</strong>。</li>
</ul>
<p>例，从一副52 张牌中抽取一张牌，那么这张牌是K的概率是 $\frac{4}{52}$ , 因为一副牌中有4张K；假设抽中的牌是一张人物牌，那么抽到是K的概率则是 $\frac{4}{12}$；因为一副牌中有12张人物牌。那么贝叶斯定理的公式为：</p>
<ul>
<li>$P(A|B) = \frac{P(A \cap B)}{P(B)}$，$P(B|A) = \frac{P(B \cap A)}{P(A)}$
<ul>
<li>$P(A \cap B)$，$P(B \cap A)$ A和B同时发生和B和A同时发生时相等的</li>
<li>$P(B \cap A) = P(B|A) \times P(A)$</li>
<li>$P(A \cap B) = P(A|B) \times P(B)$</li>
</ul>
</li>
<li>那么根据上面的公式，已知 $P(A \cap B) = P(B \cap A)$ 可推导出公式：
<ul>
<li>因为 $P(B \cap A) = P(A \cap B)$ ，那么 $P(B|A) \times P(A) = P(A|B) \times P(B)$</li>
<li>那么吧 $P(A)$ 放置等式右边即 $P(B|A) = \frac{P(A|B) \times P(B)}{P(A)}$</li>
</ul>
</li>
<li>那么最终  <code>Formula for Bayes</code> 为  $P(B|A) = \frac{P(A|B) \times P(B)}{P(A)}$</li>
</ul>
<p>其中：</p>
<ul>
<li>
<p>$P(A)$：<strong>A</strong> 的边界概率</p>
</li>
<li>
<p>$P(B)$：<strong>B</strong> 的边界概率</p>
</li>
<li>
<p>$P(A|B)$ ：条件概率，已知 <strong>B</strong>，<strong>A</strong> 的概率</p>
</li>
<li>
<p>$P(B|A)$ ：条件概率，已知 <strong>A</strong>，<strong>B</strong> 的概率</p>
</li>
<li>
<p>$P(B \cap A)$：联合概率 <strong>B</strong> 与 <strong>A</strong> 同时发生的概率</p>
</li>
</ul>
<p>一个简单的概率问题可能会问：茅台股价下跌的概率是多少？条件概率通过询问这个问题更进一步：鉴于A股平均指数下跌，茅台股价下跌的概率是多少？ 给定 B 已经发生的条件下 A 的概率可以表示为：</p>
<p>$P(Mao|AS) = \frac{P(Mao \cap AS)}{P(AS)}$</p>
<p>$P(Mao \cap AS)$ 是 A 和 B 同时发生的概率，与 A 发生的情况下 B 也发生的概率 乘 A 发生的概率相等表示为： $P(Mao) \times P(AS|Mao)$；这两个表达式相等，也就是贝叶斯定理，可以表示为：</p>
<ul>
<li>如果， $P(Mao \cap AS) = P(Mao) \times P(AS|Mao)$</li>
<li>那么， $P(Mao|AS) = \frac{P(Mao) \times P(AS|Mao)}{P(AS)}$</li>
</ul>
<p>$P(Mao)$ 和 $P(AS)$ 分别为茅台和A股的下跌概率，彼此间没有关系</p>
<p>一般情况下，都是以 <strong>x</strong> （输入） <strong>y</strong> （输出） 在函数中，假设 $x=AS$ , $y=MAO$ 那么替代到公式中就 $P(Y|X) = \frac{P(X|Y) \times P(Y)}{P(X)}$</p>
<h2 id="朴素贝叶斯算法">朴素贝叶斯算法</h2>
<p>朴素贝叶斯不是一个的算法，而是一组算法，所有这些算法都基于一个共同的原则，即每一对被分类的特征必须相互独立。朴素贝叶斯是一个基本的贝叶斯称呼，包含三种算法的集合：多项式 <code>Multinomial</code>、 伯努利 <code>Bernoulli</code>、高斯 <code>Gaussian</code>。</p>
<h3 id="伯努利">伯努利</h3>
<p>伯努利朴素贝叶斯，又叫做二项式，只接受二进制值，简而言之，在伯努利中必须计算每个值的二进制出现特征，即一个单词是与否出现在文档中。</p>
<p>通俗地来说，伯努利有两个互斥的结果：$$NB=\begin{cases}
P(X=1)\ = \ q\
P(X=0)\ = \ 1-q\
\end{cases}
$$ ，在伯努利中，可以有多个特征，但每个特征都假设为是二进制的变量，因此，需要将样本表示为二进制向量。</p>
<p>那么扩展出的公式为：$P(A|B) = \frac{P(B|A) \times P(A)}{P(A) \times P(B|A) + P(not A) \times P(B|not A)}$</p>
<p><strong>例子</strong>：假设COVID-19测试并不准确，有**95%**几率在感染时测试出阳性（敏感性），这就意味着如果有人并未感染的概率是相同的（特异性）；问：如果Jeovanna检测为阳性，那么他感染COVID-19的概率是多少？</p>
<blockquote>
<p>敏感性和特异性是医学用语；敏感性，病人测出阳性的比例，特异性，非病人测试阴性的比例</p>
</blockquote>
<p>一般情况下没有更多的信息来确定Jeovanna是否感染，如驻留场所，是否发烧，丧失味觉等。就需要更多的信息来计算Jeovanna感染率，比如预估Jeovanna感染率为1%，这1%就是先验概率。</p>
<p>此时有100000人的测试样本，预计1000人感染（先验1%），那么就是99000为感染，又因为测试具有 95% 的敏感性和 95% 的特异性，这代表了 1000的95% 和 99000的5% 是阳性。整理一个表格</p>
<table>
<thead>
<tr>
<th></th>
<th>Has COVID-19</th>
<th>Do not Has COVID-19</th>
<th>count</th>
</tr>
</thead>
<tbody>
<tr>
<td>阳性</td>
<td>950</td>
<td>4950</td>
<td>5900</td>
</tr>
<tr>
<td>阴性</td>
<td>50</td>
<td>94050</td>
<td>94100</td>
</tr>
</tbody>
</table>
<p>那么可以看出，阳性的人并感染COVID-19的概率是，$\frac{950}{5900} = 16%$ ；那么也就是Jeovanna有16%几率是感染 COVID-19。</p>
<p>此时将先验概率设置为16%，那么爱丽丝得COVID-19的可能性为：</p>
<blockquote>
<p>$P(B|A)$ ：在95%成功率情况下又获得了阳性</p>
<p>$P(A)$：阳性的检测成功率</p>
<p>已知，$P(B|A) = 0.16$ ，$P(A) = 0.95$</p>
<p>$P(A|B) = \frac{P(B|A) \times P(A)}{P(A) \times P(B|A) + P(not A) \times P(B|not A)}  = \frac{0.16\times0.95}{0.95\times 0.16 + (1-0.95)\times(1-0.16)}= \frac{0.152}{0.194} = 0.7835 = 78.35%$</p>
</blockquote>
<p>那么就可以得知，在阳性情况下感染COVID-19的情况下，再去检测会有78%几率阳性</p>
<h3 id="多项式">多项式</h3>
<p>多项式朴素贝叶斯是基于多项分布的朴素叶贝斯，用来处理文本，计算 $d$ 在 $c$ 中的概率计算如下：</p>
<p>$P(c|d) \ \propto P(c) \prod_{i=1}^n\ P(t_k|c)$</p>
<p>通俗来说就是二项式的一个变种，是计算多个不同的实例</p>
<p>$P(t_k|c)$ 是 $t_k$ 的 条件概率，发生在数据集 $c$ 中，$P(t_k|c)$ 解释为 $t_k$ 有多少证据表明 $c$ 是正确的；$P(c)$ 是先验条件 $t1..\ t2..\ t3..\ tn_d$ 中的标记 $d$，它们是我们用于分类的词汇表的一部分，$n_d$ 是 标记 $d$ 的数量。</p>
<p>例如：&ldquo;Peking and Taipei join the WTO&rdquo;，$&lt;Peking,\ Taipei,\ join,\ WTO&gt;$ ,那么 $n_d = 4$</p>
<p>那么可以简化为，</p>
<p>$P(c=x|d=c_k) = P(c^1=x^1..,\ c^2=x^2..,\ c^n=x^n|d=c_k) = \prod_{i=1}^n(c^i|d)x^i + (1-P(c^i|d))	(1-x^i)$</p>
<p>$\prod_{i=1}^n$ 连乘积，即从下标起乘到上标</p>
<h2 id="朴素贝叶斯实现">朴素贝叶斯实现</h2>
<p>首先将朴素贝叶斯为 5 个部分：</p>
<ul>
<li>分类</li>
<li>数据集汇总</li>
<li>按类别汇总数据</li>
<li>高斯密度函数</li>
<li>分类概率</li>
</ul>
<h3 id="分类">分类</h3>
<p>根据数据所属的类别来计算数据的概率，即所谓的基本率。</p>
<p>先创建一个字典对象，其中每个键都是类值，然后添加所有记录的列表作为字典中的值。</p>
<p>假设每行中的最后一列是类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 按类拆分数据集，返回结构是一个词典</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="n">vector</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">class_value</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># dataset最后一行是类别</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">class_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">separated</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>准备一些数据集</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">X1				X2						Class
</span></span><span class="line"><span class="cl">3.393533211		2.331273381				0
</span></span><span class="line"><span class="cl">3.110073483		1.781539638				0
</span></span><span class="line"><span class="cl">7.423436942		4.696522875				1
</span></span><span class="line"><span class="cl">1.343808831		3.368360954				0
</span></span><span class="line"><span class="cl">3.582294042		4.67917911				0
</span></span><span class="line"><span class="cl">9.172168622		2.511101045				1
</span></span><span class="line"><span class="cl">7.792783481		3.424088941				1
</span></span><span class="line"><span class="cl">2.280362439		2.866990263				0
</span></span><span class="line"><span class="cl">5.745051997		3.533989803				1
</span></span><span class="line"><span class="cl">7.939820817		0.791637231				1
</span></span></code></pre></td></tr></table>
</div>
</div><p>测试分类函数的功能</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="n">vector</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">class_value</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">class_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">separated</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.393533211</span><span class="p">,</span><span class="mf">2.331273381</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.110073483</span><span class="p">,</span><span class="mf">1.781539638</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.343808831</span><span class="p">,</span><span class="mf">3.368360954</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">7.423436942</span><span class="p">,</span><span class="mf">4.696522875</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.582294042</span><span class="p">,</span><span class="mf">4.67917911</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">9.172168622</span><span class="p">,</span><span class="mf">2.511101045</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.792783481</span><span class="p">,</span><span class="mf">3.424088941</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">2.280362439</span><span class="p">,</span><span class="mf">2.866990263</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.745051997</span><span class="p">,</span><span class="mf">3.533989803</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.939820817</span><span class="p">,</span><span class="mf">0.791637231</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到分类是成功的</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220503215102264.png" alt="image-20220503215102264"  /></p>
<h3 id="数据集汇总">数据集汇总</h3>
<p>现在需要对给出数据集的两个数据进行统计，如何对指定数据集做概率计算？需要以下几步</p>
<p>计算数据集两个数据的平均值和标准差</p>
<p>平均值为： $\frac{sum(x)}{n} \times count(x)$ ；其中 $x$ 为正在查找值的列表</p>
<p>mean函数用于计算平均值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>样本标准差的计算方式为平均值的平均差。公式可以为 <code> sqrt((sum i to N (x_i – mean(x))^2) / N-1)</code></p>
<p>函数用来计算</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Calculate the standard deviation of a list of numbers</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 平均值</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>还需要对每个数据的每一列计算平均值和标准偏差统计量。通过将每列的所有值收集到一个列表中并计算该列表的平均值和标准差。计算完成后，将统计信息收集到数据汇总的列表或元组中。然后，对数据集中的每一列重复此操作并返回统计元组列表。</p>
<p>下面是 数据汇总的函数 <code>summarise_dataset()</code>用来统计每列列表的平均值和标准差</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算平均数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span> <span class="c1"># 标准差</span>
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 计算平均值</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 计算所有的平方</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 数据汇总</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">summaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mean</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">stdev</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="k">del</span><span class="p">(</span><span class="n">summaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 因为分类不需要所以。删除掉分类哪行</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Test summarizing a dataset</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.393533211</span><span class="p">,</span><span class="mf">2.331273381</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.110073483</span><span class="p">,</span><span class="mf">1.781539638</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.343808831</span><span class="p">,</span><span class="mf">3.368360954</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.582294042</span><span class="p">,</span><span class="mf">4.67917911</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">2.280362439</span><span class="p">,</span><span class="mf">2.866990263</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.423436942</span><span class="p">,</span><span class="mf">4.696522875</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.745051997</span><span class="p">,</span><span class="mf">3.533989803</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">9.172168622</span><span class="p">,</span><span class="mf">2.511101045</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.792783481</span><span class="p">,</span><span class="mf">3.424088941</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.939820817</span><span class="p">,</span><span class="mf">0.791637231</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">summary</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">summary</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里使用的是<code>zip()</code> 函数，将每列作为提供的参数。使用 * 作为位置函数，运将数据集传递给 <code>zip()</code> ，这个运算会将每一行的分割为单独列表。然后<code>zip()</code> 遍历每一行的每个元素，返回一列作为数字列表。</p>
<p>然后计算每列中的平均数、标准差和行数。删掉不需要的列（第三列类别列的平均数，标准差和行数）</p>
<p>可以看到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[
</span></span><span class="line"><span class="cl">(5.178333386499999, 2.7665845055177263, 10), 
</span></span><span class="line"><span class="cl">(2.9984683241, 1.218556343617447, 10)
</span></span><span class="line"><span class="cl">]
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="根据类别汇总数据">根据类别汇总数据</h3>
<p><code>separate_by_class()</code> 是将数据分成行，现在要编写一个 <code>summarise_dataset()</code>；是先计算每列的统计汇总信息，然后在按照子集分类（X1，X2）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 按类拆分数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">separated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是完整的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算平均数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span> <span class="c1"># 标准差</span>
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="c1"># 计算平均值</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 计算所有的平方</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 数据汇总</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">summaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mean</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">stdev</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">    <span class="k">del</span><span class="p">(</span><span class="n">summaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># 因为分类不需要所以。删除掉分类哪行</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 按类进行数据汇总</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">separated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.393533211</span><span class="p">,</span><span class="mf">2.331273381</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.110073483</span><span class="p">,</span><span class="mf">1.781539638</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.343808831</span><span class="p">,</span><span class="mf">3.368360954</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.582294042</span><span class="p">,</span><span class="mf">4.67917911</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">2.280362439</span><span class="p">,</span><span class="mf">2.866990263</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.423436942</span><span class="p">,</span><span class="mf">4.696522875</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.745051997</span><span class="p">,</span><span class="mf">3.533989803</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">9.172168622</span><span class="p">,</span><span class="mf">2.511101045</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.792783481</span><span class="p">,</span><span class="mf">3.424088941</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.939820817</span><span class="p">,</span><span class="mf">0.791637231</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">summary</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">summary</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">summary</span><span class="p">[</span><span class="n">label</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照分类，对每列计算平均值和标准差</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220504174107364.png" alt="image-20220504174107364"  /></p>
<h3 id="高斯分布函数">高斯分布函数</h3>
<p>高斯分布 <code>Gaussian distribution</code> 可以用两个数字来概括，高斯分布是具有对称的钟形的分布，所以中心右侧是左侧的镜像，曲线下的面积代表概率，曲线总面积之和等于1。</p>
<p>高斯分布中的大多数连续数据值倾向于围绕均值聚集，值离均值越远，那么它发生的可能性就越小。接近但从未完全贴合x 轴。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/bell-curve.jpg" alt=""  /></p>
<p>高斯分布由均值和标准差两个参数决定的，任何点 (x) 都可以通过公式 $z = \frac{x-mean}{standard\ deviation}$ 来计算</p>
<blockquote>
<p>Reference</p>
<p><a href="https://www.simplypsychology.org/normal-distribution.html">normal distribution</a></p>
</blockquote>
<p>通过这一点，就可以知道就可以计算出给定的概率，公式为：</p>
<p>$P({x_i}|Y) = \frac{1}{\sqrt2\pi\sigma_y^2}exp(-(\frac{(x_i-\mu_y)^2}{2\sigma_y^2})$</p>
<p>其中，$\sigma$ 为标准差，$\mu$ 为平均值，那么转换为可读懂的公式为：</p>
<p>$f(x) = \frac{1}{\sqrt{(2 \times pi )}\times sigma} \times exp(-(\frac{(x-mean)^2}{(2 \times sigma)^2}))$</p>
<p>其中，<code>sigma</code>是  <code>x</code> 的标准差，<code>mean</code>  是 <code>x</code> 的平均值，PI是 就是 $\pi$ <code>math.pi</code> 的值。</p>
<p>那么在转换成python中的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">PI</span><span class="p">)</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">^</span><span class="mi">2</span><span class="p">)))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么用python实现一个函数，来实现高斯公式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">calculate_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">exponent</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stdev</span><span class="o">**</span><span class="mi">2</span> <span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev</span><span class="p">))</span> <span class="o">*</span> <span class="n">exponent</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里通过函数测试三个数据，<code>(0,1,1)</code>， <code>(1,1,1)</code>，<code>(2,1,1)</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">calculate_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">exponent</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stdev</span><span class="o">**</span><span class="mi">2</span> <span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev</span><span class="p">))</span> <span class="o">*</span> <span class="n">exponent</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">calculate_probability</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">calculate_probability</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">calculate_probability</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220504220553349.png" alt="image-20220504220553349"  /></p>
<p>这里可以看到结果，<code>(1,1,1)</code> 的概率最可能（三个值中趋于钟形顶部）</p>
<h3 id="分类概率">分类概率</h3>
<p>到这里，可以尝试通过测试数据来统计新数据的概率，这里每个类别的概率都是单独计算的，这里将简化概率计算公式 $P(class|data) = P(data|class) \times P(class)$；这是一个常见的简化，这将意味着将结果为最大值的类的计算作为预测结果。因为通常对预测感兴趣，而不是概率</p>
<p>对于上述例子，有两个变量，这里以 <code>class=0</code> 的类别来说明，公式为：</p>
<p>$P(class=0|X1,X2) = P(X1|class=0) \times P(X2|class=0) \times P(class=0)$</p>
<p>编写一个聚合函数，将上述四个步骤汇总处理，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Example of calculating class probabilities</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 拆分数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">separated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">class_value</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">class_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">separated</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">separated</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算平均数</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span> 
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>  <span class="c1"># 计算平均值</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 标准差</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 数据汇总</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mean</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">stdev</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="k">del</span><span class="p">(</span><span class="n">summaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 按类进行数据汇总</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">separated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">calculate_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">exponent</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stdev</span><span class="o">**</span><span class="mi">2</span> <span class="p">)))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev</span><span class="p">))</span> <span class="o">*</span> <span class="n">exponent</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算每个分类的概率</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算所有分类的个数</span>
</span></span><span class="line"><span class="cl">    <span class="n">total_rows</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">summaries</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">summaries</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">probabilities</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">class_summaries</span> <span class="ow">in</span> <span class="n">summaries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class="line"><span class="cl">        <span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">total_rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_summaries</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">            <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">class_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">*=</span> <span class="n">calculate_probability</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">probabilities</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 测试数据集</span>
</span></span><span class="line"><span class="cl"><span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mf">3.393533211</span><span class="p">,</span><span class="mf">2.331273381</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.110073483</span><span class="p">,</span><span class="mf">1.781539638</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">1.343808831</span><span class="p">,</span><span class="mf">3.368360954</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">3.582294042</span><span class="p">,</span><span class="mf">4.67917911</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">2.280362439</span><span class="p">,</span><span class="mf">2.866990263</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.423436942</span><span class="p">,</span><span class="mf">4.696522875</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">5.745051997</span><span class="p">,</span><span class="mf">3.533989803</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">9.172168622</span><span class="p">,</span><span class="mf">2.511101045</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.792783481</span><span class="p">,</span><span class="mf">3.424088941</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">	<span class="p">[</span><span class="mf">7.939820817</span><span class="p">,</span><span class="mf">0.791637231</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl"><span class="n">summaries</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">probabilities</span> <span class="o">=</span> <span class="n">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220505233319199.png" alt="image-20220505233319199"  /></p>
<p>由结果可以得知，<code>dataset[0]</code> <strong>X1</strong> 的概率（0.0503）要大于 <strong>X2</strong> 的概率（0.0001），所以可以正确的判断出 <code>dataset[0]</code> 属于 <strong>X1</strong> 分类</p>
<h2 id="鸢尾花iris分类">鸢尾花(Iris)分类</h2>
<p>鸢尾花分类，是模式识别中非常出名的一种数据库，需要先将数据下载：</p>
<ul>
<li>
<p><a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.names">关于Iris-databases数据集的说明</a></p>
</li>
<li>
<p><a href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv">iris dataset</a></p>
</li>
</ul>
<h3 id="实现开始">实现开始</h3>
<p>实验是根据上述实验的步骤，将朴素贝叶斯算法应用在鸢尾花数据集中，鸢尾花数据集的实验也是需要相同的步骤，只不过对于数据集中的数据还需要一些其他的步骤，大致可分为以下几种操作：</p>
<ul>
<li>数据的预处理
<ul>
<li>从文件中读取数据</li>
<li>将数据类型转换为可用于上面实验的类型（<code>float</code>）</li>
<li>将真实分类转换为数字 <code>int</code></li>
</ul>
</li>
<li>分类</li>
<li>数据集汇总</li>
<li>按类别汇总数据</li>
<li>高斯密度函数</li>
<li>分类概率</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 读取数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">csv_reader</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将每行的数字转换为float</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将真实分类转换为数字，按照下标</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">    :param dataset: list, 数据集
</span></span></span><span class="line"><span class="cl"><span class="s1">    :param column: string，是为类型的列要传入
</span></span></span><span class="line"><span class="cl"><span class="s1">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 通过循环拿到所有分类</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 对分类型去重</span>
</span></span><span class="line"><span class="cl">    <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 拿到分类值的key 下标</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 已对应的下标进行替换</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lookup</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将数据的一部分作为训练数据</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">fold_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fold_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_copy</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataset_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset_split</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算准确度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">actual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">			<span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 对算法数据进行评估</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param dataset:list, 原始数据集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param algorithm:function，算法函数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param n_folds:int，取多少数据作为训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param args:options ，参数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">folds</span> <span class="o">=</span> <span class="n">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 合并成一个数组</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="p">[])</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">test_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">test_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># 将最后一个类型字段设置为None</span>
</span></span><span class="line"><span class="cl">        <span class="n">predicted</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 真实的类型</span>
</span></span><span class="line"><span class="cl">        <span class="n">actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 精确的分数，即这一组数据正确率</span>
</span></span><span class="line"><span class="cl">        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">scores</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 按照分类拆分</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="n">vector</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="n">class_value</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">class_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">			<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">separated</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算这一系列的平均值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算一系列数字的标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算数据集中每列的平均值 标准差 长度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mean</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">stdev</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="k">del</span><span class="p">(</span><span class="n">summaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 按照分类划分数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">separated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算x的高斯概率</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">calculate_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param x:float, 计算这个值的高斯概率
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param mean:float，x的平均值
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param stdev:float，x的标准差
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">exponent</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stdev</span><span class="o">**</span><span class="mi">2</span> <span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev</span><span class="p">))</span> <span class="o">*</span> <span class="n">exponent</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算每行的概率</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算所有分类的个数</span>
</span></span><span class="line"><span class="cl">	<span class="n">total_rows</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">summaries</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">summaries</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="n">probabilities</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">class_summaries</span> <span class="ow">in</span> <span class="n">summaries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 公式中的P(class)</span>
</span></span><span class="line"><span class="cl">		<span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">total_rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 通过公式  P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_summaries</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">			<span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">class_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">*=</span> <span class="n">calculate_probability</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">probabilities</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">probabilities</span> <span class="o">=</span> <span class="n">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">best_label</span><span class="p">,</span> <span class="n">best_prob</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">probability</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">best_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">probability</span> <span class="o">&gt;</span> <span class="n">best_prob</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">best_prob</span> <span class="o">=</span> <span class="n">probability</span>
</span></span><span class="line"><span class="cl">			<span class="n">best_label</span> <span class="o">=</span> <span class="n">class_value</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">best_label</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Naive Bayes Algorithm</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">naive_bayes</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 训练数据按照类分类排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">summarize</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">summarize</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 测试</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;iris.csv&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dataset</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 转换数值为float</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将类型转换为数字</span>
</span></span><span class="line"><span class="cl">    <span class="n">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 将数据分位测试数据和训练数据，folds为多少数据为训练数据</span>
</span></span><span class="line"><span class="cl">    <span class="n">n_folds</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">    <span class="n">scores</span> <span class="o">=</span> <span class="n">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">naive_bayes</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scores: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean Accuracy: </span><span class="si">%.3f%%</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scores</span><span class="p">))))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220506190801092.png" alt="image-20220506190801092"  /></p>
<p>可以看到运行结果，对鸢尾花数据集的预测正确率，平均为95.333%</p>
<p>现在对 <code>main</code> 部分进行修改，使用全部数据集作为训练，新增记录作为预测</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 按照整个数据集分类</span>
</span></span><span class="line"><span class="cl"><span class="n">model</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 新加一行预测数据</span>
</span></span><span class="line"><span class="cl"><span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.3</span><span class="p">,</span><span class="mf">3.9</span><span class="p">,</span><span class="mf">3.2</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 根据训练集进行对数据预测</span>
</span></span><span class="line"><span class="cl"><span class="n">label</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data=</span><span class="si">%s</span><span class="s1">, Predicted: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整修改过的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">seed</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randrange</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">exp</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 读取数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="n">csv_reader</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="ow">not</span> <span class="n">row</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">continue</span>
</span></span><span class="line"><span class="cl">			<span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将每行的数字转换为float</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将真实分类转换为数字，按照下标</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">    :param dataset: list, 数据集
</span></span></span><span class="line"><span class="cl"><span class="s1">    :param column: string，是为类型的列要传入
</span></span></span><span class="line"><span class="cl"><span class="s1">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s1">    &#39;&#39;&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 通过循环拿到所有分类</span>
</span></span><span class="line"><span class="cl">    <span class="n">class_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 对分类型去重</span>
</span></span><span class="line"><span class="cl">    <span class="n">unique</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">class_values</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">lookup</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 拿到分类值的key 下标</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">lookup</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 增加一行，来显示下标和真实名称对应的数据</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">lookup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 已对应的下标进行替换</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="p">]]</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">lookup</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 将数据的一部分作为训练数据</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_split</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="n">dataset_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">fold_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_folds</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">		<span class="n">fold</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">fold_size</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">index</span> <span class="o">=</span> <span class="n">randrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset_copy</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="n">fold</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset_copy</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="n">dataset_split</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">dataset_split</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算准确度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">correct</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">actual</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">			<span class="n">correct</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">actual</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 对算法数据进行评估</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">evaluate_algorithm</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">algorithm</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param dataset:list, 原始数据集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param algorithm:function，算法函数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param n_folds:int，取多少数据作为训练集
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param args:options ，参数
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">folds</span> <span class="o">=</span> <span class="n">cross_validation_split</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">n_folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">scores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">folds</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fold</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 合并成一个数组</span>
</span></span><span class="line"><span class="cl">        <span class="n">train_set</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="p">[])</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">test_set</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">test_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_copy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">row_copy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># 将最后一个类型字段设置为None</span>
</span></span><span class="line"><span class="cl">        <span class="n">predicted</span> <span class="o">=</span> <span class="n">algorithm</span><span class="p">(</span><span class="n">train_set</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 真实的类型</span>
</span></span><span class="line"><span class="cl">        <span class="n">actual</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fold</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 精确的分数，即这一组数据正确率</span>
</span></span><span class="line"><span class="cl">        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">accuracy_metric</span><span class="p">(</span><span class="n">actual</span><span class="p">,</span> <span class="n">predicted</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">scores</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 按照分类拆分</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param dataset:list, 按分类好的列表
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: dict, 每个分类的每列（属性）的平均值，标准差，个数
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">separated</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">vector</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">class_value</span> <span class="o">=</span> <span class="n">vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">class_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">separated</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="n">separated</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">separated</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算这一系列的平均值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算一系列数字的标准差</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">stdev</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">avg</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">variance</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([(</span><span class="n">x</span><span class="o">-</span><span class="n">avg</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">])</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算数据集中每列的平均值 标准差 长度</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">summaries</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mean</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="n">stdev</span><span class="p">(</span><span class="n">column</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">dataset</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">	<span class="k">del</span><span class="p">(</span><span class="n">summaries</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 按照分类划分数据集</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">separated</span> <span class="o">=</span> <span class="n">separate_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">summaries</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">rows</span> <span class="ow">in</span> <span class="n">separated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summarize_dataset</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">summaries</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算x的高斯概率</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">calculate_probability</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param x:float, 计算这个值的高斯概率
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param mean:float，x的平均值
</span></span></span><span class="line"><span class="cl"><span class="s2">    :param stdev:float，x的标准差
</span></span></span><span class="line"><span class="cl"><span class="s2">    :return: None
</span></span></span><span class="line"><span class="cl"><span class="s2">    &#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="n">exponent</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">stdev</span><span class="o">**</span><span class="mi">2</span> <span class="p">)))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">stdev</span><span class="p">))</span> <span class="o">*</span> <span class="n">exponent</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 计算每行的概率</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 计算所有分类的个数</span>
</span></span><span class="line"><span class="cl">    <span class="n">total_rows</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">summaries</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">summaries</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="n">probabilities</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">class_summaries</span> <span class="ow">in</span> <span class="n">summaries</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 公式中的P(class)</span>
</span></span><span class="line"><span class="cl">        <span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">summaries</span><span class="p">[</span><span class="n">class_value</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">total_rows</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># 通过公式  P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_summaries</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">            <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">class_summaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">probabilities</span><span class="p">[</span><span class="n">class_value</span><span class="p">]</span> <span class="o">*=</span> <span class="n">calculate_probability</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mean</span><span class="p">,</span> <span class="n">stdev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">probabilities</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	<span class="n">probabilities</span> <span class="o">=</span> <span class="n">converge_probabilities</span><span class="p">(</span><span class="n">summaries</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">best_label</span><span class="p">,</span> <span class="n">best_prob</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="n">class_value</span><span class="p">,</span> <span class="n">probability</span> <span class="ow">in</span> <span class="n">probabilities</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">best_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">probability</span> <span class="o">&gt;</span> <span class="n">best_prob</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="n">best_prob</span> <span class="o">=</span> <span class="n">probability</span>
</span></span><span class="line"><span class="cl">			<span class="n">best_label</span> <span class="o">=</span> <span class="n">class_value</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">best_label</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># Naive Bayes Algorithm</span>
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">naive_bayes</span><span class="p">(</span><span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 训练数据按照类分类排序</span>
</span></span><span class="line"><span class="cl">    <span class="n">summarize</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">train</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">predictions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">output</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">summarize</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="c1"># 测试</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;iris.csv&#39;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dataset</span> <span class="o">=</span> <span class="n">load_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 转换数值为float</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">str_column_to_float</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 将类型转换为数字</span>
</span></span><span class="line"><span class="cl">    <span class="n">str_column_to_int</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># 按照整个数据集分类</span>
</span></span><span class="line"><span class="cl">    <span class="n">model</span> <span class="o">=</span> <span class="n">summarize_by_class</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 新加一行预测数据</span>
</span></span><span class="line"><span class="cl">    <span class="n">row</span> <span class="o">=</span> <span class="p">[</span><span class="mf">5.3</span><span class="p">,</span><span class="mf">3.9</span><span class="p">,</span><span class="mf">3.2</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 根据训练集进行对数据预测</span>
</span></span><span class="line"><span class="cl">    <span class="n">label</span> <span class="o">=</span> <span class="n">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Data=</span><span class="si">%s</span><span class="s1">, Predicted: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220506193631974.png" alt="image-20220506193631974"  /></p>
<p>可以看到对数据集 <code>[5.3,3.9,3.2,2.3]</code> 预测为 <code>versicolor</code>，那将属性修改为，<code>[2.3,0.9,0.2,1.3]</code> 预测结果为 <code>setosa</code></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220506193805325.png" alt="image-20220506193805325"  /></p>
<blockquote>
<p>Reference</p>
<p><a href="https://iq.opengenus.org/gaussian-naive-bayes/">gaussian naive bayes</a></p>
<p><a href="https://www.varsity.co.uk/science/21149">Naive Bayes Example</a></p>
<p><a href="https://www.omnicalculator.com/statistics/bayes-theorem">caculator naive bayes</a></p>
<p><a href="https://towardsdatascience.com/a-mathematical-explanation-of-naive-bayes-in-5-minutes-44adebcdb5f8">五分钟了解朴素贝叶斯</a></p>
<p><a href="https://www.investopedia.com/terms/j/jointprobability.asp">Joint Probability</a></p>
<p><a href="https://www.investopedia.com/terms/c/conditional_probability.asp">Conditional Probability</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>ch3 操作内存管理 - 连续内存分配</title>
      <link>https://www.oomkill.com/2022/04/ch3-contiguous-memory-allocation/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/04/ch3-contiguous-memory-allocation/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="一-计算机体系结构及内存分层体系">一 计算机体系结构及内存分层体系</h2>
<p>1.计算机硬件体系结构大致分为</p>
<ul>
<li>CPU，完成程序的执行控制</li>
<li>主存 （<code>main memory</code>），放置程序代码和数据</li>
<li>I/O（外）设备，配合程序工作。

  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425192206925.png" alt="image-20220425192206925"  /></li>
<li>2.内存分层体系（金字塔结构)</li>
</ul>
<p>什么是内存结构：CPU所访问的指令和数据在什么地方。</p>
<p>第一类：位于CPU内部，操作操作系统无法直接进行管理的，寄存器，cache；特点，速度快，容量小</p>
<p>第二类：主存或物理内存，主要用来放置操作系统本身及要运行的代码；其特点是，容量比cache要大很多，单速度交于cache要慢一些。</p>
<p>第三类：磁盘，永久保存的数据及代码，当对于主存要慢，容量比主存大很多。</p>
<p>操作系统的作用可以将数据访问的速度（cache与内存）与存储的大小（硬盘）很好的融合在一起</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425192237300.png" alt="image-20220425192237300"  />
3.OS管理内存时需要完成的目标</p>
<p>① 抽象：逻辑地址空间（将物理内存，外设等抽象成逻辑地址空间，只需要访问对应地址空间)</p>
<p>② 保护（独立）：操作系统完成隔离机制实现，独立地址空间（每段程序执行时，不受其他程序的影响）</p>
<p>③ 共享：进程间安全，可靠，有效，进行数据传递，访问相同的内存。</p>
<p>④ 虚拟化：更多的地址空间（利用磁盘的空间)

  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425192251895.png" alt="image-20220425192251895"  /></p>
<p>4.需要完成在操作系统中管理内存的不同方法</p>
<ul>
<li>
<p>操作系统层面</p>
</li>
<li>
<p>程序重定位</p>
</li>
<li>
<p>分段</p>
</li>
<li>
<p>分页</p>
</li>
<li>
<p>虚拟内存</p>
</li>
<li>
<p>按需分页虚拟内存</p>
</li>
<li>
<p>硬件层面</p>
<ul>
<li>必须知道内存架构</li>
<li>MMU(内存管理单元)：处理CPU的内存访问请求</li>
</ul>
</li>
</ul>
<h2 id="二-地址空间地址生成">二 地址空间&amp;地址生成</h2>
<ul>
<li>
<p>地址空间的定义</p>
</li>
<li>
<p>地址生成器</p>
</li>
<li>
<p>地址安全检查</p>
<h3 id="1内存地址的定义">1.内存地址的定义</h3>
</li>
</ul>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425192335531.png" alt="image-20220425192335531"  /></p>
<p>① 物理内存地址：硬件支持的地址空间，如主存（内存）和硬盘，由硬件完成管理和控制
② 逻辑内存地址：一个程序运行时所需要的内存范围。</p>
<hr>
<p>两者间的关系：逻辑地址空间最终是一个存在的物理地址空间，两者间的映射关系是由操作系统来管理的</p>
<hr>
<h3 id="2逻辑地址生成过程把代码转化为计算机能理解语言">2.逻辑地址生成过程（把代码转化为计算机能理解语言）</h3>
<p>一段代码运行→编译→汇编语言→机器语言→产生链接文件→将硬盘中程序载入到内存当中运行（完成逻辑地址的分配）</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425192353658.png" alt="image-20220425192353658"  /></p>
<p>如C中变量的名字，函数的位置，为逻辑地址。</p>
<h3 id="3物理地址生成逻辑地址对应的物理地址的过程">3.物理地址生成（逻辑地址对应的物理地址的过程）</h3>
<ul>
<li>
<p>CPU方面 MMU表示映射关系</p>
<ul>
<li>① CPU ALU <code>Arithmetic logic unit</code> 发出请求，为逻辑地址</li>
<li>② CPU MMU <code>Memory management unit</code> 查找逻辑地址映射表，不存在会去内存中找</li>
<li>③ 控制器提出内存请求（需要的内容，内容即指令）</li>
</ul>
</li>
<li>
<p>内存方面</p>
<ul>
<li>④ 内存通过bus发送物理内存地址的内容给CPU</li>
</ul>
</li>
<li>
<p>OS方面
建立逻辑地址和物理地址之间的映射关系（需在前四部前将映射管理建立好）</p>
</li>
</ul>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425194557713.png" alt="image-20220425194557713"  /></p>
<h3 id="4-内存安全监测检查运行的内存是否在对应内存空间范围内">4. 内存安全监测：检查运行的内存是否在对应内存空间范围内</h3>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20220425194611872.png" alt="image-20220425194611872"  /></p>
<p>操作系统确保程序的有效访问的地址空间，==起始地址==与==长度==（基址寄存器和界限寄存器），也是操作系统所建立和维护的对应的表。</p>
<h2 id="三连续式内存分配内存碎片与分区的动态分配">三、连续式内存分配：内存碎片与分区的动态分配</h2>
<ul>
<li>内存碎片问题</li>
<li>分区动态分配
<ul>
<li>第一适配</li>
<li>最佳适配</li>
<li>最差适配</li>
</ul>
</li>
<li>压缩式碎片整理</li>
<li>交换式碎片整理</li>
</ul>
<h2 id="1内存碎片问题">1.内存碎片问题</h2>
<p><em>什么是碎片？</em> 为程序分配空间后有一些无法被利用的空闲空间，这就是内存碎片。</p>
<p><em>碎片的种类：</em></p>
<ul>
<li>外部碎片：在分配单元间未使用的内存（没分配给程序的那块）</li>
<li>内部碎片：在分配单元中未使用的内存（分配给程序之后，程序无法使用）</li>
</ul>
<p></p>
<h3 id="2分区的动态分配">2.分区的动态分配</h3>
<p>操作系统为了管理空闲与非空闲空间，有对应的内存分配算法：</p>
<ul>
<li>首次适配 <code>First-Fit</code></li>
<li>最优适配 <code>Worst Fit</code></li>
<li>最佳适配 <code>Best Fit</code></li>
</ul>
<table>
<thead>
<tr>
<th>sort</th>
<th>First-Fit</th>
<th>Worst Fit</th>
<th>Best Fit</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>overview</strong></td>
<td>空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按    照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。</td>
<td>最坏适应算法与最佳适应算法的排序正好相反，它的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲    区开始查寻；<code>Worst fit</code> 会按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲区中分配</td>
<td>寻找整个空间中最适合的的空间块（比分配请求的大小要大，但其差值是最小的）</td>
</tr>
<tr>
<td></td>
<td></td>
<td><img src="../Library/Application%20Support/typora-user-images/image-20211216182201177.png" alt="image-20211216182201177" style="zoom: 50%;" /></td>
<td></td>
</tr>
<tr>
<td><strong>benefit</strong></td>
<td>该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲     区。显然为以后到达的大作业分配大的内存空间创造了条件。</td>
<td>给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利</td>
<td>每次分配给文件的都是最合适该文件大小的分区，避免吧大空间块拆散</td>
</tr>
<tr>
<td><strong>defect</strong></td>
<td>不确定性<br/>   容易产生外碎片，（低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。)</td>
<td>重新分配慢<br>产生很多外部碎片<br>易于破坏大的空闲块以致大分区无法被分配</td>
<td><strong>缺点</strong>：内存中留下许多难以利用的小的空闲区。</td>
</tr>
<tr>
<td><strong>require</strong></td>
<td>按地址排序<br/>   分配需要找到合适的分区<br/>   重新分配需要检查，看是否自由分区能合并于相邻的空间分区。<br/></td>
<td>按尺寸排列的空闲块列表<br>分配很快（获得最大的分区）<br>重新分配需要合并相邻的空闲分区，然后调整空闲块列表</td>
<td>需要按尺寸排列好空闲块列表<br/>分配需要寻找适合的分区<br/>重新分配（空闲块利用)需要搜索及合并相邻的空闲分区</td>
</tr>
</tbody>
</table>
<h2 id="四连续式内存分配-contiguous-memory-allocation压缩式与交换式碎片化整理">四、连续式内存分配 (contiguous memory allocation)：压缩式与交换式碎片化整理</h2>
<p>无论采用那种算法，都会产生内碎片<code>internal fragmentation</code> 和外碎片 <code>External fragmentation </code> ，所以需要对这些碎片进行处理使得碎片减少甚至消失。</p>
<ul>
<li>紧致算法 <code>compaction</code>：能够调整内存中运行的程序的位置
<ul>
<li>什么时候做（重定位）</li>
<li>开销</li>
<li>      </li>
</ul>
</li>
<li>换入换出 <code>swapping</code>：<code>swapping mechanism</code>，是进程可以临时从主存中交换（或移动）到辅存储（磁盘），并使该内存可供其他进程使用。稍后，系统将进程从辅存交换回主存。
<ul>
<li></li>
</ul>
</li>
</ul>
<blockquote>
<p>English Version: <a href="https://www.geeksforgeeks.org/memory-management-in-operating-system/">https://www.geeksforgeeks.org/memory-management-in-operating-system/</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
