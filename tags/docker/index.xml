<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>docker on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/docker/</link>
    <description>Recent content in docker on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 01 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用docker管理谷歌物件仓库gcr上的镜像</title>
      <link>https://www.oomkill.com/2024/06/docker-push-gcr/</link>
      <pubDate>Sat, 01 Jun 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/06/docker-push-gcr/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="创建服务账户">创建服务账户</h2>
<p>首先可以到「 IAM管理 -&gt; 服务帐户」新增帐户。在新增完成后，会得到一把 key，将它下载后请妥善保管，因为所有相关的身份认证都会用到，这个 key 在下载后就无法继续下载了。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240602000041487.png" alt="image-20240602000041487" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="授权">授权</h2>
<p>接着到「IAM -&gt; 新增」成员，并且选择角色，这里选择「Cloud Storage -&gt; 储存空间物件检视者」，让此帐户具备有 read（读取） storage 的功能。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/cylonchau/imgbed/img/image-20240602000120347.png" alt="image-20240602000120347" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="登录">登录</h2>
<pre><code class="language-bash">cat KEY-FILE | docker login -u KEY-TYPE --password-stdin \
	https://LOCATION-docker.pkg.dev
</code></pre>
<p>GCP 的 KEY-TYPE 通为 <code>json_key</code>，但这里包含两种类型 <code>_json_key</code> 和 <code>_json_key_base64</code></p>
<p>KEY-FILE 就是下载的 Service account key 的文件</p>
<pre><code class="language-bash">cat KEY-FILE | docker login -u _json_key --password-stdin \
	https://LOCATION-docker.pkg.dev
</code></pre>
<p>通常 Service account key 文件内容如下</p>
<pre><code class="language-yaml">{
  &quot;type&quot;: &quot;service_account&quot;,
  &quot;project_id&quot;: &quot;project2024-0101&quot;,
  &quot;private_key_id&quot;: &quot;bdfsd612779509406bb8452c3ek12d730ed547e722d&quot;,
  &quot;private_key&quot;: &quot;-----BEGIN PRIVATE KEY----....-----END PRIVATE KEY-----\n&quot;,
  &quot;client_email&quot;: &quot;gcr@project2024-0101.iam.gserviceaccount.com&quot;,
  &quot;client_id&quot;: &quot;206651723512339084907274&quot;,
  &quot;auth_uri&quot;: &quot;https://accounts.google.com/o/oauth2/auth&quot;,
  &quot;token_uri&quot;: &quot;https://oauth2.googleapis.com/token&quot;,
  &quot;auth_provider_x509_cert_url&quot;: &quot;https://www.googleapis.com/oauth2/v1/certs&quot;,
  &quot;client_x509_cert_url&quot;: &quot;https://www.googleapis.com/robot/v1/metadata/x509/manager-image%40project2024-0101.iam.gserviceaccount.com&quot;,
  &quot;universe_domain&quot;: &quot;googleapis.com&quot;
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker中的多进程管理 s6-overlay</title>
      <link>https://www.oomkill.com/2023/05/multi-process-management/</link>
      <pubDate>Thu, 18 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/05/multi-process-management/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是容器中的多进程管理">什么是容器中的多进程管理</h2>
<p>在容器中的主进程 (<em><strong>main running process</strong></em>) 是指 Dockerfile中 <code>ENTRYPOINT</code> 或 <code>CMD</code> 指定运行的命令，通常情况下一个进程（服务）为一个容器；也存在一种场景，就是主进程会fork多个子进程，例如nginx，不过这种多进程通常为nginx主进程进行管理。而一些场景下，我们的业务本身就需要多个启用独立的多个进程。</p>
<p>在Docker官方提到了在容器中运行多个服务的方式，官方提出，应该避免这种情况</p>
<blockquote>
<p>but to get the most benefit out of Docker, avoid one container being responsible for multiple aspects of your overall application.</p>
</blockquote>
<p>但也给出了如何管理多进程的一种思路，</p>
<ul>
<li>Use a wrapper script</li>
<li>Use Bash job controls</li>
<li>Use a process manager</li>
</ul>
<p>下面就通过官方给出的这三种方式阐述容器中的多进程管理</p>
<h2 id="use-a-wrapper-script">Use a wrapper script</h2>
<p>对于使用脚本来管理多进程来说，本质上是可以实现多进程的启动，但是你没法去监控(管理)多个进程的运行时，例如 Nginx + PHP 模式， PHP或nginx全部挂掉，只要脚本还在运行，那么这个容器的生命周期还是处于Running</p>
<h2 id="use-bash-job-controls">Use Bash job controls</h2>
<p>这种模式是利用了Bash的后台模式进行短暂的切换进程，但有些镜像不提供Bash这时应该怎么办</p>
<h2 id="use-a-process-manager">Use a process manager</h2>
<p>进程管理器，通常情况下大家想到的就是顶顶大名的 supervisor 和 systemd，但这两个程序运行的环境十分苛刻，例如 supervisor 是Python开发的程序，运行需要依赖 Python；而 systemd 的运行条件更为苛刻，例如需要额外运行dbus-damon进行注册到dbus总线之上，这种进程管理器可能运行的进程比我们要管理的进程都要多。在这种场景下，有一个部署简单，配置简单，无依赖的轻量级容器多进程管理器 <a href="https://github.com/just-containers/s6-overlay" target="_blank"
   rel="noopener nofollow noreferrer" >s6-overlay</a></p>
<h2 id="s6-overlay">s6-overlay</h2>
<p>s6-overlay 一组脚本，只需要简单解压就可以使现有的 Docker 镜像通过将 s6 用作容器的 pid 1 和服务的来管理多个进程。</p>
<p>s6-overlay 包含两个组件，<code>s6-overlay-noarch.tar.xz</code> 与 <code>s6-overlay-x86_64.tar.xz</code></p>
<ul>
<li>noarch 包含了一些脚本，是s6运行的所必须有的一个组件，他包含了 /init 作为 pid 为1 的进程</li>
<li>x86 是作为 x86系统下运行 s6 所需要的 所有二进制文件</li>
</ul>
<h2 id="编写服务启动脚本">编写服务启动脚本</h2>
<p>需要在 /etc/s6-overlay/s6-rc.d/ 与 /etc/services.d/ 中配置你要启动的app，例如</p>
<pre><code class="language-bash">/etc/services.d/nginx/run
</code></pre>
<p>run则代表启动的命令</p>
<pre><code class="language-bash">#!/command/execlineb -P
nginx -g &quot;daemon off;&quot;
</code></pre>
<p>除上述提到的内容外，还需一个 type 来指明 启动的模式</p>
<ul>
<li><em><strong>longrun</strong></em> 运行为daemon模式被s6进行管理</li>
<li><em><strong>oneshot</strong></em> 类似一个脚本，但通过s6-rc进行管理，类似于初始化任务</li>
</ul>
<p>所以你需要在 <code>/etc/s6-overlay/s6-rc.d/myapp/type</code> 中定义其 <code>type</code> 文件，这个文件内填写这两种类型的文字即可</p>
<p>到这里完成了一个基本的进程的配置，例如还有 <code>finish</code> 脚本，当在失败时执行的</p>
<h2 id="s6-init-的阶段">S6 init 的阶段</h2>
<p>s6官方对init阶段省略了用户不需要关心的一个阶段后，为 3 个阶段</p>
<ul>
<li>初始化阶段 (<em>initialization</em>)，这里是内核启动的第一个用户态进程，该阶段作为init唯一的持久进程</li>
<li>巡航阶段 (<em>cruising</em>)，这个阶段init负责启动与维护其他进程，比如运行s6系列，init 的职责是清除孤儿进程并监督进程，同时允许管理员添加或删除服务，例如上面的 <code>longrun</code> 与 <code>oneshot</code> 类的服务，都是在这个阶段被启动</li>
<li>关闭阶段 (<em>shutdown</em>)，在此阶段结束时，所有进程都将被终止
<ul>
<li>发送 TERM 信号 到遗留的 <code>longrun</code> 服务，如果需要将等待结束后退出</li>
<li>有序的关闭用户 s6-rc</li>
<li>运行 finalization 脚本</li>
<li>向进程发送 <code>TERM</code> signal，最终不会留下任何的进程</li>
<li>sleep一阵，允许驻留的进程退出完</li>
<li>发送 KILL 信号，退出所有进程，这时容器退出</li>
</ul>
</li>
</ul>
<h2 id="s6的安装">S6的安装</h2>
<p>S6的安装很简单，步骤只需要如下几步：</p>
<ul>
<li>只需要下载对应的两个tar包</li>
<li>将 <code>init</code> 作为pid为1的进程</li>
<li>准备 installiation阶段 和 finalization 阶段的脚本 复制到对应路径内就可以正常启动了</li>
</ul>
<blockquote>
<p>finalization 通常使用场景为：当你的程序在退出时存在一些特定的结束命令的场景，官方给出的通常是用于进程结束后的清理动作</p>
</blockquote>
<blockquote>
<p>Note that in general, finish scripts should only be used for local cleanups after a daemon dies. If a service is so important that the container needs to stop when it dies, we really recommend running it as the CMD.</p>
</blockquote>
<p>下面是一个完整的使用了 s6 的多进程容器的 Dockerfile</p>
<pre><code class="language-docker">FROM nginx:1.20 AS runner
WORKDIR /uranus
ARG S6_OVERLAY_VERSION=3.1.5.0
ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-noarch.tar.xz /tmp
ADD https://github.com/just-containers/s6-overlay/releases/download/v${S6_OVERLAY_VERSION}/s6-overlay-x86_64.tar.xz /tmp

RUN apt update &amp;&amp; apt install xz-utils procps iproute2 -y &amp;&amp; \
    tar -Jxpf /tmp/s6-overlay-x86_64.tar.xz -C / &amp;&amp; \
    tar -Jxpf /tmp/s6-overlay-noarch.tar.xz -C / &amp;&amp; \
    rm -f /tmp/s6-overlay-x86_64.tar.xz &amp;&amp; \
    rm -f /tmp/s6-overlay-noarch.tar.xz
ENTRYPOINT [&quot;/init&quot;]
RUN mkdir /etc/services.d/
COPY --from=builder /uranus/_output/firewalld-gateway ./bin/
COPY --from=builder /uranus/firewalld-gateway.toml .
COPY --from=builder /uranus/dist /var/run/nginx/
COPY --from=builder /uranus/uranus.nginx.conf /etc/nginx/conf.d/
COPY --from=builder /uranus/s6/ /etc/s6-overlay/s6-rc.d/
COPY --from=builder /uranus/s6/ /etc/services.d/
ENV PATH &quot;$PATH:/uranus/bin&quot;
RUN  firewalld-gateway --sql-driver=sqlite --migration &amp;&amp; \
     rm -f /etc/nginx/conf.d/default.conf &amp;&amp; \
     echo &quot;longrun&quot; &gt; /etc/s6-overlay/s6-rc.d/nginx/type &amp;&amp; \
     echo &quot;longrun&quot; &gt; /etc/s6-overlay/s6-rc.d/uranus/type &amp;&amp; \
     mkdir -pv /etc/s6-overlay/s6-rc.d/uranus/contents.d &amp;&amp; \
     mkdir -pv /etc/s6-overlay/s6-rc.d/nginx/contents.d

#CMD [ &quot; /command/s6-svscan&quot;, &quot;/etc/services.d&quot; ]
VOLUME [&quot;/uranus&quot; ]
EXPOSE 2953/tcp
</code></pre>
<p>在容器中进程内可以看出对应进程图  s6init 作为所有进程的父进程管理着supervise，之后管理者你需要管理的进程；如果进程异常，他会不断地拉起对应的进程，当然，如果是启动参数错误问题，那么永远不会被拉起，当然容器是出于 Running，这时就需要自行做服务检测</p>
<pre><code>$ pstree
s6-svscan-+-s6-supervise---s6-linux-init-s
          |-s6-supervise---s6-ipcserverd
          |-3*[s6-supervise]
          |-s6-supervise---firewalld-gatew---5*[{firewalld-gatew}]
          `-s6-supervise---nginx---4*[nginx]


$ ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 May18 ?        00:00:00 /package/admin/s6/command/s6-svscan -d4 -- /run/service
root        16     1  0 May18 ?        00:00:00 s6-supervise s6-linux-init-shutdownd
root        18    16  0 May18 ?        00:00:00 /package/admin/s6-linux-init/command/s6-linux-init-shutdownd -c /run/s6/basedir -g 3000 -C -B
root        25     1  0 May18 ?        00:00:00 s6-supervise s6rc-oneshot-runner
root        26     1  0 May18 ?        00:00:00 s6-supervise s6rc-fdholder
root        27     1  0 May18 ?        00:00:00 s6-supervise uranus
root        28     1  0 May18 ?        00:00:00 s6-supervise nginx
root        34    25  0 May18 ?        00:00:00 /package/admin/s6/command/s6-ipcserverd -1 -- /package/admin/s6/command/s6-ipcserver-access -v0 -E -l0 -i data/rules -- /package/admin/s6/command/s6-sudod -t 30000 -- /package/admin/s6-rc/command/s6-rc-oneshot-run -l .
root        69     1  0 May18 ?        00:00:00 s6-supervise uranus
root        70     1  0 May18 ?        00:00:00 s6-supervise nginx
root        71    69  1 May18 ?        00:36:40 /uranus/bin/firewalld-gateway -v 5 --sql-driver=sqlite --config=/uranus/firewalld-gateway.toml
root        72    70  0 May18 ?        00:00:00 nginx: master process nginx -g daemon off;
nginx       74    72  0 May18 ?        00:00:00 nginx: worker process
nginx       75    72  0 May18 ?        00:00:00 nginx: worker process
nginx       76    72  0 May18 ?        00:00:00 nginx: worker process
nginx       77    72  0 May18 ?        00:00:00 nginx: worker process
root        83     0  1 04:17 pts/0    00:00:00 bash
root        90    83  0 04:18 pts/0    00:00:00 ps -ef
</code></pre>
<h2 id="reference"><strong>Reference</strong></h2>
<p><a href="https://skarnet.org/software/s6/s6-svscan-1.html" target="_blank"
   rel="noopener nofollow noreferrer" >How to run s6-svscan as process 1</a></p>
<p><a href="https://github.com/just-containers/s6-overlay" target="_blank"
   rel="noopener nofollow noreferrer" >Usage</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>alpine安装网络工具</title>
      <link>https://www.oomkill.com/2023/03/alpine-network-tools/</link>
      <pubDate>Wed, 22 Mar 2023 23:00:36 +0800</pubDate>
      
      <guid>https://www.oomkill.com/2023/03/alpine-network-tools/</guid>
      <description></description>
      <content:encoded><![CDATA[<ul>
<li>telnet：<code>busybox-extras</code></li>
<li>net-tools: <code>net-tools</code></li>
<li>tcpdump: <code>tcpdump</code></li>
<li>wget: <code>wget</code></li>
<li>dig nslookup: <code>bind-tools</code></li>
<li>curl: <code>curl</code></li>
<li>nmap: <code>nmap</code></li>
<li>wget ifconfig nc traceroute.. : <code>busybox</code></li>
<li>ssh: <code>openssh-client</code></li>
<li>ss iptables: <code>iproute2</code></li>
<li>ethtool: <code>ethtool</code></li>
</ul>
<pre><code class="language-yaml">FROM  alpine
MAINTAINER  
RUN sed -i 's@http://dl-cdn.alpinelinux.org/@https://mirrors.aliyun.com/@g' /etc/apk/repositories
RUN apk add --no-cache --virtual .persistent-deps \
                curl \
		tcpdump \
                iproute2 \
                bind-tools \
                ethtool \
                busybox-extras \
                libressl \
                openssh-client \
		busybox
CMD  [ &quot;tail&quot;, &quot;-f&quot; ]
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>windows下Docker Desktop安装管理</title>
      <link>https://www.oomkill.com/2020/10/windows10-install-docker/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/10/windows10-install-docker/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="检查要求">检查要求</h2>
<ul>
<li>Windows 10 企业版、专业版或教育版  （必须windows10 1903版本以上）版本号 <code>18362.1049+</code> 或 <code>18363.1049+</code> ，次版本＃大于.<code>1049</code>。最好是最新版（新版windows可以hype-v wsl2 vmvare共存，但安卓模拟器目前还没稳定的共存版本）。建议使用wsl2，安装包容量会比起hype-v小很多 。</li>
<li>Windows开启wsl2，建议 Windows 10 2004（版本号不低于 19041.264），可wsl2与vmvare共存。</li>
<li>CPU 支持并开启虚拟化（<code>Intel  VT-c</code> 或  <code>AMD SVM</code>）。</li>
<li>最少 4 GB 内存。</li>
</ul>
<p>对于专业版、企业版、教育版可以使用docker desktop wsl2模式，此处无需开启<code>Hype-v</code></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20210703212825867.png" alt="image-20210703212825867" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>对于Win10 家庭版，Win10 19041.264之前版本，及 Win7 8用户，可以使用docker desktop <code>Hype-v</code> 后端。</p>
<h2 id="修改安装盘">修改安装盘</h2>
<p>Docker Desktop 默认安装到 <code>C:\Program Files\Docker</code> 并不可更改，这样很不友好，可以通过软连接的方式改变Docker Desktop 默认安装盘。</p>
<pre><code>mklink /J &quot;C:\Program Files\Docker&quot; &quot;D:\Program Files\Docker&quot;
</code></pre>
<h2 id="限制wsl2运行最大内存">限制wsl2运行最大内存</h2>
<p>WSL 是 Microsoft 提供的一项功能，可以使开发人员能够直接在 Windows 上运行 <code>GNU/Linux</code> 环境，无需修改，无需传统虚拟机或双引导设置，减少了开发人员的使用复杂度</p>
<p>在 Docker Desktop 使用了 WSL 2 中的动态内存分配特性，极大地提高了资源消耗。这意味着，Docker Desktop 仅使用其所需的 CPU 和内存资源量，同时使 CPU 和内存密集型任务（例如构建容器）运行得更快。</p>
<p>但WSL2目前一个弊端，可能WSL2 vm会分配所有可用内存，并最终导致操作系统和其他应用程序的内存不足。</p>
<p><img loading="lazy" src="https://miro.medium.com/max/700/1*GWlTOqcj4XeW4NO8_-OufA.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>所以需要对WLS2内存和CPU资源进行限制，在 <code>cmd</code> 或 <code>powshell</code> 终端中</p>
<pre><code>wsl --shutdown
notepad &quot;$env:USERPROFILE/.wslconfig&quot;
</code></pre>
<p>在用户目录创建一个文件<code>.wslconfig</code>  ，编辑 <code>.wslconfig</code></p>
<pre><code>[wsl2]
memory=3GB   # 限制wsl2的虚拟机最大内存
processors=4  # 限制wsl2使用的处理器数量
swap=0      # 不使用交换文件
</code></pre>
<p><img loading="lazy" src="https://miro.medium.com/max/700/1*Vv1RjqzQ5V7M2FzPQxdAkQ.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="安装docker-desktop">安装Docker Desktop</h3>
<p>完成上面的操作，可以安装Docker Desktop了。从<a href="https://www.docker.com/products/docker-desktop" target="_blank"
   rel="noopener nofollow noreferrer" >Docker Desktop</a>网站下载安装Docker Desktop for Windows，大于500M。</p>
<p>安装步骤基本上点击操作即可，没有什么难度</p>
<h2 id="镜像路径迁移">镜像路径迁移</h2>
<p>当使用了WSL2作为Docker Desktop后端引擎时，<code>WSL 2 Docker-Desktop-Data</code> 的VM磁盘镜像通常在 <code>%USERPROFILE%\AppData\Local\Docker\wsl\data\ext4.vhdx</code> 路径下，docker-desktop通常在<code>%LOCALAPPDATA%/Docker/wsl</code> 路径下，因为镜像的大小及一些交换文件，通常会占用大量C盘空间，可以改变其存储位置。</p>
<pre><code>wsl --list -v
</code></pre>
<p>输入上述命令可以看到如下内容</p>
<pre><code>  NAME                STATE          VERSION
* docker-desktop         Stopped         2
  docker-desktop-data      Stopped         2
</code></pre>
<p><code>docker-desktop</code> 替换了之前使用的 Hyper-V VM 实现 Docker Desktop。这处理容器的引导和管理。</p>
<p><code>docker-desktop-data</code> 是存储docker镜像和配置的地方；实际上是对 Hyper-V 以前使用的虚拟硬盘的直接替换。</p>
<p>从这里可以看出Docker Desktop使用了WSL2作为后端引擎时，实际上整个应用作为WLS2的两个子系统进行的。可以通过迁移WSL2系统镜像的存储位置来改变Docker霸占C盘不可转移的弊端。</p>
<p>导出wsl系统镜像</p>
<pre><code>wsl --export docker-desktop docker-desktop.tar
wsl --export docker-desktop-data docker-desktop-data.tar
</code></pre>
<p>删除Docker Desktop wsl子系统，此操作会自动删除 <code>ext4.vhdx</code> 文件，故需要先导出一份备份</p>
<pre><code>wsl --unregister docker-desktop
wsl --unregister docker-desktop-data
</code></pre>
<p>导入重新创建wsl Docker Desktop子系统</p>
<pre><code>wsl --import docker-desktop d:\{new_path} docker-desktop.tar
wsl --import docker-desktop-data d:\{new_path} docker-desktop-data.tar
</code></pre>
<p>完成后，启动Docker服务，如果服务正常，可以删除掉 <code>docker-desktop.tar</code> 与 <code>docker-desktop-data.tar</code></p>
<h2 id="无法启动">无法启动</h2>
<p>我在使用windows时，会安装冰点还原，因为windows10 以上需要 冰点还原 8.38以上，我这里使用 8.38.020.4676 版本时，在开启还原状态时，Docker无法正常启动，在关闭还原时，可以正常启动。更换 8.62.020.5630。后正常。 8.38.020.4676 是2017年的版本，当时Docker对windows兼容并不好，而8.38.020.4676 是2020年发行的版本，目前在使用中并未发现异常。 8.38.020.4676 与 8.62.020.5630为网上常见的纯净的破解版了，所以按需选择使用。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker Registry使用</title>
      <link>https://www.oomkill.com/2018/06/docker-registry/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-registry/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="docker-registry介绍">docker registry介绍</h2>
<p>Registry用于保存docker镜像，包括镜像的层次结构和元数据，用户可自建<code>Registry</code>，也可使用官方的<code>Docker Hub</code></p>
<p>分类</p>
<ul>
<li>Sponsor Registry：第三方的registry，供客户和Docker社区使用</li>
<li>Mirror Registry：第三方的registry，只让客户使用</li>
<li>Vendor Registry：由发布Docker镜像的供应商提供的registry</li>
<li>Private Registry：通过设有防火墙和额外的安全层的私有实体提供的registry</li>
</ul>
<p>一个docker Registry上拥有两种功能：</p>
<ol>
<li>提供镜像存储的仓库。</li>
<li>提供用户获取镜像时的认证功能。</li>
<li>同时提供当前服务器上所有可用镜像的搜索索引。</li>
</ol>
<p>一个docker镜像仓库有仓库的名称，等同于yum的repostory。通常简称为repo。为了使的镜像和应用程序版本之间有意义上的关联关系。在docker一个仓库通常只存放一个应用程序的镜像。因此，这个仓库名就是应用程序名。通过给每个镜像额外添加一个组件叫<font color="#f8070d" size=3><code>tag</code></font>，来标识每一个镜像。通常镜像名称:标签<font color="#f8070d" size=3><code>repo_name:tag</code></font>才能唯一标识一个镜像。</p>
<p>为了可以快速创建registry，docker专门提供了一个程序包 <font color="#f8070d" size=3><code>docker-distribution</code></font> 。https://hub.docker.com/r/distribution/registry/ regustry自身运行在容器中，而容器的文件系统会随着容器生命周期终止而删除，因此需要给registry定义存储卷，使用网络存储。</p>
<p> 在yum的extras仓库有一个<font color="#f8070d" size=3><code>docker-registry</code></font>的程序包。docker-distribution的主配置文件在 <font color="#f8070d" size=3><code>/etc/docker-distribution/registry/config.yml</code></font>，所有上传的镜像存放在<font color="#f8070d" size=3><code>/var/lib/registry</code></font> 。</p>
<pre><code class="language-sh">$ yum info docker-registry
Available Packages
Name        : docker-registry
Arch        : x86_64
Version     : 0.9.1
Release     : 7.el7
Size        : 123 k
Repo        : extras/7/x86_64
Summary     : Registry server for Docker
URL         : https://github.com/docker/docker-registry
License     : ASL 2.0
Description : Registry server for Docker (hosting/delivering of repositories and images).
</code></pre>
<h3 id="配置docker-registry访问">配置docker registry访问</h3>
<p>非 <code>docker hub</code> 必须给定registry的<font color="#f8070d" size=2><code>地址</code></font><font color="#f8070d" size=2><code>端口</code></font>，如果不是顶层仓库还要给定<font color="#f8070d" size=2><code>用户名</code></font>。
<font color="#f8070d" size=3><code>docker push</code></font> 默认基于https工作的，而服务器端使用的http，两者不兼容，需要标记为非加密、非安全的<font color="#f8070d" size=3><code>docker registry</code></font>。</p>
<pre><code class="language-sh">$ docker push node02.com:5000/php
The push refers to repository [node02.com:5000/php]
Get https://node02.com:5000/v2/: http: server gave HTTP response to HTTPS client
</code></pre>
<p>编辑 <font color="#f8070d" size=3><code>/etc/docker/daemon.json</code></font> 添加 <font color="#f8070d" size=3><code>insecure-registries</code></font> ，并且名称一定要与仓库引用时使用的名称完全保持一致，多个以逗号分隔</p>
<pre><code class="language-sh">{
    &quot;insecure-registries&quot;: [&quot;node02.com:5000&quot;]
}
</code></pre>
<p>push的镜像存放在 <font color="#f8070d" size=3><code>/var/lib/registry/</code></font> 下，V2指的是registry的协议版本</p>
<pre><code class="language-sh">$ ll /var/lib/registry/docker/registry/v2/
total 0
drwxr-xr-x 3 root root 20 Aug 28 23:31 blobs
drwxr-xr-x 3 root root 17 Aug 28 23:31 repositories
</code></pre>
<p>push时镜像会分层次，每一层都单独推送，单独存放。产生的镜像层次存放在 <font color="#f8070d" size=3><code>php/_layers/sha256/</code></font> ，真正存放的路径为 <font color="#f8070d" size=3><code>/var/lib/registry/docker/registry/v2/blobs</code></font> 下</p>
<pre><code class="language-sh">$ ll /var/lib/registry/docker/registry/v2/repositories/php/_layers/sha256/
total 0
13bb1aa790b2a283bdeb26a9dd4afa0891e37252dd6f836e2bc8e1555903f7fd
256b176beaff7815db2a93ee2071621ae88f451bb1e198ca73010ed5bba79b65
3584183957db768fc11554dfd6b06ec41be02d7872cecb65aa5ba9f238c897e6
499f1709b835427d28bc4ddb1e7038a438f1a1272abfe5489d6c74cb69b51bec
6d33f059b806836d7e63f6f26f154b99a42abcc1d384da7569de593b8135f7fb
8158b516b87541f3641937087e8048977f48f9ced0bfaeb0bc007c1ea0d49b93
8fa12d754b796a48f42433fae8a8eee24b56679bba4e5648fa50b184622dd941
ca82288118de1328f65d428e6d2acc6a87ecf552ed5cc3698fde90cf76f3ebdb
d393fc3ffa9b40bfbddd978604e0d5249b0bb1a6e4953142d8b2c80fcc85bcb4
d9f1ee7bf8cab99a7362c98708edd26c2f622f13b8c74c3cafd6197442c20609
</code></pre>
<p>通过api获取中镜像与标签</p>
<pre><code>$ curl http://192.168.50.27:5000/v2/game/tags/list
{&quot;name&quot;:&quot;game&quot;,&quot;tags&quot;:[&quot;0123-151422&quot;,&quot;0124-162847&quot;,&quot;0124-164112&quot;,&quot;0125&quot;]}
</code></pre>
<p>查看仓库中内容</p>
<pre><code>$ curl -XGET http://192.168.50.27:5000/v2/_catalog
{&quot;repositories&quot;:[&quot;apiv1&quot;,&quot;game&quot;,&quot;php&quot;,&quot;tyapi&quot;]}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker Volume</title>
      <link>https://www.oomkill.com/2018/06/docker-volume/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-volume/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>对于docker来讲，作为容器运行的底层引擎，在组织及运行容器时每个容器内只运行一个程序及子程序。对于这个容器来讲，启动时依赖于
底层镜像联合挂载启动而成。
底层能够存储此类分层构建并联合挂载镜像的文件系统。最上层构建读写层。对于此读写层来说。所有对容器的操作都保存在最上层之上。而下层内容的操作需要使用写时复制。</p>
<p>Docker镜像由多个只读层叠加而成，启动容器时，Docker会加载只读镜像层并在镜像栈顶部添加一个读写层，如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏，此即 <font style="background:#ffff00;" size=3>写时复制（COW）</font>机制。此机制对IO较高的应用在实现持久化存储时，势必对在底层应用数据存储时性能要求较高。要想绕过使用限制，可以使用存储卷机制。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025233608002.png" alt="image-20221025233608002" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>Why Data Volume？</p>
<p>宿主机的主机文件系统直接与容器内部的文件系统之上的某一访问路径建立绑定关系。</p>
<p>在宿主机上目录和容器内文件系统建立绑定关系的目录相对于容器来讲被称为<font color="#f8070d" size=3><code>volume</code></font>。容器内所有有效数据都是保存在存储卷，从而脱离容器自身文件系统。当容器关闭并删除时，只要不删除与宿主机与之绑定的存储目录，就能实现数据脱离容器的生命周期而持久化。docker的存储卷默认情况下使用其所在宿主机之上的本地文件系统目录的。</p>
<ol>
<li>关闭并重启容器，其数据不受影响；但删除Docker容器，则其更改将会全部丢失</li>
<li>存在的问题</li>
<li>存储于联合文件系统中，不易于宿主机访问；</li>
<li>容器间数据共享不便</li>
<li>删除容器其数据会丢失
解决方案：“卷（volume）”
“卷”是容器上的一个或多个“目录”，此类目录可绕过联合文件系统，与宿主机上的某目录“绑定（关联）”</li>
</ol>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025233624954.png" alt="image-20221025233624954" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>在docker中如果需要动刀存储卷时，不必要手动创建，Volume于容器初始化之时即会创建，由base image提供的卷中的数据会于此期间完成复制</p>
<p>Volume的初衷是独立于容器的生命周期实现数据持久化，因此删除容器之时既不会删除卷，也不会对哪怕未被引用的卷做垃圾回收操作；</p>
<p>Data volumes
·卷为docker提供了独立于容器的数据管理机制
·可以把“镜像”想像成静态文件，例如“程序”，把卷类比为动态内容，例如“数据
&ldquo;；于是，镜像可以重用，而卷可以共享；
·卷实现了“程序（镜像）”和“数据（卷）”分离，以及“程序（镜像）”和“制作镜像的主机
&ldquo;分离，用户制作镜像时无须再考虑镜像运行的容器所在的主机的环境；</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025233642310.png" alt="image-20221025233642310" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同；</p>
<p>Bind mount volume 绑定挂载卷
在宿主机指定一个特定路径，在容器内指定一个特定路径，二者已知路径建立关联关系。</p>
<p>a volume that points to a user-specified location on the host file system</p>
<h3 id="docker-managed-volume-docker管理卷">Docker-managed volume docker管理卷</h3>
<p>指定容器内的挂载点，与之关联的是宿主机的目录由<code>docker daemon</code>引擎自行创建空目录，或者使用已存在目录与存储卷路径建立关联关系。</p>
<p>the Docker daemon creates managed volumes in a portion of the host&rsquo;s file system that&rsquo;s owned by Docker</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/image-20221025233706235.png" alt="image-20221025233706235" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="在容器中使用volumes">在容器中使用Volumes</h3>
<p>为docker run命令使用一v选项即可使用Volume</p>
<p>Docker-managed volume</p>
<pre><code class="language-sh">docker run-it-name box1 -v /data busybox
docker inspect-f {{.Mounts} box1
</code></pre>
<p>查看bbox1容器的卷、卷标识符及挂载的主机目录
Bind-mount Volume</p>
<pre><code class="language-sh">docker run-it-v HOSTDIR:VOLUMEDIR--name box2 busybox
docker inspect-f {{.Mounts}} box2
</code></pre>
<p>Sharing volumes There are two ways to share volumes between containers
多个容器的卷使用同一个主机目录，例如</p>
<pre><code class="language-bash">$ docker run-it--namec1-v/docker/volumes/v1：/data busybox
$ docker run-it--name c2-v/docker/volumes/v1：/data busybox
</code></pre>
<p>复制使用其它容器的卷，为docker run命令使用&ndash;volumes-from选项</p>
<pre><code class="language-sh">docker run-it--name box1 -v /docker/volumes/v1:/data busybox
docker run-it--name box2 --volumes-from box1 busybox
</code></pre>
<p>EXPOSE
用于为容器打开指定要监听的端口以实现与外部通信，并不会直接暴露，只是声明需要暴露的端口，在<code>docker run -P</code>时自动暴露端口</p>
<p>Syntax</p>
<pre><code class="language-sh">EXPOSE &lt;port&gt; [/&lt;protocol&gt;] [&lt;port&gt;[/&lt;protocol&gt;]..]
</code></pre>
<p><protocol> 用于指定传输层协议，可为wp或udp二者之一，默认为TCP协议
EXPOSE指令可一次指定多个端口，例如</p>
<pre><code class="language-sh">EXPOSE 11211/udp 11211/tcp
</code></pre>
<p>ENV
用于为镜像定义所需的环境变量，并可被Dockerfile文件中位于其后的其它指令（如ENV、ADD、COPY等）所调用</p>
<p>调用格式为Svariable_name或${variable_name}</p>
<h3 id="syntax">Syntax</h3>
<ul>
<li>ENV <code>&lt;key&gt;</code> <code>&lt;value&gt;</code>或</li>
<li>ENV <code>&lt;key&gt;</code>=<code>&lt;value&gt;</code> .…</li>
</ul>
<p>第一种格式中，<key>之后的所有内容均会被视作其 <code>&lt;value&gt;</code> 的组成部分，因此，一次只能设置一个变量；</p>
<p>第二种格式可用一次设置多个变量，每个变量为一个 <code>&lt;key&gt;=&lt;value&gt;</code> 的键值对，如果
<code>&lt;value&gt;</code> 中包含空格，可以以反斜线（）进行转义，也可通过对 <code>&lt;value&gt;</code> 加引号进行标识；另外，反斜线也可用于续行；</p>
<p>定义多个变量时，建议使用第二种方式，以便在同一层中完成所有功能</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker-compose使用</title>
      <link>https://www.oomkill.com/2018/06/docker-compose/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-compose/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>Compose是一个定义和管理多容器的工具，使用Python语言编写。使用Compose配置文件描述多个容器应用的架构，比如使用
什么镜像、数据卷、网络、映射端口等；然后一条命令管理所有服务，比如启动、停止、重启等。</p>
<h2 id="1linux安装compose">1、Linux安装Compose</h2>
<p>参考网址：<a href="https://github.com/docker/compose/releases" target="_blank"
   rel="noopener nofollow noreferrer" >Releases · docker/compose · GitHub</a></p>
<ol>
<li>下载二进制文件</li>
</ol>
<pre><code class="language-bash">curl -L \
https://github.com/docker/compose/releases/download/1.22.0/docker-compose-\
`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
</code></pre>
<ol start="2">
<li>对二进制文件添加可执行权限</li>
</ol>
<pre><code class="language-bash">chmod +x /usr/local/bin/docker-compose
</code></pre>
<ol start="3">
<li>测试安装</li>
</ol>
<p>docker-compose &ndash;version</p>
<p>也可以使用pip工具安装：pip install docker-compose</p>
<h2 id="2使用compose">2、使用compose</h2>
<p>参考文档：<a href="https://docs.docker.com/compose/" target="_blank"
   rel="noopener nofollow noreferrer" >Docker Compose | Docker Documentation</a></p>
<p>compose语法详解：<a href="https://docs.docker.com/compose/compose-file/#reference-and-guidelines" target="_blank"
   rel="noopener nofollow noreferrer" >Compose file version 3 reference | Docker Documentation</a>
<a href="https://blog.csdn.net/guyue35/article/details/53891825" target="_blank"
   rel="noopener nofollow noreferrer" >Docker compose file 中文参考文档 - CSDN博客</a></p>
<h3 id="21-compose常用命令选项">2.1 Compose常用命令选项</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>build</td>
<td>构建或修改Dockerfile后重建服务</td>
</tr>
<tr>
<td>config</td>
<td>验证和查看compose文件语法<br> <code>-q</code>,只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息。<br><code>--services</code>,打印服务名，一行一个</td>
</tr>
<tr>
<td>create</td>
<td></td>
</tr>
<tr>
<td>down</td>
<td>停止和删除容器、网络、卷、镜像，这些内容是通过docker-compose up命令创建的.  默认值删除 容器 网络。</td>
</tr>
<tr>
<td>logs</td>
<td>打印compose service日志输出。</td>
</tr>
<tr>
<td>ps</td>
<td>打印compose进程，-q只打印pid</td>
</tr>
</tbody>
</table>
<p>更多参数参考：<a href="https://blog.csdn.net/wanghailong041/article/details/52162293" target="_blank"
   rel="noopener nofollow noreferrer" >Docker-compose命令详解 - CSDN博客</a></p>
<h3 id="22-compose创建tomcat环境">2.2 compose创建tomcat环境</h3>
<blockquote>
<p><strong>Dockerfile</strong></p>
</blockquote>
<pre><code class="language-bash">FROM centos
MAINTAINER lc
ADD jdk-8u144-linux-x64.tar.gz /usr/local
ENV JAVA_HOME=/usr/local/jdk1.8.0_144
ADD apache-tomcat-8.5.32.tar.gz /usr/local/
RUN mv /usr/local/apache-tomcat-8.5.32 /usr/local/tomcat
WORKDIR /usr/local/tomcat
ENTRYPOINT [&quot;bin/catalina.sh&quot;,&quot;run&quot;]
EXPOSE 8080
</code></pre>
<blockquote>
<p><strong>compose</strong></p>
</blockquote>
<pre><code class="language-bash">version: &quot;3&quot;
services: 
  web:
    build:
      context: .
      dockerfile: &quot;javafile&quot;
    ports:
      - &quot;80:8080&quot;
    image: &quot;tomcat&quot;
    container_name: &quot;tomcat&quot;
</code></pre>
<p><strong>验证是否</strong></p>
<pre><code class="language-bash">$ docker-compose ps
   Name            Command         State            Ports         
------------------------------------------------------------------
root_web_1   bin/catalina.sh run   Up      0.0.0.0:32768-&gt;8080/tcp
$ 
</code></pre>
<h3 id="23-docker-compose语法描述">2.3 docker compose语法描述</h3>
<table>
<thead>
<tr>
<th>关键词</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>version</td>
<td>compose版本</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker-compose示例</title>
      <link>https://www.oomkill.com/2018/06/docker-compose-example/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-compose-example/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="使用docker-compose构建lnmp环境">使用docker-compose构建LNMP环境。</h2>
<h3 id="编写dockerfile">编写Dockerfile</h3>
<p>这里采用的是先将nginx php打包为rpm包，然后做成镜像。与直接在容器里编译安装同理的。</p>
<blockquote>
<p><strong>nginx Dockerfile</strong></p>
</blockquote>
<pre><code class="language-bash">FROM centos
MAINTAINER lc
RUN yum install -y gcc gcc-c++ openssl-devel make pcre-devel
ADD nginx-1.13.9-1.el7.centos.x86_64.rpm /tmp/
RUN cd /tmp/ &amp;&amp; rpm -ivh nginx-1.13.9-1.el7.centos.x86_64.rpm
ADD nginx.conf /etc/nginx/
EXPOSE 80
CMD [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre>
<blockquote>
<p><strong>php Dockerfile</strong></p>
</blockquote>
<pre><code class="language-bash">FROM centos
MAINTAINER LC
RUN curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
RUN curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
RUN yum install zlib-devel \
    libxml2-devel \
    libjpeg-devel \
    libjpeg-turbo-devel \
    freetype-devel \
    libpng-devel gd-devel \
    curl-devel \
    libxslt-devel \
    bzip2-devel \
    gmp-devel \
    readline-devel \
    mcrypt \
    mhash \
    openssl-devel \
    libmcrypt-devel -y
COPY php-7.1.17-1.el7.centos.x86_64.rpm /tmp/
COPY libiconv-1.15-1.el7.centos.x86_64.rpm /tmp/
RUN rpm -ivh /tmp/libiconv-1.15-1.el7.centos.x86_64.rpm
RUN rpm -ivh /tmp/php-7.1.17-1.el7.centos.x86_64.rpm
ADD php-fpm.conf /etc/php/
CMD /usr/sbin/php-fpm &amp;&amp; tail -f /dev/null
EXPOSE 9000
</code></pre>
<h3 id="准备构建容器的配置文件">准备构建容器的配置文件</h3>
<blockquote>
<p><strong>在nginx配置文件中增加解析php的语句</strong></p>
</blockquote>
<pre><code class="language-nginx">location ~ .*\.(php|php5)$ {
		fastcgi_pass  php.com:9000;$&lt;--这里使用link将php的ip解析过来
		fastcgi_index index.php;
		include fastcgi.conf;
}
</code></pre>
<blockquote>
<p><strong>修改php-fpm监听端口为外网通讯的ip</strong></p>
</blockquote>
<pre><code class="language-bash">$ sed -i &quot;s#listen = 127.0.0.1:900$listen = 0.0.0.0:900$g&quot; php/php-fpm.conf 
$ cat php/php-fpm.conf |grep 9000
listen = 0.0.0.0:9000
</code></pre>
<hr>
<p>注：此步骤可以在打包RPM时，使用%post在安装后进行修改，免去构建镜像的步骤</p>
<hr>
<h3 id="准备rpm包">准备RPM包</h3>
<pre><code class="language-bash">$ ls -1 php
libiconv-1.15-1.el7.centos.x86_64.rpm
php-7.1.17-1.el7.centos.x86_64.rpm
phpfile
php-fpm.conf
php.ini

$ ls -1 nginx
nginx-1.13.9-1.el7.centos.x86_64.rpm
nginx.conf
nginxfile
</code></pre>
<h3 id="使用docker-compose一键构建镜像">使用docker-compose一键构建镜像</h3>
<h4 id="编写docker-composeyaml">编写docker-compose.yaml</h4>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  nginx:
    hostname: nginx
    build:
      context: ./nginx
      dockerfile: nginxfile
    expose:
      - &quot;80&quot;
    ports:
      - &quot;80:80&quot;
    links:
      - mysql
      - php:php.com
    volumes:
      - ./wwwroot:/usr/share/nginx/html/
  php:
    hostname: &quot;php&quot;
    build:
      context: ./php
      dockerfile: phpfile
    ports: 
      - &quot;9000:9000&quot;
    links:
      - mysql:mysql-db
    volumes:
      - ./wwwroot:/usr/share/nginx/html/
  mysql:
    image: mysql:5.6
    hostname: mysql
    ports:
      - &quot;3306:3306&quot;
    environment:
      MYSQL_ROOT_PASSWORD: &quot;Zhang@123&quot;
      MYSQL_USER: &quot;test&quot;
      MYSQL_PASSWORD: &quot;test@123&quot;
</code></pre>
<p>参考文档： <a href="https://hub.docker.com/_/mysql/" target="_blank"
   rel="noopener nofollow noreferrer" >https://hub.docker.com/_/mysql/</a></p>
<h4 id="检查docker-compose-yaml语法">检查docker-compose-yaml语法</h4>
<pre><code class="language-bash">$ docker-compose config
services:
  mysql:
    environment:
      MYSQL_PASSWORD: test@123
      MYSQL_ROOT_PASSWORD: Zhang@123
      MYSQL_USER: test
    hostname: mysql
    image: mysql:5.6
    ports:
......
</code></pre>
<hr>
<p><strong><font color=#f8070d; size=2>注：在语法正确时，打印docker-compose.yaml内容，语法出错直接报问题所在位置。</font></strong></p>
<hr>
<h4 id="一键构建所有镜像">一键构建所有镜像</h4>
<pre><code class="language-bash">$ docker-compose build
mysql uses an image, skipping

Building php
Step 1/12 : FROM centos
 ---&gt; 5182e96772bf

.....

Step 12/12 : EXPOSE 9000
 ---&gt; Running in 3c5f3c46124c
Removing intermediate container 3c5f3c46124c
 ---&gt; 8791ad17224d
Successfully built 8791ad17224d
Successfully tagged lnmp_php:latest

Building nginx
Step : FROM centos
 ---&gt; 5182e96772bf

.....

Step 8/8 : CMD [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&gt; Using cache
 ---&gt; 8cca531a5c21
Successfully built 8cca531a5c21
Successfully tagged lnmp_nginx:latest
</code></pre>
<h4 id="管理编排容器">管理编排容器</h4>
<pre><code class="language-bash">docker-compose up -d
docker-compose down
docker-compose ps 
</code></pre>
<p>查看运行结果</p>
<h2 id="使用docker-compose一键构建tomcat集群">使用docker-compose一键构建tomcat集群</h2>
<h3 id="编写dockerfile-1">编写Dockerfile</h3>
<h4 id="nginx-dockerfile">nginx Dockerfile</h4>
<pre><code class="language-bash">FROM centos
MAINTAINER lc
RUN yum install -y gcc gcc-c++ openssl-devel make pcre-devel
ADD nginx-1.13.9-1.el7.centos.x86_64.rpm /tmp/
RUN cd /tmp/ &amp;&amp; rpm -ivh nginx-1.13.9-1.el7.centos.x86_64.rpm
ADD nginx.conf /etc/nginx/
EXPOSE 80
CMD [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
</code></pre>
<h3 id="tomcat-dockerfile">tomcat Dockerfile</h3>
<pre><code class="language-bash">FROM centos
MAINTAINER lc
ADD apache-tomcat-8.5.29.tar.gz /usr/share/
ADD jdk-8u161-linux-x64.tar.gz /usr/share/
RUN mv /usr/share/apache-tomcat-8.5.29 /usr/share/tomcat
ENV JAVA_HOME=/usr/share/jdk1.8.0_161
WORKDIR /usr/share/tomcat
ENTRYPOINT [&quot;bin/catalina.sh&quot;,&quot;run&quot;]
EXPOSE 8080
</code></pre>
<h3 id="准备配置文件">准备配置文件</h3>
<pre><code class="language-nginx">upstream tomcat {
		server tomcat01:8080;
		server tomcat02:8080;
}

server {
		listen 81;
		location / {
		     proxy_pass http://tomcat/;
		     proxy_set_header Host $host;
		     client_max_body_size 10m;
		     proxy_set_header X-Real-IP $remote_addr;
		     proxy_set_header REMOTE-HOST $remote_addr;
		     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		 }
}

# 在日志中加入如下配置，来证明访问是负载进行的。

log_format  access  '&quot;$upstream_addr&quot; $remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                    '$status $body_bytes_sent &quot;$http_referer&quot; '
										'&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
access_log /data/nginx/log/access.log access;

</code></pre>
<pre><code class="language-bash">mkdir ./webapps/ROOT
echo jsp-test &gt;webapps/ROOT/index.jsp
</code></pre>
<h3 id="准备构建容器所需的软件">准备构建容器所需的软件</h3>
<pre><code class="language-bash">apache-tomcat-8.5.29.tar.gz
jdk-8u144-linux-x64.tar.gz
tomcatfile
</code></pre>
<h3 id="编写docker-compose文件">编写docker-compose文件</h3>
<pre><code class="language-yaml">version: &quot;3&quot;
services:
  nginx:
    hostname: nginx
    build:
      context: ./nginx
      dockerfile: nginxfile
    ports:
      - 80:81
    links:
      - tomcat01:tomcat01
      - tomcat02:tomcat02
    volumes:
      - ./webapps:/usr/share/nginx/html
    depends_on:
      - mysql
      - tomcat01
      - tomcat02
  tomcat01:
    hostname: tomcat01
    build:
      context: ./tomcat
      dockerfile: tomcatfile
    links:
      - mysql:mysql-db
    volumes:
      - ./webapps:/usr/share/tomcat/webapps/
  tomcat02:
    hostname: tomcat02
    build: 
      context: ./tomcat
      dockerfile: tomcatfile
    links: 
      - mysql:mysql-db
    volumes:
      - ./webapps:/usr/share/tomcat/webapps/
  mysql:
    hostname: mysql
    image: mysql:5.5
    ports: 
      - 3306:3306
    environment: 
      MYSQL_ROOT_PASSWORD: 123456
      MYSQL_DATABASE: wordpress
      MYSQL_USER: user
      MYSQL_PASSWORD: 123456
</code></pre>
<h3 id="使用docker-compose一键构建镜像-1">使用docker-compose一键构建镜像</h3>
<pre><code class="language-bash">$ docker-compose -f docker-compose.yml build 


mysql uses an image, skipping
Building tomcat02
Step : FROM centos
 ---&gt; 5182e96772bf
Step 2/9 : MAINTAINER lc
 ---&gt; Using cache
 ---&gt; 111890e6d42e
Step 3/9 : ADD apache-tomcat-8.5.29.tar.gz /usr/share/
 ---&gt; 46725ed86e2e
Step 4/9 : ADD jdk-8u144-linux-x64.tar.gz /usr/share/
 ---&gt; 431ea9bb9918
Step 5/9 : RUN mv /usr/share/apache-tomcat-8.5.29 /usr/share/tomcat
 ---&gt; Running in 22275e028633
Removing intermediate container 22275e028633
 ---&gt; 0f3919e97b50
Step 6/9 : ENV JAVA_HOME=/usr/share/jdk1.8.0_144
 ---&gt; Running in 60d616e0b9fc
Removing intermediate container 60d616e0b9fc
 ---&gt; 5255488c51ab
Step 7/9 : WORKDIR /usr/share/tomcat
 ---&gt; Running in 6b04d8f5524b
Removing intermediate container 6b04d8f5524b
 ---&gt; db88a81ec00a
Step 8/9 : ENTRYPOINT [&quot;bin/catalina.sh&quot;,&quot;run&quot;]
 ---&gt; Running in 189b6ee0ff4e
Removing intermediate container 189b6ee0ff4e
 ---&gt; 9b444829ed55
Step 9/9 : EXPOSE 8080
 ---&gt; Running in f2115bf03afb
Removing intermediate container f2115bf03afb
 ---&gt; 31c01ca93305
Successfully built 31c01ca93305
Successfully tagged lnmp_tomcat02:latest
Building tomcat01
Step : FROM centos
 ---&gt; 5182e96772bf
Step 2/9 : MAINTAINER lc
 ---&gt; Using cache
 ---&gt; 111890e6d42e
Step 3/9 : ADD apache-tomcat-8.5.29.tar.gz /usr/share/
 ---&gt; Using cache
 ---&gt; 46725ed86e2e
Step 4/9 : ADD jdk-8u144-linux-x64.tar.gz /usr/share/
 ---&gt; Using cache
 ---&gt; 431ea9bb9918
Step 5/9 : RUN mv /usr/share/apache-tomcat-8.5.29 /usr/share/tomcat
 ---&gt; Using cache
 ---&gt; 0f3919e97b50
Step 6/9 : ENV JAVA_HOME=/usr/share/jdk1.8.0_144
 ---&gt; Using cache
 ---&gt; 5255488c51ab
Step 7/9 : WORKDIR /usr/share/tomcat
 ---&gt; Using cache
 ---&gt; db88a81ec00a
Step 8/9 : ENTRYPOINT [&quot;bin/catalina.sh&quot;,&quot;run&quot;]
 ---&gt; Using cache
 ---&gt; 9b444829ed55
Step 9/9 : EXPOSE 8080
 ---&gt; Using cache
 ---&gt; 31c01ca93305
Successfully built 31c01ca93305
Successfully tagged lnmp_tomcat01:latest
Building nginx
Step : FROM centos
 ---&gt; 5182e96772bf
Step 2/8 : MAINTAINER lc
 ---&gt; Using cache
 ---&gt; 111890e6d42e
Step 3/8 : RUN yum install -y gcc gcc-c++ openssl-devel make pcre-devel
 ---&gt; Using cache
 ---&gt; 36090d81ef5e
Step 4/8 : ADD nginx-1.13.9-1.el7.centos.x86_64.rpm /tmp/
 ---&gt; Using cache
 ---&gt; cecd606c7619
Step 5/8 : RUN cd /tmp/ &amp;&amp; rpm -ivh nginx-1.13.9-1.el7.centos.x86_64.rpm
 ---&gt; Using cache
 ---&gt; 8c7b331fc175
Step 6/8 : ADD nginx.conf /etc/nginx/
 ---&gt; 84940ae84e06
Step 7/8 : EXPOSE 80
 ---&gt; Running in 94ac22711605
Removing intermediate container 94ac22711605
 ---&gt; ef10799c0844
Step 8/8 : CMD [&quot;/usr/sbin/nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]
 ---&gt; Running in 039ea9de17f0
Removing intermediate container 039ea9de17f0
 ---&gt; d489d87223f8
Successfully built d489d87223f8
Successfully tagged lnmp_nginx:latest
</code></pre>
<p>测试访问结果</p>
<p><img loading="lazy" src="../../images/docker-compose%E5%AE%9E%E6%88%98/e1fcd3f3.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>查看nginx访问日志，发现是负载到每一台tomcat上的。</p>
<pre><code class="language-bash">&quot;172.24.0.5:8080&quot; 10.0.0.1 - - [12/Aug/2018:17:52:39 +0000] &quot;GET /index.jsp HTTP/1.1&quot; 200 9 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.Safari/537.36&quot; &quot;-&quot;
&quot;172.24.0.4:8080&quot; 10.0.0.1 - - [12/Aug/2018:17:52:40 +0000] &quot;GET /index.jsp HTTP/1.1&quot; 200 9 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.Safari/537.36&quot; &quot;-&quot;
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Dockerfile使用示例</title>
      <link>https://www.oomkill.com/2018/06/dockerfile/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/dockerfile/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="一使用前提">一、使用前提</h2>
<p>通用镜像未必与应用程序和配置是符合我们需要的。</p>
<h3 id="11-常见镜像制作方式">1.1 常见镜像制作方式</h3>
<p>常见制作镜像方式有两种</p>
<ul>
<li>基于容器</li>
<li>基于镜像制作：编辑一个Dockerfile，而后根据此文件制作；</li>
</ul>
<h2 id="二dockerfile概述">二、Dockerfile概述</h2>
<p>Dockerfile只是构建Docker镜像的源代码，docker可以通过读取Dockerfile中的指令自动构建图像。Dockerfile是一个文本文档，其中包含用户可以在命令行上调用以组合图像的所有命令。用户可以使用 <font color="#f8070d" size=3><code>docker build</code></font> 创建连续执行多个命令行指令的自动构建。</p>
<h3 id="21-dockerfile的工作模式">2.1 Dockerfile的工作模式</h3>
<p>基于Dockerfile制作镜像时，需在专用目录放置Dockerfile文件，并且文件首字母必须大写。基于Dockerfile中打包的文件必须奇基于工作目录往下走的路径。在打包镜像时，<font color="#f8070d" size=3><code>.dockeringore</code></font> 文件本身与所有包含在 <font color="#f8070d" size=3><code>.dockeringore</code></font> 文件中的路径，都不被打包进去。在Dockerfile制作环境为底层镜像启动容器时所能够提供的环境。</p>
<h3 id="22-环境变量替换">2.2 环境变量替换</h3>
<p>制作镜像中还可以使用环境变量。环境变量（使用ENV语句声明）也可以在某些指令中使用，因为<code>Dockerfile</code>环境变量在 <code>Dockerfile</code> 中以 <font color="#f8070d" size=3><code>$variable_name</code></font> 或<font color="#f8070d" size=3><code>${variable_name}</code></font>标记。</p>
<p>语法还支持一些标准`bash修饰符</p>
<ul>
<li><font color="#f8070d" size=3><code>${variable:-word}</code></font> 表示如果设置了变量，那么结果将是该值。如果未设置变量，那么word将是结果。</li>
<li><font color="#f8070d" size=3><code>${variable+word}</code></font> 表示如果设置了变量，则word将是结果，否则结果为空字符串。</li>
</ul>
<h2 id="三dockerfile指令说明">三、Dockerfile指令说明</h2>
<hr>
<p><strong><font color="#f8070d" size=3>特别说明：Dockerfile中每一条指令都会生成一个新的镜像层。</font></strong></p>
<hr>
<h3 id="from">FROM</h3>
<p>FROM指令（最重要的一个），<font style="background:#ffff00;" size=2>必须为Dockerfile文件开篇的第一个非注释行</font>，用于为镜像文件构建过程指定基准镜像，后续的指令运行于此基准镜像所提供的运行环境。基准镜像可以是任何可用镜像文件，默认情况下，<code>docker build</code>会在docker主机上查找指定的镜像文件，在其不存在时，则会从 <font color="#f8070d" size=3><code>Docker Hub Registry</code></font> 上拉取所需的镜像文件。如果找不到指定的镜像文件，<code>docker build</code> 会返回一个错误信息</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">FROM repository[:tag]
</code></pre>
<pre><code class="language-sh">FROM registry/repository[:tag]
</code></pre>
<pre><code class="language-bash">FROM resository@[digest]  #←相同名称时，可以使用resository@镜像hush码指定镜像。
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明-</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>reposotiry</strong></td>
<td>某一个镜像的仓库，如redis镜像仓库。</td>
</tr>
<tr>
<td><strong>registry</strong></td>
<td>docker镜像仓库，如docker hub，docker registry包含很多reposotiry，如nginx php tomcat等。不指定registry，默认从docker hub下载。</td>
</tr>
<tr>
<td><strong>tag</strong></td>
<td>image的标签，为可选项，省略时默认为latest。</td>
</tr>
</tbody>
</table>
<h3 id="maintanierdepreacted">MAINTANIER(depreacted)</h3>
<p>MAINTANIER（depreacted）用于让Dockerfile制作者提供本人的详细信息。Dockerfile并不限制MAINTAINER指令可在出现的位置，但推荐将其放置于FROM指令之后。</p>
<blockquote>
<p><strong>Syntax</strong></p>
</blockquote>
<pre><code class="language-sh">MAINTAINER &lt;authtor's detail&gt;  
</code></pre>
<p>&lt;author&rsquo;s detail&gt; 可是任何文本信息，但约定俗成地使用作者名称及邮箱地址</p>
<pre><code class="language-sh">MAINTAINER &quot;lc &lt;12399.com@gmail.com&gt;&quot;
</code></pre>
<h3 id="lable">LABLE</h3>
<p>LABLE可以提供Key value信息，比MAINTANIER具有更宽泛的使用领域。LABLE让用户提供格式各样的元数据，都是键值格式。如果在LABEL值中包含空格，请使用引号和反斜杠。image可以有多个tag。您可以在一行上指定多个tag。docker17+增加此指令。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...
</code></pre>
<pre><code class="language-sh">LABEL maintainer=&quot;lc &lt;12399.com@gmail.com&gt;&quot;
</code></pre>
<h3 id="copy">COPY</h3>
<p>用于从宿主机工作目录将文件复制至到镜像的文件系统中。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">COPY src...dest
COPY &quot;src&quot;....&quot;dest&quot;
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>要复制的源文件或目录，支持使用通配符。</td>
</tr>
<tr>
<td>dest</td>
<td>目标路径，即正在创建的image的文件系统路径；建议为dest使用绝对路径，否则，COPY指定则以WORKDIR为其起始路径。</td>
</tr>
</tbody>
</table>
<hr>
<p>注意：在路径中有空白字符时，通常使用第二种格式。</p>
<hr>
<p>文件复制准则</p>
<ul>
<li><code>src</code> 必须是build上下文中的路径，不能是其父目录中的文件。</li>
<li>如果src是目录，则其内部文件或子目录会被递归复制，但src目录自身不会被复制。 等同于 <font color="#f8070d" size=3><code>cp a/*</code></font>而不是 <font color="#f8070d" size=3><code>cp -r a</code></font></li>
<li>如果指定了多个src，或在src中使用了通配符，则dest必须是一个目录，且必须以<font color="#f8070d" size=3><code>/</code></font>结尾。</li>
<li>如果dest事先不存在，它将会被自动创建，这包括其父目录路径。</li>
</ul>
<h3 id="add">ADD</h3>
<p>ADD指令类似于COPY指令，ADD支持使用TAR文件和URL路径。</p>
<p>add官方解释：<a href="https://docs.docker.com/engine/reference/builder/#add" target="_blank"
   rel="noopener nofollow noreferrer" >ADD</a></p>
<p>如果src是以</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">ADD src dest
ADD [&quot;src&quot;…&quot;dest&quot;]
</code></pre>
<p>操作准则同COPY指令</p>
<ul>
<li>
<p>如果 <code>&lt;src&gt;</code> 为URL且 <code>&lt;dest&gt;</code> 不以 <font color="#f8070d" size=3><code>/</code></font> 结尾，则 <code>&lt;src&gt;</code> 指定的文件将被下载并直接被创建为dest；如果dest以<font color="#f8070d" size=3><code>/</code></font>结尾，则文件名URL指定的文件将被直接下载并保存为 <font color="#f8070d" size=3><code>dest/filename</code></font></p>
</li>
<li>
<p>如果src是一个本地系统上的可识别的压缩格式（identity，gzip，bzip2或xz）的本地 tar存档，则将其解压缩为目录。，其行为类似于 <font color="#f8070d" size=3><code>tar -xf</code></font> 命令；然而，从URL远程网址不会自动解压。</p>
</li>
<li>
<p>如果src有多个，或其间接或直接使用了通配符，则dest必须是一个以 <font color="#f8070d" size=3><code>/</code></font> 结尾的目录路径；如果dest不以 <font color="#f8070d" size=3><code>/</code></font> 结尾，则其被视作一个普通文件，src的内容将被直接写入到dest。</p>
</li>
</ul>
<hr>
<p><font color="#0215cd" size=3>Dockerfile中每一条指令都会生成一个新的镜像层。尽量避免很多指令</font></p>
<hr>
<h3 id="workdir">WORKDIR</h3>
<p>用于为Dockerfile中所有的 <font color="#f8070d" size=3><code>RUN</code></font>、<font color="#f8070d" size=3><code>CMD</code></font>、<font color="#f8070d" size=3><code>ENTRYPOINT</code></font>、<font color="#f8070d" size=3><code>COPY</code></font> 和 <font color="#f8070d" size=3><code>ADD</code></font> 指定设定工作目录</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">WORKDIR dirpath  
</code></pre>
<p>在Dockerfile文件中，WORKDIR指令可出现多次，其路径也可以为相对路径，不过，其是相对此前一个WORKDR指令指定的路径。另外，WORKDIR也可满用由ENV指定定义的变量</p>
<p>例如</p>
<pre><code class="language-sh">WORKDIR /var/log
WORKDIR $STATEPATH  
</code></pre>
<h3 id="volume">VOLUME</h3>
<p>用于在image中创建一个挂载点目录，以挂载Docker host上的卷或其它容器上的卷，在Dockerfile中的镜像自动指定VOLUME时，一般只能指定挂载点，不能指定宿主机文件。被称之为docker管理的卷。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">VOLUME mountpoint
</code></pre>
<pre><code class="language-sh">VOLUME [&quot;mountpoint&quot;]
</code></pre>
<p>如果挂载点目录路径下此前在文件存在，docker run命令会在卷挂载完成后将此前的所有文件复制到新挂载的卷中。</p>
<h3 id="expose">EXPOSE</h3>
<p>用于为容器打开指定要监听的端口以实现与外部通信，写在文件中的端口暴露并不会直接暴露，当<font color="#f8070d" size=3><code>docker run -P</code></font>时不用声明端口，会自动读取镜像中指定要暴露的端口，动态分配到宿主机端口上。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">EXPOSE port[/protocol] [port[/protocol]  
</code></pre>
<p>protocol用于指定传输层协议，可为tcp或udp二者之一，默认为TCP协议。</p>
<p>EXPOSE指令可一次指定多个端口，例如</p>
<pre><code class="language-sh">EXPOSE 11211/udp 11211/tcp  
</code></pre>
<h3 id="env">ENV</h3>
<p>用于为镜像定义新需的环境变量，并可被Dockerfile文件中位于其后的其它指令（如ENV、ADD、COPY等）所调用格式为 <font color="#f8070d" size=3><code>$variable_name</code></font> 或 <font color="#f8070d" size=3><code>${variable_name}</code></font>。在Dockerfile中所定义的所有环境变量，是可以在启动容器后直接在容器中使用的变量。在运行容器时更改ENV并不会影响<code>docker build</code>的值。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">ENV key value
</code></pre>
<pre><code class="language-sh">ENV key1=value1 key2=value2....    
</code></pre>
<p>第一位格式中。key之后的所有内容均会被视作其value的组成部分，因此，一次只能设置一个变量。第二种格式可用一次设置多个变量，每个变量为一个 <font color="#f8070d" size=3><code>key=value</code></font> 的键值对，如果value中包含空格，可以以反斜线（\）进行转义，也可通过对value加引号递行标识；另外，反斜线也可用于续行。</p>
<p>在定义多个变量时，建议使用第二种方式，以便在同一层中完成所有功能。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/085a742e.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>运行命令。</p>
<h3 id="run">RUN</h3>
<p>用于指定 <font color="#f8070d" size=3><code>dodker build</code></font> 过程中运行的程序，其可以是任何命令。RUN可以运行多次的，如果多个命令彼此间有关联关系，建议在一条RUN中将多个Command写进来。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">RUN command
RUN [&quot;executable&quot;，&quot;param1&quot;，&quot;param2&quot;]  
</code></pre>
<p>第一种格式中，command通常是一个shell命令，且以 <font color="#f8070d" size=3><code>/bin/sh -c</code></font> 来运行它，这意味着此进程在容器中的PID不为1，不能接枚Unix信号，因此，当使用 <font color="#f8070d" size=3><code>docker stop container </code></font> 命令停止容器时，此进程接收不到SIGTERM信号；</p>
<p>第二种语法格式中的参数是一个JSON格式的数组，其中executable为要运行的命令，后面的 <font color="#f8070d" size=3><code>paramN</code></font> 为传递给命令的选项或参数；然而，此种格式指定的命令不会以 <font color="#f8070d" size=3><code>/bin/sh -c</code></font> 来发起，因此常见的shell操作如变量替换以及通配符（，*等）替换将不会进行；不过，如果要运行的命令依赖于此shell特性的话，可以将其替换为奏似下面的格式。</p>
<pre><code class="language-sh">RUN [&quot;/bin/bash&quot; , &quot;-c&quot;，&quot;executable&quot;, &quot;param1&quot;]  
</code></pre>
<p>CMD是在镜像运行为容器时没有指定默认运行命令时所运行的命令。
RUN是在基于Dockerfile构建镜像时要运行的命令。将在docker build中运行。</p>
<h3 id="cmd">CMD</h3>
<p>类似于RUN指令，CMD指令也可用于运行任何命令或应用程序，不过，二者的运行时间点不同。RUN指令运行于镜像文件构建过程中，而CMD指令运行于基于Dockerfile构建出的新映像文件启动一个容器时</p>
<p>CMD指令的首要目的在于为启动的容器指定默认要运行的程序，且其运行结束后，容器也将终止；不过，CMD指定的命令其可以被<font color="#f8070d" size=3><code>docker run</code></font>的命令行选项所覆盖。<font style="background:#ffff00;" size=2>在Dockerfile中可以存在多个CMD指令，但仅最后一个会生效</font>。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">CMD command
</code></pre>
<pre><code class="language-sh">CMD [&quot;executable&quot; , &quot;param1&quot; , &quot;param2&quot;] 
</code></pre>
<pre><code class="language-sh">CMD [&quot;param1&quot; , &quot;param2&quot;]  
</code></pre>
<ul>
<li>使用第一种方式默认使用bin/sh -c</li>
<li>前两种语法格式的意义同RUN</li>
<li>第三种则用于为ENTRYPOINT指令提供默认参数</li>
</ul>
<h3 id="entrypoint">ENTRYPOINT</h3>
<p>在<font color="#f8070d" size=3><code>docker run</code></font>时明明指定的运行命令为nginx，但是可以执行<font color="#f8070d" size=3><code>docker run -it --rm busybox ls /</code></font>，这表示了更改了镜像中默认要运行的程序。没有运行默认程序，转而运行了指定的命令。</p>
<p>对于自定义的镜像而言，默认在运行容器时运行的命令是可以被覆盖的。而不允许在运行命令是改变默认命令CMD就无法完成，而<font color="#f8070d" size=3><code>ENTRYPOINT</code></font>可以做到</p>
<p>类似CMD指令的功能，用于为容器指定默认运行程序，从而使得容器像是一个单独的可执行程序。但是与CMD不同的是，。<font style="background:#ffff00;" size=2>由ENTRYPOINT启动的程序不会被docker run命令行指定的参数所覆盖</font>，而且，这些命令行参数会被当作参数传递给ENTRYPOINT指定的程序。当CMD和ENTRYPOINT同时存在时，CMD的内容会当做参数传给ENTRYPOINT。不过，docker run命令的&ndash;entrypoint选项的参教可覆盖ENTRYPOINT指令指定的程序。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">ENTRYPOINT command
ENTRYPOINT [&quot;executable&quot;，&quot;paraml&quot;，&quot;param2&quot;]  
</code></pre>
<p>docker run命令传入的命令参数会覆盖CMD指令的内容并且附加到ENTRYPOINT命令最后做为其参数使用，Dockerfile文件中也可以存在多个ENTRYPOINT指令，但仅有最后一个会生效</p>
<p>当同时CMD与ENTRYPOINT，在运行容器时传入参数会覆盖CMD，除非使用<code>--entrypoint选项</code>否则ENTRYPOINT不能够被覆盖。</p>
<pre><code class="language-sh">CMD [&quot;/bin/httpd&quot; , &quot;-f&quot; , &quot;-h ${WEB00C_ROOT}&quot; ]
ENTRYPOINT [&quot;/bin/sh&quot;,&quot;-c&quot;]  
</code></pre>
<p><strong>为什么非要同时使用CMD与ENTRYPOINT？</strong></p>
<ol>
<li>多数情况下ENTRYPOINT是用来指定一个shell，指定一个谁用来作为启动别的进程的服务进程。在命令行中的参数会当做他的子进程来启动。这样就可以灵活传参数被shell所解析了。</li>
<li>容器接受配置要靠环境变量，要想让应用镜像（如，nginx）在run时能够通过环境变量接受参数来决定他的配置文件（监听地址、端口、document_root），变量可以在启动容器时进行传递。</li>
</ol>
<pre><code class="language-sh">#!/bin/sh
cat &gt;/etc/nginx/conf.d/www.conf &lt;&lt; EOF 
  server{
    server name ${HOSTNAME};
    listen ${IP:-0.0.0.0}:{PORT:-80};
    root ${NGX_DOC_ROOT:-/usr/share/nginx/html};
}
EOF exec &quot;$@&quot;  
</code></pre>
<pre><code class="language-sh">FROM nginx:1.14-alpine 
LABEL maintainer=&quot;lc &lt;lc.com&gt;&quot;
ENV NGX_DOC_ROOT=&quot;/data/web/html/&quot;
ADD index.html ${NGX_DOC_ROOT}
ADD entrypoint.sh /bin/
CMD [&quot;/usr/sbin/nginx&quot; , &quot;-g&quot; , &quot;daemon off;&quot; ]
ENTRYPOINT [&quot;/bin/entrypoint.sh&quot;]
</code></pre>
<h3 id="user">USER</h3>
<p>用于指定运行image时的或运行Dockerfile中任何RUN、CMD或ENTRYPOINT指令指定的程序时的用户名或UID，默认情况下，container的运行身份为root用户</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">USER UID|UseName  
</code></pre>
<p>需要注意的是，UID可以为任意教字，但实践中必须为 <font color="#f8070d" size=3><code>/etc/passwd</code></font> 中某用户的有效UID，否则，<font color="#f8070d" size=3><code>docker run</code></font> 命令将运行失败</p>
<p>在基于某个镜像启动容器后，只要容器没转向后台（没停止），这个容器就不会停止。在docker引擎在判定容器健康与否并不是主进程能否提供服务，而仅仅判断进程是否运行。因此docker判断机制并不是真正意义上判断主进程的是否健康，需要其他工具来辅助确定。</p>
<h3 id="healthcheck">HEALTHCHECK</h3>
<p>HEALTHCHECK指令定义一个command，<font color="#f8070d" size=3><code>CMD</code></font> 为固定关键词，<font color="#f8070d" size=3><code>CMD</code></font> 后指定一个命令，这个命令用于检查容器主进程工作状态健康与否。即使主进程仍在运行，这也可以检测到陷入无限循环且无法处理新连接的Web服务器等情况。</p>
<p>HEALTHCHECK指令有</p>
<pre><code class="language-sh">HEALTHCHECK [OPTIONS] CMD command # 通过在容器内运行命令来检查容器运行状况
HEALTHCHECK NONE # 禁用任何的健康状态检查，包括默认的健康状态检测机制
</code></pre>
<p>可以在CMD之前出现的选项：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明-</th>
</tr>
</thead>
<tbody>
<tr>
<td>--interval  </td>
<td>间隔 s秒、m分钟、h小时，default:30s。</td>
</tr>
<tr>
<td>--timeout</td>
<td>执行command需要时间，比如curl一个地址，如果超过timeout秒则认为超时是错误的状态，此时每次健康检查的时间是timeout+interval秒。default:30s。</td>
</tr>
<tr>
<td>--start-period</td>
<td>在启动容器是，对主进程自我初始化较慢的情况下，default:0s。17.05引入</td>
</tr>
<tr>
<td>--retries=N</td>
<td>失败次数，default:3。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>当指定了健康检测状态命令，检测请求发出时，响应值为如下3种情况：</p>
<ul>
<li>0: 成功，容器健康且随时可用。</li>
<li>1: 不健康，容器无法正常工作。</li>
<li>2: 预留值，无意义，可以自行定义。</li>
</ul>
<p>|HEALTHCHECK&ndash;start-period=3s CMD wget-0&ndash;q http://${IP:-0.0.0.0}:10080/</p>
<p>For example</p>
<pre><code class="language-sh">  HEALTHCHECK--interval=5m --timeout=3s \
  CMD curl -f http://locdlhost/ || exit 1  
</code></pre>
<h3 id="shell">SHELL</h3>
<p>SHELL指令允许覆盖用于shell命令形式的默认shell。在Linux上的默认shell是 <font color="#f8070d" size=3><code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code></font> , 在Windows上是 <font color="#f8070d" size=3><code>[&quot;cmd&quot; , &quot;/S&quot; , &quot;/C&quot;]</code></font> 。SHELL指令必须以JSON格式写入Dockerfile。</p>
<p>SHELL指令可以多次出现。每个SHELL指令覆盖先前的SHELL指令，并影响所有后续指令。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">SHELL [&quot;executable&quot;,&quot;parameters]  
</code></pre>
<h3 id="stohsignal">STOHSIGNAL</h3>
<p>STOPSIGNAL指令设置将发送到容器的系统调用信号，以退出。此信号可以是与内核的系统调用表中的位置匹配的有效无符号数，例如9，或SIGNAME格式的信号名，例如SIGKILL。
语法：<font color="#f8070d" size=3><code>STOPSIGNAL signal</code></font></p>
<h3 id="arg">ARG</h3>
<p>ARG指令使用 <font color="#f8070d" size=3><code>--build-arg varname='value'</code></font> 标志定义一个变量，用户可以在使用<font color="#f8070d" size=3><code>docker build</code></font>命令在构建时将其传递给构建器。</p>
<p>此功能使得一个Dockerfile能够适用于较多的不同场景，尤其是应用程序版本变换时。直接传参数就能确定应该基于Dockerfile制作哪个版本。<font style="background:#fee904;" size=2>如果用户指定了未在Dockerfile中定义的构建参数，则构建会输出警告</font>。</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">ARG name = default value
</code></pre>
<ul>
<li>Dockerfile中可以包括一个或多个ARG指令。</li>
<li>ARG指令可以选择性地包括默认值：</li>
</ul>
<pre><code class="language-sh">ARG version = 1.14
ARGuser = mageedu  
</code></pre>
<h3 id="onbuild">ONBUILD</h3>
<p>用于在Dockerfile中定义一个触发器。Dockerfile用于build映像文件，此映像文件亦可作为base image被另一个Dockerfile用作FROM指令的参数，并以之构建新的映像文件</p>
<p>在后面的这个Dockerfile中的FROM指令在build过程中被执行时，将会“触发”创建其base image的Dockerfile文件中的ONBUILD指令定义的触发器</p>
<blockquote>
<p><strong>Syntax</strong>:</p>
</blockquote>
<pre><code class="language-sh">ONBUILD INSTRUCTION  
</code></pre>
<p><strong>注意</strong>：</p>
<ul>
<li>尽管任何指令都可注册成为触发器指令，但ONBUILD不能自我嵌套，且不会触发FROM和MAINTAINER指令。</li>
<li>使用包含ONBUILD指令的Dockerfle构建的镜像应该使用特殊的标签，例如ruby：2.0-onbuild</li>
<li>在ONBUILD指令中使用ADD或COPY指令应该格外小心，因为新构建过程的上下文在缺少指定的源文件时会失败。</li>
</ul>
<h2 id="四构建php环境镜像">四、构建php环境镜像</h2>
<pre><code class="language-bash">FROM  centos:6
MAINTAINER   lc
RUN  yum install -y httpd php php-gd php-mysql mysql mysql-server
ENV   MYSQL_ROOT_PASSWORD 123456
RUN   echo &quot;&lt;?php phpinfo()?&gt;&quot; &gt; /var/www/html/index.php
ADD   start.sh /start.sh
RUN  chmod +x /start.sh
ADD   https://cn.wordpress.org/wordpress-4.7.4-zh_CN.tar.gz /var/www/html
COPY   wp-config.php /var/www/html/wordpress
VOLUME   [&quot;/var/lib/mysql&quot;]
CMD   /start.sh
EXPOSE  80 3306
</code></pre>
<h2 id="五构建java环境镜像">五、构建java环境镜像</h2>
<pre><code class="language-sh">FROM centos

MAINTAINER lc
ADD jdk-8u144-linux-x64.tar.gz /usr/local
ENV JAVA_HOME=/usr/local/jdk1.8.0_144
ADD apache-tomcat-8.5.32.tar.gz /usr/local/
RUN mv /usr/local/apache-tomcat-8.5.32 /usr/local/tomcat
WORKDIR /usr/local/tomcat
ENTRYPOINT [&quot;bin/catalina.sh&quot;,&quot;run&quot;]
EXPOSE 8080  
</code></pre>
<h2 id="六构建ssh环境镜像">六、构建ssh环境镜像</h2>
<pre><code class="language-bash">FROM centos
MAINTAINER zhangsan
ENV PWD 123
RUN yum install openssh openssh-server openssh-clients -y
RUN echo $PWD|passwd --stdin root
RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
RUN ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]  
</code></pre>
<h4 id="61-测试ssh镜像">6.1 测试ssh镜像</h4>
<blockquote>
<p><strong>systemd启动</strong></p>
</blockquote>
<p>构建完镜像使用systemctl启动发现没有sshd进程</p>
<pre><code class="language-sh">$ ps
   PID TTY          TIME CMD
     1 pts/0    00:00:00 bash
    18 pts/0    00:00:00 ps
$ systemctl start ssh
Failed to get D-Bus connection: Operation not permitted
</code></pre>
<p>此问题原因：systemd服务没有启动无法使用systemd启动</p>
<p><a href="https://github.com/moby/moby/issues/7459" target="_blank"
   rel="noopener nofollow noreferrer" >Failed to get D-Bus connection: No connection to service manager</a></p>
<p>故启动时一般使用 <code>CMD [&quot;/usr/sbin/sshd&quot;,&quot;-D&quot;]</code></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker跨宿主机网络通信</title>
      <link>https://www.oomkill.com/2018/06/docker-cross-node-network/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-cross-node-network/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="docker-overlay-network">Docker Overlay Network</h2>
<p>    Overlay网络是指在不改变现有网络基础设施的前提下，通过某种约定通信协议，把二层报文封装在IP报文之上的新的数据格式。这样不但能够充分利用成熟的IP路由协议进程数据分发；而且在Overlay技术中采用扩展的隔离标识位数，能够突破VLAN的4000数量限制支持高达16M的用户，并在必要时可将广播流量转化为组播流量，避免广播数据泛滥。</p>
<p>    因此，Overlay网络实际上是目前最主流的容器跨节点数据传输和路由方案。</p>
<p><strong>要想使用Docker原生Overlay网络，需要满足下列任意条件</strong></p>
<ul>
<li><strong>Docker 运行在Swarm</strong></li>
<li><strong>使用键值存储的Docker主机集群</strong></li>
</ul>
<h2 id="使用键值存储搭建docker主机集群">使用键值存储搭建Docker主机集群</h2>
<p>使用键值存储的Docker主机集群，需满足下列条件：</p>
<ul>
<li>集群中主机连接到键值存储，Docker支持 Consul、Etcd和Zookeeper</li>
<li>集群中主机运行一个Docker守护进程</li>
<li>集群中主机必须具有唯一的主机名，因为键值存储使用主机名来标识集群成员</li>
<li>集群中linux主机内核版本在3.12+,支持VXLAN数据包处理，否则可能无法通行</li>
</ul>
<h2 id="部署docker内置的overlay网络">部署docker内置的OverLAY网络</h2>
<h3 id="环境准备说明">环境准备说明</h3>
<table>
<thead>
<tr>
<th>host</th>
<th>ip-</th>
</tr>
</thead>
<tbody>
<tr>
<td>node01</td>
<td>10.0.0.15</td>
</tr>
<tr>
<td>node02</td>
<td>10.0.0.16</td>
</tr>
</tbody>
</table>
<h3 id="安装consul">安装Consul</h3>
<p>下载地址：<a href="https://www.consul.io/downloads.html" target="_blank"
   rel="noopener nofollow noreferrer" >Download Consul</a></p>
<p>启动命令</p>
<pre><code class="language-bash">consul agent -server -bootstrap -ui -data-dir /data/docker/consul \
-client=10.0.0.16 -bind=10.0.0.16 


docker run -d -p 8400:8400 -p 8500:8500 -p 8600:53/udp -h consul progrium/consul -server -bootstrap -ui-dir /ui
 
#-ui : consul 的管理界面
#-data-dir : 数据存储
</code></pre>
<h3 id="配置docker链接consul">配置docker链接consul</h3>
<pre><code class="language-bash">ExecStart=/usr/bin/dockerd  \
-H tcp://0.0.0.0:2375 \
-H unix:///var/run/docker.sock \
--cluster-store consul://10.0.0.16:8500 \
--cluster-advertise 10.0.0.16:2375
</code></pre>
<h3 id="创建-overlay网络">创建 overlay网络</h3>
<pre><code class="language-bash">docker network create -d overlay --subnet=10.0.2.1/24 overlay-net 
</code></pre>
<p>这边自动回进行通步，因为使用的是同一个服务器发件。</p>
<pre><code class="language-bash">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
5f3ff8aceaa8        bridge              bridge              local
adb97c875132        docker_gwbridge     bridge              local
497fb0d5ea2f        host                host                local
65e001b471fe        none                null                local
f72e6fcf1082        overlay-net         overlay             global
</code></pre>
<h3 id="创建使用overlay网络的容器">创建使用overlay网络的容器</h3>
<pre><code class="language-bash">docker run -tid --name test2 --net=overlay-net centos
docker run -tid --name test3 --net=overlay-net centos
</code></pre>
<p>进入查看ip信息。</p>
<p>node01</p>
<pre><code class="language-bash">sh-4.2# ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450
        inet 10.0.2.3  netmask 255.255.255.0  broadcast 10.0.2.255
        ether 02:42:0a:00:02:03  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.18.0.2  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:02  txqueuelen 0  (Ethernet)
        RX packets 3192  bytes 12218706 (11.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2569  bytes 142308 (138.9 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1  (Local Loopback)
        RX packets 76  bytes 6960 (6.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 76  bytes 6960 (6.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<p>node02</p>
<pre><code class="language-bash">sh-4.2# ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450
        inet 10.0.2.2  netmask 255.255.255.0  broadcast 10.0.2.255
        ether 02:42:0a:00:02:02  txqueuelen 0  (Ethernet)
        RX packets 4  bytes 336 (336.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 4  bytes 336 (336.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.18.0.2  netmask 255.255.0.0  broadcast 172.18.255.255
        ether 02:42:ac:12:00:02  txqueuelen 0  (Ethernet)
        RX packets 2753  bytes 12193675 (11.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 2345  bytes 130189 (127.1 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1  (Local Loopback)
        RX packets 78  bytes 6884 (6.7 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 78  bytes 6884 (6.7 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<p>测试网络</p>
<pre><code class="language-bash">$ ping 10.0.2.3
PING 10.0.2.3 (10.0.2.3) 56(84) bytes of data.
64 bytes from 10.0.2.3: icmp_seq=1 ttl=64 time=0.349 ms


$ ping 10.0.2.2
PING 10.0.2.2 (10.0.2.2) 56(84) bytes of data.
64 bytes from 10.0.2.2: icmp_seq=1 ttl=64 time=0.023 ms
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>docker容器管理</title>
      <link>https://www.oomkill.com/2018/06/docker-ma/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-ma/</guid>
      <description></description>
      <content:encoded><![CDATA[<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-i, &ndash;interactive</td>
<td>即使不是交互模式也保持stdin打开</td>
</tr>
<tr>
<td>-d, &ndash;detach</td>
<td>后台运行容器并打印容器ID</td>
</tr>
<tr>
<td>-t, &ndash;tty</td>
<td>分配一个伪TTY</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>添加自定义主机映射</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -tid --add-host docker-node:10.0.0.1 centos
61d5824c720f1a32c743a3d0f434e17a7f6860dba1cb5559653a80c064da8073
$ docker exec 61d5824c720f1a32c cat /etc/hosts
ff02::2	ip6-allrouters
10.0.0.1	docker-node
172.17.0.2	61d5824c720f
</code></pre>
<blockquote>
<p><strong>添加linux功能</strong></p>
</blockquote>
<p>linux内核特性，提供权限访问控制。如需要特殊权限，不赋权限容器将不能正常运行。</p>
<blockquote>
<p><strong>将容器pid写入一个文件内</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -itd --cidfile /tmp/pid centos
458d9f4b3cc51a4f0f3abffbc78c643b98a89eef3cdfe263e762ac05d3f5f47d
$ cat /tmp/pid 
458d9f4b3cc51a4f0f3abffbc78c643b98a89eef3cdfe263e762ac05d3f5f47d
</code></pre>
<blockquote>
<p><strong>将主机列表添加到容器中</strong></p>
</blockquote>
<pre><code class="language-bash">--device list 
</code></pre>
<blockquote>
<p><strong>设置自定义dns</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -it centos cat /etc/resolv.conf
nameserver 10.0.0.2
nameserver 10.0.0.2
$ docker run -it --dns 8.8.8.8 centos cat /etc/resolv.conf
nameserver 8.8.8.8
</code></pre>
<blockquote>
<p><strong>设置容器的环境变量</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -itd -e &quot;TEST=abc&quot; centos
2d3ef722737a0a034151060ef2d8e97b21feee7590917a0e921c21e864d18a47
$ docker attach 2d3ef722737a0
$ echo $TEST
abc
</code></pre>
<blockquote>
<p><strong>暴露端口或指定范围的端口号</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker ps 
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
f7fd3f365512        centos              &quot;/bin/bash&quot;         5 seconds ago       Up 5 seconds        8080/tcp            wonderful_golick
</code></pre>
<blockquote>
<p><strong>为容器指定主机名</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -itd -h nginx centos
bdcdf43bf4540d1a9bb794042c6d506c2680be0eab317002697a8049c5667716
$ docker exec bdcdf43bf4540 hostname
nginx
</code></pre>
<blockquote>
<p><strong>为容器分配ip</strong></p>
</blockquote>
<p><strong>创建网络</strong></p>
<pre><code class="language-bash">$ docker network create --subnet=10.10.0.0/24 network_test
85d5f3e2cd09e2bd57bc68b56c9341f5b1d4cc1194641715937d8e197cca09f7
</code></pre>
<p><strong>查看网络</strong></p>
<pre><code class="language-bash">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
6af203aae34e        bridge                  bridge              local
b20cfc0864e6        host                     host                  local
85d5f3e2cd09        network_test        bridge               local
c287f5c1181e        none                      null                  local
</code></pre>
<p><strong>删除网络</strong></p>
<pre><code class="language-bash">$ docker network rm network_test
network_test
</code></pre>
<p><strong>指定容器网络</strong></p>
<pre><code class="language-bash">$ docker run -idt --net=network_test --ip 10.10.0.3 -h network centos
ad885aebe13fa244748c040121f849385ae5b3b8d243f76cb43695495f20c301
</code></pre>
<h5 id="查看容器信息">查看容器信息</h5>
<pre><code class="language-json">&quot;Networks&quot;: {
        &quot;network_test&quot;: {
            &quot;IPAMConfig&quot;: {
                &quot;IPv4Address&quot;: &quot;10.10.0.3&quot;
            },
            &quot;Links&quot;: null,
            &quot;Aliases&quot;: [
                &quot;ad885aebe13f&quot;
            ],
            &quot;NetworkID&quot;: &quot;c1196614dc1eec93c34774f9498ea3254084e1&quot;,
            &quot;EndpointID&quot;: &quot;a1c491b6155b104ac70194d9b1fa7ab84b6d4&quot;,
            &quot;Gateway&quot;: &quot;10.10.0.1&quot;,
            &quot;IPAddress&quot;: &quot;10.10.0.3&quot;,
            &quot;IPPrefixLen&quot;: 24,
            &quot;IPv6Gateway&quot;: &quot;&quot;,
            &quot;GlobalIPv6Address&quot;: &quot;&quot;,
            &quot;GlobalIPv6PrefixLen&quot;: 0,
                    &quot;MacAddress&quot;: &quot;02:42:0a:0a:00:03&quot;
                }
</code></pre>
<blockquote>
<p><strong>link建立容器之间的连接</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -tid --name centos centos
8f6e13a26afe60ee2ac5335d419852d70580343f590c2500964f54020e54391c

$ docker exec centos ifconfig
eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
</code></pre>
<pre><code class="language-bash">$ docker run -tid --name link --link centos:nginx.org centos
8f1a542c6058caeeb8b59e02b86e7b9cabc2bc7784d71e355f5d5ca7a6738481

$ docker exec link cat /etc/hosts
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
ff00::0	ip6-mcastprefix
ff02::1	ip6-allnodes
ff02::2	ip6-allrouters
172.17.0.2	*nginx.org* 8f6e13a26afe centos
172.17.0.3	8f1a542c6058
</code></pre>
<h2 id="log-driver">log-driver</h2>
<h3 id="docker-容器默认日志保存位置">docker 容器默认日志保存位置</h3>
<p><code>/var/lib/docker/containers/container-json.log</code></p>
<pre><code class="language-bash">$ ls -1 /var/lib/docker/containers
8f1a542c6058caeeb8b59e02b86e7b9cabc2bc7784d71e355f5d5ca7a6738481
8f6e13a26afe60ee2ac5335d419852d70580343f590c2500964f54020e54391c

$ ls -1
8f6e13a26afe60ee2ac5335d419852d70580343f590c2500964f54020e54391c-json.log
checkpoints
config.v2.json
hostconfig.json
hostname
hosts
mounts
resolv.conf
resolv.conf.hash|
$ cat 8f6e..1c-json.log 
</code></pre>
<p>可以在启动时将日志输出到指定位置。</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>none</strong></td>
<td>不输出日志</td>
</tr>
<tr>
<td><strong>json-file</strong></td>
<td>Docker的默认日志记录驱动程序，格式为JSON。</td>
</tr>
<tr>
<td><strong>syslog</strong></td>
<td>将日志消息写入syslog</td>
</tr>
<tr>
<td><strong>journald</strong></td>
<td>将日志消息写入journald。 journald守护程序必须在主机上运行。</td>
</tr>
<tr>
<td><strong>gelf</strong></td>
<td>将日志消息写入Graylog扩展日志格式（GELF）端点，例如Graylog或Logstash。</td>
</tr>
<tr>
<td><strong>fluentd</strong></td>
<td>将日志消息写入流利（正向输入）。流利的守护程序必须在主机上运行</td>
</tr>
<tr>
<td><strong>awslogs</strong></td>
<td>将日志消息写入Amazon CloudWatch Logs。</td>
</tr>
<tr>
<td><strong>splunk</strong></td>
<td>使用HTTP事件收集器将日志消息写入splunk</td>
</tr>
<tr>
<td><strong>etwlogs</strong></td>
<td>将日志消息写为Windows事件跟踪（ETW）事件。仅适用于Windows平台。</td>
</tr>
<tr>
<td><strong>gcplogs</strong></td>
<td>将日志消息写入Google Cloud Platform（GCP）日志记录。</td>
</tr>
<tr>
<td><strong>nats</strong></td>
<td>用于Docker的nats NATS日志记录驱动程序。将日志条目发布到NATS服务器。</td>
</tr>
</tbody>
</table>
<h3 id="指定日志驱动测试">指定日志驱动测试</h3>
<pre><code class="language-bash">docker run -tid --name nginx --log-driver syslog nginx
</code></pre>
<pre><code class="language-bash">curl 172.17.0.4

# 新窗口查看日志可见到容器记录到宿主机的syslog中
$ tail -f /var/log/messages 
Jul 26 01:44:18 docker-node2 systemd: Started Session 8 of user root.
Jul 26 01:44:18 docker-node2 systemd: Starting Session 8 of user root.

Jul 26 01:45:20 docker-node2 5f95cf77c994[2032]: 172.17.0.1 \
- - [25/Jul/2018:17:45:20 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;curl/7.29.0&quot; &quot;-&quot;
</code></pre>
<blockquote>
<p><strong>挂载宿主机的分区到容器</strong></p>
</blockquote>
<p><a href="https://docs.docker.com/storage/bind-mounts/#choosing-the--v-or---mount-flag" target="_blank"
   rel="noopener nofollow noreferrer" >Use bind mounts | Docker Documentation</a></p>
<blockquote>
<p><strong>将容器的端口映射到宿主机上</strong></p>
</blockquote>
<pre><code class="language-bash">docker run -itd -p 8080:80 centos
</code></pre>
<blockquote>
<p><strong>将expose声明的所有端口映射到宿主机的随机端口</strong></p>
<p>-P
<strong>容器down掉自动重启</strong></p>
</blockquote>
<pre><code class="language-bash">docker run -tid --name nginx --restart always nginx

$ docker attach nginx
^C
$ docker ps 
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS               NAMES
07b2196fb6c5        nginx               &quot;nginx -g 'daemon of…&quot;   About a minute ago   Up 4 seconds        80/tcp              nginx
</code></pre>
<blockquote>
<p><strong>设置文件描述符大小</strong></p>
</blockquote>
<pre><code class="language-bash">docker run -itd --name test --ulimit nproc=1024 --ulimit nofile=1024 centos

$ docker attach test

$ ulimit -a
open files                      (-n) 1024
max user processes              (-u) 1024
</code></pre>
<h3 id="资源限制">资源限制</h3>
<blockquote>
<p><strong>例1：限制cpu使用数量</strong></p>
</blockquote>
<pre><code class="language-bash"> docker run -tid --name cpu2 --cpus=2 centos
</code></pre>
<p><strong>使用stress测试cpu使用情况</strong></p>
<p>测试机器为双核4G硬件资源</p>
<p><em><strong>1. 限制两颗CPU</strong></em></p>
<pre><code class="language-bash">$ stress -c 13
stress: info: [70] dispatching hogs: 13 cpu, 0 io, 0 vm, 0 hdd
# 使用 docker stats 查看
docker stats cpu2
CONTAINER ID        NAME       CPU %           MEM USAGE / LIMIT      MEM %      
1eed573b906a        cpu2          199.46%           792KiB / 3.686GiB       0.02%
</code></pre>
<p>在宿主机上top查看</p>
<pre><code>%Cpu0  : 99.7 us,  0.3 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</code></pre>
<ul>
<li>将cpu增加至4核，查看cpu状态</li>
</ul>
<pre><code>%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  : 99.7 us,  0.0 sy,  0.0 ni,  0.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  : 99.7 us,  0.0 sy,  0.0 ni,  0.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</code></pre>
<p><em><strong>2. 限制1颗CPU</strong></em></p>
<p>限制容器只使用1核cpu。观察容器状态。发现容器将使用率均衡在其他核心上。</p>
<pre><code>%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  : 30.4 us,  0.0 sy,  0.0 ni, 69.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  : 19.7 us,  0.0 sy,  0.0 ni, 80.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  : 49.2 us,  0.0 sy,  0.0 ni, 50.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

%Cpu0  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  : 49.5 us,  0.0 sy,  0.0 ni, 50.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  : 49.7 us,  0.3 sy,  0.0 ni, 50.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</code></pre>
<p><strong>结论：对于进程来说是没有 CPU 个数这一概念的，内核只能通过进程消耗的 CPU 时间片来统计出进程占用 CPU 的百分比。这也是我们看到的各种工具中都使用百分比来说明 CPU 使用率的原因。</strong></p>
<p>官方文档：<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank"
   rel="noopener nofollow noreferrer" >Limit a container&rsquo;s resources | Docker Documentation</a></p>
<blockquote>
<p><strong>指定固定的 CPU</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker run -tid --name cpunum --cpuset-cpus=&quot;2&quot; stress
31d72f808e8992bcfbfead1d4d7a78e37235e1e42c8b2011b67a15d542829287
$ docker attach cpunum
$ stress -c 4

</code></pre>
<p>top查看cpu状态，发现只有固定的一个cpu被使用</p>
<pre><code class="language-bash">%Cpu0  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</code></pre>
<p>限制多个cpunum。</p>
<pre><code class="language-bash">$ docker run -tid --name cpunum2 --cpuset-cpus=&quot;0,3&quot; stress
b4cb513dad71aa9c6cc5578a70253c704dcde59a5b1306943a3967c414e2d9a9
$ docker attach cpunum2
$ stress -c 4
</code></pre>
<p>top查看cpu状态</p>
<pre><code>%Cpu0  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

</code></pre>
<blockquote>
<p><strong>设置CPU权重</strong></p>
</blockquote>
<p>当 CPU 资源充足时，设置 CPU 的权重是没有意义的。只有在容器争用 CPU 资源的情况下， CPU 的权重才能让不同的容器分到不同的 CPU 用量。&ndash;cpu-shares 选项用来设置 CPU 权重，它的默认值为 1024。我们可以把它设置为 2 表示很低的权重，但是设置为 0 表示使用默认值 1024。</p>
<pre><code class="language-bash">docker run -tid --name cpu-test1 --cpuset-cpus=&quot;0&quot; --cpu-shares=512 stress
docker run -tid --name cpu-test2 --cpuset-cpus=&quot;0&quot; --cpu-shares=0 stress
</code></pre>
<p>当只有test-1使用cpu资源时的CPU负载</p>
<pre><code class="language-bash">1717c10e24ae        cpu-test2           0.00%               376KiB / 3.686GiB   0.01%              
8a1e1a944e2b        cpu-test1           99.96%              680KiB / 3.686GiB   0.02%  
</code></pre>
<p>当test-1与test-2争用资源时的CPU负载</p>
<pre><code>1717c10e24ae        cpu-test2           66.91%              668KiB / 3.686GiB   
8a1e1a944e2b        cpu-test1           33.37%              576KiB / 3.686GiB 
</code></pre>
<p>两个容器分享一个 CPU，所以总量应该是 100%。具体每个容器分得的负载则取决于 &ndash;cpu-shares 选项的设置！我们的设置分别是 512 和 1024，则它们分得的比例为 1:2。在本例中如果想让两个容器各占 50%，只要把 &ndash;cpu-shares 选项设为相同的值就可以了。</p>
<p>对容器资源的限制 /sys/fs/cgroup/</p>
<pre><code class="language-bash">docker run -tid --name cpunum2 --cpuset-cpus=&quot;0,3&quot; stress
$ cat cpuset/cpuset.cpus
0,3
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker网络</title>
      <link>https://www.oomkill.com/2018/06/docker-network/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-network/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="docker的四种网络模式">docker的四种网络模式</h2>
<h3 id="bridge模式默认">Bridge模式（默认）</h3>
<p>当Docker进程启动时，会在宿主机上创建一个<font style="background:#fee904;" size=2>名为docker0的虚拟网桥</font>，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>默认ip段172.17.0.1/16；<font style="background:#fee904;" size=2>从docker0子网中分配一个IP给容器使用，并设置docker0的IP为容器的默认网关</font>。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<p>使用 <code>docker run -p</code> 时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用 <code>iptables -t nat -nL</code> 查看。</p>
<h3 id="host模式">host模式</h3>
<p>启动容器的时候使用host模式，那么这个容器将<font style="background:#fee904;" size=2>不会获得一个独立的Network Namespace</font>，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="none模式">none模式</h3>
<p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<h3 id="container模式">container模式</h3>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h2 id="容器外部访问原理">容器外部访问原理</h2>
<pre><code class="language-bash">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:a5ff:fe59:2034  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:42:a5:59:20:34  txqueuelen 0  (Ethernet)
        RX packets 56986  bytes 2746876 (2.6 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 64106  bytes 503304169 (479.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

</code></pre>
<pre><code class="language-bash">docker run -itd --name test_network -p 80:80 centos:6

$ iptables -t nat -nL
Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0           
MASQUERADE  tcp  --  172.17.0.2           172.17.0.2           tcp dpt:80

Chain DOCKER (2 references)
target     prot opt source               destination         
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80

</code></pre>
<h2 id="配置桥接网络">配置桥接网络</h2>
<h4 id="下载网桥管理工具">下载网桥管理工具</h4>
<pre><code class="language-bash">yum install bridge-utils -y
</code></pre>
<h4 id="停止docker并删除docker0网桥">停止docker并删除docker0网桥</h4>
<pre><code class="language-bash">ip link set dev docker0 down
brctl delbr docker0
</code></pre>
<h4 id="创建新桥接物理网络虚拟网桥test">创建新桥接物理网络虚拟网桥test</h4>
<pre><code class="language-bash">brctl addbr test
ip link set dev test up
ip addr add 10.10.10.0/24 dev test     #为br0分配物理网络中的ip地址
ip addr del 10.0.0.0/24 dev eth0 #将宿主机网卡的IP清空
brctl addif test eth0
</code></pre>
<pre><code class="language-bash">$ docker run -itd --name centos centos:6
26ea6dde6564006f148e4977d131e671b578c2c5df313b1d872940a9e48f0309

$ docker attach centos
$ ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:C0:A8:00:02  
          inet addr:192.168.0.2  Bcast:0.0.0.0  Mask:255.255.255.0
          inet6 addr: fe80::42:c0ff:fea8:2/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:7 errors:0 dropped:0 overruns:0 frame:0
          TX packets:7 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:578 (578.0 b)  TX bytes:578 (578.0 b)
</code></pre>
<p>将docker0加入网桥中</p>
<pre><code>$ brctl show
bridge name	bridge id		STP enabled	interfaces
docker0		8000.024206e55aa2	no		
</code></pre>
<pre><code class="language-bash">$ docker run -itd --net host centos
5237ae95c660a0354046f0e5ff839c9a4babda7c9743ca8f4d2338e6a8445e55

            &quot;Networks&quot;: {
                &quot;host&quot;: {
                    &quot;IPAMConfig&quot;: null,
                    &quot;Links&quot;: null,
                    &quot;Aliases&quot;: null,
                    &quot;NetworkID&quot;: &quot;b2768c9e7cb0de16cde0626abbca8414ca80c96101531aa7842dfed7ee9fc884&quot;,
                    &quot;EndpointID&quot;: &quot;645627ef6384f1f36e3cfeddd5d9346cfdf1e8997b597c2ec1edd8577e17d6f5&quot;,
                    &quot;Gateway&quot;: &quot;&quot;,
                    &quot;IPAddress&quot;: &quot;&quot;,
                    &quot;IPPrefixLen&quot;: 0,
                    &quot;IPv6Gateway&quot;: &quot;&quot;,
                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,
                    &quot;GlobalIPv6PrefixLen&quot;: 0,
                    &quot;MacAddress&quot;: &quot;&quot;,
                    &quot;DriverOpts&quot;: null
                }
            }
        }
    }
]
</code></pre>
<blockquote>
<p><strong>查看网络模式</strong></p>
</blockquote>
<pre><code class="language-bash">$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
a39cc87800d6        bridge              bridge              local
b2768c9e7cb0        host                host                local
329e3d9d1c3f        none                null                local
</code></pre>
<hr>
<p>tags: []</p>
<p>isStarred: false</p>
<p>isTrashed: false</p>
<p>修改docker0默认ip</p>
<pre><code class="language-bash">$ cat /etc/docker/daemon.json 
{
    &quot;bip&quot;: &quot;192.168.100.1/24&quot;
}
</code></pre>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.cnblogs.com/weifeng1463/p/7468497.html" target="_blank"
   rel="noopener nofollow noreferrer" >Docker Centos7 下建立 Docker 桥接网络 - weifengCorp - 博客园</a></li>
<li><a href="http://blog.51cto.com/zhaoyfcomeon/1968886" target="_blank"
   rel="noopener nofollow noreferrer" >centos7 docker宿主机配置桥接物理网络终极实战-zhaoyfcomeon-成长之路-51CTO博客</a></li>
<li><a href="https://blog.csdn.net/jackliu16/article/details/79360581" target="_blank"
   rel="noopener nofollow noreferrer" >docker自定义网桥 - CSDN博客</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>macvlan实现docker跨宿主机访问</title>
      <link>https://www.oomkill.com/2018/06/docker-cross-node-network-macvlan/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/docker-cross-node-network-macvlan/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="关于vlan说明">关于vlan说明</h2>
<p>Macvlan和ipvlan是Linux网络驱动程序，它们将底层或主机接口直接暴露给在主机中运行的VM或容器。</p>
<p>Macvlan允许单个物理接口使用macvlan子接口具有多个mac和ip地址。这与使用vlan在物理接口上创建子接口不同。使用vlan子接口，每个子接口使用vlan属于不同的L2域，所有子接口都具有相同的mac地址。使用macvlan，每个子接口将获得唯一的mac和ip地址，并将直接暴露在底层网络中。Macvlan接口通常用于虚拟化应用程序，每个macvlan接口都连接到Container或VM。每个容器或VM可以直接从公共服务器获取dhcp地址，就像主机一样。这将有助于希望Container成为传统网络的客户使用他们已有的IP寻址方案。Macvlan有4种类型(Private, VEPA, Bridge, Passthru)。常用的类型是Macvlan网桥，它允许单个主机中的端点能够在没有数据包离开主机的情况下相互通信。对于外部连接，使用底层网络。下图显示了两个使用macvlan网桥相互通信以及外部世界的容器。两个容器将使用Macvlan子接口直接暴露在底层网络中。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/24ffba73.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="使用mavvlan构建docker网络">使用mavvlan构建docker网络</h2>
<p>Macvlan，MACVLAN或MAC-VLAN允许您在单个物理接口上配置多个第2层（即以太网MAC）地址。 Macvlan允许您配置父物理以太网接口（也称为上层设备）的子接口（也称为从设备），<font style="background:#ffff00;" size=3>每个接口都有自己唯一的（随机生成的）MAC地址，因此也有自己的IP地址</font>。然后，应用程序、VM和容器可以绑定到特定的子接口，以使用自己的MAC和IP地址直接连接到物理网络。</p>
<p><font style="background:#ffff00;" size=2>Mavlan子接口不能直接与父接口通信</font>，即VM不能直接与主机通信。如果需要VM主机通信，则应添加另一个macvlan子接口并将其分配给主机。</p>
<p>Macvlan子接口使用 <font color="#f8070d" size=3><code>eth0.20@eth0</code></font> 表示法来清楚地识别子接口及其父接口。子接口状态绑定到其父级状态。如果eth0关闭，则 <font color="#f8070d" size=3><code>eth0.20@eth0</code></font> 也会关闭。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/49435814.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="配置macvlan先决条件">配置macvlan先决条件</h3>
<ul>
<li>至少需要Linux内核版本3.9以上，建议使用4.0或更高版本。</li>
</ul>
<h3 id="环境准备">环境准备</h3>
<table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>地位</th>
<th>软件环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理机</td>
<td>10.0.0.1</td>
<td>物理机</td>
<td>windows10</td>
</tr>
<tr>
<td>网关</td>
<td>10.0.0.2</td>
<td>宿主机网关</td>
<td>vmvare网关</td>
</tr>
<tr>
<td>c1</td>
<td>10.0.0.3</td>
<td>容器01</td>
<td>docker</td>
</tr>
<tr>
<td>c2</td>
<td>10.0.0.4</td>
<td>容器02</td>
<td>docker</td>
</tr>
<tr>
<td>node01</td>
<td>10.0.0.15</td>
<td>宿主机01（vm虚拟机）</td>
<td>centos 7.3/docker-ce1806</td>
</tr>
<tr>
<td>node02</td>
<td>10.0.0.16</td>
<td>宿主机02（vm虚拟机）</td>
<td>centos 7.3/docker-ce1806</td>
</tr>
</tbody>
</table>
<h3 id="23-启动网卡混合模式">2.3 启动网卡混合模式</h3>
<p>两台主机网卡使用桥接模式,网卡混杂模式开启全部允许。</p>
<p>主机上配置的eth0网卡和创建的vlan网卡,均需要开启混杂模式。如果不开启混杂模式会导致macvlan网络无法访问外界,具体在不使用vlan时,表现为无法ping通路由,无法ping通同一网络内其他主机。</p>
<pre><code class="language-sh">ip link set eth0 promisc on
ip link set eth0  promisc off
</code></pre>
<p>开启后查看网卡状态</p>
<pre><code class="language-sh">$ ip addr
2: eth0: &lt;BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0c:29:84:f3:29 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.15/24 brd 10.0.0.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe84:f329/64 scope link 
       valid_lft forever preferred_lft forever
</code></pre>
<p>其中<font color="#f8070d" size=3><code>BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP</code></font>的<font color="#f8070d" size=3><code>PROMISC</code></font>说明网卡eth0已开启成混杂模式。</p>
<hr>
<p>注：以上设置临时生效</p>
<hr>
<h3 id="基于macvlan构建docker跨宿主机通讯">基于macvlan构建docker跨宿主机通讯</h3>
<pre><code class="language-sh">docker network create \
-d macvlan \
--subnet=10.10.0.0/24 \
--gateway=10.10.0.254 \
-o parent=eth0 mvl1
</code></pre>
<hr>
<p><font color="#0215cd" size=3> 说明：容器默认使用主机的DNS设置，因此无需配置DNS服务器。</font></p>
<hr>
<p>查看创建结果</p>
<pre><code class="language-sh">$ docker network ls 
NETWORK ID          NAME                DRIVER              SCOPE
3d2449dfe4b1        bridge              bridge              local
7110f9183457        host                host                local
9852fc2a7109        mvl1                macvlan             local
</code></pre>
<p>在node01上运行容器</p>
<pre><code class="language-sh">docker run -tid --name c1 --net mvl1 --ip 10.10.0.1 busybox
</code></pre>
<p>在node02上运行容器</p>
<pre><code class="language-sh">docker run -tid --name c2 --net mvl1 --ip 10.10.0.2 busybox
</code></pre>
<p>在C1上平C2 检查结果</p>
<pre><code class="language-sh">/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:0A:0A:00:01  
          inet addr:10.10.0.1  Bcast:10.10.0.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1 
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

/ # ping 10.10.0.2
PING 10.10.0.2 (10.10.0.2): 56 data bytes
64 bytes from 10.10.0.2: seq=0 ttl=64 time=0.397 ms
64 bytes from 10.10.0.2: seq=1 ttl=64 time=0.278 ms
</code></pre>
<h3 id="构建macvlan与宿主机同网段docker网络">构建macvlan与宿主机同网段docker网络</h3>
<blockquote>
<p><strong>在两台主机上分别创建docker网络</strong></p>
</blockquote>
<pre><code class="language-sh">docker network create -d macvlan --subnet=10.0.0.0/24 --gateway=10.0.0.2 -o parent=eth0 mvl1
</code></pre>
<p>说明：</p>
<ul>
<li><font color="#f8070d" size=3><code>--gateway</code></font>为宿主机的网关，如宿主机为物理机则设置路由器的ip。</li>
<li><font color="#f8070d" size=3><code>--subnet</code></font>为宿主机所在网段。</li>
</ul>
<blockquote>
<p><strong>在两台主机上分别创建容器</strong></p>
</blockquote>
<pre><code class="language-sh">docker run -ti --net mvl1 --ip 10.0.0.4 busybox
docker run -ti --net mvl1 --ip 10.0.0.3 busybox
</code></pre>
<blockquote>
<p><strong>测试网络连通情况</strong></p>
</blockquote>
<p>ping网关，结论：通。</p>
<pre><code class="language-sh">/ # ping 10.0.0.2
PING 10.0.0.2 (10.0.0.2): 56 data bytes
64 bytes from 10.0.0.2: seq=0 ttl=128 time=0.330 ms
</code></pre>
<p>ping宿主机，结论：不通。</p>
<pre><code class="language-sh">/ # ping 10.0.0.15
PING 10.0.0.15 (10.0.0.15): 56 data bytes
</code></pre>
<p>ping其他宿主机，结论：通。</p>
<pre><code class="language-sh">/ # ping 10.0.0.16
PING 10.0.0.16 (10.0.0.16): 56 data bytes
64 bytes from 10.0.0.16: seq=0 ttl=64 time=0.530 ms
</code></pre>
<p>ping其他容器，结论：通。</p>
<pre><code class="language-sh">/ # ping 10.0.0.3
PING 10.0.0.3 (10.0.0.3): 56 data bytes
64 bytes from 10.0.0.3: seq=0 ttl=64 time=0.435 ms
</code></pre>
<h2 id="带有vlan的macvlan">带有VLAN的macvlan</h2>
<h3 id="说明">说明</h3>
<p>单个Docker主机网络接口只能作为一个macvlan或ipvlan网络的父接口。然而，一个macvlan，一个第2层域和每个物理接口一个子网是现代虚拟化解决方案中相当严重的限制。幸运的是，Docker主机子接口可以作为macvlan网络的父接口。这与VLAN的Linux实现完全一致，其中802.1Q中继连接上的每个VLAN都在物理接口的子接口上。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/36a2cb7d.png" alt="image" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="vlan介绍">vlan介绍</h3>
<p>VLAN(Virtual Local Area Network)又称虚拟局域网，是指在局域网的基础上，采用网络管理软件构建的可跨越不同网段、不同网络的端到端的逻辑网络。</p>
<p>一个VLAN组成一个逻辑子网，即一个逻辑广播域，它可以覆盖多个网络设备，允许处于不同地理位置的网络用户加入到一个逻辑子网中。使用VLAN功能后，能够将网络分割成多个广播域。</p>
<p>Linux支持在物理网卡上创建vlan子接口。每个vlan子接口属于不同的二层域，所有的vlan子接口拥有相同的MAC地址。这点是和Macvlan子接口不同的地方。</p>
<blockquote>
<p><strong>vlan范围说明</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>范围</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0，4095</td>
<td>保留 仅限系统使用 用户不能查看和使用这些VLAN</td>
</tr>
<tr>
<td>1 正常</td>
<td>Cisco默认VLAN 用户能够使用该VLAN，但不能删除它</td>
</tr>
<tr>
<td>2-1001</td>
<td>正常 用于以太网的VLAN 用户可以创建、使用和删除这些VLAN</td>
</tr>
<tr>
<td>1002-1005</td>
<td>正常 用于FDDI和令牌环的Cisco默认VLAN 用户不能删除这些VLAN</td>
</tr>
<tr>
<td>1006-1024</td>
<td>保留 仅限系统使用 用户不能查看和使用这些VLAN</td>
</tr>
<tr>
<td>1025-4094</td>
<td>扩展 仅用于以太网VLAN</td>
</tr>
</tbody>
</table>
<h3 id="环境准备-1">环境准备</h3>
<table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>地位</th>
<th>软件环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1</td>
<td>10.10.0.1</td>
<td>容器01-02</td>
<td>docker</td>
</tr>
<tr>
<td>c2</td>
<td>10.10.0.2</td>
<td>容器01-02</td>
<td>docker</td>
</tr>
<tr>
<td>c3</td>
<td>10.10.0.3</td>
<td>容器02-01</td>
<td>docker</td>
</tr>
<tr>
<td>c4</td>
<td>10.10.0.4</td>
<td>容器02-02</td>
<td>docker</td>
</tr>
<tr>
<td>gateway01</td>
<td>10.0.0.253</td>
<td>容器01网关</td>
<td></td>
</tr>
<tr>
<td>gateway01</td>
<td>10.0.0.254</td>
<td>容器01网关</td>
<td></td>
</tr>
<tr>
<td>node01</td>
<td>10.0.0.15</td>
<td>宿主机01（vm虚拟机）</td>
<td>centos 7.3/docker-ce1806</td>
</tr>
<tr>
<td>node02</td>
<td>10.0.0.16</td>
<td>宿主机02（vm虚拟机）</td>
<td>centos 7.3/docker-ce1806</td>
</tr>
</tbody>
</table>
<h3 id="创建vlan">创建VLAN</h3>
<blockquote>
<p><strong>为node01物理网卡创建macvlan子接口</strong></p>
</blockquote>
<pre><code class="language-sh">ip link add link eth0 name eth0.100 type vlan id 100
ip link add link eth0 name eth0.200 type vlan id 200
</code></pre>
<blockquote>
<p><strong>启用macvlan</strong></p>
</blockquote>
<pre><code class="language-sh">ip link set eth0.100 up
ip link set eth0.200 up
</code></pre>
<blockquote>
<p><strong>设置macvlan的ip和网关</strong></p>
</blockquote>
<pre><code>ip addr add 10.10.0.254/24 dev eth0.100
ip addr add 10.20.0.254/24 dev eth0.200

ip route add default via 10.10.0.254 dev eth0.100
ip route add default via 10.20.0.254 dev eth0.200
</code></pre>
<h2 id="参考网址">参考网址</h2>
<p><a href="https://raid-zero.com/2017/08/02/exploring-docker-networking-host-none-and-macvlan/3/" target="_blank"
   rel="noopener nofollow noreferrer" >Exploring Docker Networking – Host, None, and MACVLAN | raid-zero.com | Page 3</a></p>
<p><a href="http://hicu.be/docker-networking-macvlan-vlan-configuration" target="_blank"
   rel="noopener nofollow noreferrer" >Docker Networking: macvlans with VLANs – HiCube</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>容器的资源限制</title>
      <link>https://www.oomkill.com/2018/06/container-limit/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/container-limit/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>默认情况下，容器没有任何资源限制，因此几乎耗尽docker主机之上，内核可分配给当前容器的所有资源。可以使用主机内核调度程序允许的尽可能多的给定资源。在此基础上Docker provides提供了控制容器可以使用多少内存，CPU或块IO的方法，设置docker run命令的运行时配置标志。</p>
<p>容器得以实现主要依赖于内核中的两个属性<font color="#f8070d" size=3><code>namespace cgroup</code></font>。其中许多功能都要求您的内核支持Linux功能。要检查支持，可以使用<code>docker info</code>命令。</p>
<p>Memory
OOME</p>
<p>在Linux主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出OOME或<code>Out of Memory Exception</code>异常，并开始终止进程以释放内存资源。一旦发生OOME，任何进程都有可能被杀死，包括docker daemon自身在内。为此，Docker特地调整了docker daemon的OOM优选级，以免它被内核“正法”，但容器的优选级并未被调整。</p>
<p>工作逻辑为</p>
<p>在宿主机上跑有很多容器并包括系统级进程。系统级进程也包括docke daemon自身。当内核执行系统管理操作，如内核需要使用内存，发现可以内存已经为空，会启动评估操作，评估谁占用内存高。我们认为哪个资源占用内存高就该将其kill来释放内存空间。（需要注意的是占用内存高的进程也不一定被kill掉。A进程分配10G已使用5G，进程B分配1G已使用1G。A只使用50%内存，而B已经耗尽所有内存）。内核会提供这些进程进行评分，按照优先级逆序强制kill，直至可使用内存空间足够。此时内核就可以使用内存资源创建其他进程。</p>
<p>每一个进程被计算之后会有一个oom scores，得分越高就会被优先kill。得分是由内存申请分配空间等一系列复杂计算得知。当进程得分最高也不能被kill掉时，如docker daemon，此时需要调整优先级。每一个进程有一个oom.adj的参数，将优先级调整越低，计算的分数就越少。</p>
<p>在docker run时可以直接调整容器的OOM.adj参数。如果想限制容器能使用多少内存资源、或CPU资源，有专门的选项可以实现。非常重要的容器化应用需要在启动容器时调整其OOM.adj，还可以定义容器的策略，一旦被kill直接restart</p>
<p><a href="https://docs.docker.com/config/containers/resource_constraints/#limit-a-containers-access-to-memory" target="_blank"
   rel="noopener nofollow noreferrer" >Limit a container&rsquo;s resources</a></p>
<p>限制一个容器能使用多少内存资源或CPU资源docker有专门的选项来实现</p>
<p><code>-m</code> 限制容器可用RAM空间。选项参数可以使用KB M G等作为接受单位使用。可单独使用。</p>
<p><code>--memory-swap</code> 设置容器可用交换分区大小。使用swap允许容器在容器耗尽可用的所有RAM时将多余的内存需求写入磁盘。<code>--memory-swap</code>是一个修饰符标志，只有在设置了&ndash;memorys时才有意义。</p>
<p><code>--memory-swap</code></p>
<table>
<thead>
<tr>
<th>--memory-swap</th>
<th style="text-align:left">--memory</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>正数S</td>
<td style="text-align:left">正数 M     </td>
<td>容器可用总空间为S，其中可用ram为M</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:left">正数</td>
<td>M相当于未设置swap（unset）</td>
</tr>
<tr>
<td>unset（未设置）</td>
<td style="text-align:left">正数 M</td>
<td>若主机（Docker Host）启用了swap，则容器的可用swap为 <code>2*M</code></td>
</tr>
<tr>
<td>-1</td>
<td style="text-align:left">正数M</td>
<td>若主机（Docker Host）启用了swap，则容器可使用交换分区总空间大小为宿主机上的所有swap空间的swap资源</td>
</tr>
<tr>
<td></td>
<td style="text-align:left"></td>
<td>注意：在容器内使用free命令可以看到的swap空间并不具有其所展现出的空间指示意义。</td>
</tr>
</tbody>
</table>
<p>&ndash;memory-swappiness</p>
<p>用来限定容器使用交换分区的倾向性。</p>
<p>&ndash;memory-reservation</p>
<p>预留的内存空间</p>
<p>&ndash;oom-kill-disable</p>
<p>禁止oom被kill掉</p>
<p>默认情况下，每个容器对主机CPU周期的访问权限是不受限制的。可以设置各种约束来限制给定容器访问主机的CPU周期。大多数用户使用和配置默认CFS调度程序。在Docker 1.13及更高版本中，还可以配置实时调度程序。
<a href="https://docs.docker.com/config/containers/resource_constraints/#cpu" target="_blank"
   rel="noopener nofollow noreferrer" >CPU Limit a container&rsquo;s resources</a></p>
<p>内核中进程管理子系统当中最重要的组件为进程角度器scheduler，非实时优先级,有效范围为100-139[-20,19]。因此每个进程的默认优先级为120。实时优先级0-99。调度100-139之间的进程有个非常重要的调度器CFS scheduler（完全公平调度器），公平调度每一个进程在需要执行时，去分配scores到这个进程上。</p>
<p>在各容器之间分配CPU资源选项：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&ndash;cpu-shares</td>
<td>限制CPU使用个数的参数按比例切分当前系统上可用cpu资源。<br>例如：当前系统上运行2各容器，第一个为1024，第二个为512。这两个容器都尽可能多个使用CPU，会将CPU资源分3份，1024占2份，第二个容器占1份。可随时按比例调整CPU资源。</td>
</tr>
<tr>
<td>&ndash;cups</td>
<td>指定容器可以使用的可用CPU资源量。例如，如果主机有两个CPU并且已设置&ndash;cpus=&ldquo;1.5&rdquo;，则容器最多保证1.5个CPU。例如：4核CPU，4个使用总量为1.5而不是0使用100%，1使用50%。</td>
</tr>
<tr>
<td>&ndash;cpuset-cpus</td>
<td>限制CPU使用范围的参数。限制容器可以使用的特定CPU或核心。当有多个CPU，则容器可以使用的以逗号分隔的列表或连字符分隔的CPU范围。第一个CPU编号为0.有效值可能是0-3 <code>1,3</code>使用第二个和第四个CPU。</td>
</tr>
</tbody>
</table>
<p>docker pull lorel/docker-stress-ng</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用weave实现docker跨宿主机通讯</title>
      <link>https://www.oomkill.com/2018/06/weave-over-host/</link>
      <pubDate>Sat, 02 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/06/weave-over-host/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>项目地址：https://github.com/weaveworks/weave</p>
<blockquote>
<p>注：weave公司与2024年关门</p>
</blockquote>
<h2 id="weaves说明">weaves说明</h2>
<p>Weave是由weaveworks公司开发的解决Docker跨主机网络的解决方案，它能够创建一个虚拟网络，用于连接部署在多台主机上的Docker容器，这样容器就像被接入了同一个网络交换机，那些使用网络的应用程序不必去配置端口映射和链接等信息。</p>
<p>外部设备能够访问Weave网络上的应用程序容器所提供的服务，同时已有的内部系统也能够暴露到应用程序容器上。Weave能够穿透防火墙并运行在部分连接的网络上，另外，Weave的通信支持加密，所以用户可以从一个不受信任的网络连接到主机。</p>
<h3 id="weaves实现原理">weaves实现原理</h3>
<p><code>weave launch</code>初始化时会自动下载三个docker容器来辅助运行，并且创建linux网桥与docker网络</p>
<p>weave 运行了三个容器：</p>
<ul>
<li>weave 是主程序，负责建立<code>weave</code>网络，收发数据，提供 DNS 服务等。</li>
<li>weavevolumes容器提供卷存储</li>
<li>weavedb容器提供数据存储</li>
</ul>
<pre><code class="language-sh">$ docker images
REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
weaveworks/weavedb     latest              15c78a9b1895        4 weeks ago         698B
weaveworks/weaveexec   2.4.0               bf0c403ea58d        4 weeks ago         151MB
weaveworks/weave       2.4.0               7aa67bc6bc43        4 weeks ago         96.7MB
   
</code></pre>
<p>自动创建网桥</p>
<pre><code class="language-sh">$ brctl show
bridge name	      bridge id		       STP enabled	interfaces
docker0		        8000.02426cf29450	 no		
docker_gwbridge		8000.02420cb2e439	 no	 
weave		          8000.a2ec14f583ef	 no	 vethwe-bridge
</code></pre>
<ul>
<li>datapath：是一个openvswitch</li>
<li>vethwe-datapath@vethwe-bridge：是veth pair</li>
<li>vethwe-datapath：父设备是datapath</li>
<li>vxlan-6784：是vxlan interface，其maste也是datapath，weave主机之间通过Vxlan节能型通信</li>
</ul>
<pre><code class="language-sh">$ ifconfig
datapath: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1376
        inet6 fe80::e45d:12ff:fee2:9d69  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether e6:5d:12:e2:9d:69  txqueuelen 1000  (Ethernet)
        RX packets 19  bytes 1060 (1.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 648 (648.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:24:0d:54:06  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

docker_gwbridge: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500
        inet 172.18.0.1  netmask 255.255.0.0  broadcast 172.18.255.255
        inet6 fe80::42:52ff:fe25:3b18  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:42:52:25:3b:18  txqueuelen 0  (Ethernet)
        RX packets 1032  bytes 89148 (87.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1032  bytes 89148 (87.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth0: flags=4419&lt;UP,BROADCAST,RUNNING,PROMISC,MULTICAST&gt;  mtu 1500
        inet 10.0.0.15  netmask 255.255.255.0  broadcast 10.0.0.255
        inet6 fe80::20c:29ff:fe84:f329  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 00:0c:29:84:f3:29  txqueuelen 1000  (Ethernet)
        RX packets 97077  bytes 109615069 (104.5 MiB)
        RX errors 0  dropped 244  overruns 0  frame 0
        TX packets 21805  bytes 3174138 (3.0 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;
        loop  txqueuelen 1  (Local Loopback)
        RX packets 1032  bytes 89148 (87.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1032  bytes 89148 (87.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

vethwe-bridge: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1376
        inet6 fe80::f056:b7ff:fe0f:c146  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether f2:56:b7:0f:c1:46  txqueuelen 0  (Ethernet)
        RX packets 272  bytes 25496 (24.8 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 275  bytes 25670 (25.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

vethwe-datapath: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1376
        inet6 fe80::c495:98ff:fec0:508d  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether c6:95:98:c0:50:8d  txqueuelen 0  (Ethernet)
        RX packets 1032  bytes 89148 (87.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1032  bytes 89148 (87.0 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

vxlan-6784: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 65470
        ether 7a:a1:d9:e9:f7:39  txqueuelen 1000  (Ethernet)
        RX packets 513  bytes 372948 (364.2 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 520  bytes 379884 (370.9 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

weave: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1376
        inet6 fe80::469:deff:fe6b:f186  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 06:69:de:6b:f1:86  txqueuelen 1000  (Ethernet)
        RX packets 19  bytes 1060 (1.0 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8  bytes 648 (648.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
</code></pre>
<pre><code class="language-sh">$  docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
0ca046b6232c        bridge              bridge              local
776a38c5868e        docker_gwbridge     bridge              local
51bfcaafee94        weave               weavemesh           local

</code></pre>
<p>自动创建docker网络<code>weave</code></p>
<pre><code class="language-sh">$ brctl show
bridge name	      bridge id		        STP enabled	  interfaces
docker0		        8000.0242240d5406	  no		
docker_gwbridge		8000.024252253b18	  no		         vethcb0a2e3
weave		          8000.0669de6bf186	  no		         vethwe-bridge
							                                       vethwl95e206ea7
</code></pre>
<p>查看<code>weave</code>网络的信息dirver为<code>&quot;Driver&quot;: &quot;weavemesh&quot;</code></p>
<pre><code class="language-sh">$ docker network inspect weave
[
    {
        &quot;Name&quot;: &quot;weave&quot;,
        &quot;Id&quot;: &quot;522dd1c8152750aa5862bdcc3c025bb07b9d66410f267503ae9c4305363d5a82&quot;,
        &quot;Created&quot;: &quot;2018-08-27T17:27:37.265691267+08:00&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;weavemesh&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;weavemesh&quot;,
            &quot;Options&quot;: null,
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;10.32.0.0/12&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {},
        &quot;Options&quot;: {
            &quot;works.weave.multicast&quot;: &quot;true&quot;
        },
        &quot;Labels&quot;: {}
    }
]
</code></pre>
<p>Weave网络会在每个宿主机上创建一个网桥，每个容器通过veth pair连接到这个Weave 网桥。容器里面的veth网卡会获取到Weave网络分配给的IP地址和子网掩码。每当容器启动时，会创建两个网络接口。<code>eth0if51</code> 与<code>docker_gwbridge</code> 同属于一个网段。</p>
<pre><code class="language-sh">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
48: ethwe0@if49: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1376 qdisc noqueue 
    link/ether 3e:78:8b:2e:c9:4b brd ff:ff:ff:ff:ff:ff
    inet 10.40.0.0/12 brd 10.47.255.255 scope global ethwe0
       valid_lft forever preferred_lft forever
50: eth0@if51: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</code></pre>
<p>其中<code>ethwe0@if49</code>，从名称上看出与weave相关，其对应的编号是48。我们从宿主机上面ip link进行查看，<code>ethwe0@if49</code>与<code>vethwle9c9e24ce@if48</code>是一对veth pair，而且被挂在了weave网桥上</p>
<pre><code class="language-sh">49: vethwle9c9e24ce@if48: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1376 qdisc noqueue master weave state UP 
    link/ether 1a:c5:52:37:66:72 brd ff:ff:ff:ff:ff:ff link-netnsid 1
    inet6 fe80::18c5:52ff:fe37:6672/64 scope link 
       valid_lft forever preferred_lft forever
51: veth9c86c85@if50: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker_gwbridge state UP 
    link/ether da:57:cc:0c:7d:32 brd ff:ff:ff:ff:ff:ff link-netnsid 1
    inet6 fe80::d857:ccff:fe0c:7d32/64 scope link 
       valid_lft forever preferred_lft forever
</code></pre>
<pre><code class="language-sh">weave		8000.a2ec14f583ef	no		vethwe-bridge
							                  vethwle9c9e24ce

</code></pre>
<h2 id="weave安装配置">weave安装配置</h2>
<p>项目地址：https://github.com/weaveworks/weave</p>
<h3 id="环境准备">环境准备</h3>
<p>环境要求：</p>
<ul>
<li>linux内核版本为3.8以上</li>
<li>dockers版本为1.10.0或更高</li>
</ul>
<table>
<thead>
<tr>
<th>主机名</th>
<th>IP地址</th>
<th>软件环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>node01</td>
<td>10.0.0.15</td>
<td>docker-1806 weare</td>
</tr>
<tr>
<td>node02</td>
<td>10.0.0.16</td>
<td>docker-1806 weare</td>
</tr>
</tbody>
</table>
<h3 id="下载安装weave">下载安装weave</h3>
<p>Weave不需要集中式的key-value存储，所以安装和运行都很简单。直接把Weave二进制文件下载到系统中就可以了。主从节点都需要安装。</p>
<pre><code class="language-sh">wget -O /usr/local/bin/weave \
https://github.com/weaveworks/weave/releases/download/v2.4.0/weave &amp;&amp; \
chmod +x /usr/local/bin/weave
</code></pre>
<h2 id="reference">Reference</h2>
<p>1 <a href="https://www.cnblogs.com/bigberg/p/8694971.html" target="_blank"
   rel="noopener nofollow noreferrer" >Docker网络 Weave - Bigberg - 博客园</a></p>
<p>2 <a href="https://thenewstack.io/end-of-an-era-weaveworks-closes-shop-amid-cloud-native-turbulence/" target="_blank"
   rel="noopener nofollow noreferrer" >End of an Era: Weaveworks Closes Shop Amid Cloud Native Turbulence</a></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
