<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/tags/go/</link>
    <description>Recent content in go on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 21 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Goswagger - Skipping &#39;&#39;, recursion detected</title>
      <link>https://www.oomkill.com/2024/09/goswagger-skipping-recursion-detected/</link>
      <pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/09/goswagger-skipping-recursion-detected/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>问题：当使用的结构体为嵌套格式，会提示 <code>recursion detected</code> 或 <code>cannot find type definition</code></p>
<pre><code class="language-go">type Instance struct {
	metav1.TypeMeta
	Instances       []InstanceItem    `json:&quot;instances&quot; yaml:&quot;instances&quot; form:&quot;instances&quot; binding:&quot;required&quot;`
	ServiceSelector map[string]string `json:&quot;serivce_selector&quot; yaml:&quot;serivce_selector&quot; form:&quot;serivce_selector&quot;`
}

type InstanceItem struct {
	Name         string            `json:&quot;name&quot; yaml:&quot;name&quot; form:&quot;name&quot; binding:&quot;required&quot;`
	PromEndpoint string            `json:&quot;prom_endpoint&quot; yaml:&quot;prom_endpoint&quot; form:&quot;prom_endpoint&quot; binding:&quot;required&quot;`
	Labels       map[string]string `json:&quot;labels&quot; yaml:&quot;labels&quot; form:&quot;labels&quot;`
}
</code></pre>
<p>go swagger 注释为</p>
<pre><code>// deleteInstance godoc
// @Summary Remove prometheus instance.
// @Description Remove prometheus instance.
// @Tags Instances
// @Accept json
// @Produce json
// @Param query body instance.Instance false &quot;body&quot;
// @securityDefinitions.apikey BearerAuth
// @Success 200 {object} interface{}
// @Router /ph/v1/instance [DELETE]
</code></pre>
<p>执行命令时报错如下：</p>
<pre><code class="language-bash">$ swag init -g cmd/ph-server/main.go --output ./docs/  --packageName docs
2024/09/22 19:56:19 Generate swagger docs....
2024/09/22 19:56:19 Generate general API Info, search dir:./
2024/09/22 19:56:19 warning: failed to get package name in dir: ./, error: execute go list command, exit status 1, stdout:, stderr:no Go files in /mnt/d/src/go/work/prometheus-hub
2024/09/22 19:56:19 Generating instance.Instance
2024/09/22 19:56:19 Error parsing type definition 'instance.Instance': : cannot find type definition: metav1.TypeMeta
2024/09/22 19:56:19 Skipping 'instance.Instance', recursion detected.
2024/09/22 19:56:19 Skipping 'instance.Instance', recursion detected.
2024/09/22 19:56:19 Skipping 'instance.Instance', recursion detected.
2024/09/22 19:56:19 Generating target.TargetItem
</code></pre>
<p>解决： <code>--parseDependency </code></p>
<pre><code class="language-bash">$ swag init -g cmd/ph-server/main.go --output ./docs/  \
	--packageName docs  \
	--parseDependency --parseInternal
	
2024/09/22 20:20:40 Generate swagger docs....
2024/09/22 20:20:40 Generate general API Info, search dir:./
2024/09/22 20:20:40 warning: failed to get package name in dir: ./, error: execute go list command, exit status 1, stdout:, stderr:no Go files in /mnt/d/src/go/work/prometheus-hub
2024/09/22 20:20:41 warning: failed to evaluate const mProfCycleWrap at /usr/local/go/src/runtime/mprof.go:165:7, reflect: call of reflect.Value.Len on zero Value
2024/09/22 20:20:41 Generating github_com_cylonchau_prometheus-hub_pkg_apis_instance.Instance
2024/09/22 20:20:41 Generating github_com_cylonchau_prometheus-hub_pkg_apis_meta_v1.TypeMeta
2024/09/22 20:20:41 Generating github_com_cylonchau_prometheus-hub_pkg_apis_instance.InstanceItem
</code></pre>
<h2 id="reference">Reference</h2>
<p><a href="https://stackoverflow.com/questions/65947311/how-to-use-a-type-definition-in-another-file-with-swaggo" target="_blank"
   rel="noopener nofollow noreferrer" >How to use a type definition in another file with swaggo?</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Gin - 参数默认值问题</title>
      <link>https://www.oomkill.com/2024/09/gin-param-default-value/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/09/gin-param-default-value/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>遇到问题：gin 使用 Bind 时无法填充，改成下面代码可以获取到</p>
<pre><code class="language-go">type User struct {
	Name string `form:&quot;name,default=user1&quot; json:&quot;name,default=user2&quot;`
	Age  int    `form:&quot;age,default=10&quot; json:&quot;age,default=20&quot;`
}

r := gin.Default()

// way1 curl 127.0.0.1:8900/bind?name=aa
// way2 curl -X POST 127.0.0.1:8900/bind -d &quot;name=aa&amp;age=30&quot;
// way3 curl -X POST 127.0.0.1:8900/bind -H &quot;Content-Type: application/json&quot; -d &quot;{\&quot;name\&quot;: \&quot;aa\&quot;}&quot;
r.Any(&quot;/bind&quot;, func(c *gin.Context) {
    var user User
    //user = User{Name: &quot;bb&quot;, Age: 11} //way4:A variable of type User can be generated with the default value before bind

    if c.ContentType() == binding.MIMEJSON {
        //way5:A variable of type User can be generated with the default value before bind.
        _ = binding.MapFormWithTag(&amp;user, nil, &quot;json&quot;)
    }

    _ = c.Bind(&amp;user) //Note that because bind is used here to request json, you specify the Content-Type header
    c.String(200, &quot;Hello %v age %v&quot;, user.Name, user.Age)
})

// The above 4 way.
// way1/2 structTag is work.because gin at queryBinding/formBinding execute mapFormByTag logic, will check formTag
// way3 structTag not work. gin at jsonBinding non-execution  mapFormByTag logic
// way4/way5 no matter query/form/json All valid
// way5 is work.  Because the mapFormByTag logic is triggered in addition

r.Run(&quot;:8900&quot;)
</code></pre>
<h2 id="reference">Reference</h2>
<p><a href="https://github.com/gin-gonic/gin/issues/1052#issuecomment-2167091249" target="_blank"
   rel="noopener nofollow noreferrer" >Bind should support default values</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Gorm - BeforeDelete无法获取正确条目</title>
      <link>https://www.oomkill.com/2024/09/gorm-before-delete/</link>
      <pubDate>Fri, 20 Sep 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/09/gorm-before-delete/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>遇到问题：BeforeDelete 在删除时获取 SQL 不正确</p>
<p>BeforeDelete 代码如下</p>
<pre><code class="language-go">func (t *Target) BeforeDelete(tx *gorm.DB) (err error) {
	// 找到与此 Target 相关的所有 Labels
	var labels []Label
	if err := tx.Model(t).Association(&quot;Labels&quot;).Find(&amp;labels); err != nil {
		klog.V(4).Infof(&quot;Error fetching labels: %v&quot;, err)
		return err
	}

	for _, label := range labels {
		if err := tx.Delete(&amp;label).Error; err != nil {
			klog.V(4).Infof(&quot;Error deleting label:&quot;, err)
			return err
		}
	}

	// 注意：由于设置了 OnDelete:SET NULL，因此在删除 Labels 后，会清理 target_labels 表中的关联
	return nil
}
</code></pre>
<p>删除写法</p>
<pre><code class="language-go">func DeleteTargets(target *target.TargetItem) (enconterError error) {
	// 创建 Target
	existingTarget := &amp;Target{}
	if enconterError = DB.Model(&amp;Target{}).Where(&quot;address = ? AND metric_path = ? AND scrape_time = ? AND scrape_timeout = ?&quot;,
		target.Address, target.MetricPath, target.ScrapeTime, target.ScrapeTimeout).Delete(existingTarget).Error; enconterError != nil {
		return enconterError // 如果找不到记录，则返回错误
	}
	return enconterError
}
</code></pre>
<p>删除时遇到的问题：SQL 生成不正确 <code>target_id IN (NULL)</code></p>
<pre><code class="language-bash">BeforeDelete hook triggered

2024/09/22 00:33:36 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:37
[0.184ms] [rows:0] SELECT `labels`.`id`,`labels`.`key`,`labels`.`value` FROM `labels` JOIN `target_labels` ON `target_labels`.`label_id` = `labels`.`id` AND `target_labels`.`target_id` IN (NULL) 
</code></pre>
<p>问题原因，在删除这条记录时，默认 <code>(t *Target)</code> 必须 id 存在，如果不存在就是 NULL，所以先用 find 查询保证这个操作的 <code>t</code> 中存在主键才可以。</p>
<pre><code class="language-go">func DeleteTargets(target *target.TargetItem) (enconterError error) {
	// 创建 Target
	existingTarget := &amp;Target{}
	if enconterError = DB.Model(&amp;Target{}).Where(&quot;address = ? AND metric_path = ? AND scrape_time = ? AND scrape_timeout = ?&quot;,
		target.Address, target.MetricPath, target.ScrapeTime, target.ScrapeTimeout).Find(existingTarget).Delete(existingTarget).Error; enconterError != nil {
		return enconterError // 如果找不到记录，则返回错误
	}
	return enconterError
}
</code></pre>
<p>修改后的输出 SQL</p>
<pre><code class="language-go">2024/09/22 00:41:21 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:33
[0.126ms] [rows:3] SELECT `labels`.`id`,`labels`.`key`,`labels`.`value` FROM `labels` JOIN `target_labels` ON `target_labels`.`label_id` = `labels`.`id` AND `target_labels`.`target_id` = 17        

2024/09/22 00:41:21 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:39
[5.229ms] [rows:1] DELETE FROM `labels` WHERE `labels`.`id` = 7

2024/09/22 00:41:21 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:39
[0.078ms] [rows:1] DELETE FROM `labels` WHERE `labels`.`id` = 8

2024/09/22 00:41:21 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:39
[0.062ms] [rows:1] DELETE FROM `labels` WHERE `labels`.`id` = 9

2024/09/22 00:41:21 /mnt/d/src/go/work/prometheus-hub/pkg/model/target.go:70
[15.661ms] [rows:1] DELETE FROM `targets` WHERE (address = &quot;10.0.0.14:9090&quot; AND metric_path = &quot;/metrics&quot; AND scrape_time = 30 AND scrape_timeout = 10) AND `targets`.`id` = 17
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - 使用 gin &#43; goswagger 构建 REST API 文档</title>
      <link>https://www.oomkill.com/2024/06/golib-go-swagger/</link>
      <pubDate>Wed, 19 Jun 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/06/golib-go-swagger/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="openapi">OpenAPI</h2>
<h3 id="什么是openapi">什么是OpenAPI</h3>
<p>Swagger 是一套围绕 OpenAPI 规范构建的开源工具，可帮助我们设计，构建，记录和使用 REST API。</p>
<p><strong>OpenAPI 规范</strong>（前名称为 Swagger 规范）是 REST API 的 API 描述格式。包括：</p>
<ul>
<li>可用端点 ( 例如 <code>/users</code>) 以及每个 endpoint 上的操作 (例如 <code>GET /users</code>, <code>POST /users</code>)</li>
<li>操作参数，每个操作的输入和输出</li>
<li>认证方法</li>
<li>联系信息，许可证，使用条款等其他信息。</li>
</ul>
<h3 id="什么是-swagger">什么是 Swagger？</h3>
<p><strong>Swagger</strong> 是一组围绕 OpenAPI 规范构建的开源工具，有助于用户设计，构建，记录和使用 REST API，支持整个 API 生命周期的开发，从设计和文档到测试和部署。</p>
<h3 id="使用-swagger-的目的">使用 Swagger 的目的</h3>
<ol>
<li><strong>标准化文档格式</strong>：Swagger (OpenAPI) 采用了准化 API 文档格式。通过使用 Swaggo（将注释转换为 Swagger2.0文档的包） 生成 Swagger 文档，Swagger 的结构化格式的文档，使开发人员更容易理解产品的 API 交互。</li>
<li><strong>交互式文档体验</strong>：Swagger UI 与 Swaggo 集成，提供交互式且用户友好的界面，用于测试 API。Swaggo提供了一个自动生成的界面，允许开发人员浏览 Endpoint，查看请求/响应示例，甚至可以直接从文档执行 API 请求。这种交互式体验可提高开发人员的工作效率并加速 API 的采用。</li>
<li><strong>自动且最新的文档</strong>：Swaggo 可自动从用户的 Go 代码生成 API 文档。这种自动化无需手动维护单独的文档文件。Swaggo 直接从用户的代码库中提取信息，包括 endpoint 详细信息，请求/响应模型和注释。使用这种方法可确保用户的 API 文档随着代码的更新而保持最新。</li>
</ol>
<h2 id="swagger-与-gin-的集成">Swagger 与 Gin 的集成</h2>
<h3 id="拉取-swaggo">拉取 Swaggo</h3>
<p>使用如下命令下载swag</p>
<pre><code class="language-bash">$ go install github.com/swaggo/swag/cmd/swag
</code></pre>
<h3 id="与-gin-的集成">与 Gin 的集成</h3>
<h4 id="添加通用注释">添加通用注释</h4>
<p>swaggo 中包含两种注释，通用注释与 API 注释，通用注释是用于程序 main.go 中，标记文档的信息，API 注释是用于标注每个接口的信息。</p>
<ol>
<li>下载相关包</li>
</ol>
<pre><code class="language-bash">$ go install github.com/swaggo/swag/cmd/swag
$ go get -v github.com/swaggo/gin-swagger # gin-swagger middleware
$ go get -v github.com/swaggo/files # swagger embed files
</code></pre>
<ol start="2">
<li>在项目 main.go 源代码中添加通用的 API 注释：</li>
</ol>
<pre><code class="language-go">// @title           Swagger Example API
// @version         1.0
// @description     This is a sample server celler server.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.url    http://www.swagger.io/support
// @contact.email  support@swagger.io

// @license.name  Apache 2.0
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /api/v1

// @securityDefinitions.basic  BasicAuth

// @externalDocs.description  OpenAPI
// @externalDocs.url          https://swagger.io/resources/open-api/
func main() {
    r := gin.Default()
...
}
</code></pre>
<h4 id="为-swagger-docs-添加路由">为 Swagger Docs 添加路由</h4>
<p>以将中间件添加到您的 Gin 应用程序中。在您的路由函数中或者主函数中，添加如下下代码：</p>
<p>此代码为 Swagger UI 设置了一条路由，并告诉它在指定的 URL 处查找 Swagger 文档。</p>
<pre><code class="language-go">// 默认路由
r := gin.Default()
url := ginSwagger.URL(&quot;http://localhost:8080/swagger/doc.json&quot;)
r.GET(&quot; /swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler, url))
// 路由组
// 如果已存在路由组，可以在对应注册路由的函数中添加 docs 路径
func RegisteredRouter(e *gin.Engine) {
    e.Handle(&quot;GET&quot;, &quot;/swagger/*any&quot;,
        ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL(&quot;/swagger/doc.json&quot;)))
...
}
</code></pre>
<h4 id="向-gin-api-服务器添加-api-注释">向 Gin API 服务器添加 API 注释</h4>
<pre><code class="language-go">// ShowAccount godoc
// @Summary      Show an account
// @Description  get string by ID
// @Tags         accounts
// @Accept       json
// @Produce      json
// @Param        id   path      int  true  &quot;Account ID&quot;
// @Success      200  {object}  model.Account
// @Failure      400  {object}  httputil.HTTPError
// @Failure      404  {object}  httputil.HTTPError
// @Failure      500  {object}  httputil.HTTPError
// @Router       /accounts/{id} [get]
func (c *Controller) ShowAccount(ctx *gin.Context) {
</code></pre>
<h4 id="生成-swagger-文档">生成 Swagger 文档</h4>
<p>将注释添加到代码后，可以通过运行以下命令生成 Swagger 文档</p>
<pre><code class="language-bash">$ swag init -g cmd/main.go --output ./docs/  --packageName docs
</code></pre>
<p>此命令将会在项目中 docks 文件夹中生成一个文件 <code>doc.json</code> 。我们之前添加的中间件将使用此文件在 Swagger UI 中显示文档。</p>
<p>确保导入了生成的包 <code>docs/docs.go</code> 文件，这样特定的配置文件才会被初始化。如果通用 API 注释没有写在 <code>main.go</code> 中，可以使用 <code>-g</code> 参数来告知 swag-cli</p>
<pre><code class="language-bash">$ swag init -g http/api.go
</code></pre>
<h3 id="访问-swagger-文档">访问 swagger 文档</h3>
<p>在完成上述步骤后，可以浏览器中访问 http://{project_domain}/swagger/index.html，来查看 swagger 文档，这个路径取决于在 gin 路由里配置的路径。</p>
<h2 id="swagger-注释">swagger 注释</h2>
<h3 id="通用-api-注释">通用 API 注释</h3>
<table>
<thead>
<tr>
<th>注释</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td><strong>必填</strong> 应用程序的名称。</td>
<td>// @title Swagger Example API</td>
</tr>
<tr>
<td>version</td>
<td><strong>必填</strong> 提供应用程序API的版本。</td>
<td>// @version 1.0</td>
</tr>
<tr>
<td>description</td>
<td>应用程序的简短描述。</td>
<td>// @description This is a sample server celler server.</td>
</tr>
<tr>
<td>tag.name</td>
<td>标签的名称。</td>
<td>// @tag.name This is the name of the tag</td>
</tr>
<tr>
<td>tag.description</td>
<td>标签的描述。</td>
<td>// @tag.description Cool Description</td>
</tr>
<tr>
<td>tag.docs.url</td>
<td>标签的外部文档的URL。</td>
<td>// @tag.docs.url <a href="https://example.com/" target="_blank"
   rel="noopener nofollow noreferrer" >https://example.com</a></td>
</tr>
<tr>
<td>tag.docs.description</td>
<td>标签的外部文档说明。</td>
<td>// @tag.docs.description Best example documentation</td>
</tr>
<tr>
<td>termsOfService</td>
<td>API的服务条款。</td>
<td>// @termsOfService <a href="http://swagger.io/terms/" target="_blank"
   rel="noopener nofollow noreferrer" >http://swagger.io/terms/</a></td>
</tr>
<tr>
<td>contact.name</td>
<td>公开的API的联系信息。</td>
<td>// @contact.name API Support</td>
</tr>
<tr>
<td>contact.url</td>
<td>联系信息的URL。 必须采用网址格式。</td>
<td>// @contact.url <a href="http://www.swagger.io/support" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.swagger.io/support</a></td>
</tr>
<tr>
<td>contact.email</td>
<td>联系人/组织的电子邮件地址。 必须采用电子邮件地址的格式。</td>
<td>// @contact.email <a href="mailto:support@swagger.io">support@swagger.io</a></td>
</tr>
<tr>
<td>license.name</td>
<td><strong>必填</strong> 用于API的许可证名称。</td>
<td>// @license.name Apache 2.0</td>
</tr>
<tr>
<td>license.url</td>
<td>用于API的许可证的URL。 必须采用网址格式。</td>
<td>// @license.url <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank"
   rel="noopener nofollow noreferrer" >http://www.apache.org/licenses/LICENSE-2.0.html</a></td>
</tr>
<tr>
<td>host</td>
<td>运行API的主机（主机名或IP地址）。</td>
<td>// @host localhost:8080</td>
</tr>
<tr>
<td>BasePath</td>
<td>运行API的基本路径。</td>
<td>// @BasePath /api/v1</td>
</tr>
<tr>
<td>accept</td>
<td>API 可以使用的 MIME 类型列表。 请注意，Accept 仅影响具有请求正文的操作，例如 POST、PUT 和 PATCH。 值必须如“<a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md#mime%e7%b1%bb%e5%9e%8b" target="_blank"
   rel="noopener nofollow noreferrer" >Mime类型</a>”中所述。</td>
<td>// @accept json</td>
</tr>
<tr>
<td>produce</td>
<td>API可以生成的MIME类型的列表。值必须如“<a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md#mime%e7%b1%bb%e5%9e%8b" target="_blank"
   rel="noopener nofollow noreferrer" >Mime类型</a>”中所述。</td>
<td>// @produce json</td>
</tr>
<tr>
<td>query.collection.format</td>
<td>请求URI query里数组参数的默认格式：csv，multi，pipes，tsv，ssv。 如果未设置，则默认为csv。</td>
<td>// @query.collection.format multi</td>
</tr>
<tr>
<td>schemes</td>
<td>用空格分隔的请求的传输协议。</td>
<td>// @schemes http https</td>
</tr>
<tr>
<td>externalDocs.description</td>
<td>Description of the external document.</td>
<td>// @externalDocs.description OpenAPI</td>
</tr>
<tr>
<td>externalDocs.url</td>
<td>URL of the external document.</td>
<td>// @externalDocs.url <a href="https://swagger.io/resources/open-api/" target="_blank"
   rel="noopener nofollow noreferrer" >https://swagger.io/resources/open-api/</a></td>
</tr>
<tr>
<td>x-name</td>
<td>扩展的键必须以x-开头，并且只能使用json值</td>
<td>// @x-example-key {&ldquo;key&rdquo;: &ldquo;value&rdquo;}</td>
</tr>
</tbody>
</table>
<h3 id="api-注释">API 注释</h3>
<table>
<thead>
<tr>
<th>注释</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>description</td>
<td>操作行为的详细说明。</td>
</tr>
<tr>
<td>description.markdown</td>
<td>应用程序的简短描述。该描述将从名为 <code>endpointname.md</code> 的文件中读取。</td>
</tr>
<tr>
<td>id</td>
<td>用于标识操作的唯一字符串。在所有 API 操作中必须唯一。</td>
</tr>
<tr>
<td>tags</td>
<td>每个 API 操作的标签列表，以逗号分隔。</td>
</tr>
<tr>
<td>summary</td>
<td>该操作的简短摘要。</td>
</tr>
<tr>
<td>accept</td>
<td>API 可以使用的 MIME 类型列表。 请注意，Accept 仅影响具有请求正文的操作，例如 POST、PUT 和 PATCH。 值必须如 “Mime类型” 中所述。</td>
</tr>
<tr>
<td>produce</td>
<td>API可以生成的MIME类型的列表。值必须如 “Mime类型” 中所述。</td>
</tr>
<tr>
<td>param</td>
<td>用空格分隔的参数。<br /><code>param name</code>,<br /><code>param type</code>,<br /><code>data type</code>,<br /><code>is mandatory?</code>,<br /><code>comment</code> <code>attribute(optional)</code></td>
</tr>
<tr>
<td>security</td>
<td>每个 API 操作的安全性。</td>
</tr>
<tr>
<td>success</td>
<td>以空格分隔的成功响应。<code>return code</code>,<code>{param type}</code>,<code>data type</code>,<code>comment</code></td>
</tr>
<tr>
<td>failure</td>
<td>以空格分隔的故障响应。<code>return code</code>,<code>{param type}</code>,<code>data type</code>,<code>comment</code></td>
</tr>
<tr>
<td>response</td>
<td>与success、failure作用相同</td>
</tr>
<tr>
<td>header</td>
<td>以空格分隔的头字段。 <code>return code</code>,<code>{param type}</code>,<code>data type</code>,<code>comment</code></td>
</tr>
<tr>
<td>router</td>
<td>以空格分隔的路径定义。 <code>path</code>,<code>[httpMethod]</code></td>
</tr>
<tr>
<td>deprecatedrouter</td>
<td>与router相同，但是是deprecated的。</td>
</tr>
<tr>
<td>x-name</td>
<td>扩展字段必须以 <code>x-</code> 开头，并且只能使用 json 值。</td>
</tr>
<tr>
<td>deprecated</td>
<td>将当前 API 操作的所有路径设置为deprecated</td>
</tr>
</tbody>
</table>
<h3 id="安全相关参数">安全相关参数</h3>
<table>
<thead>
<tr>
<th>注释</th>
<th>描述</th>
<th>参数</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>securitydefinitions.basic</td>
<td><a href="https://swagger.io/docs/specification/2-0/authentication/basic-authentication/" target="_blank"
   rel="noopener nofollow noreferrer" >Basic</a> auth.</td>
<td></td>
<td>// @securityDefinitions.basic BasicAuth</td>
</tr>
<tr>
<td>securitydefinitions.apikey</td>
<td><a href="https://swagger.io/docs/specification/2-0/authentication/api-keys/" target="_blank"
   rel="noopener nofollow noreferrer" >API key</a> auth.</td>
<td>in, name</td>
<td>// @securityDefinitions.apikey ApiKeyAuth</td>
</tr>
<tr>
<td>securitydefinitions.oauth2.application</td>
<td><a href="https://swagger.io/docs/specification/authentication/oauth2/" target="_blank"
   rel="noopener nofollow noreferrer" >OAuth2 application</a> auth.</td>
<td>tokenUrl, scope</td>
<td>// @securitydefinitions.oauth2.application OAuth2Application</td>
</tr>
<tr>
<td>securitydefinitions.oauth2.implicit</td>
<td><a href="https://swagger.io/docs/specification/authentication/oauth2/" target="_blank"
   rel="noopener nofollow noreferrer" >OAuth2 implicit</a> auth.</td>
<td>authorizationUrl, scope</td>
<td>// @securitydefinitions.oauth2.implicit OAuth2Implicit</td>
</tr>
<tr>
<td>securitydefinitions.oauth2.password</td>
<td><a href="https://swagger.io/docs/specification/authentication/oauth2/" target="_blank"
   rel="noopener nofollow noreferrer" >OAuth2 password</a> auth.</td>
<td>tokenUrl, scope</td>
<td>// @securitydefinitions.oauth2.password OAuth2Password</td>
</tr>
<tr>
<td>securitydefinitions.oauth2.accessCode</td>
<td><a href="https://swagger.io/docs/specification/authentication/oauth2/" target="_blank"
   rel="noopener nofollow noreferrer" >OAuth2 access code</a> auth.</td>
<td>tokenUrl, authorizationUrl, scope</td>
<td>// @securitydefinitions.oauth2.accessCode OAuth2AccessCode</td>
</tr>
</tbody>
</table>
<h2 id="troubleshooting">troubleshooting</h2>
<h3 id="failed-to-load-api-definition">Failed to load API definition.</h3>
<p>引用了 swaggo 的文件必须添加下面包引用</p>
<pre><code class="language-go">_ &quot;project_root_dir/cmd/docs&quot;
</code></pre>
<h3 id="failed-to-load-api-definition-not-found-swaggerv1swaggerjson">failed to load api definition. not found /swagger/v1/swagger.json</h3>
<p>指定 doc 文档路径必须写对 [ginSwagger.URL(&quot;/swagger/doc.json&quot;)]</p>
<pre><code class="language-go">// 默认路由
r := gin.Default()
url := ginSwagger.URL(&quot;http://localhost:8080/swagger/doc.json&quot;)
r.GET(&quot; /swagger/*any&quot;, ginSwagger.WrapHandler(swaggerFiles.Handler, url))
// 路由组
// 如果已存在路由组，可以在对应注册路由的函数中添加 docs 路径
func RegisteredRouter(e *gin.Engine) {
    e.Handle(&quot;GET&quot;, &quot;/swagger/*any&quot;,
        ginSwagger.WrapHandler(swaggerFiles.Handler, ginSwagger.URL(&quot;/swagger/doc.json&quot;)))
</code></pre>
<h3 id="cannot-find-type-definition-api_queryuserquery">cannot find type definition: api_query.UserQuery</h3>
<p>如果参数引用了一个对象，不可以写成 <code>&amp;api_query.UserQuery</code> 的格式</p>
<h3 id="parsecomment-error-in-file--missing-required-param-comment-parameters-xxx">ParseComment error in file  :missing required param comment parameters &ldquo;xxx&rdquo;</h3>
<p>你的项目内其他非 API 接口的函数不能使用与 API 注释相同格式的注释</p>
<h3 id="cannot-find-type-definition-errcodeerror">cannot find type definition: errcode.Error</h3>
<h2 id="reference">Reference</h2>
<p><sup id="1">[1]</sup> <a href="https://github.com/swaggo/swag/issues/830" target="_blank"
   rel="noopener nofollow noreferrer" >&ldquo;Failed to load API definition&rdquo; / &ldquo;not yet registered swag&rdquo; error when rendering docs page #830</a></p>
<p><sup id="2">[2]</sup> <a href="https://github.com/swaggo/gin-swagger/issues/2" target="_blank"
   rel="noopener nofollow noreferrer" >localhost:8080/swagger returns 404 page not found #2</a></p>
<p><sup id="3">[3]</sup> <a href="https://medium.com/julotech/implementing-swagger-in-go-projects-8579a5fb955" target="_blank"
   rel="noopener nofollow noreferrer" >Implementing Swagger in Go Projects</a></p>
<p><sup id="4">[4]</sup> <a href="https://lemoncode21.medium.com/how-to-add-swagger-in-golang-gin-6932e8076ec0" target="_blank"
   rel="noopener nofollow noreferrer" >How to add Swagger in Golang Gin.</a></p>
<p><sup id="5">[5]</sup> <a href="https://www.cnblogs.com/Zev_Fung/p/11588515.html" target="_blank"
   rel="noopener nofollow noreferrer" >Swagger使用的时候报错：Failed to load API definition</a></p>
<p><sup id="6">[6]</sup> <a href="https://github.com/swaggo/swag/blob/master/README_zh-CN.md" target="_blank"
   rel="noopener nofollow noreferrer" >README_zh-CN.md</a></p>
<p><sup id="7">[7]</sup> <a href="https://stackoverflow.com/questions/62101550/golang-swaggo-rendering-error-failed-to-load-api-definition-and-fetch-error" target="_blank"
   rel="noopener nofollow noreferrer" >Golang swaggo rendering error: &ldquo;Failed to load API definition&rdquo; and &ldquo;Fetch error doc.json&rdquo;</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go设计模式</title>
      <link>https://www.oomkill.com/2023/03/design-patterns/</link>
      <pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/03/design-patterns/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="创建型模式">创建型模式</h2>
<h3 id="工厂模式">工厂模式</h3>
<h4 id="概念说明">概念说明</h4>
<p>工厂模式 (<em><strong>factory pattern</strong></em>) 是在父类中提供一个创建对象的方法，是用于创建不同类型的对象，而无需指定对象的真实的类</p>
<p>工厂模式的特点：</p>
<ul>
<li>对客户端隐藏对象创建的复杂逻辑</li>
<li>可以通过修改工厂类来创建对象而不影响客户端代码</li>
<li>提供创建对象的单一来源。  单个工厂类用以各组件保持一致性。</li>
<li>允许子类创建对象类型</li>
</ul>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/Factory_Pattern.png" alt="Factory_Pattern" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：工厂设计模式的示意图</center>
<center><em>Source：</em>https://www.techcrashcourse.com/2015/10/factory-design-pattern.html</center><br>
<p>图片说明： Owl, Eagle, Sparrow 类都必须实现 Brid 接口， 该接口声明了一个名为 <code>fly()</code> 的方法。 每个类都将以不同的方式实现该方法。而使用工厂模式后的代码机构则为图所示，当 Owl, Eagle, Sparrow 实现了共同的接口，就可以将其对象传递给客户代码， 而无需提供额外数据。</p>
<p>而 “调用工厂方法的代码” 称为 “客户端代码”，这样可以做到 “不需要了解不同子类返回实际对象之间的差别”。客户端代码将所有 Brid Sanctuary 视为抽象的 <code>Brid</code>  ，这样 ”客户端代码“ 知道所有鸟类对象都提供 <code>fly()</code> 方法， 但是并不关心其实现方式。</p>
<h4 id="代码实现">代码实现</h4>
<p><strong>brid.go</strong></p>
<pre><code class="language-go">package main

type Brid interface {
    Fly()
}
</code></pre>
<p><strong>Owl.go</strong></p>
<pre><code class="language-go">type Owl struct {}

func (g *Owl) Fly() {
    fmt.Println(&quot;猫头鹰在飞&quot;)
}
</code></pre>
<p><strong>Eagle.go</strong></p>
<pre><code class="language-go">type Eagle struct {}

func (e *Eagle) Fly() {
    fmt.Println(&quot;鹰在飞&quot;)
}
</code></pre>
<p><strong>Sparrow.go</strong></p>
<pre><code class="language-go">type Sparrow struct {}

func (e *Sparrow) Fly() {
    fmt.Println(&quot;麻雀在飞&quot;)
}
</code></pre>
<p>创建一个工厂类 <strong>BridSanctuary.go</strong></p>
<pre><code class="language-go">func BridSanctuary(type string) Brid { 
    if type == &quot;Owl&quot;{ 
     return  newOwl()
    } 

    if  type == &quot;Eagle&quot;{ 
     return  newEagle()
    } 

    if  type == &quot;Sparrow&quot;{ 
     return  newSparrow()
    } 
} 
</code></pre>
<p>客户端使用时通过工厂类获得不同的对象</p>
<pre><code class="language-go">sparrow := BridSanctuary(&quot;sparrow&quot;)
eagle := BridSanctuary(&quot;eagle&quot;)
</code></pre>
<p>工厂模式特点</p>
<ul>
<li>客户端代码使用工厂模式提供的创建对象，而不是直接使用 new 运算符创建对象。</li>
<li>调用工厂对象并指定需要什么类型的对象。</li>
<li>工厂模式在不暴露对象创建的复杂逻辑的情况下可以创建各种对象。</li>
<li>工厂方法在将其类型转换为公共接口后，根据客户端代码的请求返回新创建的对象。</li>
<li>客户端通过 Interface 与对象进行交互，但并不知道具体类的类型</li>
</ul>
<h3 id="抽象工厂">抽象工厂</h3>
<h4 id="概念说明-1">概念说明</h4>
<p>抽象工厂模式 (<em><strong>Abstract Factory</strong></em>)，是提供了一个 接口 或 抽象类创建一系列相关或依赖的对象，而不需要指定的具体类。抽象工厂模式，是工厂模式的超集，换句话说，抽象工厂是工厂的工厂，或者是工厂的wapper</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/Abstract_Factory_Pattern.png" alt="Abstract_Factory_Pattern" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：抽象工厂设计模式的示意图</center>
<center><em>Source：</em>https://www.techcrashcourse.com/2015/10/abstract-factory-design-pattern.html</center><br>
<h4 id="代码实现-1">代码实现</h4>
<p><strong>brid.go</strong></p>
<pre><code class="language-go">type Brid interface {
	fly()
}
</code></pre>
<p><strong>Owl.go</strong></p>
<pre><code class="language-go">type Owl struct{}

func (g *Owl) fly() {
	fmt.Println(&quot;猫头鹰在飞&quot;)
}

func newOwl() Brid {
	return &amp;Owl{}
}
</code></pre>
<p><strong>Eagle.go</strong></p>
<pre><code class="language-go">type Eagle struct{}

func (e *Eagle) fly() {
	fmt.Println(&quot;鹰在飞&quot;)
}

func newEagle() Brid {
	return &amp;Eagle{}
}
</code></pre>
<p><strong>Sparrow.go</strong></p>
<pre><code class="language-go">type Sparrow struct{}

func (e *Sparrow) fly() {
	fmt.Println(&quot;麻雀在飞&quot;)
}

func newSparrow() Brid {
	return &amp;Sparrow{}
}
</code></pre>
<p><strong>Animal.go</strong></p>
<pre><code class="language-go">type Animal interface {
    run()
}
</code></pre>
<p><strong>Horse.go</strong></p>
<pre><code class="language-go">type Horse struct{}

func (a *Horse) run() {
	fmt.Println(&quot;马在跑&quot;)
}

func newHorse() Animal {
	return &amp;Horse{}
}
</code></pre>
<p><strong>Lion.go</strong></p>
<pre><code class="language-go">type Lion struct {}

func (a *Lion) run() {
    fmt.Println(&quot;狮子在跑&quot;)
}

func newLion() Animal {
	return &amp;Lion{}
}
</code></pre>
<p>接下来创建 动物园的抽象工厂模式</p>
<pre><code class="language-go">type Zoo interface {
	GetBrid(t string) Brid
	GetAnimal(t string) Animal
}
// 抽象工厂的初始化
func FactoryCreator(t string) Zoo {
	if t == &quot;EZooFactory&quot; {
		return new(EZooFactory)
	}

	if t == &quot;SZooFactory&quot; {
		return new(EZooFactory)
	}
	return nil
}
</code></pre>
<p>实现两个动物园，EZoo 和 SZoo</p>
<pre><code class="language-go">type EZooFactory struct{}

func (e *EZooFactory) GetBrid(t string) Brid {
	if t == &quot;Eagle&quot; {
		return newEagle()
	}

	if t == &quot;Sparrow&quot; {
		return newSparrow()
	}
	return nil
}

func (c *EZooFactory) GetAnimal(t string) Animal {
	if t == &quot;Lion&quot; {
		return newLion()
	}
	return nil
}
</code></pre>
<p>SZoo</p>
<pre><code class="language-go">type SZooFactory struct{}

func (e *SZooFactory) GetBrid(t string) Brid {
	if t == &quot;Owl&quot; {
		return newOwl()
	}
	return nil
}

func (c *SZooFactory) GetAnimal(t string) Animal {
	if t == &quot;Horse&quot; {
		return newHorse()
	}
	return nil
}
</code></pre>
<p><strong>客户端代码</strong>，通过creator可以定义了创建不同动物园的类，而每个动物园有其独特的动物。换句话来说，客户端代码通过抽象接口，将工厂模式与实体柔和为一体，使客户端创建出的工厂类可以是任何动物的变体</p>
<pre><code class="language-go">func main() {
	e := FactoryCreator(&quot;EZooFactory&quot;)
	s := FactoryCreator(&quot;SZooFactory&quot;)
	e.GetBrid(&quot;owl&quot;)
	e.GetAnimal(&quot;Horse&quot;)
}
</code></pre>
<p>抽象工厂模式的特点：</p>
<ul>
<li>抽象工厂设计模式目的是为了创建一系列相关的对象，从而不依赖具体的每一个子类</li>
<li>客户端代码并不知道使用了那个子类的工厂，首先工厂，然后调用具体方法获得具体的类</li>
<li>抽象工厂是工厂模式的超集</li>
</ul>
<h4 id="工厂模式与抽象工厂模式比较">工厂模式与抽象工厂模式比较</h4>
<table>
<thead>
<tr>
<th>Factory Method</th>
<th>Abstract Factory</th>
</tr>
</thead>
<tbody>
<tr>
<td>当包含一个工厂类时，只能产生一种类型的对象</td>
<td>包含一个工厂类时，能够产生一系列的多种不同类型的对象</td>
</tr>
<tr>
<td>工厂类通过create方法实现接口</td>
<td>使用interface为工厂创建抽象类</td>
</tr>
<tr>
<td>子类决定了返回什么样的对象</td>
<td>每一种专门的工厂用于创建一种类型的对象，因此也被称为 “factory of factories”</td>
</tr>
<tr>
<td>一个工厂产生一种对象</td>
<td>一个广义的工厂，包含一或多个工厂，每个工厂可产生一种类型的对象</td>
</tr>
</tbody>
</table>
<h3 id="建造者模式">建造者模式</h3>
<p>建造者 (<em><strong>Builder</strong></em>) 是一种使用相同的代码逐步构建复杂对象的方式，</p>
<p>假设一个复杂对象， 在对其进行构造时需要对诸多成员变量和嵌套对象进行繁琐的初始化工作。 这种场景的初始化代码通常是包含众多参数的构造函数中。例如，盖房子 House对象。 建造一栋简单的房屋， 首先需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果想要一栋更大更明亮的房屋，还需要其他设施 （例如暖气，排水系统，供电系统，冷气系统）。</p>
<p>在这种场景下，建造者模式就应景而生，Builder 建议将对象构造代码从产品类中抽取出来， 并将其放在一个名为 Builder 的独立对象中。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/solution1.png" alt="solution1" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Builder示意图/center>
<center><em>Source：</em>https://www.techcrashcourse.com/2015/10/abstract-factory-design-pattern.html</center><br>
<p>在这种情况下， 通过创建多个不同的Builder， 用不同方式实现一组相同的创建步骤。 然后你就可以在创建过程中使用这些Builder （例如按顺序调用多个构造步骤） 来生成不同类型的对象。</p>
<h4 id="代码实现-2">代码实现</h4>
<p><strong>Builder interface</strong></p>
<pre><code class="language-go">type IBuilder interface {
    setWindowType()
    setDoorType()
    setNumFloor()
    getHouse() House
}

func getBuilder(builderType string) IBuilder {
    if builderType == &quot;normal&quot; {
        return newNormalBuilder()
    }

    if builderType == &quot;igloo&quot; {
        return newIglooBuilder()
    }
    return nil
}
</code></pre>
<p><strong>一般房屋</strong></p>
<pre><code class="language-go">package main

type NormalBuilder struct {
    windowType string
    doorType   string
    floor      int
}

func newNormalBuilder() *NormalBuilder {
    return &amp;NormalBuilder{}
}

func (b *NormalBuilder) setWindowType() {
    b.windowType = &quot;Wooden Window&quot;
}

func (b *NormalBuilder) setDoorType() {
    b.doorType = &quot;Wooden Door&quot;
}

func (b *NormalBuilder) setNumFloor() {
    b.floor = 2
}

func (b *NormalBuilder) getHouse() House {
    return House{
        doorType:   b.doorType,
        windowType: b.windowType,
        floor:      b.floor,
    }
}
</code></pre>
<p><strong>冰屋</strong></p>
<pre><code class="language-go">type IglooBuilder struct {
    windowType string
    doorType   string
    floor      int
}

func newIglooBuilder() *IglooBuilder {
    return &amp;IglooBuilder{}
}

func (b *IglooBuilder) setWindowType() {
    b.windowType = &quot;Snow Window&quot;
}

func (b *IglooBuilder) setDoorType() {
    b.doorType = &quot;Snow Door&quot;
}

func (b *IglooBuilder) setNumFloor() {
    b.floor = 1
}

func (b *IglooBuilder) getHouse() House {
    return House{
        doorType:   b.doorType,
        windowType: b.windowType,
        floor:      b.floor,
    }
}
</code></pre>
<p>房屋属性</p>
<pre><code class="language-go">package main

type House struct {
    windowType string
    doorType   string
    floor      int
}
</code></pre>
<p>工人</p>
<pre><code class="language-go">type Worker struct {
    builder IBuilder
}

func newWorker(b IBuilder) *Worker {
    return &amp;Worker{
        builder: b,
    }
}

func (d *Worker) setBuilder(b IBuilder) {
    d.builder = b
}

func (d *Worker) buildHouse() House {
    d.builder.setDoorType()
    d.builder.setWindowType()
    d.builder.setNumFloor()
    return d.builder.getHouse()
}
</code></pre>
<p>客户端代码实现，即建造房屋</p>
<pre><code class="language-go">func main() {
    // 定义房屋的类型
    normalBuilder := getBuilder(&quot;normal&quot;)
    iglooBuilder := getBuilder(&quot;igloo&quot;)
	
    // 请工人盖房子
    worker := newWorker(normalBuilder)
    normalHouse := worker.buildHouse() // 设置工人需要施工的方向，即要盖什么类型的房子

    fmt.Printf(&quot;Normal House Door Type: %s\n&quot;, normalHouse.doorType)
    fmt.Printf(&quot;Normal House Window Type: %s\n&quot;, normalHouse.windowType)
    fmt.Printf(&quot;Normal House Num Floor: %d\n&quot;, normalHouse.floor)

    worker.setBuilder(iglooBuilder)
    iglooHouse := worker.buildHouse()

    fmt.Printf(&quot;\nIgloo House Door Type: %s\n&quot;, iglooHouse.doorType)
    fmt.Printf(&quot;Igloo House Window Type: %s\n&quot;, iglooHouse.windowType)
    fmt.Printf(&quot;Igloo House Num Floor: %d\n&quot;, iglooHouse.floor)

}
</code></pre>
<h3 id="prototype">prototype</h3>
<h4 id="模式概念">模式概念</h4>
<p>prototype 这种设计模式，提供的是一种复制现有对象的模式，在这种模式下不需要重复的构建对象。</p>
<p>prototype 的特点有：</p>
<ul>
<li>客户端代码克隆对象时，客户端并不知道它获得的对象类型，而需要指定其对象类型</li>
<li>提高了系统性能；对于资源密集型操作的对象，可以通过克隆来减少创建成本</li>
<li>隐藏了客户端代码创建新示例的复杂性</li>
<li>该类型主要的体系就是在clone() 上</li>
</ul>
<p>选择 prototype的场景</p>
<ul>
<li>当创建对象很复杂时，或需要大量的资源操作时</li>
<li>当想对客户端隐藏创建逻辑时</li>
<li>当一个类有多种状态，可以通过先全部创建，用时克隆来提高效率</li>
</ul>
<h4 id="代码的实现">代码的实现</h4>
<p><strong>brid.go</strong></p>
<pre><code class="language-go">type Brid interface {
	fly()
    Clone() Brid
}
</code></pre>
<p><strong>Owl.go</strong></p>
<pre><code class="language-go">type Owl struct{
    Name string
}

func (g *Owl) fly() {
	fmt.Printf(&quot;猫头鹰 %s 在飞\n&quot;, g.Name)
}

func (g *Owl) clone() Brid {
    return &amp;Owl{Name: g.Name}
}

func newOwl() Brid {
	return &amp;Owl{}
}
</code></pre>
<p><strong>Eagle.go</strong></p>
<pre><code class="language-go">type Eagle struct{
    Name string
}

func (e *Eagle) fly() {
	fmt.Printf(&quot;鹰 %s 在飞\n&quot;, e.Name)
}

func (g *Eagle) clone() Brid {
    return &amp;Eagle{Name: g.Name}
}

func newEagle() Brid {
	return &amp;Eagle{}
}
</code></pre>
<p><strong>Sparrow.go</strong></p>
<pre><code class="language-go">type Sparrow struct{
    Name string
}

func (e *Sparrow) fly() {
	fmt.Printf(&quot;麻雀 %s 在飞\n&quot;, e.Name)
}

func (g *Sparrow) clone() Brid {
    return &amp;Sparrow{Name: g.Name}
}

func newSparrow() Brid {
	return &amp;Sparrow{}
}
</code></pre>
<p>prototype 类，使用 BridsFactory 对象来创建 Parrot、Sparrow 和 Eagle 等类的对象。</p>
<pre><code class="language-go">type BridsFactory struct {
    children []Brid
    name     string
}

func (b *BridsFactory) print(indentation string) {
    fmt.Println(indentation + b.name)
    for _, i := range f.children {
        i.fly()
    }
}

func (b *BridsFactory) clone() BridsFactory {
    clonBrid := &amp;Brids{name: b.name + &quot;_clone&quot;}
    var tempChildren []Brid
    for _, i := range f.children {
        copy := i.clone()
        tempChildren = append(tempChildren, copy)
    }
    clonBrid.children = tempChildren
    return clonBrid
}
</code></pre>
<p>客户端代码</p>
<pre><code class="language-go">func main() {
    brid1 := &amp;Owl{name: &quot;jackchan&quot;}
    brid2 := &amp;Eagle{name: &quot;calenlee&quot;}
    brid3 := &amp;Sparrow{name: &quot;jerrywong&quot;}

    brids1 := &amp;BridsFactory{
        children: []Brid{brid1, brid2, brid3},
        name:     &quot;owls&quot;,
    }

    cloneBrids := brids1.clone()
    fmt.Println(&quot;\nPrinting hierarchy for clone Brids&quot;)
    cloneBrids.print(&quot;  &quot;)
}
</code></pre>
<h3 id="单例">单例</h3>
<h4 id="概念说明-2">概念说明</h4>
<p>单例 (<em><strong>Singleton</strong></em>) 模式主要特点是确保一个类只能创建一个对象，其提供了一种只能创建一个对象的方法。</p>
<p>单例模式的特点:</p>
<ul>
<li>确保一个类只能创建的一个实例</li>
<li>通常情况下构造函数是私有的，以防止通过new来创建多个实例</li>
<li>类似静态的构建函数的方法，它将提供了一种调用私有构建函数来创建出对象并保存在静态字段中，后续所有的构建调用都会返回唯一的这个静态对象</li>
</ul>
<h4 id="代码实现-3">代码实现</h4>
<pre><code class="language-go">type single struct {}

var singleInstance *single // 定义一个静态字段

func getInstance() *single {
    if singleInstance == nil { // 当这个“静态变量”为空时，则创建这个对象，已确保只能被初始化一次
        if singleInstance == nil {
            fmt.Println(&quot;Creating single instance now.&quot;)
            singleInstance = &amp;single{}
        } else {
            fmt.Println(&quot;Single instance already created.&quot;)
        }
    } else {
        fmt.Println(&quot;Single instance already created.&quot;)
    }

    return singleInstance
}
</code></pre>
<p>客户端代码</p>
<pre><code class="language-go">func main() {

    for i := 0; i &lt; 30; i++ {
        go getInstance()
    }
}
</code></pre>
<h2 id="结构模式">结构模式</h2>
<h3 id="适配器">适配器</h3>
<p>适配器设计模式 (<em><strong>Adapter</strong></em>)，是一种结构设计模式，主要是使具有不兼容接口的对象可以进行协作；通俗来讲，是将一个类的接口转换为客户端期望的另一个接口，可以使不兼容的两个类通过 适配器，完成与现有类的交互。</p>
<p>Adapter 将作为一个 “代理人” 的职责</p>
<p>适配器模式特点：</p>
<ul>
<li>使不兼容的类可以通过Adapter进行交互</li>
<li>提升了现有系统的可用性（一个类可以使多个类使用）</li>
</ul>
<p>很常见的一个例子，数据使一个结构体，而客户端需要 json, 那么 Adapter 就可以是 json.Marshual</p>
<h4 id="适配器模式的组成">适配器模式的组成</h4>
<ul>
<li><strong>Target Interface</strong>：客户端期望的数据格式，即客户端使用的类型</li>
<li><strong>Adapter</strong>:  接收来自客户端的调用，假设服务端类型是 <code>Adaptee</code>，他会将客户端的调用转换为<code>Adaptee</code> 类型</li>
<li><strong>Adaptee Interface</strong>: 实际的类型，客户端想与其交互，由于类型不相同无法直接请求</li>
<li><strong>Client</strong>: 客户端使用 <code>Target Interface</code> 与 Adapter 交互</li>
</ul>
<h4 id="代码示例">代码示例</h4>
<p>例如我们有一个Windows电脑来作为 Adaptee Interface，电脑上有各类的接口，例如USB，这两种类型是不同的，这时就需要 Adapter</p>
<p><strong>client.go</strong></p>
<pre><code class="language-go">type Client struct {}

func (c *Client) InsertLightningConnectorIntoComputer(com Computer) {
    fmt.Println(&quot;Client inserts Lightning connector into computer.&quot;)
    com.InsertIntoLightningPort()
}
</code></pre>
<p><strong>Client interface</strong> 为Computer配置一个雷电接口</p>
<pre><code class="language-go">type Computer interface {
    InsertIntoLightningPort()
}
</code></pre>
<p><strong>Mac PC</strong> 实现了Computer接口，这样客户端与服务端可以直接通讯</p>
<pre><code class="language-go">type Mac struct {}

func (m *Mac) InsertIntoLightningPort() {
    fmt.Println(&quot;Lightning connector is plugged into mac machine.&quot;)
}
</code></pre>
<p><strong>windows PC</strong> 没有实现 Computer 接口，</p>
<pre><code class="language-go">type Windows struct{}

func (w *Windows) insertIntoUSBPort() {
    fmt.Println(&quot;USB connector is plugged into windows machine.&quot;)
}
</code></pre>
<p>要使 windows 也可以 使用 Lightning，那么需要适配器</p>
<pre><code class="language-go">type WindowsAdapter struct {
    windowMachine *Windows
}

func (w *WindowsAdapter) InsertIntoLightningPort() {
    fmt.Println(&quot;Adapter converts Lightning signal to USB.&quot;)
    w.windowMachine.insertIntoUSBPort()
}
</code></pre>
<p>客户端代码</p>
<pre><code class="language-go">package main

func main() {

    client := &amp;Client{}
    mac := &amp;Mac{}

    client.InsertLightningConnectorIntoComputer(mac)

    windowsMachine := &amp;Windows{}
    windowsMachineAdapter := &amp;WindowsAdapter{
        windowMachine: windowsMachine,
    }

    client.InsertLightningConnectorIntoComputer(windowsMachineAdapter)
}
</code></pre>
<h3 id="bridge">Bridge</h3>
<p>桥接 (<em><strong>Bridge</strong></em>) 允许将大类拆分为两个独立的层次结构（abstraction 和 implementation），桥接模式提供一个接口，来充当两个层次间的桥梁</p>
<p>桥接模式的特点：</p>
<ul>
<li></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中的类型断言与类型转换</title>
      <link>https://www.oomkill.com/2023/01/go-type-assertion/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/01/go-type-assertion/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="类型断言">类型断言</h2>
<p>类型断言 <em><strong>type assertion</strong></em> 并不是真正的将 <code>interface</code> 类型转换为另一种确定的类型，只是提供了对 <code>interface</code> 类型的值的访问，通常情况下，这是常见的需求</p>
<p>类型断言通过 语法 <code>x.(T)</code> ，这将会确定 x 变量中存储的值是否属于 T 类型，通常场景有两种：</p>
<ul>
<li>如果 T 不是 interface 类型，而是一个具体的类型，那么这次断言将断言 x 的 动态类型是否与 T 相同</li>
<li>如果 T 是 interface 类型，这次断言 x 的动态类型是否实现了 T</li>
</ul>
<pre><code class="language-go">var x interface{} = &quot;foo&quot;

var s string = x.(string)
fmt.Println(s)     // &quot;foo&quot;

s, ok := x.(string)
fmt.Println(s, ok) // &quot;foo true&quot;

n, ok := x.(int)
fmt.Println(n, ok) // &quot;0 false&quot;

n = x.(int)        // ILLEGAL
</code></pre>
<blockquote>
<p>Note：在断言时，x 的类型必须为 <code>interface{}</code></p>
</blockquote>
<p>那么怎么理解 <code>T=interface</code> 和 <code>T != interface</code> 这两句话呢</p>
<ul>
<li><code>T != interface</code>  则是一个正常的断言，即 x (interface) 是否等于 T (really type)，这里 x 必须为 interface，T 则可以为任意类型而不是变量</li>
<li><code>T=interface</code> 时 不能说是一个断言，而是一个对 interface 的断言，此时 x 必须为 interface，T 也必须为 interface</li>
</ul>
<p>如下面代码所示：</p>
<pre><code class="language-go">type s interface {}

// 一个interface类型的变量a
var a interface{}
a = a
a = 1

// 一个int 类型的变量b
var b = 20
b = b

x, ok := a.(s) // 1 true 因为a实现了interface
x, ok := b.(s) //  false b 不是interface不能断言
x, ok := a.(int) // 1 true 因为a的值为int
x := a.(string) // 当一个返回参数时将触发panic
</code></pre>
<h2 id="类型转换">类型转换</h2>
<p>类型转换 <em><strong>type switch</strong></em> 是指类型断言的应用场景，是通过对一个interface类型的变量进行多次断言，以匹配到真实的数据类型</p>
<pre><code class="language-go">var x interface{} = &quot;foo&quot;

switch v := x.(type) {
case nil:
	fmt.Println(&quot;x is nil&quot;)            // here v has type interface{}
case int: 
	fmt.Println(&quot;x is&quot;, v)             // here v has type int
case bool, string:
	fmt.Println(&quot;x is bool or string&quot;) // here v has type interface{}
default:
	fmt.Println(&quot;type unknown&quot;)        // here v has type interface{}
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何使用go语言来检查端口可用性</title>
      <link>https://www.oomkill.com/2023/01/goskill-port-is-available/</link>
      <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/01/goskill-port-is-available/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="方法1dial">方法1：dial</h2>
<p>使用 <code>net.DialTimeout</code> 去检查端口的技巧：</p>
<p>在通过Dial检查端口占用时，需要知道网络中常见的报错状态，而不是 <code>err != nil</code> 都为可用</p>
<h3 id="connection-reset-by-peer">Connection reset by peer</h3>
<p>connection reset by peer 这种错误情况下有以下几种场景：</p>
<ul>
<li>基于包过滤的防火墙给予 <code>RST</code>；对于此情况，基于网络模型来说处于网络层与传输层之间的netfilter，如果是防火墙拒绝那么未到应用层无法确认端口</li>
<li>对端应用资源限制而reset，通常为负载过高；对于此场景是已到达应用层</li>
<li>客户端关闭了连接，而服务器还在给客户端发送数据；对于端口检查来说不会到这步</li>
</ul>
<p>由上面可知，这种错误<em>一定为占用</em></p>
<h3 id="connection-timed-out">Connection timed out</h3>
<p><strong>Connection timed out</strong> 这种场景根本就dial不成功，go中给出了一个专门的事件 <code>opErr.Timeout()</code> 来说明这个错误，故此错误将<em>不能确认端口是否占用</em></p>
<h3 id="connection-refused">Connection refused</h3>
<p><strong>Connection refused</strong> 这种场景催在两种情况</p>
<ul>
<li>对于 local 场景来说，这将表示端口未监听</li>
<li>对于远端场景来说，这种基本上表示 client 发往 remote ，remote不能接受 <code>host:port</code> 这个连接</li>
</ul>
<p>通常对于存在两种情况，但多数为端口为监听</p>
<ol>
<li>Misconfiguration, such as where a user has mistyped the port number, or is using stale information about what port the service they require is running on.</li>
<li>A service error, such as where the service that should be listening on a port has crashed or is otherwise unavailable.</li>
</ol>
<p>所以此状态可以用于判断端口的状态，而对于端口检测通常为 local，所以可以用作判断依据</p>
<pre><code class="language-go">func checkPortIsAvailable(protocol string, port int) {
	timeoutSecs := 3
	addr, err := GetInterfaceIpv4Addr(&quot;eth0&quot;)
	conn, err := net.DialTimeout(protocol, net.JoinHostPort(addr, strconv.Itoa(port)), time.Duration(timeoutSecs)*time.Second)
	for {
		if err != nil {
			opErr, ok := err.(*net.OpError)
			if ok &amp;&amp; strings.Contains(opErr.Err.Error(), &quot;refused&quot;) {
				break
			} else if opErr.Timeout() {
				continue
			} else {
				continue
			}
		}
		
		if conn != nil {
			defer conn.Close()
			continue
		}
	}
}
</code></pre>
<h2 id="方法2golib">方法2：golib</h2>
<p>库 <a href="https://github.com/antelman107/net-wait-go/" target="_blank"
   rel="noopener nofollow noreferrer" >github.com/antelman107/net-wait-go</a> 可以用于等待端口直到状态为open，通过这种方法也可以很好的检测端口是否占用</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - gocolly</title>
      <link>https://www.oomkill.com/2022/03/golib-gocolly/</link>
      <pubDate>Tue, 29 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2022/03/golib-gocolly/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>本文对colly如何使用，整个代码架构设计，以及一些使用实例的收集。</p>
<p>Colly是Go语言开发的Crawler Framework，并不是一个完整的产品，Colly提供了类似于Python的同类产品（<code>BeautifulSoup</code> 或  <code>Scrapy</code>）相似的表现力和灵活性。</p>
<p>Colly这个名称源自 <code>Collector</code>  的简写，而<code>Collector</code> 也是 Colly的核心。</p>
<p><a href="http://go-colly.org/docs/" target="_blank"
   rel="noopener nofollow noreferrer" >Colly Official Docs</a>，内容不是很多，最新的消息也很就远了，仅仅是活跃在Github</p>
<h2 id="concepts">Concepts</h2>
<h3 id="architecture">Architecture</h3>
<p>从理解上来说，Colly的设计分为两层，核心层和解析层，</p>
<ul>
<li><code>Collector</code> ：是Colly实现，该组件负责网络通信，并负责在<code>Collector</code> 作业运行时执行对应事件的回调。</li>
<li><code>Parser </code>：这个其实是抽象的，官网并未对此说明，goquery和一些htmlquery，通过这些就可以将访问的结果解析成类Jquery对象，使html拥有了，XPath选择器和CSS选择器</li>
</ul>
<p>通常情况下Crawler的工作流生命周期大致为</p>
<blockquote>
<ul>
<li>构建客户端</li>
<li>发送请求</li>
<li>获取响应的数据</li>
<li>将相应的数据解析</li>
<li>对所需数据处理</li>
<li>持久化</li>
</ul>
</blockquote>
<p>而Colly则是将这些概念进行封装，通过将事件注册到每个步骤中，通过事件的方式对数据进行清理，抽象来说，Colly面向的是过程而不是对象。大概的工作架构如图</p>
<p><img loading="lazy" src="../../images/gocolly/image-20220401003447726.png" alt="image-20220401003447726" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="event">event</h3>
<p>通过上述的概念，可以大概了解到 <code>Colly </code> 是一个基于事件的Crawler，通过开发者自行注册事件函数来触发整个流水线的工作</p>
<p>Colly 具有以下事件处理程序：</p>
<ul>
<li>OnRequest：在请求之前调用</li>
<li>OnError ：在请求期间发生错误时调用</li>
<li>OnResponseHeaders ：在收到响应头后调用</li>
<li>OnResponse： 在收到响应后调用</li>
<li>OnHTML：如果接收到的内容是 HTML，则在 OnResponse 之后立即调用</li>
<li>OnXML ：如果接收到的内容是 HTML 或 XML，则在 OnHTML 之后立即调用</li>
<li>OnScraped：在 OnXML 回调之后调用</li>
<li>OnHTMLDetach：取消注册一个OnHTML事件函数，取消后，如未执行过得事件将不会再被执行</li>
<li>OnXMLDetach：取消注册一个OnXML事件函数，取消后，如未执行过得事件将不会再被执行</li>
</ul>
<blockquote>
<p>Reference</p>
<p><a href="https://github.com/PuerkitoBio/goquery" target="_blank"
   rel="noopener nofollow noreferrer" >goquery</a></p>
<p><a href="https://github.com/antchfx/htmlquery" target="_blank"
   rel="noopener nofollow noreferrer" >htmlquery</a></p>
</blockquote>
<h2 id="utilities">Utilities</h2>
<h3 id="简单使用">简单使用</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;github.com/gocolly/colly&quot;
)

func main() {
	// Instantiate default collector
	c := colly.NewCollector(
		// Visit only domains: hackerspaces.org, wiki.hackerspaces.org
		colly.AllowedDomains(&quot;hackerspaces.org&quot;, &quot;wiki.hackerspaces.org&quot;),
	)

	// On every a element which has href attribute call callback
	c.OnHTML(&quot;a[href]&quot;, func(e *colly.HTMLElement) {
		link := e.Attr(&quot;href&quot;)
		// Print link
		fmt.Printf(&quot;Link found: %q -&gt; %s\n&quot;, e.Text, link)
		// Visit link found on page
		// Only those links are visited which are in AllowedDomains
		c.Visit(e.Request.AbsoluteURL(link))
	})

	// Before making a request print &quot;Visiting ...&quot;
	c.OnRequest(func(r *colly.Request) {
		fmt.Println(&quot;Visiting&quot;, r.URL.String())
	})

	// Start scraping on https://hackerspaces.org
	c.Visit(&quot;https://hackerspaces.org/&quot;)
}
</code></pre>
<h3 id="错误处理">错误处理</h3>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;github.com/gocolly/colly&quot;
)

func main() {
	// Create a collector
	c := colly.NewCollector()

	// Set HTML callback
	// Won't be called if error occurs
	c.OnHTML(&quot;*&quot;, func(e *colly.HTMLElement) {
		fmt.Println(e)
	})

	// Set error handler
	c.OnError(func(r *colly.Response, err error) {
		fmt.Println(&quot;Request URL:&quot;, r.Request.URL, &quot;failed with response:&quot;, r, &quot;\nError:&quot;, err)
	})

	// Start scraping
	c.Visit(&quot;https://definitely-not-a.website/&quot;)
}
</code></pre>
<h3 id="处理本地文件">处理本地文件</h3>
<p>word.html</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Document title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;p&gt;List of words&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;dark&lt;/li&gt;
    &lt;li&gt;smart&lt;/li&gt;
    &lt;li&gt;war&lt;/li&gt;
    &lt;li&gt;cloud&lt;/li&gt;
    &lt;li&gt;park&lt;/li&gt;
    &lt;li&gt;cup&lt;/li&gt;
    &lt;li&gt;worm&lt;/li&gt;
    &lt;li&gt;water&lt;/li&gt;
    &lt;li&gt;rock&lt;/li&gt;
    &lt;li&gt;warm&lt;/li&gt;
&lt;/ul&gt;
&lt;footer&gt;footer for words&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;

    &quot;github.com/gocolly/colly/v2&quot;
)

func main() {

    t := &amp;http.Transport{}
    t.RegisterProtocol(&quot;file&quot;, http.NewFileTransport(http.Dir(&quot;.&quot;)))

    c := colly.NewCollector()
    c.WithTransport(t)

    words := []string{}

    c.OnHTML(&quot;li&quot;, func(e *colly.HTMLElement) {
        words = append(words, e.Text)
    })

    c.Visit(&quot;file://./words.html&quot;)

    for _, p := range words {
        fmt.Printf(&quot;%s\n&quot;, p)
    }
}
</code></pre>
<h3 id="使用代理交换器">使用代理交换器</h3>
<p>通过 <code>ProxySwitcher</code> , 可以直接使用一批代理IP池进行访问了，然而这里只有RR，如果需要其他的均衡算法，需要有自己实现了</p>
<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	&quot;log&quot;

	&quot;github.com/gocolly/colly&quot;
	&quot;github.com/gocolly/colly/proxy&quot;
)

func main() {
	// Instantiate default collector
	c := colly.NewCollector(colly.AllowURLRevisit())

	// Rotate two socks5 proxies
	rp, err := proxy.RoundRobinProxySwitcher(&quot;socks5://127.0.0.1:1337&quot;, &quot;socks5://127.0.0.1:1338&quot;)
	if err != nil {
		log.Fatal(err)
	}
	c.SetProxyFunc(rp)

	// Print the response
	c.OnResponse(func(r *colly.Response) {
		log.Printf(&quot;Proxy Address: %s\n&quot;, r.Request.ProxyURL)
		log.Printf(&quot;%s\n&quot;, bytes.Replace(r.Body, []byte(&quot;\n&quot;), nil, -1))
	})

	// Fetch httpbin.org/ip five times
	for i := 0; i &lt; 5; i++ {
		c.Visit(&quot;https://httpbin.org/ip&quot;)
	}
}

</code></pre>
<h3 id="随机延迟">随机延迟</h3>
<p>该功能可以对行为设置一种特征，以免被反扒机器人检测，并禁止我们，如速率限制和延迟</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;time&quot;

	&quot;github.com/gocolly/colly&quot;
	&quot;github.com/gocolly/colly/debug&quot;
)

func main() {
	url := &quot;https://httpbin.org/delay/2&quot;

	// Instantiate default collector
	c := colly.NewCollector(
		// Attach a debugger to the collector
		colly.Debugger(&amp;debug.LogDebugger{}),
		colly.Async(true),
	)

	// Limit the number of threads started by colly to two
	// when visiting links which domains' matches &quot;*httpbin.*&quot; glob
	c.Limit(&amp;colly.LimitRule{
		DomainGlob:  &quot;*httpbin.*&quot;,
		Parallelism: 2,
		RandomDelay: 5 * time.Second,
	})

	// Start scraping in four threads on https://httpbin.org/delay/2
	for i := 0; i &lt; 4; i++ {
		c.Visit(fmt.Sprintf(&quot;%s?n=%d&quot;, url, i))
	}
	// Start scraping on https://httpbin.org/delay/2
	c.Visit(url)
	// Wait until threads are finished
	c.Wait()
}
</code></pre>
<h3 id="多线程请求队列">多线程请求队列</h3>
<pre><code>package main

import (
	&quot;fmt&quot;

	&quot;github.com/gocolly/colly&quot;
	&quot;github.com/gocolly/colly/queue&quot;
)

func main() {
	url := &quot;https://httpbin.org/delay/1&quot;

	// Instantiate default collector
	c := colly.NewCollector(colly.AllowURLRevisit())

	// create a request queue with 2 consumer threads
	q, _ := queue.New(
		2, // Number of consumer threads
		&amp;queue.InMemoryQueueStorage{MaxSize: 10000}, // Use default queue storage
	)

	c.OnRequest(func(r *colly.Request) {
		fmt.Println(&quot;visiting&quot;, r.URL)
		if r.ID &lt; 15 {
			r2, err := r.New(&quot;GET&quot;, fmt.Sprintf(&quot;%s?x=%v&quot;, url, r.ID), nil)
			if err == nil {
				q.AddRequest(r2)
			}
		}
	})

	for i := 0; i &lt; 5; i++ {
		// Add URLs to the queue
		q.AddURL(fmt.Sprintf(&quot;%s?n=%d&quot;, url, i))
	}
	// Consume URLs
	q.Run(c)

}
</code></pre>
<h3 id="异步">异步</h3>
<p>默认情况下，Colly的工作模式是同步的。可以使用 <code>Async</code> 函数启用异步模式。在异步模式下，我们需要调用<code>Wait</code> 等待<code>Collector</code> 工作完成。</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;

    &quot;github.com/gocolly/colly/v2&quot;
)

func main() {

    urls := []string{
        &quot;http://webcode.me&quot;,
        &quot;https://example.com&quot;,
        &quot;http://httpbin.org&quot;,
        &quot;https://www.perl.org&quot;,
        &quot;https://www.php.net&quot;,
        &quot;https://www.python.org&quot;,
        &quot;https://code.visualstudio.com&quot;,
        &quot;https://clojure.org&quot;,
    }

    c := colly.NewCollector(
        colly.Async(),
    )

    c.OnHTML(&quot;title&quot;, func(e *colly.HTMLElement) {
        fmt.Println(e.Text)
    })

    for _, url := range urls {

        c.Visit(url)
    }

    c.Wait()

}
</code></pre>
<h3 id="最大深度">最大深度</h3>
<p>深度是在访问这个页面时，其页面还有link，此时需要采集到入口link几层的link？默认1</p>
<pre><code class="language-go">package main

import (
   &quot;fmt&quot;

   &quot;github.com/gocolly/colly&quot;
)

func main() {
   // Instantiate default collector
   c := colly.NewCollector(
      // MaxDepth is 1, so only the links on the scraped page
      // is visited, and no further links are followed
      colly.MaxDepth(1),
   )

   // On every a element which has href attribute call callback
   c.OnHTML(&quot;a[href]&quot;, func(e *colly.HTMLElement) {
      link := e.Attr(&quot;href&quot;)
      // Print link
      fmt.Println(link)
      // Visit link found on page
      e.Request.Visit(link)
   })

   // Start scraping on https://en.wikipedia.org
   c.Visit(&quot;https://en.wikipedia.org/&quot;)
}
</code></pre>
<blockquote>
<p>Reference</p>
<p><a href="https://faun.pub/web-scrapping-using-golang-gocolly-21f824070291" target="_blank"
   rel="noopener nofollow noreferrer" >gocolly</a></p>
<p><a href="https://zetcode.com/golang/colly/" target="_blank"
   rel="noopener nofollow noreferrer" >colly</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - deepcopier</title>
      <link>https://www.oomkill.com/2021/10/golib-deepcopier/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/golib-deepcopier/</guid>
      <description></description>
      <content:encoded><![CDATA[<blockquote>
<p><strong>question</strong>: How use golang Copy one struct to another where structs have same members and different types</p>
</blockquote>
<p>此时需要的库</p>
<ul>
<li><code>github.com/ulule/deepcopier</code></li>
<li><code>github.com/jinzhu/copier</code></li>
</ul>
<p>E.g.</p>
<pre><code class="language-go">package main

import (
   &quot;fmt&quot;

   &quot;github.com/ulule/deepcopier&quot;
)

// Model
type User struct {
    // Basic string field
    Name  string
    // Deepcopier supports https://golang.org/pkg/database/sql/driver/#Valuer
    Email sql.NullString
}

func (u *User) MethodThatTakesContext(ctx map[string]interface{}) string {
    // do whatever you want
    return&quot;hello from this method&quot;
}

// Resource
type UserResource struct {
    //copy from field&quot;Name&quot;
    DisplayName            string `deepcopier:&quot;field:Name&quot;`
    //this will be skipped in copy
    SkipMe                 string `deepcopier:&quot;skip&quot;`
    //this should call method named MethodThatTakesContext
    MethodThatTakesContext string `deepcopier:&quot;context&quot;`
    Email                  string `deepcopier:&quot;force&quot;`

}

func main() {
    user := &amp;User{
        Name:&quot;gilles&quot;,
        Email: sql.NullString{
            Valid: true,
            String:&quot;gilles@example.com&quot;,
        },
    }

    resource := &amp;UserResource{}

    deepcopier.Copy(user).To(resource)
    //copied from User's Name field
    fmt.Println(resource.DisplayName)//output: gilles
    fmt.Println(resource.Email) //output: gilles@example.com
    fmt.Println(resource.MethodThatTakesContext) //output: hello from this method
}
</code></pre>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://www.codenong.com/37246473/" target="_blank"
   rel="noopener nofollow noreferrer" >copy different struct</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>goland设置import规范</title>
      <link>https://www.oomkill.com/2021/10/go-mod-specification/</link>
      <pubDate>Thu, 14 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/go-mod-specification/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>import 规范</p>
<p>引入了三种类型的包，<em>标准库包</em>，<em>第三方包</em>，<em>程序内部包</em>，建议采用如下方式进行组织你的包：</p>
<p>有顺序的引入包，不同的类型采用空格分离，</p>
<ul>
<li>第一种标准库</li>
<li>第二是第三方包</li>
<li>第三是项目包。</li>
</ul>
<p>在项目中不要使用相对路径引入包，在goland中可以使用如下设置自动格式化为引入标准</p>
<blockquote>
<p><strong>打开设置：Editor &gt; Code Style &gt; Go，选择import标签，将排序改为<code>goimports</code>, 剩下的按照自己喜好进行修改即可</strong></p>
</blockquote>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20211014191200274-1721289778.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://www.jetbrains.com/help/go/creating-and-optimizing-imports.html#use-the-goimports-local-grouping" target="_blank"
   rel="noopener nofollow noreferrer" >goimports-group</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>goland在mod模式下不从vendor文件夹查找依赖</title>
      <link>https://www.oomkill.com/2020/12/go-vendor-file-in-goland/</link>
      <pubDate>Sun, 13 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/12/go-vendor-file-in-goland/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="goland使用vendor作为获取依赖源">goland使用vendor作为获取依赖源</h2>
<p>软件版本：</p>
<ul>
<li>system：windows10 1709</li>
<li>terminal： wsl ubuntu1804</li>
<li>goland：201903</li>
</ul>
<p>goland 打开项目时使用mod模式，无法识别外部包的依赖</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201213223548527-786340550.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201213223808063-2002771119.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>根据<a href="https://www.jetbrains.com/help/go/configuring-build-constraints-and-vendoring.html#vendoring" target="_blank"
   rel="noopener nofollow noreferrer" >goland</a>官方提示，开启时，将忽略go.mod依赖描述，所以就找不到相对应的依赖，但是编译时正常的。可以看到下图中，<code>external libraries</code> 并没有加载外部的库导致了无法识别。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201213223827606-198056237.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>此时想要正常使用的话，可以按照提示操作</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201213224355732-1993575476.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>将 goland 改为gopath模式，执行<code>go mod vendor</code> 将依赖同步到vendor 。此时正常。</p>
<p>当依赖更新时，可以手动添加对应的依赖库，<code>go mod tidy</code> 后 。因为vendor中没有新的依赖，需要手动执行下<code>go mod vendor</code>即可正常使用。</p>
<h2 id="使用vendor编译">使用vendor编译</h2>
<p>在编译时，可以使用 <code>-mod=vendor</code> 标记，使用代码主目录文件夹下<code>vendor</code>目录满足依赖获取，<code>go build -mod=vendor</code>。此时，<code>go build</code> 忽略<code>go.mod</code> 中的依赖，（这里仅使用代码root目录下的vendor其他地方的将忽略）</p>
<p><code>GOFLAGS=-mod=vendor</code> 设置顶级vendor作为依赖 <code>go env -w GOFLAGS=&quot;-mod=vendor&quot;</code> 进行设置。 取消 <code>go env -w GOFLAGS=&quot;-mod=&quot;</code></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go mod</title>
      <link>https://www.oomkill.com/2019/10/go-mod/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-mod/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>自从Go官方推出 1.11 之后，增加新的依赖管理模块并且更加易于管理项目中所需要的模块。模块是存储在文件树中的 Go 包的集合，其根目录中包含 go.mod 文件。 go.mod 文件定义了模块的模块路径，它也是用于根目录的导入路径，以及它的依赖性要求。每个依赖性要求都被写为模块路径和特定语义版本。</p>
<p>从 Go 1.11 开始，Go 允许在 <code>$GOPATH/src</code> 外的任何目录下使用 go.mod 创建项目。在 <code>$GOPATH/src</code> 中，为了兼容性，Go 命令仍然在旧的 GOPATH 模式下运行。从 ==Go 1.13== 开始，模块模式将成为默认模式。</p>
<p>使用模块开发 Go 代码时出现的一系列常见操作：</p>
<ul>
<li>创建一个新模块。</li>
<li>添加依赖项。</li>
<li>升级依赖项。</li>
<li>删除未使用的依赖项。</li>
</ul>
<p>要使用go module,首先要设置 ==<code>GO111MODULE=on</code>== ,如果没设置，执行命令的时候会有提示。</p>
<p>==<code>GO111MODULE</code>== 的取值为 <code>off</code>, <code>on</code>, <code>or auto</code> (默认值，因此前面例子里需要注意2个重点)。</p>
<ul>
<li><strong><code>off</code></strong>: <code>GOPATH mode</code>，查找vendor和GOPATH目录</li>
<li><strong><code>on</code></strong>：<code>module-aware mode</code>，使用 go module，忽略GOPATH目录</li>
<li><strong><code>auto</code></strong>：如果当前目录不在<code>$GOPATH</code> 并且 当前目录（或者父目录）下有go.mod文件，则使用<code>GO111MODULE</code>， 否则仍旧使用 <code>GOPATH mode</code>。</li>
</ul>
<pre><code class="language-sh">export GO111MODULE=on
export GOPROXY=https://goproxy.io ## 设置代理
</code></pre>
<h3 id="go-mod-参数说明">go mod 参数说明</h3>
<table>
<thead>
<tr>
<th>commond</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>download</td>
<td>download modules to local cache (下载依赖的module到本地cache))</td>
</tr>
<tr>
<td>edit</td>
<td>edit go.mod from tools or scripts (编辑go.mod文件)</td>
</tr>
<tr>
<td>graph</td>
<td>print module requirement graph (打印模块依赖图))</td>
</tr>
<tr>
<td>init</td>
<td>initialize new module in current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))</td>
</tr>
<tr>
<td>tidy</td>
<td>add missing and remove unused modules (增加丢失的module，去掉未用的module)</td>
</tr>
<tr>
<td>vendor</td>
<td>make vendored copy of dependencies (将依赖复制到vendor下)</td>
</tr>
<tr>
<td>verify</td>
<td>verify dependencies have expected content (校验依赖)</td>
</tr>
<tr>
<td>why</td>
<td>explain why packages or modules are needed (解释为什么需要依赖)</td>
</tr>
</tbody>
</table>
<h4 id="新的项目">新的项目</h4>
<p>可以在<code>GOPATH</code>之外创建新的项目。</p>
<p>使用空目录创建<code>go.mod (module)</code></p>
<pre><code>go mod init {packagename}

go mod init test
</code></pre>
<h4 id="go-get-升级"><code>go get</code> 升级</h4>
<ul>
<li>运行 <code>go get -u</code> 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)</li>
<li>运行 <code>go get -u=patch</code> 将会升级到最新的修订版本</li>
<li>运行 <code>go get package@version</code> 将会升级到指定的版本号version</li>
<li>运行<code>go get</code>如果有版本的更改，那么<code>go.mod</code>文件也会更改</li>
</ul>
<h4 id="包管理">包管理</h4>
<p>当我们使用<code>go build</code>，<code>go test</code>以及<code>go list</code>时，go会自动得更新go.mod文件，将依赖关系写入其中。</p>
<p>下载的包保存在<code>$GOPATH/</code></p>
<h4 id="升级依赖项">升级依赖项</h4>
<p>查看使用到的依赖列表 <code>go list -m all</code></p>
<pre><code class="language-sh">root@lc-virtual-machine:~# go list -m all
chat
github.com/Knetic/govaluate v3.0.0+incompatible
github.com/OwnLocal/goes v1.0.0
github.com/astaxie/beego v1.12.0
github.com/beego/goyaml2 v0.0.0-20130207012346-5545475820dd
github.com/beego/x2j v0.0.0-20131220205130-a0352aadc542
github.com/bradfitz/gomemcache v0.0.0-20180710155616-bc664df96737
github.com/casbin/casbin v1.7.0
github.com/cloudflare/golz4 v0.0.0-20150217214814-ef862a3cdc58
github.com/couchbase/go-couchbase v0.0.0-20181122212707-3e9b6e1258bb
github.com/couchbase/gomemcached v0.0.0-20181122193126-5125a94a666c
github.com/couchbase/goutils v0.0.0-20180530154633-e865a1461c8a
github.com/cupcake/rdb v0.0.0-20161107195141-43ba34106c76
github.com/edsrzf/mmap-go v0.0.0-20170320065105-0bce6a688712
github.com/elazarl/go-bindata-assetfs v1.0.0
github.com/garyburd/redigo v1.6.0
github.com/go-redis/redis v6.14.2+incompatible
github.com/go-sql-driver/mysql v1.4.1
github.com/gogo/protobuf v1.1.1
github.com/golang/snappy v0.0.0-20180518054509-2e65f85255db
github.com/gomodule/redigo v2.0.0+incompatible
github.com/lib/pq v1.0.0
github.com/mattn/go-sqlite3 v1.10.0
github.com/pelletier/go-toml v1.2.0
github.com/pkg/errors v0.8.0
github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644
github.com/siddontang/go v0.0.0-20180604090527-bdc77568d726
github.com/siddontang/ledisdb v0.0.0-20181029004158-becf5f38d373
github.com/siddontang/rdb v0.0.0-20150307021120-fc89ed2e418d
github.com/ssdb/gossdb v0.0.0-20180723034631-88f6b59b84ec
github.com/syndtr/goleveldb v0.0.0-20181127023241-353a9fca669c
github.com/wendal/errors v0.0.0-20130201093226-f66c77a7882b
golang.org/x/crypto v0.0.0-20181127143415-eb0de9b17e85
golang.org/x/net v0.0.0-20181114220301-adae6a3d119a
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405
gopkg.in/yaml.v2 v2.2.1
</code></pre>
<blockquote>
<p><strong>列出包的历史版本</strong></p>
</blockquote>
<p><code>go list -m -versions {package name}</code></p>
<pre><code class="language-sh">root@lc-virtual-machine:~# go list -m -versions github.com/astaxie/beego 
github.com/astaxie/beego v0.6.0 v0.7.0 v0.8.0 v0.9.0 v1.0.1 v1.2.0 v1.3.0 v1.4.0 v1.4.1 v1.4.2 v1.4.3 v1.5.0 v1.6.0 v1.6.1 v1.7.0 v1.7.1 v1.7.2 v1.8.0 v1.8.1 v1.8.2 v1.8.3 v1.9.0 v1.9.2 v1.10.0 v1.10.1 v1.11.0 v1.11.1 v1.12.0

</code></pre>
<blockquote>
<p><strong>手动处理依赖关系</strong></p>
</blockquote>
<p><code>go mod tidy</code> 会自动清理掉不需要的依赖项，同时可以将依赖项更新到当前版本。</p>
<blockquote>
<p><strong>切换包的版本</strong></p>
</blockquote>
<pre><code class="language-bash">go mod edit -require=&quot;github.com/astaxie/beego@v1.9.0&quot;
</code></pre>
<blockquote>
<p><strong>清楚缓存</strong></p>
</blockquote>
<pre><code class="language-bash">go clean -modcache
</code></pre>
<h3 id="go-mod-replace">go mod replace</h3>
<p>不过因为某些未知原因，并不是所有的包都能直接用go get获取到，这时我们就需要使用go modules的replace功能了。（当然大部分问题挂个梯子就能解决，但是我们也可以有其它选项）</p>
<pre><code class="language-go.mod">replace (
	github.com/testcontainers/testcontainers-go =&gt; github.com/testcontainers/testcontainers-go v0.0.9
	golang.org/x/lint =&gt; github.com/golang/lint latest
)
</code></pre>
<p>修改后悔自动生成</p>
<pre><code class="language-mod">replace (
	github.com/testcontainers/testcontainers-go =&gt; github.com/testcontainers/testcontainers-go v0.0.9
	golang.org/x/lint =&gt; github.com/golang/lint v0.0.0-20191125180803-fdd1cda4f05f
)
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>go net/http使用</title>
      <link>https://www.oomkill.com/2019/10/go-net/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-net/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>Go语言标准库内建提供了net/http包，涵盖了HTTP客户端和服务端的具体实现。使用net/http包，我们可以很方便地编写HTTP客户端或服务端的程序。</p>
<h2 id="http服务端的创建流程">http服务端的创建流程</h2>
<p>在使用http/net包创建服务端只需要两个步骤 绑定处理器函数 <code>func(ResponseWriter, *Request)</code>与 启用监听 <code>http.ListenAndServe</code>。</p>
<pre><code class="language-go">package main

import &quot;net/http&quot;

func main() {
	http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(&quot;123&quot;))
	})
	http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>
<p>通过分析<code>net/http</code>包中<code>server.go</code> 在执行创建http服务端主要执行了下面几个步骤：</p>
<ul>
<li><code>http.HandleFunc</code> 绑定处理函数</li>
<li>所有的操作的方法都属于一个结构体 <code>ServeMux</code>
<ul>
<li>m: 用户传入的路由和处理方法的映射表，路由和处理函数被定义为结构体<code>muxEntry</code>的属性</li>
<li>mu： 实例化出来的对象的读写锁</li>
</ul>
</li>
<li>调用<code>DefaultServeMux.Handle()</code></li>
<li>在<code>DefaultServeMux.Handle()</code>中调用<code>DefaultServeMux.HandleFunc(pattern, handler)</code></li>
<li>在将传入http.HandleFunc()的回调函数，与路由的映射信息，放到该<code>DefaultServeMux</code>的属性中 映射map中 <code>muxEntry</code></li>
<li><code>http.ListenAndServe</code> 启动服务监听</li>
<li>实例化一个server结构体</li>
<li>调用 <code>ListenAndServe()</code></li>
<li><code>ListenAndServe()</code>中 <code>net.Listen(&quot;tcp&quot;, addr)</code> 启动tcp服务监听</li>
<li>Serve()中 appcet()处理用户连接，<code>go c.serve(connCtx)</code> 处理业务段（如判断信息，拼接http、找到对应处理函数）</li>
</ul>
<p>综上所述，<code>net/http server.go</code> 一切的基础为ServeMux 和 Handler</p>
<p>Go语言的<code>net/http</code>包还封装了常用处理器，如 <code>FileServer</code>，<code>NotFoundHandler</code> <code>RedirectHandler</code></p>
<h2 id="http客户端的使用">http客户端的使用</h2>
<h3 id="简单的get请求">简单的Get请求</h3>
<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;reflect&quot;
)

func main() {
	resp, err := http.Get(&quot;http://www.baidu.com&quot;)

	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(reflect.TypeOf(resp.Body)) // *http.gzipReader
	b := bytes.NewBuffer(make([]byte, 1024))
	b.ReadFrom(resp.Body)
	fmt.Println(string(b.Bytes()))
}
</code></pre>
<h3 id="post请求">post请求</h3>
<pre><code class="language-go">package main

import (
	&quot;net/http&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/url&quot;
)

func main() {

	postParam := url.Values{
		&quot;user&quot;:      {&quot;xxxxxx&quot;},
		&quot;Pwd&quot;: {&quot;1&quot;},
	}

	resp, err := http.PostForm(&quot;http://www.baidu.com/loginRegister/login&quot;, postParam)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(string(body))
}
</code></pre>
<h3 id="构建客户端请求">构建客户端请求</h3>
<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;net/http&quot;
  &quot;io/ioutil&quot;
)

func main() {

  url := &quot;http://10.0.0.3:5555/v2/services/haproxy/configuration/version&quot;
  method := &quot;GET&quot;

  client := &amp;http.Client {
  }
  req, err := http.NewRequest(method, url, nil)

  if err != nil {
    fmt.Println(err)
  }

  res, err := client.Do(req)
  defer res.Body.Close()
  body, err := ioutil.ReadAll(res.Body)

  fmt.Println(string(body))
}
</code></pre>
<h2 id="使用认证">使用认证</h2>
<pre><code class="language-go">func basicAuth(username, password string) string {
  auth := username + &quot;:&quot; + password
  return base64.StdEncoding.EncodeToString([]byte(auth))
}

func redirectPolicyFunc(req *http.Request, via []*http.Request) error{
  req.Header.Add(&quot;Authorization&quot;,&quot;Basic &quot; + basicAuth(&quot;username1&quot;,&quot;password123&quot;))
  return nil
}

func main() {
  client := &amp;http.Client{
    Jar: cookieJar,
    CheckRedirect: redirectPolicyFunc,
  }

  req, err := http.NewRequest(&quot;GET&quot;, &quot;http://localhost/&quot;, nil)
  req.Header.Add(&quot;Authorization&quot;,&quot;Basic &quot; + basicAuth(&quot;username1&quot;,&quot;password123&quot;)) 
  resp, err := client.Do(req)
}
</code></pre>
<blockquote>
<p>Reference</p>
<p><a href="https://stackoverflow.com/questions/16673766/basic-http-auth-in-go" target="_blank"
   rel="noopener nofollow noreferrer" >Basic HTTP Auth in Go</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go socket TCP协议实现</title>
      <link>https://www.oomkill.com/2019/10/go-tcp-in-go/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-tcp-in-go/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>在TCP/IP协议中，“IP地址+TCP或UDP端口号”唯一标识网络通讯中的一个进程。“IP地址+端口号”就对应一个socket。欲建立连接的两个进程各自有一个socket来标识，那么这两个socket组成的socket pair就唯一标识一个连接。因此可以用Socket来描述网络连接的一对一关系。</p>
<p>常用的Socket类型有两种：流式Socket（SOCK_STREAM）和数据报式Socket（SOCK_DGRAM）。流式是一种面向连接的Socket，针对于面向连接的TCP服务应用；数据报式Socket是一种无连接的Socket，对应于无连接的UDP服务应用。</p>
<p>套接字通讯原理示意</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015112932245-832922409.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="tcp的cs架构">TCP的C/S架构</h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015112953158-858280748.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>在整个通信过程中，服务器端有两个socket参与进来，但用于通信的只有conn这个socket。它是由 listener创建的。隶属于服务器端。客户端有一个socket参与进来。</p>
<p><code>net.Listen()</code> 建立一个用于连接监听的套接字
<code>listen.Accept()</code> // 阻塞监听客户端连接请求，成功用于连接，返回用于通信的socket
<code>net.Dial()</code> 客户端向服务端发起连接建立一个socket连接</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015113232583-2036839633.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="并发的cs模型通信">并发的C/S模型通信</h2>
<h3 id="server">Server</h3>
<p>Accept()函数的作用是等待客户端的链接，如果客户端没有链接，该方法会阻塞。如果有客户端链接，那么该方法返回一个Socket负责与客户端进行通信。所以，每来一个客户端，该方法就应该返回一个Socket与其通信，因此，可以使用一个死循环，将Accept()调用过程包裹起来。</p>
<p>需要注意，实现并发处理多个客户端数据的服务器，就需要针对每一个客户端连接，单独产生一个Socket，并创建一个单独的goroutine与之完成通信。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;net&quot;
	&quot;strings&quot;
)

func handleConnect(conn net.Conn){
	var (
		b []byte
		err error
		n int
	)
	fmt.Println(conn.RemoteAddr(),&quot;建立连接.&quot;)
	defer conn.Close()
	b = make([]byte,4096)
        // 客户端可能持续不断的发送数据，因此接收数据的过程可以放在for循环中，服务端也持续不断的向客户端返回处理后的数据。
	for {
		n,err = conn.Read(b)

		content := strings.Trim(string(b[:n]),&quot;\r\n&quot;) // window中传送的内容存在换行符，作为判断时需要删除
                // 当客户端退出，服务端从chan中读取内容时是没有的，因此的到0 或者客户端主动退出输入exit或者quit
		if n == 0 || content == &quot;exit&quot; || content == &quot;quit&quot; {
			fmt.Println(&quot;客户端退出：&quot;,conn.RemoteAddr())
			return
		}

		if err != nil {
			fmt.Println(err)
			return
		}

		if _,err =  conn.Write([]byte(fmt.Sprintf(&quot;server reply:%s&quot;,b[:n])));err !=nil {
			fmt.Println(err)
			return
		}
		fmt.Println(&quot;client send: &quot;,content)
	}
}

func main() {
	var (
		listener net.Listener
		err      error
		conn     net.Conn
	)
	// 建立一个用于连接监听的套接字
	if listener, err = net.Listen(&quot;tcp&quot;, &quot;10.0.0.1:8088&quot;); err != nil {
		fmt.Println(err)
		return
	}
	defer listener.Close()

	fmt.Println(&quot;waiting client connect.&quot;)

	// 阻塞监听客户端连接请求，成功用于连接，返回用于通信的socket
	for {
		if conn, err = listener.Accept(); err != nil {
			fmt.Println(err)
			return
		}

		go handleConnect(conn)
	}
}
</code></pre>
<p>使用nc作为客户端向服务端发送信息</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015113907465-654602281.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="自定义客户端">自定义客户端</h3>
<p>客户端需要持续的向服务端发送数据，同时也要接收从服务端返回的数据。因此可将发送和接收放到不同的协程中。</p>
<ul>
<li>主协程循环接收服务器回发的数据（该数据应已转换为大写），并打印至屏幕；</li>
<li>子协程循环从键盘读取用户输入数据。</li>
<li>读取键盘输入可使用 <code>os.Stdin.Read()</code>。</li>
</ul>
<p>注意事项：</p>
<ul>
<li>服务端有对 exit返回的是 <code>io.EOF</code></li>
<li>当服务端断开时，chan读取的信息就为0了即服务端已经退出，如果客户端不退出会一直报错</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;strings&quot;
)

func main() {

	var (
		conn net.Conn
		err  error
		n    int
	)

	if conn, err = net.Dial(&quot;tcp&quot;, &quot;10.0.0.1:8088&quot;); err != nil {
		fmt.Println(err, 111)
		return
	}
	defer conn.Close()

	go func() {
		str := make([]byte, 1024)
		for {
			n, err := os.Stdin.Read(str)
			content := strings.ToLower(strings.Trim(string(str[:n]), &quot;\r\n&quot;))

			if n == 0 {
				fmt.Println(&quot;与服务端断开连接&quot;)
				return
			}

			if err == io.EOF || content == &quot;quit&quot; {
				return
			}

			if err != nil {
				fmt.Println(1, err)
				continue
			}

			_, err = conn.Write([]byte(content))
			if err != nil {
				fmt.Println(111, err)
				return
			}

		}
	}()

	byt := make([]byte, 1024)
	for {
		if _, err = conn.Read(byt); err != nil {
			if err == io.EOF {
				return
			}
			fmt.Println(err)
			continue
		}
		fmt.Println(&quot;server reply:&quot;, string(byt[:n]))
	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015115233290-1311572382.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 函数 function</title>
      <link>https://www.oomkill.com/2019/10/go-function/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-function/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="golang保留的函数">golang保留的函数</h2>
<p><code>init()</code>, <code>main()</code>是golang的保留函数，有如下特点：</p>
<ul>
<li><code>main()</code> 只能用在main包中，仅可定义一个，<code>init()</code> 可定义任意包，可重复定义，建议只定义一个</li>
<li>两个函数定义时不能有任何返回值</li>
<li>只能由go自动调用，不可被引用</li>
<li><code>init()</code> 先于 <code>main()</code> 执行，并不能被其他函数调用，执行时按照main import顺序执行。</li>
</ul>
<h3 id="包的执行顺序">包的执行顺序</h3>
<ul>
<li>Go的初始化和执行总是从main.main函数（main包导入其它的包）</li>
<li>同包下的不同 <code>.go</code> 文件，按照以文件名或包路径名的字符串顺序“<strong>从小到大</strong>”排序顺序执行</li>
<li>其他的包只有被<code>main</code>包 import 才会执行，按照 import 的先后顺序执行;</li>
<li>如果某个包被多次导入的话，在执行的时候只会导入一次;</li>
<li>当一个包被导入时，如果它还导入了其它的包，则先将其它的包包含进来;</li>
<li>导入顺序与初始化顺序相反 main =&gt; p1 =&gt; p2 | p2 =&gt; p1 =&gt; p</li>
<li>main被最后一个初始化，因其总是依赖其他包</li>
</ul>
<h2 id="函数">函数</h2>
<p>函数是将具有独立功能的代码组织成为一个整体，使其具有特殊功能的代码集。在Go语言中，函数是一种数据类型，其特性有如下：</p>
<ul>
<li>支持匿名函数</li>
<li>支持带有变量名的返回值</li>
<li>支持多值返回</li>
<li>支持匿名函数</li>
<li>不支持重载，一个包中不能有两个名字一样的函数。</li>
</ul>
<p>定义语法</p>
<pre><code class="language-go">func test(){

}

func test(a int, b int){

}

func test(a,b int){

}

func test(a,b int list...int){

}

func test(a int, b int) int{

}

func test(a int, b int ) (int,int){

}

func test(a,b int) (num int, err error){

}
</code></pre>
<p>花括号必须与函数声明在同一行，这种写法是错误的</p>
<pre><code class="language-go">func test()
{

}
</code></pre>
<h2 id="命名返回值名称">命名返回值名称</h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func test(a, b, c int) (he int, cha int) {
	he = a + b + c
	cha = a - b - c
	return
}

func main() {

	a, b := test(15, 10, 5)
	fmt.Println(a)
	fmt.Println(b)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004004404068-1876101209.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>_标识符，用来忽略返回值</p>
</blockquote>
<h2 id="函数参数传递方式">函数参数传递方式</h2>
<p>\1. 值传递
\2. 引用传递</p>
<p>注意：无论是值传递，还是引用传递，传递给函数的都是变量的副本，不过，值传递是值的持贝。引用传递是地址的持贝，一般来说，地址持贝更为高效。而值持贝取决于拷贝的对象大小，对象越大，则性能越低。</p>
<p>注意2：map、slice、chan、指针、interface默认以引用的方式传递</p>
<h2 id="自定义函数类型">自定义函数类型</h2>
<pre><code>package main

import &quot;fmt&quot;

type ty_func func(int, int) int

func add(a, b int) int {
	return a + b
}

func operator(op ty_func, a, b int) int {
	return op(a, b)
}

func main() {
	c := add
	sum := operator(c, 100, 200)

	fmt.Println(sum)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004005822762-1019812877.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="不定参数">不定参数</h2>
<ul>
<li>不定参数可以通过下标/循环方式获取参数值</li>
<li>不定参数在定义时，固定参数放前面，不定参数放后面</li>
<li>在对函数调用时，固定参数必须传值，不定参数可以根据需要来决定是否要传值</li>
</ul>
<p>语法</p>
<pre><code class="language-go">func {func_name}({param} ...{type}){
	func_body
}
</code></pre>
<p>参数的类型是一个 <code>{type}</code> 类型的集合</p>
<p>练习：写一个函数add，支持1个或多个int相加，并返回相加结果</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func test(num ...int) {
	var sum int
	for n := 1; n &lt;= len(num); n++ {
		sum += num[(n - 1)]
	}
	fmt.Println(sum)
}

func main() {
	test(1)
	test(1, 2, 3)
    test(1, 2, 3, 4)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004004529342-1382648432.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>练习：写一个函数concat，支持1个或多个string相拼接，并返回结果</p>
<pre><code class="language-go">func concat(age ...string) {
	var str string
	for _,v := range age {
		str += v
	}

	fmt.Println(str)
}

func main() {
	concat(&quot;hellow&quot;, &quot; world&quot;, &quot; go&quot;)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004004636040-1844877115.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="延迟调用defer">延迟调用defer</h2>
<ul>
<li>当函数返回时，执行defer语句。因此，可以用来做资源清理</li>
<li>多个defer语句，按LIFO（后进先出）的顺序执行</li>
<li>defer语句中的变量，在defer声明时就决定了。</li>
</ul>
<p>用途</p>
<ul>
<li>关闭文件句柄</li>
<li>锁资源释放</li>
<li>数据库连接释放</li>
</ul>
<p>defer语句中的变量，在defer声明时就决定了其值</p>
<pre><code class="language-go">func defer_test() {
	i := 0
	defer fmt.Println(i)

	i = 10

	fmt.Println(i)
}

func main() {
	defer_test()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004005551020-1793978404.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>多个defer按LIFO（后进先出）的顺序执行</p>
<pre><code>func defer_test() {
	i := 0
	defer fmt.Println(i)

	i = 10

	fmt.Println(i)
}

func main() {
	defer_test()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004005449280-2056741609.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>defer的作用域，此处可以看到，defer的传入不是在main的作用域下，测试可发现 <code>defer</code>只会在当前函数和方法返回之前被调用。</p>
<pre><code class="language-GO">package main

import &quot;fmt&quot;

func main() {
   fmt.Println(&quot;block starts&quot;)
   {
      defer fmt.Println(&quot;defer runs&quot;)
      fmt.Println(&quot;block ends&quot;)
   }

   fmt.Println(&quot;main ends&quot;)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004005407717-2125693767.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="函数作用域">函数作用域</h2>
<p>全局变量：既能在函数中使用，也能在其他函数中使用，可以称为定义在函数外的变量。</p>
<p>局部变量：定义在函数内部的变量成为局部变量，局部变量的作用域在函数内部。</p>
<p>如果全局变量的名字和局部变量的名字相同，使用的是局部变量</p>
<h2 id="匿名函数">匿名函数</h2>
<pre><code>package main

import &quot;fmt&quot;

var (
	test = func(a, b int) int {
		return a + b
	}(10, 20)
)

var test1 = func(age ...int) int {
	var sum int

	for n := 0; n &lt; len(age); n++ {
		sum += age[n]
	}
	return sum
}

func main() {
	c := test
	fmt.Println(c)

	d := test1(100, 100, 100)
	fmt.Println(d)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004004811240-1122578804.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 数据结构</title>
      <link>https://www.oomkill.com/2019/10/go-datastruct/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-datastruct/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。</p>
<p>基础数据类型包括：</p>
<ul>
<li>基础类型：
- 布尔型、整型、浮点型、复数型、字符型、字符串型、错误类型。</li>
<li>复合数据类型包括：
- 指针、数组、切片、字典、通道、结构体、接口。</li>
</ul>
<h2 id="基础数据类型">基础数据类型</h2>
<h3 id="布尔值和布尔表达式">布尔值和布尔表达式</h3>
<p>布尔类型的变量取值结果要么是真，要么是假，用<code>bool</code>关键字进行定义</p>
<p>布尔类型默认值为 <code>false</code></p>
<p>指定格式的输出 <code>%t</code></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述/结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>!b</td>
<td>逻辑非操作符 b值为true 则 操作结果为false</td>
</tr>
<tr>
<td>a || b</td>
<td>短路逻辑或，只要布尔值 a b 中任何一个为true表达式结果都为true</td>
</tr>
<tr>
<td>a &amp;&amp; b</td>
<td>短路逻辑与，两个表达式a b都为true，则整个表达式结果为true</td>
</tr>
<tr>
<td>x &gt; y</td>
<td>表达式x的值小于表达式Y的值，则表达式的结果为true</td>
</tr>
</tbody>
</table>
<h3 id="数值类型">数值类型</h3>
<p>go语言提供了大内置的数值类型，标准库也提供了big.Int类型的整数，和big.Rat类型的有理数，这些都是大小不限（只限于机器内存）</p>
<h4 id="整型">整型</h4>
<p>GO语言提供了11种整型，包含5种有符号，和5种无符号的与一种用于存储指针的整数类型。Go语言允许使用byte来作为无符号uint8类型的同义词，在使用单个字符时提倡使用<code>rune</code>来替代 <code>int32</code></p>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">存储空间</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td style="text-align:left">8-bit</td>
<td>同uint8</td>
</tr>
<tr>
<td>int</td>
<td style="text-align:left">系统决定</td>
<td>依赖不通平台实现，32位操作系统为<code>int32</code>的值范围，64位操作系统为<code>int64</code>的值范围</td>
</tr>
<tr>
<td>int8</td>
<td style="text-align:left">8-bit</td>
<td>[-128, 127] ，表示 UTF-8 字符串的单个字节的值，对应 ASCII 码的字符值</td>
</tr>
<tr>
<td>int16</td>
<td style="text-align:left">16-bit</td>
<td>[-32678, 32767]</td>
</tr>
<tr>
<td>int32</td>
<td style="text-align:left">32-bit</td>
<td>[2147483648, 2147483647]</td>
</tr>
<tr>
<td>int64</td>
<td style="text-align:left">64-bit</td>
<td>[-9223372036854775808 , 9223372036854775807]</td>
</tr>
<tr>
<td>rune</td>
<td style="text-align:left">32-bit</td>
<td>同uint32，表示 单个 Unicode 字符</td>
</tr>
<tr>
<td>uint</td>
<td style="text-align:left">系统决定</td>
<td>依赖不通平台下的实现，可以是uint32或uint64</td>
</tr>
<tr>
<td>uint8</td>
<td style="text-align:left">8-bit</td>
<td></td>
</tr>
<tr>
<td>uint16</td>
<td style="text-align:left">16-bit</td>
<td>[0, 65535]</td>
</tr>
<tr>
<td>uint32</td>
<td style="text-align:left">32-bit</td>
<td>[0, 4294967295]</td>
</tr>
<tr>
<td>uint64</td>
<td style="text-align:left">64-bit</td>
<td>[0, 18446744073709551615]</td>
</tr>
<tr>
<td>uintptr</td>
<td style="text-align:left">系统决定</td>
<td>一个可以恰好容纳指针值得无符号整数类型（32位操作系统为<code>uint32</code>的值范围，64位系统为<code>uint64</code>的值范围）</td>
</tr>
</tbody>
</table>
<h4 id="浮点类型">浮点类型</h4>
<p>Go语言提供了两种类型的浮点类型和两种类型的复数类型，</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储空间</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>float32</td>
<td>32-bit</td>
<td>[1.401298464324817070923729583289916131280e-45 , 3.402823466385288598117041834516925440e+38] 精确到小数点后7位</td>
</tr>
<tr>
<td>float64</td>
<td>64-bit</td>
<td>[4.940656458412465441765687928682213723651e-324 , 1.797693134862315708145274237317043567981e+308]  精确到小数点后15位</td>
</tr>
<tr>
<td>complexm64</td>
<td>64-bit</td>
<td>实部和虚部都是一个float32</td>
</tr>
<tr>
<td>complexm128</td>
<td>128-bit</td>
<td>实部和虚部都是一个float64</td>
</tr>
</tbody>
</table>
<pre><code class="language-go">fmt.printf(&quot;%.2f&quot;,num) // 保留两位小数，同时进行了四舍五入
</code></pre>
<h4 id="字符串-string">字符串 (string)</h4>
<p>字符串使用双引号 <code>&quot;</code> 或者反引号 ```来创建，双引号可以解析字符串变量</p>
<p>定义字符变量用 <code>byte</code> 关键词 <code>var ch byte = 'a'</code>  8-bit，代表了 ASCII 码的一个字符。指定格式的输出 <code>%c</code>
定义字符变量用 <code>rune</code> 关键词 <code>var ch rune = 'a'</code>  32-bit  代表了 Unicode（UTF-8）码的一个字符。
定义字符变量用 <code>string</code> 关键词 <code>var ch string = &quot;abc&quot;</code>指定格式的输出 <code>%s</code></p>
<p>字符串的结束标志 <code>\0</code>，Go语言使用的UTF8编码，英文占1个字符，一个汉字占3个字符</p>
<h3 id="自动推导类型">自动推导类型</h3>
<p>自动推到类型，创建的浮点型默认为 float64，整型为int</p>
<pre><code class="language-go">      a := &quot;123&quot;
      a := 10
</code></pre>
<h3 id="使用fmt格式化输出">使用fmt格式化输出</h3>
<p>格式指令通常由用于输出单个值，每个值都按格式指令格式化。用于<code>fmt.Printf()</code> <code>fmt.Errorf()</code>  <code>fmt.Fprintf()</code> <code>fmt.Sprintf()</code>函数的格式字符串包含一个或多个格式指令</p>
<table>
<thead>
<tr>
<th>格式指令</th>
<th>含义/结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>%b</td>
<td>二进制数值</td>
</tr>
<tr>
<td>%c</td>
<td>数值对应的 Unicode 编码字符</td>
</tr>
<tr>
<td>%d</td>
<td>十进制数值</td>
</tr>
<tr>
<td>%o</td>
<td>八制数值</td>
</tr>
<tr>
<td>%e</td>
<td>科学计数法，e表示</td>
</tr>
<tr>
<td>%E</td>
<td>科学计数法，E表示</td>
</tr>
<tr>
<td>%f</td>
<td>有小数部分，无指数部分</td>
</tr>
<tr>
<td>%g</td>
<td>以%f或%e表示浮点数或复数</td>
</tr>
<tr>
<td>%G</td>
<td>以%f或%E表示浮点数或复数</td>
</tr>
<tr>
<td>%s</td>
<td>直接输出字符串或者[]byte</td>
</tr>
<tr>
<td>%q</td>
<td>双引号括起来的字符串或者[]byte</td>
</tr>
<tr>
<td>%x</td>
<td>每个字节用两字节十六进制表示，a-f表示</td>
</tr>
<tr>
<td>%X</td>
<td>每个字节用两字节十六进制表示，A-F表示</td>
</tr>
<tr>
<td>%t</td>
<td>以true或fales输出布尔值</td>
</tr>
<tr>
<td>%T</td>
<td>输出值得类型</td>
</tr>
<tr>
<td>%v</td>
<td>默认格式输出内置或自定义类型的值</td>
</tr>
</tbody>
</table>
<h3 id="强制类型转换">强制类型转换</h3>
<p>类型转换用于将一种数据类型转换为另外一种类型</p>
<pre><code>var num float64 = 3.15
fmt.Printf(&quot;%d&quot;, int(num))
</code></pre>
<p>类型不一致的不能进行运算，在类型转换时，建议将低类型转换为高类型，保证数据精度，高类型转换成地类型，可能会丢失精度，或数据溢出</p>
<h2 id="复合数据类型">复合数据类型</h2>
<h3 id="数组">数组</h3>
<p>数组，一系列同一类型数据的集合，数组是值类型,在初始化后长度是固定的，无法修改其长度。</p>
<h4 id="数组的定义">数组的定义</h4>
<p><code>var arr [元素数量]类型</code></p>
<h4 id="数组初始化">数组初始化</h4>
<p>全部初始化  <code>var arr [5]int = [5]int{1,2,3,4,5}</code></p>
<p>部分初始化 <code>var arr [5]int = [5]int{1,2}</code> ,没有指定初值的元素将会赋值为其元素类型(int)的默认值(0)</p>
<p>指定下标初始化 <code>var arr = [5]int{2:5, 3:6}</code>  <code>key:value</code>的格式</p>
<p>通过初始化确定数组长度，<code>var arr = [...]int{1, 2, 3}</code> 长度是根据初始化时指定个数</p>
<p>相同空间大小（类型）的数组可以用 <code>==</code> <code>!=</code> 来比较是否相同。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var arr [2]int = [2]int{1, 2}
	var arr2 [2]int = [...]int{2, 2}
	fmt.Println(arr == arr2)
}


D:\go_work\src&gt;go run main.go
false
</code></pre>
<h4 id="数组的遍历">数组的遍历</h4>
<ul>
<li>通过 <code>for .. len()</code> 完成遍历</li>
<li>通过 <code>for .. range</code> 完成遍历</li>
</ul>
<h4 id="作为函数值传递">作为函数值传递</h4>
<p>golang数组是值类型，当数组作为函数参数，函数中修改数组中的值，不会影响原数组</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func test(t [2]int) {
	fmt.Println(&amp;t)
}

func main() {
	var arr [2]int = [2]int{1, 2}
	test(arr)
}
</code></pre>
<h4 id="二维数组">二维数组</h4>
<p>初始化方式</p>
<ul>
<li>全部初始化 <code>var arr [2][2]int = [2][2]int{ {1,2},{3,4} }</code></li>
<li>部分初始化 <code>var arr [2][2]int = [2][2]int{ {1,2},{3} }</code></li>
<li>指定元素初始化 <code>var arr [2][2]int = [2][2]int{ 1:{1} }</code>，<code>var arr [2][2]int = [2][2]int{ 1:{1:3} }</code></li>
<li>通过初始化确定二维数组行数 <code>var arr [...][2]int = [2][2]int{ {1,2},{3,4} }</code> 行下标可以用 <code>...</code> 列下标不可用 <code>...</code></li>
</ul>
<h3 id="map">map</h3>
<p>Go语言中的字典结构是有键和值构成的，所谓的键，就类似于字典的索引，可以快速查询出对应的数据。</p>
<p>map是只用无序的键值对的集合。</p>
<p>map最重要的一点是通过key来快速检索数据，key类似于索引，指向数据的值。</p>
<p>map中key的值是不能重复的</p>
<p>引用类型或包含引用类型的数据类型不能作为key</p>
<h4 id="map的创建">map的创建</h4>
<ul>
<li>字面量：<code>var map_name map[keyType]valType</code></li>
<li>类型推导： <code>map_name :=  map[keyType]valType</code></li>
<li>关键词：<code>make(map[keyType]valType)</code></li>
</ul>
<h4 id="map的初始化">map的初始化</h4>
<ul>
<li>字面量：<code>var maps[int]string = map[int]string{1: &quot;zhangsan&quot;, 2: &quot;lisi&quot;}</code></li>
<li>类型推导： <code>maps := map[int]string{1: &quot;zhangsan&quot;, 2: &quot;lisi&quot;}</code></li>
<li>关键词：<code>maps := make(map[string]int,10)</code>; <code>maps[&quot;zhangsan&quot;] = 14</code></li>
</ul>
<h4 id="map的key-value">map的key value</h4>
<p>通过key获取值时，判断key是否存在 <code>var1, var2 := map[key]</code>，如存在，var1存储对应的值，var2的值为true，var2否则为false</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func initial(t []int) {
	for n := 0; n &lt; 10; n++ {
		t[n] = n
	}
}

func main() {
	var m map[int]string = map[int]string{1: &quot;zhangsan&quot;, 2: &quot;lisi&quot;}

	fmt.Println(m)
	v, ok := m[2]

	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(ok)
	}

	v, ok = m[3]

	if ok {
		fmt.Println(v)
	} else {
		fmt.Println(ok)
	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004222750318-150497349.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><code>delete(map,2)</code> 通过key删除某个值</p>
<h4 id="作为函数参数传递">作为函数参数传递</h4>
<p>slice  map channel都是引用类型，所以改变是改变的变量的地址。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func initial(t map[int]string) {
	for n := 0; n &lt; 10; n++ {
		t[n] = fmt.Sprintf(&quot;aaa%d&quot;, n)
	}
}

func main() {
	var m = make(map[int]string, 10)

	initial(m)
	fmt.Println(m)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004222734115-568397490.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="切片">切片</h3>
<p>切片与数组相比，切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大，所以可以将切片理解为“动态数组”，但是，它不是数组。</p>
<h4 id="切片定义">切片定义</h4>
<p><code>var slice_name []type</code> 默认空切片，长度为0</p>
<p><code>slice_name := []type{}</code> 默认空切片，长度为0</p>
<p><code>make([]type, length, capacity)</code> length：已初始化的空间，capacity：已开辟的空间（length+空闲）。length不能大于capacity</p>
<p><code>len()</code> 返回长度 <code>cap()</code> 返回容量</p>
<p>如果使用字面量的方式创建切片，大部分的工作就都会在编译期间完成，使用 <code>make()</code> 关键字创建切片时，很多工作都需要运行时的参与。</p>
<h4 id="切片初始化">切片初始化</h4>
<p>通过 <code>var slice_name []type</code> 方式创建</p>
<pre><code class="language-go">import &quot;fmt&quot;

func main() {
	var slices []int

	slices = append(slices, 1, 2, 3, 4, 5, 6)

	fmt.Print(slices)

	slices = append(slices, 100, 99)

	fmt.Print(slices)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004193503175-356412365.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>通过 <code>slice_name := []type{}</code> 方式创建</p>
<ul>
<li>直接在 <code>{}</code> 中添加值</li>
<li>通过 <code>append()</code> 添加</li>
</ul>
<p>通过 <code>make([]type, length, capacity)</code>  方式创建</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var slices []int

	slices = make([]int, 3, 5)

	slices[0] = 1
	slices[1] = 2
	slices[2] = 3
	slices[3] = 4

	fmt.Println(slices)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004193452228-590165965.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="切片的截取">切片的截取</h4>
<p>切片截取</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>s[n]</td>
<td>切片s中索引位置为N的项</td>
</tr>
<tr>
<td>s[:]</td>
<td>从切片s的索引位置到 <code>len(s) - 1</code> 处所获得的切片</td>
</tr>
<tr>
<td>s[low:]</td>
<td>从切片s的索引位置low到 <code>len(s) - 1</code> 处所获得的切片</td>
</tr>
<tr>
<td>s[:high]</td>
<td>从切片s的索引位置0到high处所获得的切片 len=high</td>
</tr>
<tr>
<td>s[low:higt]</td>
<td>从切片s的索引位置low到high处所获得的切片 len=high-low</td>
</tr>
<tr>
<td>s[low:higt:max]</td>
<td>从切片s的索引位置low到high处所获得的切片，len=high-low，cap=max-low</td>
</tr>
<tr>
<td>len(s)</td>
<td>切片s的长度，&lt;=cap(s)</td>
</tr>
<tr>
<td>cap(s)</td>
<td>切片s的容量，&gt;=len(s)</td>
</tr>
</tbody>
</table>
<p><code>slice[startVal, length, Capacity]</code></p>
<p>容量为：<code>capacity - startVal</code></p>
<p>长度为： <code>length - startVal</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var slices []int

	slices = []int{1, 2, 3, 4, 5, 6, 7, 8}
	s := slices[1:3:5]

	fmt.Println(s)
	fmt.Println(len(s))
	fmt.Println(cap(s))
}

</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004201436109-1262934052.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>在截取时，<code>capacity</code> 不能超过原slice的 capacity</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var slices []int

	slices = []int{1, 2, 3, 4, 5, 6, 7, 8}
	s := slices[1:3:10]

	fmt.Println(s)
	fmt.Println(len(s))
	fmt.Println(cap(s))
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004201422642-1224055142.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="切片值得修改">切片值得修改</h4>
<p>问：切片截取后返回新切片，对新切片的值修改，会影响原切片吗</p>
<p>当对切片进行截取操作后，产生了新的切片，新的切片是指向原有切片的，对新切片值修改，会影响到原有切片</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var slices []int

	slices = []int{1, 2, 3, 4, 5, 6, 7, 8}
	s := slices[1:3]

	s[1] = 100

	fmt.Println(s)
	fmt.Println(slices)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004201354129-1430327244.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="追加和拷贝">追加和拷贝</h4>
<ul>
<li><code>append(slice, 1,2,3)</code> 向切片末尾追加数据</li>
<li><code>copy(slice1, slice2)</code>  拷贝的长度为两个切片中长度较小的长度值</li>
</ul>
<p>作为参数值传递，切片是数组的一个引用，因此切片是引用类型，操作会修改原有切片</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func initial(t []int) {
	for n := 0; n &lt; 10; n++ {
		t[n] = n
	}
}

func main() {
	var slices = make([]int, 10)
	fmt.Println(slices)
	initial(slices)
	fmt.Println(slices)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004211110895-1653694753.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="切片扩容">切片扩容</h4>
<p>切片扩容，一般方式：上一次容量的2倍，超过1024字节，每次扩容上一次的1/4</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func initial(t []int) {
	for n := 0; n &lt; 10; n++ {
		t[n] = n
	}
}

func main() {
	var slices = make([]int, 3)
	var slices1 = []int{4, 5}

	copy(slices, slices1)

	fmt.Println(slices)
	fmt.Println(slices1)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201004211522893-490726737.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="struct-结构体">struct 结构体</h3>
<p>结构体 <code>struct</code> 是由一系列具有相同类型或不同类型的数据构成的数据集合，结构体可以很好的管理一批有联系的数据，使用结构体可以提高程序的易读性。Go中提供了对 <code>struct</code> 的支持，与数组一样，<strong>struct属于复合类型，并非引用类型</strong>。</p>
<p>Go语言中结构体包含以下特性</p>
<ul>
<li>值传递，Go语言中结构体和数组一样是值类型，可以声明结构体指针向下传递</li>
<li>不可继承，Go语言中没有继承的概念，在结构体中，可以通过组合结构体，来构建更复杂的结构体。</li>
<li>结构体不能包含自己。</li>
</ul>
<h4 id="结构体声明">结构体声明</h4>
<p>成员名称前不能加 <code>var</code></p>
<pre><code class="language-go">type Student struct {
	id int
    name string
    age int
    addr string
}
</code></pre>
<h4 id="空结构体">空结构体</h4>
<p>结构体也可以不包含任何字段，称为空结构体 <code>struct{}</code></p>
<h4 id="结构体初始化">结构体初始化</h4>
<ul>
<li>顺序初始化 <code>var stu = Student{ id:101, name:&quot;zhangsan&quot;, age:19, addr:&quot;shanghai&quot; }</code></li>
<li>指定成员初始化 <code>var stu = Student{name:&quot;zhangsan&quot;, age:19}</code></li>
<li>通过 <code>结构体变量.成员</code> 完成初始化 <code>var stu Student  stu.age=19 stu.addr=&quot;peking&quot;</code></li>
</ul>
<h4 id="结构体传递">结构体传递</h4>
<p>结构体与数组一样，都是值传递，将结构体作为函数实参传给函数的形参时，会复制一个副本，所以为了提高性能，在结构体传给函数时，可以使用指针结构体。</p>
<p>指针结构体定义：声明结构体变量时，在结构体类型前加 <code>*</code> 号，便声明一个指向结构体的指针。 <code>var stu *Student</code>。
指针结构体访问： 由于<code>.</code>的优先级高于<code>*struct_name</code>,故在使用时，需要对结构体加括号。<code>(*struct_name).成员属性</code>  <code>(*stu).name</code></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 运算符</title>
      <link>https://www.oomkill.com/2019/10/go-arithmetic/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-arithmetic/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="算术运算符">算术运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>10 + 5</td>
<td>15</td>
</tr>
<tr>
<td>-</td>
<td>10 - 5</td>
<td>5</td>
</tr>
<tr>
<td>* （除数不能为0）</td>
<td>10 * 5</td>
<td>50</td>
</tr>
<tr>
<td>/</td>
<td>10 / 5</td>
<td>2</td>
</tr>
<tr>
<td>% （除数不能为0）</td>
<td>10 % 3</td>
<td>1</td>
</tr>
<tr>
<td>++</td>
<td>a = 0; a++</td>
<td>a = 1</td>
</tr>
<tr>
<td>&ndash;</td>
<td>a = 2; a&ndash;</td>
<td>a = 1</td>
</tr>
</tbody>
</table>
<p>总结</p>
<ul>
<li>除法/取余运算除数不能为0</li>
<li>只有后自增/减，没有前自增/减。没有 <code>++a</code> 或 <code>--a</code> 只有 <code>a++</code>  或 <code>a--</code></li>
</ul>
<p>输入半径，计算圆的面积和周长并打印出来（PI为3.14）</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	const PI = 3.14

	fmt.Println(&quot;请输入半径：&quot;)
	var r float64
	fmt.Scan(&amp;r)

	fmt.Printf(&quot;面积为：%.2f\n&quot;, 2*PI*r)
	fmt.Printf(&quot;周长为：%.2f\n&quot;, PI*r*r)
}
</code></pre>
<p>某学生三门课成绩为，语文90，数学89，英语69，编程求总分与平均分</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var (
		chinese = 90
		math    = 89
		english = 69
	)
	score := chinese + math + english
	//avg := score / 3 // 此处是整数值
	avg := float64(score) / 3

	fmt.Printf(&quot;总分为：%d\n&quot;, score)
	fmt.Printf(&quot;平均分为：%.2f\n&quot;, avg)
}
</code></pre>
<p>问题: 计算商品价格</p>
<p>问题1： 某商店T-shirt的价格为35圆/件，裤子的价格120圆/条，小明在该店购买了3件t-shirt和2条裤子，并且打8.8折，小明应该付多少钱</p>
<p>问题2：如上题打完8.8折后，出现小数，商店为了方便结算只收取商品整数部分的钱，如 303.6，则只收取303元。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	var (
		tshirt   = 35
		trousers = 120
	)

	total := 3*tshirt + 2*trousers

	realMember := float64(total) / 0.88
	fmt.Printf(&quot;打88折后价格为：%.2f\n&quot;, realMember)
	fmt.Printf(&quot;只收取整钱为：%d&quot;, int(realMember))
}
</code></pre>
<h2 id="赋值运算符">赋值运算符</h2>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>普通赋值</td>
<td>c = a + b 将a + b表达式结果赋值给c</td>
</tr>
<tr>
<td>+=</td>
<td>相加后在赋值</td>
<td>c += a 等价于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>相减后再赋值</td>
<td>c -= a 等价于 c =  c - a</td>
</tr>
<tr>
<td>*=</td>
<td>相乘后再赋值</td>
<td>c *= a 等价于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>相除后再赋值</td>
<td>c /= a 等价于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取余后再赋值</td>
<td>c %= a 等价于 c = c % a</td>
</tr>
</tbody>
</table>
<p>算数运算符优先级高于赋值运算符</p>
<pre><code>package main

import &quot;fmt&quot;

func main() {
	num := 20
	num %= 2 + 3
	fmt.Println(num)
}
</code></pre>
<h2 id="关系运算符">关系运算符</h2>
<p>关系运算符的结果是布尔类型的</p>
<p>优先级  算数 &gt; 关系 &gt; 赋值</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>&amp;&amp; || !</p>
<p>逻辑非后面的内容是bool类型</p>
<p>逻辑非的运算优先级高于关系运算符</p>
<p>逻辑与/逻辑或运算符优先级低于关系运算符</p>
<p><code>&amp;&amp;</code> 逻辑与的优先级高于  <code>||</code> <code>fmt.Println(1 &gt; 2 || 2 &gt; 1 &amp;&amp; 10 != 10)</code></p>
<p><strong>单目运算符</strong>：指运算所需变量为一个运算符，即在运算当中只有一个操作数。如：<code>a++</code> ，<code>b--</code>，<code>!test</code>，<code>&amp;</code> 等</p>
<p><strong>双目运算符</strong>：运算所需比那里为两个运算符叫做双目运算符。如：<code>a + b</code> ，<code>a &gt;= b</code> 等</p>
<h2 id="运算符优先级">运算符优先级</h2>
<p>算数运算符 <code>*</code> <code>/</code> <code>%</code> &gt; 算数运算符 <code>+</code> <code>-</code> &gt; 比较运算符 <code>&lt; &gt; &gt;= &lt;= == !=</code> &gt; 逻辑运算符 <code>&amp;&amp;</code> &gt; 逻辑运算符 <code>||</code> &gt; 赋值运算符</p>
<h2 id="运算符总结">运算符总结</h2>
<ul>
<li>运算符分为单目运算符双目运算符与特殊运算符 <code>()</code>  <code>.</code></li>
<li>逻辑运算的结果同样也是bool类型</li>
<li>逻辑运算符两边放的一般都是关系运算或者bool类型的值</li>
<li>逻辑非运算符的运算优先级要高于关系运算符</li>
<li>单目运算符是指运算所需变量为一个运算符，即在运算当中只有一个操作数</li>
<li>运算所需变量为两个运算符的叫做双目运算符</li>
<li>单目运算符的优先级高于双目运算符</li>
<li>比较运算符优先级高于逻辑与</li>
<li>逻辑与的运算级别高于逻辑或</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - 时间格式化</title>
      <link>https://www.oomkill.com/2019/10/golib-timeformat/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/golib-timeformat/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>该文可以快速在Go语言中获得时间的计算。</p>
<h2 id="在go中获取时间">在Go中获取时间</h2>
<h3 id="如何获取当前时间">如何获取当前时间</h3>
<pre><code class="language-go">now := time.Now()
fmt.Printf(&quot;current time is :%s&quot;, now)

current time is :2009-11-10 23:00:00 +0000 UTC m=+0.000000001
</code></pre>
<h3 id="如何获取unix-timestamp">如何获取UNIX Timestamp</h3>
<pre><code class="language-go">cur_time := time.Now().Unix()
fmt.Printf(&quot;current unix timestamp is :%v\n&quot;, cur_time )
</code></pre>
<h3 id="如何获取当日00000-00000">如何获取当日0:00:00 0:00:00</h3>
<pre><code class="language-go">now := time.Now()
date := time.Date(now.Year(), now.Month(), now.Day(),0, 0, 0, 0, time.Local)
fmt.Printf(&quot;date is :%s&quot;, date)

date is :2021-04-13 00:00:00 +0800 
</code></pre>
<h3 id="如何获取时区时间">如何获取时区时间</h3>
<p>标准时间 <code>time.Now().UTC()</code>
本地时区 <code>time.Now().Local()</code></p>
<pre><code class="language-go">
 // 获取0时区时间
fmt.Printf(&quot;date is :%s\n&quot;, time.Now().UTC())

date is :2021-04-13 16:02:33.853254 +0000 UTC

// 快速设置时区
timeLocation, _ := time.LoadLocation(&quot;Asia/Tokyo&quot;) //使用时区码
fmt.Println(time.Now().In(timeLocation).String()) // 快速设置时区

2021-04-14 01:09:18.140997 +0900 JST
</code></pre>
<h2 id="go中的固定时间格式">Go中的固定时间格式</h2>
<h3 id="获取月份">获取月份</h3>
<pre><code>time.April

type Month int

const (
	January Month = 1 + iota
	February
	March
	April
	May
	June
	July
	August
	September
	October
	November
	December
)
</code></pre>
<h3 id="获取星期">获取星期</h3>
<pre><code>time.Sunday


type Weekday int

const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
</code></pre>
<h2 id="go中的时间格式化">Go中的时间格式化</h2>
<p>Go中时间格式化的格式为 <code>2006-01-02 15:04:05</code> 612345为格式，而不是具体时间</p>
<pre><code class="language-go">    
    // YYYY-MM-DD
    fmt.Println(time.Now().Format(&quot;2006-01-02&quot;))
 
    //  YYYY-MM-DD hh:mm:ss
    fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05&quot;))
    
    //  M-DD
    fmt.Println(time.Now().Format(&quot;1-02&quot;))

    //  MM-DD
    fmt.Println(time.Now().Format(&quot;01-02&quot;)
   
    // 获取当前的小时、分钟、秒（整数）
    nowHour, nowMinute, nowSecond = time.Now().Clock()

    // 获取前一天
    //  AddDate(Years, months, days)
    yesterday = time.Now().AddDate(0,0,-1).Format(&quot;01/02&quot;)

    // 显示星期英文简写
    fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05 Mon&quot;))
 
    // 星期的大写
    fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05 Monday&quot;))
 
    // 增加微秒
    fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05.000000&quot;))
 
    // 纳秒
    fmt.Println(time.Now().Format(&quot;2006-01-02 15:04:05.000000000&quot;))
}

// print result
08-10-2018
08-10-2018 21:11:58
08-10-2018 21:11:58 Fri
08-10-2018 21:11:58 Friday
08-10-2018 21:11:58.880934
08-10-2018 21:11:58.880934320
</code></pre>
<h2 id="go中的时间计算">Go中的时间计算</h2>
<h3 id="如何获取本周日期有哪些">如何获取本周日期有哪些？</h3>
<p>获取一个星期的第一天是几号</p>
<pre><code>t:=time.Now()
fmt.Println(t.Weekday()) // 获取现在时间为本周的星期几

</code></pre>
<p>得到本日为星期几后，可以对时间进行计算，因为time包内星期的常量都为int，可以直接进行算数运算.
用一周的第一天减去当日为星期几，如果为0既『本日为本周的第一天』</p>
<p><code>time.AddDate(year, month, date)</code>，仅可以添加年月日
<code>time.Add(Hours, Minutes, Seconds)</code>，仅可以添加时分秒</p>
<pre><code class="language-go">offset := int(time.Monday - t.Weekday()) //=-1
</code></pre>
<p>如不为0，time包提供了，「以当前时间为基点，进行加减运算」</p>
<pre><code class="language-go">// t.AddDate(year, month, date)
t.AddDate(0,0,offset) // 可以获取到，周一为几月几日
</code></pre>
<p>综上所属，可以获得每周第一天为几月几日，每周随后一天为几月几日</p>
<pre><code class="language-go">
/**
  *     获取上周周第一天具体年月日
**/

func GetLastWeekFirstDate() (weekMonday string) {
	thisWeekMonday := GetFirstDateOfWeek()
	TimeMonday, _ := time.Parse(&quot;2006-01-02&quot;, thisWeekMonday)
	lastWeekMonday := TimeMonday.AddDate(0, 0, -7)
	weekMonday = lastWeekMonday.Format(&quot;2006-01-02&quot;)
	return
}


/**
  *     获取本周的周一具体年月日
**/

func GetFirstDateOfWeek() (weekMonday string) {
	now := time.Now()
	offset := int(time.Monday - now.Weekday())
	if offset &gt; 0 {
		offset = -6
	}

	weekStartDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.Local).AddDate(0, 0, offset)
	weekMonday = weekStartDate.Format(&quot;2006-01-02&quot;)
	return
}

/**
  *     获取上周最后一天具体年月日
**/

func GetLastWeekLastDate() (weekMonday string) {
	now := time.Now()

	offset := int(time.Monday - now.Weekday())
	if offset &gt; 0 {
		offset = -6
	}

	weekStartDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.Local).AddDate(0, 0, offset)
	weekMonday = weekStartDate.AddDate(0, 0, -1).Format(&quot;2006-01-02&quot;)
	return
}

/**
  *     获取上周一星期所有天数的具体年月日
**/

func GetBetweenDates(sdate, edate string) []string {
	d := []string{}
	timeFormatTpl := &quot;2006-01-02 15:04:05&quot;
	if len(timeFormatTpl) != len(sdate) {
		timeFormatTpl = timeFormatTpl[0:len(sdate)]
	}
	date, err := time.Parse(timeFormatTpl, sdate)
	if err != nil {
		return d
	}
	date2, err := time.Parse(timeFormatTpl, edate)
	if err != nil {
		return d
	}
	if date2.Before(date) {
		return d
	}
	// 输出日期格式固定
	timeFormatTpl = &quot;2006-01-02&quot;
	date2Str := date2.Format(timeFormatTpl)
	d = append(d, date.Format(timeFormatTpl))
	for {
		date = date.AddDate(0, 0, 1)
		dateStr := date.Format(timeFormatTpl)
		d = append(d, dateStr)
		if dateStr == date2Str {
			break
		}
	}
	return d
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - 使用go操作dbus</title>
      <link>https://www.oomkill.com/2019/10/golib-gobus/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/golib-gobus/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>github <a href="https://github.com/godbus/dbus" target="_blank"
   rel="noopener nofollow noreferrer" >https://github.com/godbus/dbus</a></p>
<p>增加一个端口</p>
<pre><code class="language-go">package main

import (
	&quot;github.com/godbus/dbus/v5&quot;
)

func main() {
	cli, err := dbus.SystemBus()

	if err != nil {
		panic(err)
	}

	obj := cli.Object(&quot;org.fedoraproject.FirewallD1&quot;, &quot;/org/fedoraproject/FirewallD1&quot;)
	call := obj.Call(&quot;oorg.fedoraproject.FirewallD1.zone.addPort&quot;, 0, &quot;public&quot;, &quot;81&quot;, &quot;tcp&quot;, &quot;30000&quot;)

	if call.Err != nil {
		panic(call.Err)
	}
}
</code></pre>
<p>go-dbus 简单教程 <a href="https://blog.csdn.net/mathmonkey/article/details/38095289" target="_blank"
   rel="noopener nofollow noreferrer" >https://blog.csdn.net/mathmonkey/article/details/38095289</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go面向对象</title>
      <link>https://www.oomkill.com/2019/10/go-object/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-object/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>所谓的面向对象其实就是找一个专门做这个事的人来做，不用关心具体怎么实现的。所以说，面向过程强调的是过程，步骤。而面向对象强调的是对象，也就是干事的人。</p>
<h2 id="go语言面向对象语言特性">Go语言：面向对象语言特性</h2>
<ul>
<li>
<p>方法</p>
</li>
<li>
<p>嵌入</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>没有类</p>
</li>
<li>
<p>支持类型。 特别是， 它支持structs。 Structs是用户定义的类型。 Struct类型(含方法)提供类似于其它语言中类的服务。</p>
</li>
</ul>
<h3 id="structs">Structs</h3>
<p>一个struct定义一个状态。 这里有一个strudent struct。 它有一个Name属性和一个布尔类型的标志Real，告诉我们它是一个真实的strudent还是一个虚构的strudent。 Structs只保存状态，不保存行为。</p>
<pre><code class="language-go">type Creature struct {
  Name string
  Real bool
}
</code></pre>
<h3 id="为结构体添加方法">为结构体添加方法</h3>
<p>方法是对特定类型进行操作的函数。 它们有一个<strong>接收器条款</strong>，命令它们对什么样的类型可进行操作。 这里是一个Hello()方法，它可对student结构进行操作，并打印出它们的状态：</p>
<pre><code class="language-go">func (s Student) Hello() {
  fmt.Printf(&quot;Name: '%s', Real: %t\n&quot;, s.Name, s.Real)
}
</code></pre>
<p><code>func (s Student) func_name(){}</code> 这是一个不太常见的语法，但是它非常的具体和清晰，不像this的隐喻性。</p>
<p>一般在定义方法时，需要定义为结构体的指针，值类型的在修改结构体属性时，无法修改其内容</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type human struct {
	Name string
	Real bool
}

type Student struct {
	human
	Id int
}

func (h human) Hello() {
	fmt.Printf(&quot;姓名：%s\n&quot;, h.Name)

}

func (s Student) PrintId() {
	fmt.Printf(&quot;学号：%d\n&quot;, s.Id)
}

func (s Student) EditId(id int) {
	s.Id = id
}

func main() {
	zhangsan := Student{
		human: human{&quot;zhangsan&quot;, true},
		Id:    10,
	}

	zhangsan.Hello()
	zhangsan.EditId(101)
	zhangsan.PrintId()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201009175856183-293037939.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="嵌入继承">嵌入（继承）</h3>
<p>可以将匿名的类型嵌入进struct。 如果你嵌入一个匿名的struct那么被嵌入的struct对接受嵌入的struct直接提供它自己的状态（和方法）。 比如，<code>strudent</code> 有一个匿名子的被嵌入的 <code>human</code> struct，这意味着一个 <code>student</code> 就是一个 <code>hunman</code>。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type human struct {
	Name string
	Real bool
}

type Student struct {
	human
	Id int
}

func (h *human) Hello() {
	fmt.Printf(&quot;姓名：%s&quot;, h.Name)

}

func main() {
	zhangsan := &amp;Student{
		human: human{&quot;zhangsan&quot;, true},
		Id:    10,
	}

	zhangsan.Hello()
}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201009174556489-489320062.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="重写">重写</h3>
<p>就是子类(结构体)中的方法，将父类中的相同名称的方法的功能重新给改写了</p>
<p>注意：在调用时，默认调用的是子类中的方法</p>
<h3 id="方法值和表达式值">方法值和表达式值</h3>
<p>方法表达式，即方法对象赋值给变量，方法表达式有两种使用方式：</p>
<ul>
<li>隐式调用：方法值，调用函数时，无需再传递接收者，隐藏了接收者</li>
<li>显式调用：方法表达式，显示的把接收者*Student传递过去</li>
</ul>
<p>实例：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type human struct {
	Name string
	Real bool
}

type Student struct {
	human
	Id int
}

func (h *human) Hello() {
	fmt.Printf(&quot;姓名：%s\n&quot;, h.Name)

}

func (s Student) PrintId() {
	fmt.Printf(&quot;学号：%d\n&quot;, s.Id)
}

func (s Student) EditId(id int) {
	s.Id = id
}

func main() {
	zhangsan := Student{
		human: human{&quot;zhangsan&quot;, true},
		Id:    10,
	}

	// 常规调用
	zhangsan.Hello()

	// 方法值 无需传递接收者
	hello := zhangsan.Hello
	hello()

	// 方法表达式，调用函数式，传递接收者
	hello1 := (*Student).Hello // 括号是因为 . 的优先级要高于取指符，需要做特殊处理

	hello1(&amp;zhangsan)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201009181121417-3067588.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="go语言面向对象的设计">Go语言：面向对象的设计</h2>
<h3 id="接口">接口</h3>
<p>接口是Go语言对面向对象支持的标志。 接口是声明方法集的类型。 实现所有接口方法的对象自动地实现接口。 它没有继承或子类或 <code>implements</code> 关键字。</p>
<h4 id="接口的定义">接口的定义</h4>
<pre><code class="language-go">type 接口名字  interface {

	方法声明
}
</code></pre>
<h4 id="接口的继承">接口的继承</h4>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Fooer interface {
	Foo1()
}

type Fooerson interface {
	Fooer
	Foo2()
}

type Foo struct {
}

type Fooson struct {
}

func (f Fooson) Foo1() {
	fmt.Println(&quot;Foo1() here&quot;)
}

func (f Fooson) Foo2() {
	fmt.Println(&quot;Foo2() here&quot;)
}

func (f Foo) Foo1() {
	fmt.Println(&quot;Foo1() here&quot;)
}

func main() {
	var fooerson Fooson
	var fooson Fooerson

	fooson = &amp;fooerson
	fooson.Foo1()
	fooson.Foo2()

	var foo Fooer

	foo = fooson
	fooson = foo  // 这样是不允许的，fooson为Fooerson接口的实现，而foo是一个Fooer接口类型的变量，可以子转换为父不能反之
	foo.Foo1() 

}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201009232825993-1946944685.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="空接口">空接口</h4>
<p>空接口(interface{})不包含任何的方法，正因为如此，所有的类型都实现了空接口，因此空接口可以存储任意类型的数值</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {

	var arr []interface{}

	arr = append(arr, 1, &quot;zhangsan&quot;, 3.3)
	fmt.Println(arr)
}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201009233003804-1098270083.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="类型断言">类型断言</h4>
<p>通过类型断言，可以判断空接口中存储的数据类型。</p>
<p>语法：<code>value, ok := m.(T)</code></p>
<p>m:表空接口类型变量</p>
<p>T:是断言的类型</p>
<p>value: 变量m中的值。</p>
<p>ok: 布尔类型变量，如果断言成功为true,否则为false</p>
<pre><code class="language-go">func main() {
	var a interface{}

	a = 10

	ok, value := a.(int)
	fmt.Println(ok, value)

	ok1, value1 := a.(string)
	fmt.Println(ok1, value1)
}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201009234432928-2114138876.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="封装">封装</h3>
<p>Go语言在包的级别进行封装。 以小写字母开头的名称只在该程序包中可见。 可以隐藏私有包中的任何内容，只暴露特定的类型，接口和工厂函数。</p>
<p>例如，在这里要隐藏上面的Foo类型，只暴露接口，你可以将其重命名为小写的foo，并提供一个NewFoo()函数，返回公共Fooer接口：</p>
<pre><code class="language-go">type foo struct {
}
 
func (f foo) Foo1() {
    fmt.Println(&quot;Foo1() here&quot;)
}
 
func (f foo) Foo2() {
    fmt.Println(&quot;Foo2() here&quot;)
}
 
func (f foo) Foo3() {
    fmt.Println(&quot;Foo3() here&quot;)
}
 
func NewFoo() Fooer {
    return &amp;Foo{}
}
</code></pre>
<p>在另一个包的代码可以使用<code>NewFoo()</code>并访问由内部foo类型实现的Footer接口：</p>
<pre><code class="language-go">f := NewFoo()
 
f.Foo1()
 
f.Foo2()
 
f.Foo3()
</code></pre>
<h3 id="继承">继承</h3>
<p>Go语言没有任何类型层次结构。 它允许你通过组合来共享实现的细节。 但Go语言，允许嵌入匿名组合。</p>
<p>通过嵌入一个匿名类型的组合等同于实现继承，这是它所有意图和目的。 一个嵌入的struct与基类一样脆弱。 你还可以嵌入一个接口， 如果嵌入类型没有实现所有接口方法，它甚至可能导致产生在编译时未被发现的运行错误。</p>
<p>这里SuperFoo嵌入Fooer接口，但是SuperFoo没有实现Foo的方法。 Go编译器会愉快地让你创建一个新的SuperFood并调用Fooer的方法，但很显然这在运行时会失败。 这会编译：</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

type Fooer interface {
	Foo1()
	Foo2()
	Foo3()
}

type Foo struct {
}

func (f Foo) Foo1() {
	fmt.Println(&quot;Foo1() here&quot;)
}

func (f Foo) Foo2() {
	fmt.Println(&quot;Foo2() here&quot;)
}

func (f Foo) Foo3() {
	fmt.Println(&quot;Foo3() here&quot;)
}

type SuperFooer struct {
	Fooer
}

func main() {
	s := SuperFooer{}
	s.Foo3()
}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201009231036948-951548379.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="多态">多态</h3>
<p>多态性是面向对象编程的本质：只要对象坚持实现同样的接口，Go语言就能处理不同类型的那些对象。 Go接口以非常直接和直观的方式提供这种能力。</p>
<p>Golang当中的接口解决了这个问题，只要接口中定义的方法能对应的上，那么就可以认为这个类实现了这个接口。同一个接口，使用不同的实例而执行不同操作</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201009233350848-426016267.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

type animal interface {
	Say()
}

type human struct {
}

type cat struct {
}

func (h human) Say() {
	fmt.Println(&quot;人类&quot;)
}

func (c cat) Say() {
	fmt.Println(&quot;猫&quot;)
}

func main() {
	var a animal

	a = cat{}
	a.Say()

	a = human{}
	a.Say()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201009233804687-1199049992.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go协程安全</title>
      <link>https://www.oomkill.com/2019/10/go-goroutine-security/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-goroutine-security/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="多路复用">多路复用</h2>
<p>Go语言中提供了一个关键字<code>select</code>，通过<code>select</code>可以监听<code>channel</code>上的数据流动。select的用法与switch语法类似，由select开始一个新的选择块，每个选择条件由case语句来描述。只不过，select的<code>case</code>有比较多的限制，其中最大的一条限制就是每个case语句里必须是一个IO操作。</p>
<p>select 语法如下：</p>
<pre><code class="language-go">   select {
    case &lt;-chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
    case chan2 &lt;- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
    default:
        // 如果上面都没有成功，则进入default处理流程
    }
</code></pre>
<p>在一个select语句中，会按顺序从头至尾评估每一个发送和接收的语句；如果其中的任意一语句可以继续执行(即没有被阻塞)，那么就从那些可以执行的语句中任意选择一条来使用。如果没有任意一条语句可以执行(即所有的通道都被阻塞)，那么有两种可能的情况：⑴ 如果给出了default语句，那么就会执行default语句，同时程序的执行会从select语句后的语句中恢复。⑵ 如果没有default语句，那么select语句将被阻塞，直到至少有一个channel可以进行下去。</p>
<p>在一般的业务场景下，select不会用<code>default</code>，当监听的流中再没有数据，IO操作就 会阻塞现象，如果使用了<code>default</code>，此时可以出让CPU时间片。如果使用了<code>default</code> 就形成了非阻塞状态，形成了<strong>忙轮训</strong>，会占用CPU、系统资源。</p>
<p>阻塞与非阻塞使用场景</p>
<ul>
<li>阻塞： 如：在监听超时退出时，如果100秒内无操作，择退出，此时添加了default会形成忙轮训，超时监听变成了无效。</li>
<li>非阻塞： 如，在一个只有一个业务逻辑处理时，主进程控制进程的退出。此时可以使用default。</li>
</ul>
<h2 id="定时器">定时器</h2>
<p>Go语言中定时器的使用有三个方法</p>
<ul>
<li><code>time.Sleep()</code></li>
<li><code>time.NewTimer()</code> 返回一个时间的管道， time.C 读取管道的内容</li>
<li><code>time.After(5 * time.Second)</code> 封装了time.NewTimer()，反回了一个 <code>time.C</code>的管道</li>
</ul>
<p>示例</p>
<pre><code class="language-go">select {
    case &lt;-time.After(time.Second * 10):
}
</code></pre>
<h2 id="锁和条件变量">锁和条件变量</h2>
<p>Go语言中为了解决协程间同步问题，提供了标准库代码，包<code>sync</code>和<code>sync/atomic</code>中。</p>
<h3 id="互斥锁">互斥锁</h3>
<p>互斥锁是传统并发编程对共享资源进行访问控制的主要手段，它由标准库sync中的Mutex结构体类型表示。sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前的共享资源，Unlock进行解锁。</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

var mutex sync.Mutex

func print(str string) {
	mutex.Lock()         // 添加互斥锁
	defer mutex.Unlock() // 使用结束时解锁

	for _, data := range str { // 迭代器
		fmt.Printf(&quot;%c&quot;, data)
		time.Sleep(time.Second) // 放大协程竞争效果
	}
	fmt.Println()
}

func main() {
	go print(&quot;hello&quot;) // main 中传参
	go print(&quot;world&quot;)
	for {
		runtime.GC()
	}
}
</code></pre>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201026195343567-1267456404.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="读写锁">读写锁</h3>
<p>读写锁的使用场景一般为<strong>读多写少</strong>，可以让多个读操作并发，同时读取，但是对于写操作是完全互斥的。也就是说，当一个goroutine进行写操作的时候，其他goroutine不能进行读写操作；当一个goroutine获取读锁之后，其他的goroutine获取写锁都会等待</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026200352683-2138464590.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

var count int           // 全局变量count
var rwlock sync.RWMutex // 全局读写锁 rwlock

func read(n int) {
	for {
		rwlock.RLock()
		fmt.Printf(&quot;reading goroutine %d ...\n&quot;, n)
		num := count
		fmt.Printf(&quot;read goroutine %d finished，get number %d\n&quot;, n, num)
		rwlock.RUnlock()
	}

}
func write(n int) {
	for {
		rwlock.Lock()
		fmt.Printf(&quot;writing goroutine %d ...\n&quot;, n)
		num := rand.Intn(1000)
		count = num
		fmt.Printf(&quot;write goroutine %d finished，write number %d\n&quot;, n, num)
		rwlock.Unlock()
	}
}

func main() {
	for i := 0; i &lt; 5; i++ {
		go read(i + 1)
		time.Sleep(time.Microsecond * 100)
	}
	for i := 0; i &lt; 5; i++ {
		go write(i + 1)
		time.Sleep(time.Microsecond * 100)
	}
	for {

	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026201220373-1468946475.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>可以看出，读写锁控制下的多个写操作之间都是互斥的，并且写操作与读操作之间也都是互斥的。但是，多个读操作之间不存在互斥关系。</p>
<h3 id="go语言中的死锁">Go语言中的死锁</h3>
<p>死锁 <code>deadlock</code> 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
<h4 id="单gorutine同时读写写死锁">单gorutine同时读写，写死锁</h4>
<p>在一个gorutine中，当channel无缓冲，写阻塞，等待读取导致死锁</p>
<p>解决，应该至少在2个gorutine进行channle通讯，或者使用缓冲区。</p>
<pre><code class="language-go">package main

func main() {
	channel := make(chan int)
	channel &lt;- 1
	&lt;-channel
}
</code></pre>
<h4 id="多gorutine使用一个channel通信写先于读">多gorutine使用一个channel通信，写先于读</h4>
<p>代码顺序执行时，写操作阻塞，导致后面协程无法启动进行读操作，导致死锁</p>
<pre><code class="language-go">package main

func main() {
	channel := make(chan int)
	channel &lt;- 1
	go func() {
		&lt;-channel
	}()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026193737321-444785180.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="多channel交叉死锁">多channel交叉死锁</h4>
<p>在goroutine中，多个goroutine使用多个channel互相等待对方写入，导致死锁</p>
<pre><code class="language-go">package main

func main() {

	channel1 := make(chan int)
	channel2 := make(chan int)

	go func() {

		select {
		case &lt;-channel1:
			channel2 &lt;- 1
		}
	}()

	select {
	case &lt;-channel2:
		channel1 &lt;- 1
	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026194206902-684762536.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="隐性死锁">隐性死锁</h4>
<p>尽量不要将 互斥锁、读写锁 与 channel 混用情况下，让读先进行读时，因为没写入被阻塞，无法解除。写入时，因为没有读出被阻塞，锁无法解除，导致无数据输出，形成隐形死锁。此时编译器是不报错的。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026202657202-461749877.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
)

func main() {
	channel := make(chan int)
	var rwlock sync.RWMutex
	go func() {
		for {
			rwlock.Lock()
			channel &lt;- 1
			fmt.Println(&quot;write&quot;, 1)
			rwlock.Unlock()
		}
	}()

	go func() {
		for {
			rwlock.RLock()
			n := &lt;-channel
			fmt.Println(n)
			rwlock.Unlock()
		}

	}()

	for {

	}
}
</code></pre>
<h2 id="context-上下文">Context 上下文</h2>
<p>context定义了上下文类型，该类型在API边界之间以及进程之间传递截止时间，取消信号和其他请求范围的值。当在对请求传入一个上下文，可以选择将其替换为使用<code>WithCancel</code>，<code>WithDeadline</code>，<code>WithTimeout</code>。在取消后，从该context处派生的所有子请求也会被取消。</p>
<p>Context的结构体</p>
<ul>
<li>Deadline() 返回context的截止时间。</li>
<li>Done() 返回一个channle，当timeout或cancelfuc将会close(chan)</li>
<li>Err() 返回错误，未关闭Done()返回nil，取消，返回 <code>&quot;context canceled&quot;</code>, Deadline返回超时</li>
<li>Value 返回值。</li>
</ul>
<pre><code class="language-go">type Context interface {
	// Deadline returns the time when work done on behalf of this context
	// should be canceled. Deadline returns ok==false when no deadline is
	// set. Successive calls to Deadline return the same results.
	Deadline() (deadline time.Time, ok bool)

	// Done returns a channel that's closed when work done on behalf of this
	// context should be canceled. Done may return nil if this context can
	// never be canceled. Successive calls to Done return the same value.
	// The close of the Done channel may happen asynchronously,
	// after the cancel function returns.
	//
	// WithCancel arranges for Done to be closed when cancel is called;
	// WithDeadline arranges for Done to be closed when the deadline
	// expires; WithTimeout arranges for Done to be closed when the timeout
	// elapses.
	//
	// Done is provided for use in select statements:
	//
	//  // Stream generates values with DoSomething and sends them to out
	//  // until DoSomething returns an error or ctx.Done is closed.
	//  func Stream(ctx context.Context, out chan&lt;- Value) error {
	//  	for {
	//  		v, err := DoSomething(ctx)
	//  		if err != nil {
	//  			return err
	//  		}
	//  		select {
	//  		case &lt;-ctx.Done():
	//  			return ctx.Err()
	//  		case out &lt;- v:
	//  		}
	//  	}
	//  }
	//
	// See https://blog.golang.org/pipelines for more examples of how to use
	// a Done channel for cancellation.
	Done() &lt;-chan struct{}

	// If Done is not yet closed, Err returns nil.
	// If Done is closed, Err returns a non-nil error explaining why:
	// Canceled if the context was canceled
	// or DeadlineExceeded if the context's deadline passed.
	// After Err returns a non-nil error, successive calls to Err return the same error.
	Err() error

	// Value returns the value associated with this context for key, or nil
	// if no value is associated with key. Successive calls to Value with
	// the same key returns the same result.
	//
	// Use context values only for request-scoped data that transits
	// processes and API boundaries, not for passing optional parameters to
	// functions.
	//
	// A key identifies a specific value in a Context. Functions that wish
	// to store values in Context typically allocate a key in a global
	// variable then use that key as the argument to context.WithValue and
	// Context.Value. A key can be any type that supports equality;
	// packages should define keys as an unexported type to avoid
	// collisions.
	//
	// Packages that define a Context key should provide type-safe accessors
	// for the values stored using that key:
	//
	// 	// Package user defines a User type that's stored in Contexts.
	// 	package user
	//
	// 	import &quot;context&quot;
	//
	// 	// User is the type of value stored in the Contexts.
	// 	type User struct {...}
	//
	// 	// key is an unexported type for keys defined in this package.
	// 	// This prevents collisions with keys defined in other packages.
	// 	type key int
	//
	// 	// userKey is the key for user.User values in Contexts. It is
	// 	// unexported; clients use user.NewContext and user.FromContext
	// 	// instead of using this key directly.
	// 	var userKey key
	//
	// 	// NewContext returns a new Context that carries value u.
	// 	func NewContext(ctx context.Context, u *User) context.Context {
	// 		return context.WithValue(ctx, userKey, u)
	// 	}
	//
	// 	// FromContext returns the User value stored in ctx, if any.
	// 	func FromContext(ctx context.Context) (*User, bool) {
	// 		u, ok := ctx.Value(userKey).(*User)
	// 		return u, ok
	// 	}
	Value(key interface{}) interface{}
}
</code></pre>
<p>演示使用可取消的上下文。可在函数结束时<code>defer cancel()</code> 防止<code>goroutine</code>的泄露。</p>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

func worker(ctx context.Context, name string) {
	n := 0
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(name, &quot;去划水了&quot;, n)
			return
		default:
			fmt.Println(name, &quot;干活中&quot;, n)
			time.Sleep(time.Second)
		}
		n++
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())

	for n := 0; n &lt; 5; n++ {
		go worker(ctx, fmt.Sprintf(&quot;worker%d&quot;, n))
	}

	&lt;-time.After(time.Second * 5)
	cancel()
	for {

	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201027003405631-971778476.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>超时处理，<code>WithTimeout</code> 当时间到达设置的时间后退出，也可以使用<code>cancelFunc()</code>退出处理</p>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

func worker(ctx context.Context, name string) {
	n := 0
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(name, &quot;去划水了&quot;, n)
			return
		default:
			fmt.Println(name, &quot;干活中&quot;, n)
			time.Sleep(time.Second)
		}
		n++
	}
}

func main() {
	//ctx, cancel := context.WithCancel(context.Background())
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)

	for n := 0; n &lt; 2; n++ {
		go worker(ctx, fmt.Sprintf(&quot;worker%d&quot;, n))
	}

	&lt;-time.After(time.Second * 5)
	fmt.Println(&quot;取消了&quot;)
	cancel()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201027003955469-353595368.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>WithDeadline，在标准库中可以看出，实际上WithTimeout是封装了WithDeadline。其功能也是超时退出。</p>
<p><img loading="lazy" src="https://img2020.cnblogs.com/blog/1380340/202010/1380340-20201027004554454-1396510619.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;fmt&quot;
	&quot;time&quot;
)

func worker(ctx context.Context, name string) {
	n := 0
	for {
		select {
		case &lt;-ctx.Done():
			fmt.Println(name, &quot;去划水了&quot;, n)
			fmt.Println(ctx.Err())
			return
		default:
			fmt.Println(name, &quot;干活中&quot;, n)
			time.Sleep(time.Second)
		}
		n++
	}
}

func main() {
	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second*3))
	for n := 0; n &lt; 2; n++ {
		go worker(ctx, fmt.Sprintf(&quot;worker%d&quot;, n))
	}

	&lt;-time.After(time.Second * 5)
	fmt.Println(&quot;取消了&quot;)
	cancel()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201027004659406-744263091.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="context总结">Context总结</h3>
<ul>
<li>Context是Go语言在1.7中加入标准库的，是作为<code>Goroutine</code>线程安全，防止线程泄露的上下文管理的操作。</li>
<li>context包的核心是<code>Context</code>结构体。</li>
<li>Context的常用方法为 <code>WithTimeout()</code> 与 <code>WithCancel()</code></li>
<li>Context在使用时，不要放在结构体内使用，要以函数的参数进行传递。</li>
<li>Context是线程安全的，可以在多个<code>Goroutine</code>传递，当对其取消操作时，所有<code>Goroutine</code>都执行取消操作。</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go协程通讯</title>
      <link>https://www.oomkill.com/2019/10/go-goroutine-communication/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-goroutine-communication/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>      channel是Go语言中的一个核心<strong>数据类型</strong>，channel是一个数据类型，主要用来解决协程的同步问题以及协程之间数据共享（数据传递）的问题。在并发核心单元通过它就可以发送或者接收数据进行通讯，这在一定程度上又进一步降低了编程的难度。</p>
<p>      goroutine运行在相同的内存地址空间，channel可以避开所有内存共享导致的坑；通道的通信方式保证了同步性。数据通过channel：同一时间只有一个协程可以访问数据：所以不会出现数据竞争，确保并发安全。</p>
<h2 id="channel的定义">channel的定义</h2>
<p>channel是对应make创建的底层数据结构的引用。 创建语法： <code>make(chan Type, capacity)</code></p>
<pre><code class="language-go">channel := make(chan bool) //创建一个无缓冲的bool型Channel ，等价于make(chan Type, 0)
channel := make(chan bool, 1024) //创建一个有缓冲，切缓冲区为1024的bool型Channel 

channel &lt;- x           //向一个Channel发送一个值
&lt;- channel             //从一个Channel中接收一个值
x = &lt;- channel         //从Channel c接收一个值并将其存储到x中
x, ok = &lt;- channel     //从Channel接收一个值，如果channel关闭了或没有数据，那么ok将被置为false
</code></pre>
<p>      channel是一个引用类型，当复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值（定义未初始化）也是nil。</p>
<p>      在默认情况下，channel<strong>接收</strong>和<strong>发送</strong>数据都是阻塞的，（<code>channel &lt;- 1</code>，写端写数据，读端不在读。写端阻塞； <code>str := &lt;-channel</code> 读端读数据， 同时写端不在写，读端阻塞。）除非另一端已经准备好，这样就使得goroutine同步变的更加的简单，而不需要显式的lock。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023210604900-1402843122.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>示例</strong></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

var c = make(chan int32)

func printstr(s string) {
	for _, value := range s {
		fmt.Printf(&quot;写入%+q\r\n&quot;, value)
		time.Sleep(time.Second)
		c &lt;- value
	}
}

func main() {
	runtime.GOMAXPROCS(1)
	go func() {
		time.Sleep(time.Second)
		printstr(&quot;hello&quot;)
	}()

	go func() {
		for v := range c {
			fmt.Printf(&quot;读取%+q\r\n&quot;, v)
		}
	}()
	for {
              ;
	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023205925898-1792789339.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="channel的缓冲">channel的缓冲</h2>
<h3 id="无缓冲的channel">无缓冲的channel</h3>
<p>      无缓冲的channel <code>unbuffered channel</code> 是指在接收前没有能力保存任何值的通道。这种类型的channel <strong>要求发送端和接收端同时准备好</strong>，才能完成发送和接收操作。否则，通道会导致先执行发送或接收操作的<strong>阻塞等待</strong>。顾又称为同步通信</p>
<ul>
<li>阻塞：由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足，才接触阻塞。</li>
<li>同步：在两个或多个协程（线程）间，保持数据内容一致性的机制。</li>
</ul>
<p>示例如上，写了没有读会导致阻塞，读了没有写会导致堵塞</p>
<h3 id="有缓冲的channel">有缓冲的channel</h3>
<p>      有缓冲的通道（<code>buffered channel</code>）是一种在被接收前能存储一个或者多个数据值的通道。这种类型的channel并不强制要求<code>goroutine</code>之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也不同。</p>
<ul>
<li>只有channel通道中没有要接收的值时，接收动作才会阻塞。</li>
<li>只有通道没有可用缓冲区容纳被写入（发送）的值时，发送动作才会阻塞。</li>
</ul>
<p>      有缓冲的channel和无缓冲的channel之间的不同：无缓冲的channel保证进行发送和接收的 <code>goroutine</code> 会在同一时间进行数据交换；有缓冲的channel没有这种保证。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023210556108-1125304418.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>示例</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

var c = make(chan int32, 10)

func printstr(s string) {
	for _, value := range s {
		fmt.Printf(&quot;写入%+q\r\n&quot;, value)
		c &lt;- value
	}
}

func main() {
	runtime.GOMAXPROCS(1)
	go func() {

		printstr(&quot;hello&quot;)
	}()

	go func() {

		time.Sleep(time.Second * 2)
		fmt.Println(&quot;读通道开始读取数据&quot;)
		for v := range c {
			fmt.Printf(&quot;读取%+q\r\n&quot;, v)
		}
	}()
	for {

	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023210810282-1509130297.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>      结果可以看出，如果给定了一个缓冲区容量，channel就是<strong>异步</strong>的。只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会<strong>无阻塞</strong>地进行。</p>
<h3 id="channel的关闭">channel的关闭</h3>
<p>当发送的一端没有更多的数据发送到channel的话，需要使接收端也能及时知道channel中没有多余的数据可以接收。因此可以通过 <code>close()</code>函数来关闭channel的实现。</p>
<p><strong>示例</strong></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;time&quot;
)

var c = make(chan int32, 10)

func printstr(s string) {
	for _, value := range s {
		fmt.Printf(&quot;写入%+q\r\n&quot;, value)
		c &lt;- value
	}
	close(c)
}

func main() {
	runtime.GOMAXPROCS(1)
	go func() {
		printstr(&quot;hello&quot;)
	}()

	time.Sleep(time.Second * 2)
	fmt.Println(&quot;读通道开始读取数据&quot;)
	for {
		if char, ok := &lt;-c; ok {
			fmt.Printf(&quot;读取%+q\r\n&quot;, char)
		} else {
			break
		}
	}
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023211728625-1454348143.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p><strong>提示</strong></p>
<ul>
<li>channel不像文件一样需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的，才去关闭channel；</li>
<li>关闭channel后，无法向channel 再发送数据(引发 panic 错误后导致接收立即返回零值)；</li>
<li>关闭channel后，可以继续从channel接收数据（读取到的数据为channel类型的默认值，如int默认值0 string默认值&quot;&quot;）；</li>
<li>对于nil channel，无论收发都会被阻塞。</li>
</ul>
</blockquote>
<h3 id="缓冲channel-和-非缓冲channel的区别">缓冲channel 和 非缓冲channel的区别</h3>
<ul>
<li>缓冲channel的创建方式为<code>make(chan TYPE,CAPCTIY)</code>，非缓冲channel的创建方式为<code>make(chan TYPE)</code></li>
<li>缓冲channel的通信方式为同步通信，非缓冲channel的通信方式为异步通信</li>
</ul>
<h2 id="单项channel及应用">单项channel及应用</h2>
<p>默认情况下，channel是双向的，既可以往里面发送数据也可以接收数据。但是，常将channel作为参数进行传递而只希望对方是单向使用的，要么只让它发送数据，要么只让它接收数据，这时候可以指定通道的方向。</p>
<h3 id="单项channel的声明">单项channel的声明</h3>
<ul>
<li>双向channel <code>ch = make(chan int)</code></li>
<li>单向写channel: <code>var ch chan &lt;- int</code> <code>ch = make(chan &lt;- int)</code></li>
<li>单向读channel:	<code>var ch &lt;- chan int</code> <code>ch = make(&lt;-chan int)</code></li>
</ul>
<p>可以将 channel 隐式转换为单向队列，只收或只发，不能将单向 channel 转换为普通 channel，示例：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
)

var c = make(chan string, 10)

func read(c &lt;-chan string) {
	fmt.Println(&quot;读通道开始读取数据&quot;)
	for {
		if char, ok := &lt;-c; ok {
			fmt.Printf(&quot;读取%s\r\n&quot;, char)
		} else {
			break
		}
	}
}

func write(ch chan&lt;- string, str []string) {
	defer close(ch)
	for _, value := range str {
		fmt.Printf(&quot;写入%+q\r\n&quot;, value)
		ch &lt;- value
	}
}

func main() {
	runtime.GOMAXPROCS(3)

	go write(c, []string{&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;})
	read(c)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201023233734222-1224564313.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go语言的并发编程gorouting</title>
      <link>https://www.oomkill.com/2019/10/go-goroutine/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-goroutine/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="并行和并发">并行和并发</h2>
<p>并发编程是指在一台处理器上“同时”处理多个任务。</p>
<p>    宏观并发：在一段时间内，有多个程序在同时运行。</p>
<p>    微观并发：在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022213953628-1042262509.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>并行 <code>parallel</code>：<strong>同一时刻</strong>，多条指令在多个处理器上同时执行。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022214443342-1494160147.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>并发</strong> <code>concurrency</code>：在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过cpu时间片轮转使多个进程快速交替的执行。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022214556610-268912445.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>    通俗来讲，并行是两组队列同时使用一个进程；并发是两个队列分别交替使用两个进程</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022214726191-1905152427.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="进程并发">进程并发</h2>
<p>    程序，以Go语言为例，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁&hellip;.)</p>
<p>    进程，是一个抽象的概念，与操作系统原理联系紧密。以Go语言为例，将编译好的程序运行起来，在内存空间中形成一个独立的内存体，内存体有自己的独立空间，上级挂靠单位是操作系统。</p>
<p>    进程是操作系统进行资源分配和调度的一个独立单位，一般由程序，数据集合和进程控制块三部分组成。</p>
<ul>
<li>程序：描述进程完成的功能，是控制进程执行的指令集；</li>
<li>数据集合：程序在执行时所需要的数据和工作区；</li>
<li>程序控制块PCB：<code>Program Control Block</code>，包含进程的描述信息和控制信息，是进程存在的唯一标志。</li>
</ul>
<p>进程是活跃的程序，占用系统资源。在内存中执行。<strong>同一个程序也可以加载为不同的进程(彼此之间互不影响)</strong></p>
<h3 id="进程状态">进程状态</h3>
<p>    进程基本的状态有5种。分别为初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022222227435-218532248.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="线程的任务调度">线程的任务调度</h3>
<p>    大部分操作系统的任务调度是采用<strong>时间片轮转</strong>的抢占式调度方式。</p>
<p>    <strong>时间片轮转</strong>是指，在一个进程中，当线程任务执行几毫秒后，由操作系统内核进行调度，通过硬件计数器终端处理器，让线程强行暂停，并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。</p>
<p>    在<strong>时间片轮转</strong>中，任务执行那段时间叫做<strong>时间片</strong>，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。</p>
<p>    由于CPU的执行效率非常高，（i5 6600 约200亿/秒，奔腾4 约13亿/秒）<a href="https://setiathome.berkeley.edu/cpu_list.php" target="_blank"
   rel="noopener nofollow noreferrer" >CPU preformance</a> 时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。多任务运行过程的示意图如下：</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022224542127-1305299520.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="进程实现并发时会出现的问题呢">进程实现并发时会出现的问题呢</h3>
<p>    孤儿进程: 父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程成为init进程，称为init进程领养孤儿进程。</p>
<p>    僵尸进程: 进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
<h2 id="线程并发">线程并发</h2>
<p>    在早期操作系统当中，没有线程的概念，进程是最小分配资源与执行单位，可以看做是一个进程中只有一个线程，故进程即线程。所以线程LWP被称为：<code>：Lightweight process</code>，轻量级的进程，是程序执行中一个单一的顺序控制流程，在Linux操作系统下，线程的本质仍是进程。</p>
<p>    线程有独立的PCB，但没有独立的地址空间，各个线程之间共享程序的内存空间。</p>
<h2 id="进程和线程的区别">进程和线程的区别</h2>
<ul>
<li>进程：最小分配资源单位，可看成是只有一个线程的进程。</li>
<li>线程：最小的执行单位</li>
<li>一个进程由一个或多个线程组成</li>
<li>进程之间相互独立，同一进程下的各个线程之间共享程序的内存空间</li>
</ul>
<h2 id="协程并发">协程并发</h2>
<p>    协程 <code>coroutines</code>，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序来管理的轻量级线程叫做<code>『用户空间线程』</code>，具有对内核来说不可见的特性。</p>
<p>多数语言在语法层面并不直接支持协程，而是通过库的方式支持，但用库的方式支持的功能也并不完整，比如仅仅提供协程的创建、销毁与切换等能力。如果在这样的轻量级线程中调用一个同步 IO 操作，比如网络通信、本地文件读写，都会阻塞其他的并发执行轻量级线程，从而无法真正达到轻量级线程本身期望达到的目标。</p>
<h3 id="协程和线程的区别">协程和线程的区别</h3>
<ul>
<li>占用资源：线程，初始单位为1MB,固定不可变；协程初始一般为 2KB，可随需要而增大。</li>
<li>调度：线程，由操作系统内核完成，协程，由用户完成。</li>
<li>性能： 线程，占用资源高，频繁创建销毁带来性能问题。占用资源小，不会带来严重的性能问题。</li>
<li>数据： 线程，多线程需要锁机制确保数据一致性和可见性；而线程因为只有一个进程，不存在同时读/写冲突，协程中控制共享数据不用加锁，顾执行效率较线程高。</li>
</ul>
<h2 id="go并发-goroutine">Go并发 goroutine</h2>
<p>    Go语言在语言级别支持协程，叫<code>goroutine</code>。Go语言标准库提供的所有系统调用操作（包括所有同步IO操作），都会出让CPU给其他goroutine。这种轻量级线程的切换管理不依赖于系统的线程和进程，也不需要依赖于CPU的核心数量。</p>
<p>    Go语言为并发编程而内置的上层API基于顺序通信进程模型CSP(communicating sequential processes)。这就意味着显式锁都是可以避免的，因为Go通过相对安全的通道发送和接受数据以实现同步，这大大地简化了并发程序的编写。</p>
<p>    Go语言中的并发程序主要使用两种手段来实现。goroutine和channel。</p>
<h3 id="什么是goroutine">什么是goroutine</h3>
<blockquote>
<p>Go语言作者Rob Pike说， “<code>Goroutine</code>是一个与其他<code>goroutines</code>并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个<code>goroutine</code>组成。它与线程、协程、进程等不同。它是一个<code>goroutine</code>*。</p>
</blockquote>
<p>    goroutine是Go并行设计的核心。goroutine说到底其实就是协程，它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<h2 id="mpg模型">MPG模型</h2>
<p>M 操作系统的线程抽象，一个M直接关联了一个内核线程；代表着真正执行计算的资源。
P Processor，提供相关执行环境的上下文，处理用户级代码逻辑的处理器，P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256。
G Goroutine，G并非执行体，每个G需要绑定到P才能被调度执行。</p>
<p>    在操作系统每一个线程都有一个固定大小的块来做栈，这个栈会用来存储当前正在被调用或挂起(指在调用其它函数时)的函数的内部变量。</p>
<p>    在Go语言中，每一个goroutine是一个独立的执行单元，goroutine的栈采取了动态扩容方式， 初始时仅为2KB，随着任务执行按需增长，最大可达1GB（64最大1G，32位最大256M）</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022234017595-926106329.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>    上图，图中P正在执行的Goroutine为蓝色的，处于待执行状态的Goroutine为灰色的，灰色的Goroutine形成了一个队列runqueues。</p>
<p>    在这里，当一个P关联多个G时，就会处理G的执行顺序，就是并发，当一个P在执行一个协程工作时，其他的会在等待，当正在执行的协程遇到阻塞情况，例如IO操作等，go的处理器就会去执行其他的协程，因为对于类似IO的操作，处理器不知道你需要多久才能执行结束，所以他不回去等你执行完。</p>
<blockquote>
<p>Rreferences
<a href="https://i6448038.github.io/2017/12/04/golang-concurrency-principle/" target="_blank"
   rel="noopener nofollow noreferrer" >go语言并发编程</a>
<a href="https://www.cnblogs.com/Survivalist/p/11527949.html#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank"
   rel="noopener nofollow noreferrer" >进程和线程</a>
<a href="https://juejin.im/entry/6844903621969215495" target="_blank"
   rel="noopener nofollow noreferrer" >a</a>
<a href="https://bingjian-zhu.github.io/2019/09/12/%E5%BC%84%E6%87%82goroutine%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" target="_blank"
   rel="noopener nofollow noreferrer" >groutine之间的调度</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go语言数据类型转换</title>
      <link>https://www.oomkill.com/2019/10/goskill-golang-type-convert/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/goskill-golang-type-convert/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="string-in-mutual-conversion">string in mutual conversion</h2>
<pre><code class="language-go">// int to int64
m := int64(n)

// int64 to int
n := int(m)

// string to int
int,err := strconv.Atoi(string)

// string to int64
int64, err := strconv.ParseInt(string, 10, 64)

// int to string
string := strconv.Itoa(int)

// int64 to string
string := strconv.FormatInt(int64,10)

// custom type string to string
// useful link
// https://stackoverflow.com/questions/45891600/converting-a-custom-type-to-string-in-go
  type CustomType string
  Foobar CustomType = &quot;somestring&quot;
// error
  var a string
  a = Foobar
// correct
  var a string
  a = string(Foobar)
</code></pre>
<h2 id="slice-to-struct">slice to struct</h2>
<blockquote>
<p>Question: in golang how to convert slice to struct</p>
</blockquote>
<h3 id="scene-1use-reflect-convert--slice-to-struct">scene 1：use reflect convert  slice to struct</h3>
<pre><code class="language-go">func SliceToStruct(array interface{}) (forwardPort *ForwardPort, err error) {
	forwardPort = &amp;ForwardPort{}
	valueOf := reflect.ValueOf(forwardPort)
	if valueOf.Kind() != reflect.Ptr {
		return nil, errors.New(&quot;must ptr&quot;)
	}
	valueOf = valueOf.Elem()
	if valueOf.Kind() != reflect.Struct {
		return nil, errors.New(&quot;must struct&quot;)
	}

	switch array.(type) {
	case []string:
		arrayImplement := array.([]string)
		for i := 0; i &lt; valueOf.NumField(); i++ {
			if i &gt;= len(arrayImplement) {
				break
			}
			val := arrayImplement[i]
			if val != &quot;&quot; &amp;&amp; reflect.ValueOf(val).Kind() == valueOf.Field(i).Kind() {
				valueOf.Field(i).Set(reflect.ValueOf(val))
			}
		}
	case []interface{}:
		arrayImplement := array.([]interface{})
		for i := 0; i &lt; valueOf.NumField(); i++ {
			if i &gt;= len(arrayImplement) {
				break
			}
			val := arrayImplement[i]
			if val != &quot;&quot; &amp;&amp; reflect.ValueOf(val).Kind() == valueOf.Field(i).Kind() {
				valueOf.Field(i).Set(reflect.ValueOf(val))
			}
		}
	}

	return forwardPort, nil
}
</code></pre>
<h3 id="struct-to-anything">struct to anything</h3>
<p><a href="https://github.com/fatih/structs" target="_blank"
   rel="noopener nofollow noreferrer" >https://github.com/fatih/structs</a></p>
<h2 id="byte-json-to-map">byte json to map</h2>
<p>json实例如下所示，要求转换结果是需要data，这个是haproxy dataplane api的数据结构</p>
<pre><code class="language-json">{
    &quot;_version&quot;: 14,
    &quot;data&quot;: [
        {
            &quot;name&quot;: &quot;http&quot;,
            &quot;address&quot;: &quot;127.0.0.1&quot;,
            &quot;port&quot;: 80
        }
    ]
}
</code></pre>
<p>此时无需定义一个结构体，使用 map即可完成</p>
<pre><code class="language-go">// frist, define a map struct
bindList := map[string][]models.Bind{}

// convert with json.Unmarshal
json.Unmarshal(resp, &amp;bindList)
</code></pre>
<blockquote>
<p>Notes：这里不要去判断error，因为&quot;_version&quot; 字段是一个int类型，必然是 != nil ，转换时正确格式的会被转换，错误格式则被忽略报错了</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中的signal处理</title>
      <link>https://www.oomkill.com/2019/10/go-signal/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-signal/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="什么是信号">什么是信号</h2>
<p>在计算机科学中，信号是Unix、类Unix以及其他POSIX兼容的操作系统中进程间通讯的一种有限制的方式。它是一种异步的通知机制，用来提醒进程一个事件已经发生。</p>
<p>当一个信号发送给一个进程，操作系统中断了进程正常的控制流程，如果进程定义了对信号的处理，此时，程序将进入捕获到的信号对应的处理函数，否则执行默认的处理函数。</p>
<h2 id="linux中信号的介绍">Linux中信号的介绍</h2>
<p>在Linux系统共定义了64种信号，分为两大类：<strong>实时信号</strong>与<strong>非实时信号</strong>，1-31为非实时，32-64种为实时信号。</p>
<blockquote>
<ul>
<li>非实时信号： 也称为不可靠信号，为早期Linux所支持的信号，不支持排队，信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次. 信号值取值区间为1~31；</li>
<li>实时信号： 也称为可靠信号，支持排队, 信号不会丢失, 发多少次, 就可以收到多少次. 信号值取值区间为32~64</li>
</ul>
</blockquote>
<p>Linux操作系统中，在终端上执行 <code>kill -l</code> 便可看到系统定义的所有信号</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201025201542398-333856774.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="信号表">信号表</h3>
<h4 id="posix1-1990标准信号">POSIX.1-1990标准信号</h4>
<p>此表参考自：<a href="https://dsa.cs.tsinghua.edu.cn/oj/static/unix_signal.html" target="_blank"
   rel="noopener nofollow noreferrer" >POSIX信号</a></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>值</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>Term</td>
<td>终端控制进程结束(终端连接断开)</td>
</tr>
<tr>
<td>SIGINT</td>
<td>2</td>
<td>Term</td>
<td>用户发送INTR字符(Ctrl+C)触发</td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>Core</td>
<td>用户发送QUIT字符(Ctrl+/)触发</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>Core</td>
<td>非法指令(程序错误、试图执行数据段、栈溢出等)</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>Core</td>
<td>调用abort函数触发</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>Core</td>
<td>算术运行错误(浮点运算错误、除数为零等)</td>
</tr>
<tr>
<td>SIGKILL</td>
<td>9</td>
<td>Term</td>
<td>无条件结束程序(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>11</td>
<td>Core</td>
<td>无效内存引用(试图访问不属于自己的内存空间、对只读内存空间进行写操作)</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>Term</td>
<td>消息管道损坏(FIFO/Socket通信时，管道未打开而进行写操作)</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>Term</td>
<td>时钟定时信号</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>15</td>
<td>Term</td>
<td>结束程序(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>Term</td>
<td>用户保留</td>
</tr>
<tr>
<td>SIGCHLD</td>
<td>20,17,18</td>
<td>Ign</td>
<td>子进程结束(由父进程接收)</td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>Cont</td>
<td>继续执行已经停止的进程(不能被阻塞)</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>Stop</td>
<td>停止进程(不能被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>Stop</td>
<td>停止进程(可以被捕获、阻塞或忽略)</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>Stop</td>
<td>后台程序从终端中读取数据时触发</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>Stop</td>
<td>后台程序向终端中写数据时触发</td>
</tr>
</tbody>
</table>
<p>更多的信号说明请查阅<a href="https://www.man7.org/linux/man-pages/man7/signal.7.html" target="_blank"
   rel="noopener nofollow noreferrer" >man7</a></p>
<p>此表的操作为每个信号的默认配置，如下所示</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Term</td>
<td>默认操作是，终止进程。</td>
</tr>
<tr>
<td>Ign</td>
<td>默认操作是，忽略信号。</td>
</tr>
<tr>
<td>Core</td>
<td>默认操作是，终止该进程并核心转储</td>
</tr>
<tr>
<td>Stop</td>
<td>默认操作是，停止进程。</td>
</tr>
<tr>
<td>Cont</td>
<td>默认操作是，如果当前已停止，则继续该进程。</td>
</tr>
</tbody>
</table>
<h2 id="信号的产生">信号的产生</h2>
<p>信号是事件发生时对进程的通知机制。信号中断与硬件中断的相似之处在于打断了程序执行的正常流程。</p>
<p>信号事件的来源分为软件信号和硬件信号：</p>
<ul>
<li>硬件信号： <strong>用户输入</strong>：比如在终端上按下组合键ctrl+C，产生SIGINT信号；<strong>硬件异常</strong>：CPU检测到内存非法访问等异常，通知内核生成相应信号，并发送给发生事件的进程；</li>
<li>软件信号： <strong>通过系统调用</strong>： 如，发送signal信号：<code>kill</code>，<code>raise</code>等。</li>
</ul>
<h2 id="发送的信号">发送的信号</h2>
<ul>
<li><code>Ctrl-C</code> 发送 INT signal (SIGINT)，通常导致进程结束</li>
<li><code>Ctrl-Z</code> 发送 TSTP signal (SIGTSTP); 通常导致进程挂起(suspend)</li>
<li><code>Ctrl-\</code> 发送 QUIT signal (SIGQUIT); 通常导致进程结束 和 dump core.</li>
</ul>
<h2 id="信号的处理">信号的处理</h2>
<p>内核处理进程收到的signal是在当前进程的上下文，故进程必须是Running状态。当进程唤醒或者调度后获取CPU，则会从内核态转到用户态时检测是否有signal等待处理，处理完，进程会把相应的未决信号从链表中去掉。</p>
<p>signal信号处理时机： 内核 ==&gt; 信号处理 ==&gt; 用户</p>
<blockquote>
<ol>
<li>内核态：在内核态，signal信号不起作用；</li>
<li>signal信号处理: 在用户态，signal所有未被屏蔽的信号都处理完毕；当屏蔽信号，取消屏蔽时，会在下一次内核转用户态的过程中执行；</li>
</ol>
</blockquote>
<h3 id="信号处理方式">信号处理方式</h3>
<p>进程对信号的处理方式有3种：</p>
<ul>
<li>默认 接收到信号后按默认的行为处理该信号。 这种方式为多数应用采取的处理方式。</li>
<li>自定义处理 用自定义的信号处理函数来执行特定的动作</li>
<li>忽略忽略信号 接收到信号后不做任何反应。</li>
</ul>
<p>对信号的处理动作：</p>
<ul>
<li>Term： 中止进程</li>
<li>Ign： 忽略信号</li>
<li>Core： 中止进程并保存内存信息</li>
<li>Stop： 停止进程</li>
<li>Cont： 继续运行进程</li>
</ul>
<h2 id="linux信号命令">Linux信号命令</h2>
<h3 id="kill">kill</h3>
<p>kill命令用来终止指定的进程, 对于一个后台进程就须用kill命令来终止，我们就需要先使用ps/pidof/pstree/top等工具获取进程PID，然后使用kill命令来杀掉该进程。</p>
<blockquote>
<p><strong>命令格式</strong>
<code>kill[参数] [进程id]</code></p>
</blockquote>
<blockquote>
<p><strong>命令参数</strong>
<code>-l</code>  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
<code>-a</code>  当处理当前进程时，不限制命令名和进程号的对应关系
<code>-p</code>  指定kill 命令只打印相关进程的进程号，而不发送任何信号
<code>-s</code>  指定发送信号
<code>-u</code>  指定用户</p>
</blockquote>
<h3 id="killall">killall</h3>
<p>Linux系统中的<code>killall</code>用于杀死指定名字的进程（kill processes by name）。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。</p>
<blockquote>
<p><strong>命令格式</strong>
<code>killall[参数] [进程名]</code></p>
</blockquote>
<blockquote>
<p><strong>命令参数</strong>
<code>-I</code>  忽略小写
<code>-a</code>  当处理当前进程时，不限制命令名和进程号的对应关系
<code>-i</code>  交互模式，杀死进程前先询问用户
<code>-s</code>  发送指定的信号
<code>-w</code>  等待进程死亡
<code>-e</code>  要求匹配进程名称</p>
</blockquote>
<h3 id="pkill">PKILL</h3>
<p><code>pkill</code> 与 <code>killall</code> 使用方法类似，用于杀死指定名称的进程</p>
<h2 id="go语言中的signal的使用">Go语言中的Signal的使用</h2>
<p>在Go语言中，处理信号仅需要3个步骤即可完成对信号的处理</p>
<ul>
<li>信号的接收： <code>signalChan := make(chan os.Signal,1)</code></li>
<li>信号的监听捕获： <code>signal.Notify(signalChan)</code></li>
<li>信号的触发： <code>signal := &lt;-signalChan</code></li>
</ul>
<p>注意事项：</p>
<ul>
<li><code>SIGKILL kill -9</code>和<code>SIGSTOP kill -19</code> 信号可能不会被Notify方法捕获，因此无法处理这些信号。</li>
<li>如果在Notify方法中没有指定信号作为参数，那么该方法将捕获所有的信号。</li>
</ul>
<h2 id="在go语言中的signal的处理">在Go语言中的Signal的处理</h2>
<p>在某些场景下，如，在大量并发及，批量处理未完成时，此时需要在Go程序中处理Signal信号，比如收到SIGTERM信号后优雅的关闭程序。</p>
<blockquote>
<p>实例：在一个计算场景下，有5个goroutine在处理业务，当收到 <code>kill -15</code>时计算完成后退出程序， <code>kill -4</code>不做处理。</p>
</blockquote>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;os/signal&quot;
	&quot;sync&quot;
	&quot;syscall&quot;
	&quot;time&quot;
)

var wg sync.WaitGroup

func exitProcess() {
	fmt.Println(&quot;等待进程完成&quot;)
	wg.Wait()
	fmt.Println(&quot;进程退出&quot;)
}

func process(n int) {
	i := n
	for {
		fmt.Println(&quot;process&quot;, n, &quot;:&quot;, i)
		if i &gt; 100 {
			break
		}
		time.Sleep(time.Second)
		i++
	}
	fmt.Println(&quot;process&quot;, n, &quot;finnshed&quot;)
	defer wg.Done()
}

func main() {
	signals := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	signal.Notify(signals, syscall.SIGILL, syscall.SIGTERM)

	go func() {
		for signal := range signals {
			switch signal {
			case syscall.SIGTERM, syscall.SIGQUIT:
				fmt.Println(&quot;kill -15 进程退出&quot;)
				exitProcess()
			case syscall.SIGILL:
				fmt.Println(&quot;kill -4&quot;)
			}
		}
		done &lt;- true
	}()

	wg.Add(5)
	for n := 0; n &lt; 10; n++ {
		go process(n)
	}

	fmt.Println(&quot;waiting signal...&quot;)
	wg.Wait()
	fmt.Println(&quot;exiting&quot;)
}
</code></pre>
<p>收到kill -4 信号打印kill -4</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026001747221-1942598103.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>收到kill -15 信号后，带程序处理完成后退出</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026002133354-425851540.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201026002146639-515404564.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何使用golang通过进程ID找到进程名称</title>
      <link>https://www.oomkill.com/2019/10/goskill-process-id/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/goskill-process-id/</guid>
      <description></description>
      <content:encoded><![CDATA[<blockquote>
<p>一个很好的问题：How golang to get process name by process id (pid)?</p>
</blockquote>
<p>目前看来go api并没有提供通过pid获取进程名称的方法，可以通过 <code>/proc/&lt;pid&gt;/cmdline</code>来获取对应的进程名称，也可以通过 <code>readlink /proc/6530/exe</code> 来获取</p>
<ul>
<li><code>/proc/&lt;pid&gt;/cmdline</code> 获取的为运行进程的名称，通常包含一些特殊字符。例如 <code>&quot;-bash\x00&quot;</code>，<code>sshd: root@pts/0</code></li>
<li><code>readlink /proc/6530/exe</code> 获取的为对应进程运行的程序的路径</li>
</ul>
<pre><code class="language-go">pid := os.Getppid()
contents, err := ioutil.ReadFile(fmt.Sprintf(&quot;/proc/%d/cmdline&quot;,pid))
</code></pre>
<pre><code class="language-go">pid := os.Getppid()
contents, err := os.Readlink(fmt.Sprintf(&quot;/proc/%d/cmdline&quot;,pid))
</code></pre>
<blockquote>
<p>Reference
<a href="https://superuser.com/questions/632979/if-i-know-the-pid-number-of-a-process-how-can-i-get-its-name" target="_blank"
   rel="noopener nofollow noreferrer" >process name from pid</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用go语言颁发CA证书</title>
      <link>https://www.oomkill.com/2019/10/goskill-x509-in-go/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/goskill-x509-in-go/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>本篇文章中，将描述如何使用go创建CA，并使用CA签署证书。在使用openssl创建证书时，遵循的步骤是 创建秘钥 &gt; 创建CA &gt; 生成要颁发证书的秘钥 &gt; 使用CA签发证书。这种步骤，那么我们现在就来尝试下。</p>
<h3 id="创建证书的颁发机构">创建证书的颁发机构</h3>
<p>首先，会从将从创建 <em>CA</em> 开始。<em>CA</em> 会被用来签署其他证书</p>
<pre><code class="language-go">// 对证书进行签名
ca := &amp;x509.Certificate{
	SerialNumber: big.NewInt(2019),
	Subject: pkix.Name{
        CommonName:    &quot;domain name&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	},
	NotBefore:             time.Now(),  // 生效时间
	NotAfter:              time.Now().AddDate(10, 0, 0), // 过期时间 年月日
	IsCA:                  true, // 表示用于CA
    // openssl 中的 extendedKeyUsage = clientAuth, serverAuth 字段
	ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
    // openssl 中的 keyUsage 字段
	KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
	BasicConstraintsValid: true,
}
</code></pre>
<p>接下来需要对证书生成公钥和私钥</p>
<pre><code class="language-go">caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
if err != nil {
	return err
}
</code></pre>
<p>然后生成证书：</p>
<pre><code class="language-go">caBytes, err := x509.CreateCertificate(rand.Reader, ca, ca, &amp;caPrivKey.PublicKey, caPrivKey)
if err != nil {
	return err
}
</code></pre>
<p>我们看到的证书内容是PEM编码后的，现在<code>caBytes</code>我们有了生成的证书，我们将其进行 PEM 编码以供以后使用：</p>
<pre><code class="language-go">caPEM := new(bytes.Buffer)
pem.Encode(caPEM, &amp;pem.Block{
	Type:  &quot;CERTIFICATE&quot;,
	Bytes: caBytes,
})

caPrivKeyPEM := new(bytes.Buffer)
pem.Encode(caPrivKeyPEM, &amp;pem.Block{
	Type:  &quot;RSA PRIVATE KEY&quot;,
	Bytes: x509.MarshalPKCS1PrivateKey(caPrivKey),
})
</code></pre>
<h3 id="创建证书">创建证书</h3>
<p>证书的 <code>x509.Certificate</code> 与CA的 <code>x509.Certificate</code> 属性有稍微不同，需要进行一些修改</p>
<pre><code class="language-go">cert := &amp;x509.Certificate{
	SerialNumber: big.NewInt(1658),
	Subject: pkix.Name{
        CommonName:    &quot;domain name&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	},
    IPAddresses:  []net.IP{}, // 这里就是openssl配置文件中 subjectAltName 里的 IP:/IP=
    DNSNames:     []string{}, // 这里就是openssl配置文件中 subjectAltName 里的 DNS:/DNS=
	NotBefore:    time.Now(),
	NotAfter:     time.Now().AddDate(10, 0, 0),
	SubjectKeyId: []byte{1, 2, 3, 4, 6},
    // 这里就是openssl中的extendedKeyUsage 
	ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
	KeyUsage:     x509.KeyUsageDigitalSignature,
}
</code></pre>
<blockquote>
<p>注：这里会在证书中特别添加了 <code>DNS</code> 和 <code>IP</code> （这个不是必须的），这个选项的增加代表的我们的证书可以支持多域名</p>
</blockquote>
<p>为该证书创建私钥和公钥：</p>
<pre><code class="language-go">certPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
if err != nil {
	return err
}
</code></pre>
<h3 id="使用ca签署证书">使用CA签署证书</h3>
<p>有了上述的内容后，可以创建证书并用CA进行签名</p>
<pre><code class="language-go">certBytes, err := x509.CreateCertificate(rand.Reader, cert, ca, &amp;certPrivKey.PublicKey, caPrivKey)
if err != nil {
	return err
}
</code></pre>
<p>要保存成证书格式需要做PEM编码</p>
<pre><code class="language-go">certPEM := new(bytes.Buffer)
pem.Encode(certPEM, &amp;pem.Block{
	Type:  &quot;CERTIFICATE&quot;,
	Bytes: certBytes,
})

certPrivKeyPEM := new(bytes.Buffer)
pem.Encode(certPrivKeyPEM, &amp;pem.Block{
	Type:  &quot;RSA PRIVATE KEY&quot;,
	Bytes: x509.MarshalPKCS1PrivateKey(certPrivKey),
})
</code></pre>
<h3 id="把上面内容融合为一起">把上面内容融合为一起</h3>
<p>创建一个 <code>ca.go</code> 里面是创建ca和颁发证书的逻辑</p>
<pre><code class="language-go">package main

import (
	&quot;bytes&quot;
	cr &quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/x509&quot;
	&quot;crypto/x509/pkix&quot;
	&quot;encoding/pem&quot;
	&quot;math/big&quot;
	&quot;math/rand&quot;
	&quot;net&quot;
	&quot;os&quot;
	&quot;time&quot;
)

type CERT struct {
	CERT       []byte
	CERTKEY    *rsa.PrivateKey
	CERTPEM    *bytes.Buffer
	CERTKEYPEM *bytes.Buffer
	CSR        *x509.Certificate
}

func CreateCA(sub *pkix.Name, expire int) (*CERT, error) {
	var (
		ca  = new(CERT)
		err error
	)

	if expire &lt; 1 {
		expire = 1
	}
	// 为ca生成私钥
	ca.CERTKEY, err = rsa.GenerateKey(cr.Reader, 4096)
	if err != nil {
		return nil, err
	}

	// 对证书进行签名
	ca.CSR = &amp;x509.Certificate{
		SerialNumber: big.NewInt(rand.Int63n(2000)),
		Subject:      *sub,
		NotBefore:    time.Now(),                       // 生效时间
		NotAfter:     time.Now().AddDate(expire, 0, 0), // 过期时间
		IsCA:         true,                             // 表示用于CA
		// openssl 中的 extendedKeyUsage = clientAuth, serverAuth 字段
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		// openssl 中的 keyUsage 字段
		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
		BasicConstraintsValid: true,
	}
	// 创建证书
	// caBytes 就是生成的证书
	ca.CERT, err = x509.CreateCertificate(cr.Reader, ca.CSR, ca.CSR, &amp;ca.CERTKEY.PublicKey, ca.CERTKEY)
	if err != nil {
		return nil, err
	}
	ca.CERTPEM = new(bytes.Buffer)
	pem.Encode(ca.CERTPEM, &amp;pem.Block{
		Type:  &quot;CERTIFICATE&quot;,
		Bytes: ca.CERT,
	})
	ca.CERTKEYPEM = new(bytes.Buffer)
	pem.Encode(ca.CERTKEYPEM, &amp;pem.Block{
		Type:  &quot;RSA PRIVATE KEY&quot;,
		Bytes: x509.MarshalPKCS1PrivateKey(ca.CERTKEY),
	})

	// 进行PEM编码，编码就是直接cat证书里面内容显示的东西
	return ca, nil
}

func Req(ca *x509.Certificate, sub *pkix.Name, expire int, dns []string, ip []net.IP) (*CERT, error) {
	var (
		cert = &amp;CERT{}
		err  error
	)
	cert.CERTKEY, err = rsa.GenerateKey(cr.Reader, 4096)
	if err != nil {
		return nil, err
	}
	if expire &lt; 1 {
		expire = 1
	}
	cert.CSR = &amp;x509.Certificate{
		SerialNumber: big.NewInt(rand.Int63n(2000)),
		Subject:      *sub,
		IPAddresses:  ip,
		DNSNames:     dns,
		NotBefore:    time.Now(),
		NotAfter:     time.Now().AddDate(expire, 0, 0),
		SubjectKeyId: []byte{1, 2, 3, 4, 6},
		ExtKeyUsage:  []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:     x509.KeyUsageDigitalSignature,
	}

	cert.CERT, err = x509.CreateCertificate(cr.Reader, cert.CSR, ca, &amp;cert.CERTKEY.PublicKey, cert.CERTKEY)
	if err != nil {
		return nil, err
	}

	cert.CERTPEM = new(bytes.Buffer)
	pem.Encode(cert.CERTPEM, &amp;pem.Block{
		Type:  &quot;CERTIFICATE&quot;,
		Bytes: cert.CERT,
	})
	cert.CERTKEYPEM = new(bytes.Buffer)
	pem.Encode(cert.CERTKEYPEM, &amp;pem.Block{
		Type:  &quot;RSA PRIVATE KEY&quot;,
		Bytes: x509.MarshalPKCS1PrivateKey(cert.CERTKEY),
	})
	return cert, nil
}

func Write(cert *CERT, file string) error {
	keyFileName := file + &quot;.key&quot;
	certFIleName := file + &quot;.crt&quot;
	kf, err := os.Create(keyFileName)
	if err != nil {
		return err
	}
	defer kf.Close()

	if _, err := kf.Write(cert.CERTKEYPEM.Bytes()); err != nil {
		return err
	}

	cf, err := os.Create(certFIleName)
	if err != nil {
		return err
	}
	if _, err := cf.Write(cert.CERTPEM.Bytes()); err != nil {
		return err
	}
	return nil
}
</code></pre>
<p>如果需要使用的话，可以引用这些函数</p>
<pre><code class="language-go">package main

import (
	&quot;crypto/x509/pkix&quot;
	&quot;log&quot;
	&quot;net&quot;
)

func main() {
	subj := &amp;pkix.Name{
		CommonName:    &quot;chinamobile.com&quot;,
		Organization:  []string{&quot;Company, INC.&quot;},
		Country:       []string{&quot;US&quot;},
		Province:      []string{&quot;&quot;},
		Locality:      []string{&quot;San Francisco&quot;},
		StreetAddress: []string{&quot;Golden Gate Bridge&quot;},
		PostalCode:    []string{&quot;94016&quot;},
	}
	ca, err := CreateCA(subj, 10)
	if err != nil {
		log.Panic(err)
	}

	Write(ca, &quot;./ca&quot;)

	crt, err := Req(ca.CSR, subj, 10, []string{&quot;test.default.svc&quot;, &quot;test&quot;}, []net.IP{})

	if err != nil {
		log.Panic(err)
	}

	Write(crt, &quot;./tls&quot;)
}
</code></pre>
<h3 id="遇到的问题">遇到的问题</h3>
<p><strong>panic: x509: unsupported public key type: rsa.PublicKey</strong></p>
<p>这里是因为 <code>x509.CreateCertificate</code> 的参数 <code>privatekey</code> 需要传入引用变量，而传入的是一个普通变量</p>
<blockquote>
<p><strong>注</strong>：x509: only RSA and ECDSA public keys supported</p>
</blockquote>
<h3 id="一些参数的意思">一些参数的意思</h3>
<p><code>extendedKeyUsage</code> ：增强型密钥用法(参见&quot;new_oids&quot;字段)：服务器身份验证、客户端身份验证、时间戳。</p>
<pre><code class="language-cnf">extendedKeyUsage = critical,serverAuth, clientAuth, timeStamping
</code></pre>
<p><code>keyUsage </code>： 密钥用法，防否认(nonRepudiation)、数字签名(digitalSignature)、密钥加密(keyEncipherment)。</p>
<pre><code class="language-conf">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</code></pre>
<blockquote>
<p>Reference</p>
<p><a href="https://shaneutt.com/blog/golang-ca-and-signed-cert-go/" target="_blank"
   rel="noopener nofollow noreferrer" >golang ca and signed cert go</a></p>
<p><a href="https://golang.google.cn/pkg/crypto/x509/" target="_blank"
   rel="noopener nofollow noreferrer" >package x509</a></p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>通过Go语言中阐述TCP Handshake</title>
      <link>https://www.oomkill.com/2019/10/go-tcp-hadshake/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-tcp-hadshake/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="tcp的三次握手">TCP的三次握手</h2>
<p>所谓三次握手 <code>Three-Way Handshake</code> 是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。好比两个人在打电话：</p>
<p><strong>当连接被建立或被终止，交换的报文段只包含TCP头部，而没有数据。</strong></p>
<h3 id="tcp报文头部结构">tcp报文头部结构</h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015181428149-1959216565.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<ul>
<li>序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，<strong>发起方发送数据时对此进行标记。</strong></li>
<li>确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，确认方ack=发起方seq+1，两端配对。</li>
<li>标志位
<ul>
<li>ACK：确认序号有效。</li>
<li>FIN：释放一个连接。</li>
<li>RST：重置连接。</li>
<li>SYN：发起一个新连接。</li>
<li>PSH：接收方应该尽快将这个报文交给应用层。</li>
<li>URG：紧急指针（urgent pointer）有效。</li>
</ul>
</li>
</ul>
<p>    第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。</p>
<p>    第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。</p>
<p>    第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201015202229030-277503076.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="四次挥手">四次挥手</h3>
<p>    比如客户端初始化的序列号ISA=100，服务端初始化的序列号ISA=300。TCP连接成功后客户端总共发送了1000个字节的数据，服务端在客户端发FIN报文前总共回复了2000个字节的数据。</p>
<p>    第一次挥手：当客户端的数据都传输完成后，客户端向服务端发出连接释放报文(当然数据没发完时也可以发送连接释放报文并停止发送数据)，释放连接报文包含FIN标志位(FIN=1)、序列号seq=1101(100+1+1000，其中的1是建立连接时占的一个序列号)。需要注意的是客户端发出FIN报文段后只是不能发数据了，但是还可以正常收数据；另外FIN报文段即使不携带数据也要占据一个序列号。</p>
<p>    第二次挥手：服务端收到客户端发的FIN报文后给客户端回复确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=1102(客户端FIN报文序列号1101+1)、序列号seq=2300(300+2000)。此时服务端处于关闭等待状态，而不是立马给客户端发FIN报文，这个状态还要持续一段时间，因为服务端可能还有数据没发完。</p>
<p>    第三次挥手：服务端将最后数据(比如50个字节)发送完毕后就向客户端发出连接释放报文，报文包含FIN和ACK标志位(FIN=1,ACK=1)、确认号和第二次挥手一样ack=1102、序列号seq=2350(2300+50)。</p>
<p>    第四次挥手：客户端收到服务端发的FIN报文后，向服务端发出确认报文，确认报文包含ACK标志位(ACK=1)、确认号ack=2351、序列号seq=1102。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>正则表达式在go中使用</title>
      <link>https://www.oomkill.com/2019/10/go-regular-expression/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/10/go-regular-expression/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活。按照它的语法规则，随需构造出的匹配模式就能够从原始文本中筛选出几乎任何你想要得到的字符组合。</p>
<p>Go语言通过regexp（regular expression）标准包为正则表达式提供了官方支持，包名采用<code>regular expression</code>的每个单词的前三个首字母组成。</p>
<p>Go语言的正则表达式实现的是RE2标准，Go语言的正则表达式与其他编程语言之间也有一些小的差异。</p>
<h2 id="正则表达式规则">正则表达式规则</h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022164330719-1170561795.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="go语言中regexp包使用">go语言中regexp包使用</h2>
<p>简单来说，Go语言中使用正则表达式只需要两步即可：</p>
<ul>
<li>解析、编译正则表达式 <code>regexp.MustCompile()</code> 返回一个regexp结构体</li>
<li>根据解析好的规则（结构体形式），从指定字符串中提取需要的信息。如 <code>MatchString()</code> <code>FindAllSubmatch()</code>等</li>
</ul>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;regexp&quot;
)

func main() {
	rege := regexp.MustCompile(`(\d{1,3}\.){3}\d{1,3}`)
	str := rege.FindAllString(&quot;SLAJDLKAJ192.168.0.1DASDASA1231&quot;, -1)
	fmt.Println(str)

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201022165701430-1274324162.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>deepin下安装goland中文字体显示全是方块</title>
      <link>https://www.oomkill.com/2019/04/deepin-goland/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/04/deepin-goland/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>下载中文字体</p>
<pre><code class="language-bash">apt-get install ttf-arphic-uming xfonts-intl-chinese
</code></pre>
<p>替换goland的汉化包，两个jar包。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - cobra</title>
      <link>https://www.oomkill.com/2019/03/go-cobra/</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/03/go-cobra/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="cobra功能">Cobra功能</h2>
<p>简单子命令cli 如 kubectl verion  kubectl get</p>
<p>自动识别-h，&ndash;help 帮助</p>
<p>更过参考官方手册：https://github.com/spf13/cobra</p>
<p><code>kubectl get pod --all-namespaces</code></p>
<ul>
<li><code>get</code> 代表命令（command）</li>
<li><code>pod</code> 代表事务（args）</li>
<li><code>--all-namespaces</code> 代表标识（flag）</li>
<li><code>command</code> 代表动作，</li>
<li><code>Args</code> 代表事务，</li>
<li><code>flags</code> 代表动作的修饰符。</li>
</ul>
<h2 id="使用cobra">使用Cobra</h2>
<p>使用cobra需要main.go或和cmd/cmd.go(非固定，根据官方手册说明操作的)，来创建需要添加的命令。</p>
<p>cobra不需要构造函数，只需要创建命令即可</p>
<pre><code class="language-go">rootCmd = &amp;cobra.Command{
    Use:   &quot;db &quot;,
    Short: &quot;test1&quot;,
    Long:  `this is a test123`,
    Run: func(cmd *cobra.Command, args []string) {
	log.Println(cfgFile, port)
    },
}

func Execute() {
    if err := rootCmd.Execute(); err != nil {
        log.Fatal(err)
        os.Exit(1)
    }
}
</code></pre>
<p>还需要在init()方法中定义flag和handle等配置。</p>
<pre><code class="language-go">func init() {
    rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;c&quot;, &quot;&quot;, &quot;config file (default /etc/php.ini)&quot;)
    rootCmd.PersistentFlags().IntVar(&amp;port, &quot;p&quot;, 3306, &quot;config file (default /etc/php.ini)&quot;)
}
</code></pre>
<p>创建main.go，在其初始化cobra</p>
<pre><code class="language-go">package main

import &quot;your_app/cmd&quot;

func main() {
    cmd.Execute()
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20190307005608457-2032759416.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="使用flag">使用flag</h2>
<p>标志是args来控制动作command的操作方式的。</p>
<p>**Persistent Flags：**全局性flag 可用于它所分配的命令以及该命令下的每个命令。在根上分配标志作为全局flag。</p>
<p><strong>Local Flags：<strong>局部性flag 在本args分配一个标志，该标志仅适用于该特定命令</strong>。</strong></p>
<p><strong>Required flags：<strong>必选flag，flag默认是可选的。如果希望命令在未设置flag时报告错误，请将其标记为</strong>required</strong></p>
<pre><code class="language-go">rootCmd.Flags().StringVarP(&amp;cfgFile, &quot;config&quot;, &quot;c&quot;, &quot;&quot;, &quot;config file (require)&quot;)
rootCmd.MarkFlagRequired(&quot;config&quot;)
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20190307034537988-127741233.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>使用子命令</p>
<pre><code class="language-go">testCmd = &amp;cobra.Command{
　　Use:   &quot;zhangsan&quot;,
　　Short: &quot;child command&quot;,
　　Long:  `this is a child command`,
　　Run: func(cmd *cobra.Command, args []string) {
　　	fmt.Println(&quot;root &gt; zhangsan&quot;)
　　},
}

rootCmd.AddCommand(testCmd)
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20190307034834419-1890381759.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - cronexpr</title>
      <link>https://www.oomkill.com/2019/02/cronexpr/</link>
      <pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2019/02/cronexpr/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>包获取：<code>go get -u github.com/gorhill/cronexpr</code></p>
<p>创建一个定时任务</p>
<pre><code class="language-go">expr, err = cron.Parse(&quot;* * * * *&quot;);
</code></pre>
<p>获得任务的下次执行时间</p>
<pre><code class="language-go">nextTime = expr.Next(now)
</code></pre>
<p>完整代码</p>
<pre><code class="language-go">package main

import (
　　&quot;fmt&quot;
　　&quot;time&quot;
　　cron &quot;github.com/gorhill/cronexpr&quot;
)

type CronJob struct {
　　expr     *cron.Expression
　　nextTime time.Time //expr.now
}

func main() {

　　var (
　　　　cronJob       *CronJob
　　　　expr          *cron.Expression
　　　　now           time.Time
　　　　scheduleTable map[string]*CronJob // key 任务的名称
　　)

　　scheduleTable = make(map[string]*CronJob)


　　now = time.Now()
　　expr = cron.MustParse(&quot;*/5 * * * * * *&quot;)

　　cronJob = &amp;CronJob{
　　　　expr:     expr,
　　　　nextTime: expr.Next(now),
　　}

　　scheduleTable[&quot;job1&quot;] = cronJob

　　expr = cron.MustParse(&quot;*/10 * * * * * *&quot;)

　　cronJob = &amp;CronJob{
　　　　expr:     expr,
　　　　nextTime: expr.Next(now),
　　}

　　// 将任务注册到调度表中

　　scheduleTable[&quot;job2&quot;] = cronJob


　　// 调度协程
　　go func() {
　　　　var(
　　　　　　_now time.Time
　　　　　　cname string
　　　　　　cronjob *CronJob
　　　　)

　　　　for {
　　　　　　_now = time.Now()
　　　　　　for cname, cronjob = range scheduleTable {
　　　　　　　　if cronjob.nextTime.Before(_now) || cronjob.nextTime.Equal(_now) {
　　　　　　　　　　go func(name string) {
　　　　　　　　　　　　fmt.Println(&quot;exec&quot;, name)
　　　　　　　　　　}(cname)

　　　　　　　　　　cronjob.nextTime = cronjob.expr.Next(_now)
　　　　　　　　　　fmt.Println(&quot;next exec time: &quot;,cronjob.nextTime)
　　　　　　　　}
　　　　　　}

　　　　　　select {
　　　　　　　　case &lt;-time.NewTimer(100 * time.Millisecond).C: //睡眠
　　　　　　}
　　　}
　　}()

　　time.Sleep(time.Minute*3)
}
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go byte与rune区别</title>
      <link>https://www.oomkill.com/2018/12/golang-byte-and-rune/</link>
      <pubDate>Wed, 12 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/12/golang-byte-and-rune/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>先看代码</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func main() {
	var a = &quot;hello world&quot;

	var b = &quot;中&quot;
	fmt.Println([]rune(a))
	fmt.Println([]rune(b))
	fmt.Println([]byte(b))

}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181212231909208-1840622497.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>go源码中的定义</p>
<pre><code class="language-go">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8

// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
</code></pre>
<p>byte是uint8、rune为uint32，一个仅限于ascii码的值，一个支持更多的值。rune比byte能表达更多的数。</p>
<p>golang默认使用utf8编码，一个中文占用3字节，一个utf8数字占用1字节，utf8字母占用1字节</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go每日一库 - bufio缓冲区的终端输入</title>
      <link>https://www.oomkill.com/2018/11/go-bufio/</link>
      <pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/11/go-bufio/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，os.stdin就是实现了这个接口</p>
<pre><code class="language-go">package main
 
import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)
 
var buff *bufio.Reader
 
func main() {
    buff = bufio.NewReader(os.Stdin)
    str, err := buff.ReadString('\n')
    
    if err == nil {
        fmt.Printf(&quot;input was :%s&quot;, str)
    }
}
</code></pre>
<p><code>ReadString(byte)</code> 遇到byte后返回，包含已读到的和byte，如果在读到之前遇到错误，返回读取的信息及该错误</p>
<p>在写文件时。可以写入缓冲区来可以提升磁盘性能</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go数组排序算法</title>
      <link>https://www.oomkill.com/2018/10/go-datasort/</link>
      <pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2018/10/go-datasort/</guid>
      <description></description>
      <content:encoded><![CDATA[<h3 id="冒泡排序">冒泡排序</h3>
<p>图 <a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank"
   rel="noopener nofollow noreferrer" >https://www.cnblogs.com/onepixel/articles/7674659.html</a></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024190418457-684324734.gif" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
　　&quot;fmt&quot;
)

func bubbleSort(slice []int) []int {
	for n := 0; n &lt;= len(slice); n++ {
		for i := 1; i &lt; len(slice)-n; i++ {
			if slice[i] &lt; slice[i-1] {
				slice[i], slice[i-1] = slice[i-1], slice[i]
			}
		}
	}
	return slice
}


func main() {

	var arr = [...]int{99, 51, 41, 2, 31}

	var rarr = bubble(arr[:])
	fmt.Println(rarr)
}
</code></pre>
<h3 id="比较排序">比较排序</h3>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024190418457-684324734.gif" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func selectionSort(slice []int) []int {
	for n := 0; n &lt;= len(slice); n++ {
		fmt.Println(slice)
		fmt.Println(&quot;#####################&quot;)
		for i := n + 1; i &lt; len(slice); i++ {

			if slice[n] &gt; slice[i] {
				slice[n], slice[i] = slice[i], slice[n]
				fmt.Println(slice)
			}
		}
		fmt.Println(&quot;---------------&quot;)
	}
	return slice
}

func main() {

	var arr = [...]int{99, 51, 41, 2, 31}

	var rarr = selectionSort(arr[:])
	fmt.Println(rarr)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024192039075-202363040.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="插入排序">插入排序</h3>
<p>思路：将数组拆分为一个有序的，一个无序的。初始时下标0永远为有序数组。</p>
<p>建立循环，从下标1开始到数组的长度，每个都与前一个进行对比，如果比前一个值小，就互相换位，当当前值比上一个值大时，说明当前值之前都是已经排序好的数组。就退出。</p>
<p>例子：如该数组 <code>[...]int{10, 56, 4, 654, 8, 997}</code>，</p>
<p>第一次循环时，<code>n=1 i=1 56 &gt; 10</code> 跳出。</p>
<p>第二次循环时，<code>{10, 56, 4, 654, 8, 997} n=2 i=n=2</code>， <code>4&lt;56</code> 互换，值为 <code>{10, 4, 56,  654, 8, 997}</code> ，内部循环继续进行，i=1 4&lt;10互换为 <code>[4 10 56 654 8  997]</code> 。内部循环结束，条件为i&lt;0</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024235059413-104460375.gif" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func insertSort(arr []int) {
	for n := 1; n &lt; len(arr); n++ {
		for i := n; i &gt; 0; i-- {
			if arr[i] &gt; arr[i-1] {
				break
			}
			arr[i], arr[i-1] = arr[i-1], arr[i]
			fmt.Println(arr)
		}
	}
}

func main() {
	var array = [...]int{10, 56, 4, 654, 8, 997}
	insertSort(array[:])

	fmt.Println(array)
}
</code></pre>
<h3 id="快速排序">快速排序</h3>
<p>思路：以一个基准数将数组拆分为两个，一边大于这个数，一边小于这个数。从数组第0个开始，首先先记录此基准数的下标和值 <code>{312, 84, 543, 5, 100, 23}</code> ，k=0 v=312。需要传入一个从哪里开始到哪里的位置。这里基准数为第一个，顾循环位置就从0+1开始 循环完之后为 84 84 543 5 100 23</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024192500164-765677648.gif" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
)

func qsort(arr []int, start int, end int) {
	if start &gt;= end {
		return
	}

	key := start
	value := arr[start] //记录当前基准值位置
	fmt.Println(arr)
	for n := start + 1; n &lt;= end; n++ {
		// a[n] &lt; arr[start]
		if arr[n] &lt; value {
			arr[key] = arr[n]   //就将a[n]挪至arr[key]所在位置
			arr[n] = arr[key+1] //a[n]空缺了，将arr[key]向后移动一位
			// 理论上现在值为这个 {84, 84, 543, 5, 100, 23}
			key++ //key的位置改变了1位，key++
			//最后在将进位后的arr[key] = 之前保存的value即为
			// value=321 {84, 312, 543, 5, 100, 23}
			//这样完成了替换
		}
	}

	arr[key] = value
	fmt.Println(&quot;---------------------------&quot;)
	//一轮循环后该数组为[84 5 100 23 312 543]
	//将基准数两边的数进行进行排序 此时 key=3 start=0 左边为 start-key-1
	qsort(arr, start, key-1)
	qsort(arr, key+1, end) //右边为key+1-end
}

func main() {
	var array = [...]int{312, 84, 543, 5, 100, 23}
	qsort(array[:], 0, len(array)-1)
	fmt.Println(array)
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed//img/1380340-20181024192552212-1519669369.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
