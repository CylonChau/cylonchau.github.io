<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>kube-proxy参数ClusterCIDR做什么 | Cylon's Collection</title><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NP3JNCPR" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><meta name=keywords content="kube-proxy,kube-proxy cidr原理"><meta name=description content="我们可以看到，kube-proxy 有一个 &ndash;cluster-cidr 的参数，我们就来解开这个参数究竟有没有用
bash 1 2 $ kube-proxy -h|grep cidr --cluster-cidr string The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead 可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。
首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。"><meta name=author content="cylon"><link rel=canonical href=http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/favicon.ico><link rel=mask-icon href=http://localhost:1313/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-NP3JNCPR")</script><meta property="og:title" content="kube-proxy参数ClusterCIDR做什么"><meta property="og:description" content="我们可以看到，kube-proxy 有一个 &ndash;cluster-cidr 的参数，我们就来解开这个参数究竟有没有用
bash 1 2 $ kube-proxy -h|grep cidr --cluster-cidr string The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead 可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。
首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-15T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-15T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="kube-proxy参数ClusterCIDR做什么"><meta name=twitter:description content="我们可以看到，kube-proxy 有一个 &ndash;cluster-cidr 的参数，我们就来解开这个参数究竟有没有用
bash 1 2 $ kube-proxy -h|grep cidr --cluster-cidr string The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead 可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。
首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"kube-proxy参数ClusterCIDR做什么","item":"http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kube-proxy参数ClusterCIDR做什么","name":"kube-proxy参数ClusterCIDR做什么","description":"我们可以看到，kube-proxy 有一个 \u0026ndash;cluster-cidr 的参数，我们就来解开这个参数究竟有没有用\nbash 1 2 $ kube-proxy -h|grep cidr --cluster-cidr string The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead 可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。\n首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。","keywords":["kube-proxy","kube-proxy cidr原理"],"articleBody":"我们可以看到，kube-proxy 有一个 –cluster-cidr 的参数，我们就来解开这个参数究竟有没有用\nbash 1 2 $ kube-proxy -h|grep cidr --cluster-cidr string The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead 可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。\n首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。\n在 API KubeProxyConfiguration 中我们找到的对应的 ClusterCIDR ，在这里的注释又变为 ”用于桥接集群外部流量“。这里涉及到关于 kube-proxy 的两个模式 “LocalMode” 和 “ProxyMode“。\nLocalMode：表示是来自节点本地流量的模式，包含 ClusterCIDR, NodeCIDR ProxyMode：就是 kube-proxy 最常用的模式，包含 iptables, IPVS, user namespace, kernelspace 而参数 –cluster-cidr 是作为选择使用的 “本地网络检测器” (Local Network Detector)，这里起到的作用就是 “将集群外部的流量伪装成 service VIP” ，从代码中我们可以看到 Detector 将决定了你使用的是什么网络，无论是 LocalMode 还是 ProxyMode。\n在代码 cmd/kube-proxy/app/server_others.go 中可以看到是如何选择的 LocalMode 方式，可以看出在存在三种模式：\n没有配置 –cluster-cidr 则会返回一个 NoOpLocalDetector； 在配置了 –cluster-cidr ，则将会使用 CIDR 的本地模式； 如果 –cluster-cidr 没有配置，但配置了 LocalModeNodeCIDR，则会设置为 CNI 为该 Node 配置的 POD CIDR 的地址 (使用参数 –proxy-mode 指定的模式，如果为空，那么会检测对应操作系统默认 Linux 为 iptables，如果内核开启 IPVS 那么则使用 IPVS，windows 默认为 kernelspace) go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func getLocalDetector(mode proxyconfigapi.LocalMode, config *proxyconfigapi.KubeProxyConfiguration, ipt utiliptables.Interface, nodeInfo *v1.Node) (proxyutiliptables.LocalTrafficDetector, error) { switch mode { case proxyconfigapi.LocalModeClusterCIDR: if len(strings.TrimSpace(config.ClusterCIDR)) == 0 { klog.Warning(\"detect-local-mode set to ClusterCIDR, but no cluster CIDR defined\") break } return proxyutiliptables.NewDetectLocalByCIDR(config.ClusterCIDR, ipt) case proxyconfigapi.LocalModeNodeCIDR: if len(strings.TrimSpace(nodeInfo.Spec.PodCIDR)) == 0 { klog.Warning(\"detect-local-mode set to NodeCIDR, but no PodCIDR defined at node\") break } return proxyutiliptables.NewDetectLocalByCIDR(nodeInfo.Spec.PodCIDR, ipt) } klog.V(0).Info(\"detect-local-mode: \", string(mode), \" , defaulting to no-op detect-local\") return proxyutiliptables.NewNoOpLocalDetector(), nil } 这里我们以 IPVS 为例，如果开启了 localDetector 在 这个 ipvs proxier 中做了什么? 在代码 pkg/proxy/ipvs/proxier.go 可以看到\ngo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 if !proxier.ipsetList[kubeClusterIPSet].isEmpty() { args = append(args[:0], \"-A\", string(kubeServicesChain), \"-m\", \"comment\", \"--comment\", proxier.ipsetList[kubeClusterIPSet].getComment(), \"-m\", \"set\", \"--match-set\", proxier.ipsetList[kubeClusterIPSet].Name, ) if proxier.masqueradeAll { writeLine(proxier.natRules, append(args, \"dst,dst\", \"-j\", string(KubeMarkMasqChain))...) } else if proxier.localDetector.IsImplemented() { // This masquerades off-cluster traffic to a service VIP. The idea // is that you can establish a static route for your Service range, // routing to any node, and that node will bridge into the Service // for you. Since that might bounce off-node, we masquerade here. // If/when we support \"Local\" policy for VIPs, we should update this. writeLine(proxier.natRules, proxier.localDetector.JumpIfNotLocal(append(args, \"dst,dst\"), string(KubeMarkMasqChain))...) } else { // Masquerade all OUTPUT traffic coming from a service ip. // The kube dummy interface has all service VIPs assigned which // results in the service VIP being picked as the source IP to reach // a VIP. This leads to a connection from VIP: to // VIP:. // Always masquerading OUTPUT (node-originating) traffic with a VIP // source ip and service port destination fixes the outgoing connections. writeLine(proxier.natRules, append(args, \"src,dst\", \"-j\", string(KubeMarkMasqChain))...) } } 可以看到“不管使用了什么模式，都会更新一条 iptables 规则” 这就代表了使用了什么模式，而这个则被称之为 LocalTrafficDetector，也就是本地流量的检测，那我们看一下这个做了什么。\n在使用 IPVS 的日志中，可以看到这样一条规则，这个是来自集群外部的 IP 去访问集群 CLUSTER IP (KUBE-CLUSTER-IP，即集群内所有 service IP) 时, 将非集群 IP 地址，转换为集群内的 IP 地址 (做源地址转换)\nbash 1 [DetectLocalByCIDR (10.244.0.0/16)] Jump Not Local: [-A KUBE-SERVICES -m comment --comment \"Kubernetes service cluster ip + port for masquerade purpose\" -m set --match-set KUBE-CLUSTER-IP dst,dst ! -s 10.244.0.0/16 -j KUBE-MARK-MASQ] 而这个步骤分布在所有模式下 (iptables\u0026ipvs)，这里还是没说到两个概念 LocalMode 和 ProxyMode，实际上这两个模式的区别为：\nLocalMode：集群 IP 伪装采用 ClusterCIDR 还是 NodeCIDR，ClusterCIDR 是使用集群 Pod IP 的地址段 (IP Range)，而 LocalCIDR 只仅仅使用被分配给该 kubernetes node 上的 Pod 做地址伪装 ProxyMode：和 LocalMode 没有任何关系，是 kube-proxy 在运行时使用什么为集群 service 做代理，例如 iptables, ipvs ，而在这些模式下将采用什么 LocalMode 为集群外部地址作伪装，大概分为三种类型： 为来自集群外部地址 (cluster-off)：所有非 Pod 地址的请求执行跳转 (KUBE-POSTROUTING) 没有操作 ：在非 iptables/ipvs 模式下，不做伪装 masqueradeAll：为所有访问 cluster ip 的地址做伪装 ClusterCIDR 原理 kube-proxy 为 kube node 上生成一些 NAT 规则，如下所示\nbash 1 2 3 4 5 6 7 8 9 10 11 -A KUBE-FIREWALL -j KUBE-MARK-DROP -A KUBE-LOAD-BALANCER -j KUBE-MARK-MASQ -A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000 -A KUBE-NODE-PORT -p tcp -m comment --comment \"Kubernetes nodeport TCP port for masquerade purpose\" -m set --match-set KUBE-NODE-PORT-TCP dst -j KUBE-MARK-MASQ -A KUBE-POSTROUTING -m comment --comment \"Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose\" -m set --match-set KUBE-LOOP-BACK dst,dst,src -j MASQUERADE -A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN -A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0 -A KUBE-POSTROUTING -m comment --comment \"kubernetes service traffic requiring SNAT\" -j MASQUERADE -A KUBE-SERVICES ! -s 10.244.0.0/16 -m comment --comment \"Kubernetes service cluster ip + port for masquerade purpose\" -m set --match-set KUBE-CLUSTER-IP dst,dst -j KUBE-MARK-MASQ -A KUBE-SERVICES -m addrtype --dst-type LOCAL -j KUBE-NODE-PORT -A KUBE-SERVICES -m set --match-set KUBE-CLUSTER-IP dst,dst -j ACCEPT 可以看到这里做了几个链，在 KUBE-SERVICES 链中指明了非来自 ClusterCIDR 的 IP 都做一个，并且访问的目的地址是 KUBE-CLUSTER-IP (ipset 里配置的地址) 那么将跳转到 KUBE-MARK-MASQ 链做一个 --set-xmark 0x4000/0x4000 ，而在 KUBE-POSTROUTING 中对没有被标记 0x4000/0x4000 的操作不做处理\n具体来说，-A KUBE-NODE-PORT -p tcp -m comment --comment \"Kubernetes nodeport TCP port for masquerade purpose\" -m set --match-set KUBE-NODE-PORT-TCP dst -j KUBE-MARK-MASQ 做了如下操作：\n-A KUBE-SERVICES：将这条规则附加到名为KUBE-SERVICES的iptables链。 ! -s 10.244.0.0/16：排除源IP地址为10.244.0.0/16的流量（即来自Kubernetes服务集群IP的流量）。 -m comment --comment \"Kubernetes service cluster ip + port for masquerade purpose\"：添加一条注释，说明这个规则的用途。 -m set --match-set KUBE-CLUSTER-IP dst,dst：使用IP集合KUBE-CLUSTER-IP来匹配目标IP地址和目标端口。 -j KUBE-MARK-MASQ：如果流量匹配了前面的条件，将流量传递到名为KUBE-MARK-MASQ的目标。 iptables -j RETURN 是用于iptables规则中的一个目标动作，它不是用于拒绝或接受数据包的动作，而是用于从当前规则链中返回（返回到调用链）的动作。\n具体来说，当规则链中的数据包被标记为 RETURN 时，它们将不再受到当前链中后续规则的影响，而会立即返回到调用链，以便继续进行后续规则的处理。这通常用于某些高级设置，例如在自定义规则链中执行特定的操作后返回到主要的防火墙链。\n从代码中可以看到，对应执行 jump 的操作的链就是 KUBE-MARK-MASQ\ngo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 } else if proxier.localDetector.IsImplemented() { // This masquerades off-cluster traffic to a service VIP. The idea // is that you can establish a static route for your Service range, // routing to any node, and that node will bridge into the Service // for you. Since that might bounce off-node, we masquerade here. // If/when we support \"Local\" policy for VIPs, we should update this. writeLine(proxier.natRules, proxier.localDetector.JumpIfNotLocal(append(args, \"dst,dst\"), string(KubeMarkMasqChain))...)\t// KubeMarkMasqChain is the mark-for-masquerade chain KubeMarkMasqChain utiliptables.Chain = \"KUBE-MARK-MASQ\" // 具体拼接的就是 -j 链名的操作 func (d *detectLocalByCIDR) JumpIfNotLocal(args []string, toChain string) []string { line := append(args, \"!\", \"-s\", d.cidr, \"-j\", toChain) klog.V(4).Info(\"[DetectLocalByCIDR (\", d.cidr, \")]\", \" Jump Not Local: \", line) return line } 继续往下 KUBE-POSTROUTING 可以看到对应伪装是一个动态的源地址改造，而 RETURN 则不是被标记的请求\ngo 1 2 3 4 5 6 Chain KUBE-POSTROUTING (1 references) target prot opt source destination MASQUERADE all -- 0.0.0.0/0 0.0.0.0/0 /* Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose */ match-set KUBE-LOOP-BACK dst,dst,src RETURN all -- 0.0.0.0/0 0.0.0.0/0 mark match ! 0x4000/0x4000 MARK all -- 0.0.0.0/0 0.0.0.0/0 MARK xor 0x4000 MASQUERADE all -- 0.0.0.0/0 0.0.0.0/0 /* kubernetes service traffic requiring SNAT */ 这整体就是 ClusterCIDR 在 kube-proxy 中的应用，换句话说还需要关注一个 LocalCIDR\n","wordCount":"987","inLanguage":"zh","datePublished":"2023-09-15T00:00:00Z","dateModified":"2023-09-15T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/><img src=http://localhost:1313/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives><span>归档</span></a></li><li><a href=http://localhost:1313/tags><span>标签</span></a></li><li><a href=http://localhost:1313/search><span>搜索</span></a></li><li><a href=http://localhost:1313/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">kube-proxy参数ClusterCIDR做什么</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2023-09-15</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>987 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>5 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=http://localhost:1313/tags/kubernetes/>#Kubernetes</a>
<a href=http://localhost:1313/tags/kubernetes-develop/>#Kubernetes Develop</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#clustercidr-%e5%8e%9f%e7%90%86 aria-label="ClusterCIDR 原理">ClusterCIDR 原理</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><p>我们可以看到，<em>kube-proxy</em> 有一个 <em>&ndash;cluster-cidr</em> 的参数，我们就来解开这个参数究竟有没有用</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ kube-proxy -h<span class=p>|</span>grep cidr
</span></span><span class=line><span class=cl>      --cluster-cidr string                          The CIDR range of pods in the cluster. When configured, traffic sent to a Service cluster IP from outside this range will be masqueraded and traffic sent from pods to an external LoadBalancer IP will be directed to the respective cluster IP instead</span></span></code></pre></td></tr></table></div></div></div></div><p>可以看到，参数说明是说，如果配置，那么从外部发往 Service Cluster IP 的流量将被伪装，从 Pod 发往外部 LB 将被直接发往对应的 cluster IP。但实际上做了什么并不知道，那么就从源码解决这个问题。</p><p>首先我们知道，参数是作为 kube-proxy server 的参数，位于 cmd/kube-proxy 下，而对应的逻辑则位于 pkg/kube-proxy 下，参数很明显，就是 clusterCIDR，那么我们就寻找这个参数的调用即可。</p><p>在 API <em>KubeProxyConfiguration</em> 中我们找到的对应的 <em>ClusterCIDR</em> ，在这里的注释又变为 ”用于桥接集群外部流量“。这里涉及到关于 <em>kube-proxy</em> 的两个模式 “LocalMode” 和 “ProxyMode“。</p><ul><li><em><strong>LocalMode</strong></em>：表示是来自节点本地流量的模式，包含 ClusterCIDR, NodeCIDR</li><li><em><strong>ProxyMode</strong></em>：就是 kube-proxy 最常用的模式，包含 iptables, IPVS, user namespace, kernelspace</li></ul><p>而参数 <em>&ndash;cluster-cidr</em> 是作为选择使用的 “本地网络检测器” (Local Network Detector)，这里起到的作用就是 “将集群外部的流量伪装成 service VIP” ，从代码中我们可以看到 Detector 将决定了你使用的是什么网络，无论是 <em>LocalMode</em> 还是 <em>ProxyMode</em>。</p><p>在代码 <a href=cmd/kube-proxy/app/server_others.go>cmd/kube-proxy/app/server_others.go</a> 中可以看到是如何选择的 <em>LocalMode</em> 方式，可以看出在存在三种模式：</p><ul><li>没有配置 <em>&ndash;cluster-cidr</em> 则会返回一个 <em>NoOpLocalDetector</em>；</li><li>在配置了 <em>&ndash;cluster-cidr</em> ，则将会使用 CIDR 的本地模式；</li><li>如果 <em>&ndash;cluster-cidr</em> 没有配置，但配置了 LocalModeNodeCIDR，则会设置为 CNI 为该 Node 配置的 POD CIDR 的地址 (使用参数 <em>&ndash;proxy-mode</em> 指定的模式，如果为空，那么会检测对应操作系统默认 Linux 为 iptables，如果内核开启 IPVS 那么则使用 IPVS，windows 默认为 kernelspace)</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getLocalDetector</span><span class=p>(</span><span class=nx>mode</span> <span class=nx>proxyconfigapi</span><span class=p>.</span><span class=nx>LocalMode</span><span class=p>,</span> <span class=nx>config</span> <span class=o>*</span><span class=nx>proxyconfigapi</span><span class=p>.</span><span class=nx>KubeProxyConfiguration</span><span class=p>,</span> <span class=nx>ipt</span> <span class=nx>utiliptables</span><span class=p>.</span><span class=nx>Interface</span><span class=p>,</span> <span class=nx>nodeInfo</span> <span class=o>*</span><span class=nx>v1</span><span class=p>.</span><span class=nx>Node</span><span class=p>)</span> <span class=p>(</span><span class=nx>proxyutiliptables</span><span class=p>.</span><span class=nx>LocalTrafficDetector</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>switch</span> <span class=nx>mode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>proxyconfigapi</span><span class=p>.</span><span class=nx>LocalModeClusterCIDR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>config</span><span class=p>.</span><span class=nx>ClusterCIDR</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>klog</span><span class=p>.</span><span class=nf>Warning</span><span class=p>(</span><span class=s>&#34;detect-local-mode set to ClusterCIDR, but no cluster CIDR defined&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>proxyutiliptables</span><span class=p>.</span><span class=nf>NewDetectLocalByCIDR</span><span class=p>(</span><span class=nx>config</span><span class=p>.</span><span class=nx>ClusterCIDR</span><span class=p>,</span> <span class=nx>ipt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>case</span> <span class=nx>proxyconfigapi</span><span class=p>.</span><span class=nx>LocalModeNodeCIDR</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>strings</span><span class=p>.</span><span class=nf>TrimSpace</span><span class=p>(</span><span class=nx>nodeInfo</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>PodCIDR</span><span class=p>))</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>klog</span><span class=p>.</span><span class=nf>Warning</span><span class=p>(</span><span class=s>&#34;detect-local-mode set to NodeCIDR, but no PodCIDR defined at node&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>proxyutiliptables</span><span class=p>.</span><span class=nf>NewDetectLocalByCIDR</span><span class=p>(</span><span class=nx>nodeInfo</span><span class=p>.</span><span class=nx>Spec</span><span class=p>.</span><span class=nx>PodCIDR</span><span class=p>,</span> <span class=nx>ipt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>klog</span><span class=p>.</span><span class=nf>V</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=nf>Info</span><span class=p>(</span><span class=s>&#34;detect-local-mode: &#34;</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>mode</span><span class=p>),</span> <span class=s>&#34; , defaulting to no-op detect-local&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>proxyutiliptables</span><span class=p>.</span><span class=nf>NewNoOpLocalDetector</span><span class=p>(),</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>这里我们以 IPVS 为例，如果开启了 localDetector 在 这个 <em>ipvs proxier</em> 中做了什么? 在代码 <a href=pkg/proxy/ipvs/proxier.go>pkg/proxy/ipvs/proxier.go</a> 可以看到</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>	<span class=k>if</span> <span class=p>!</span><span class=nx>proxier</span><span class=p>.</span><span class=nx>ipsetList</span><span class=p>[</span><span class=nx>kubeClusterIPSet</span><span class=p>].</span><span class=nf>isEmpty</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>args</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>[:</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>			<span class=s>&#34;-A&#34;</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>kubeServicesChain</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=s>&#34;-m&#34;</span><span class=p>,</span> <span class=s>&#34;comment&#34;</span><span class=p>,</span> <span class=s>&#34;--comment&#34;</span><span class=p>,</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>ipsetList</span><span class=p>[</span><span class=nx>kubeClusterIPSet</span><span class=p>].</span><span class=nf>getComment</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>			<span class=s>&#34;-m&#34;</span><span class=p>,</span> <span class=s>&#34;set&#34;</span><span class=p>,</span> <span class=s>&#34;--match-set&#34;</span><span class=p>,</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>ipsetList</span><span class=p>[</span><span class=nx>kubeClusterIPSet</span><span class=p>].</span><span class=nx>Name</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>masqueradeAll</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nf>writeLine</span><span class=p>(</span><span class=nx>proxier</span><span class=p>.</span><span class=nx>natRules</span><span class=p>,</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=s>&#34;dst,dst&#34;</span><span class=p>,</span> <span class=s>&#34;-j&#34;</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>KubeMarkMasqChain</span><span class=p>))</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>localDetector</span><span class=p>.</span><span class=nf>IsImplemented</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// This masquerades off-cluster traffic to a service VIP.  The idea
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// is that you can establish a static route for your Service range,
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// routing to any node, and that node will bridge into the Service
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// for you.  Since that might bounce off-node, we masquerade here.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// If/when we support &#34;Local&#34; policy for VIPs, we should update this.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>writeLine</span><span class=p>(</span><span class=nx>proxier</span><span class=p>.</span><span class=nx>natRules</span><span class=p>,</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>localDetector</span><span class=p>.</span><span class=nf>JumpIfNotLocal</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=s>&#34;dst,dst&#34;</span><span class=p>),</span> <span class=nb>string</span><span class=p>(</span><span class=nx>KubeMarkMasqChain</span><span class=p>))</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Masquerade all OUTPUT traffic coming from a service ip.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// The kube dummy interface has all service VIPs assigned which
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// results in the service VIP being picked as the source IP to reach
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// a VIP. This leads to a connection from VIP:&lt;random port&gt; to
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// VIP:&lt;service port&gt;.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// Always masquerading OUTPUT (node-originating) traffic with a VIP
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// source ip and service port destination fixes the outgoing connections.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>writeLine</span><span class=p>(</span><span class=nx>proxier</span><span class=p>.</span><span class=nx>natRules</span><span class=p>,</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=s>&#34;src,dst&#34;</span><span class=p>,</span> <span class=s>&#34;-j&#34;</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>KubeMarkMasqChain</span><span class=p>))</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>可以看到“不管使用了什么模式，都会更新一条 iptables 规则” 这就代表了使用了什么模式，而这个则被称之为 <em>LocalTrafficDetector</em>，也就是本地流量的检测，那我们看一下这个做了什么。</p><p>在使用 IPVS 的日志中，可以看到这样一条规则，这个是来自集群外部的 IP 去访问集群 CLUSTER IP (<em>KUBE-CLUSTER-IP</em>，即集群内所有 service IP) 时, 将非集群 IP 地址，转换为集群内的 IP 地址 (做源地址转换)</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>DetectLocalByCIDR <span class=o>(</span>10.244.0.0/16<span class=o>)]</span> Jump Not Local: <span class=o>[</span>-A KUBE-SERVICES -m comment --comment <span class=s2>&#34;Kubernetes service cluster ip + port for masquerade purpose&#34;</span> -m <span class=nb>set</span> --match-set KUBE-CLUSTER-IP dst,dst ! -s 10.244.0.0/16 -j KUBE-MARK-MASQ<span class=o>]</span></span></span></code></pre></td></tr></table></div></div></div></div><p>而这个步骤分布在所有模式下 (iptables&amp;ipvs)，这里还是没说到两个概念 <em><strong>LocalMode</strong></em> 和 <em><strong>ProxyMode</strong></em>，实际上这两个模式的区别为：</p><ul><li><strong>LocalMode</strong>：集群 IP 伪装采用 <em>ClusterCIDR</em> 还是 <em>NodeCIDR</em>，<em>ClusterCIDR</em> 是使用集群 Pod IP 的地址段 (IP Range)，而 <em>LocalCIDR</em> 只仅仅使用被分配给该 kubernetes node 上的 Pod 做地址伪装</li><li><strong>ProxyMode</strong>：和 <em><strong>LocalMode</strong></em> 没有任何关系，是 <em>kube-proxy</em> 在运行时使用什么为集群 service 做代理，例如 iptables, ipvs ，而在这些模式下将采用什么 <em>LocalMode</em> 为集群外部地址作伪装，大概分为三种类型：<ul><li>为来自集群外部地址 (<em>cluster-off</em>)：所有非 Pod 地址的请求执行跳转 (<em>KUBE-POSTROUTING</em>)</li><li>没有操作 ：在非 iptables/ipvs 模式下，不做伪装</li><li>masqueradeAll：为所有访问 cluster ip 的地址做伪装</li></ul></li></ul><h2 id=clustercidr-原理>ClusterCIDR 原理<a hidden class=anchor aria-hidden=true href=#clustercidr-原理>#</a></h2><p><em>kube-proxy</em> 为 kube node 上生成一些 NAT 规则，如下所示</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>-A KUBE-FIREWALL -j KUBE-MARK-DROP
</span></span><span class=line><span class=cl>-A KUBE-LOAD-BALANCER -j KUBE-MARK-MASQ
</span></span><span class=line><span class=cl>-A KUBE-MARK-MASQ -j MARK --set-xmark 0x4000/0x4000
</span></span><span class=line><span class=cl>-A KUBE-NODE-PORT -p tcp -m comment --comment <span class=s2>&#34;Kubernetes nodeport TCP port for masquerade purpose&#34;</span> -m <span class=nb>set</span> --match-set KUBE-NODE-PORT-TCP dst -j KUBE-MARK-MASQ
</span></span><span class=line><span class=cl>-A KUBE-POSTROUTING -m comment --comment <span class=s2>&#34;Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose&#34;</span> -m <span class=nb>set</span> --match-set KUBE-LOOP-BACK dst,dst,src -j MASQUERADE
</span></span><span class=line><span class=cl>-A KUBE-POSTROUTING -m mark ! --mark 0x4000/0x4000 -j RETURN
</span></span><span class=line><span class=cl>-A KUBE-POSTROUTING -j MARK --set-xmark 0x4000/0x0
</span></span><span class=line><span class=cl>-A KUBE-POSTROUTING -m comment --comment <span class=s2>&#34;kubernetes service traffic requiring SNAT&#34;</span> -j MASQUERADE
</span></span><span class=line><span class=cl>-A KUBE-SERVICES ! -s 10.244.0.0/16 -m comment --comment <span class=s2>&#34;Kubernetes service cluster ip + port for masquerade purpose&#34;</span> -m <span class=nb>set</span> --match-set KUBE-CLUSTER-IP dst,dst -j KUBE-MARK-MASQ
</span></span><span class=line><span class=cl>-A KUBE-SERVICES -m addrtype --dst-type LOCAL -j KUBE-NODE-PORT
</span></span><span class=line><span class=cl>-A KUBE-SERVICES -m <span class=nb>set</span> --match-set KUBE-CLUSTER-IP dst,dst -j ACCEPT</span></span></code></pre></td></tr></table></div></div></div></div><p>可以看到这里做了几个链，在 <em>KUBE-SERVICES</em> 链中指明了非来自 ClusterCIDR 的 IP 都做一个，并且访问的目的地址是 <em>KUBE-CLUSTER-IP</em> (ipset 里配置的地址) 那么将跳转到 <em>KUBE-MARK-MASQ</em> 链做一个 <code>--set-xmark 0x4000/0x4000</code> ，而在 <em>KUBE-POSTROUTING</em> 中对没有被标记 <code>0x4000/0x4000</code> 的操作不做处理</p><p>具体来说，<code>-A KUBE-NODE-PORT -p tcp -m comment --comment "Kubernetes nodeport TCP port for masquerade purpose" -m set --match-set KUBE-NODE-PORT-TCP dst -j KUBE-MARK-MASQ</code> 做了如下操作：</p><ul><li><code>-A KUBE-SERVICES</code>：将这条规则附加到名为<code>KUBE-SERVICES</code>的iptables链。</li><li><code>! -s 10.244.0.0/16</code>：排除源IP地址为<code>10.244.0.0/16</code>的流量（即来自Kubernetes服务集群IP的流量）。</li><li><code>-m comment --comment "Kubernetes service cluster ip + port for masquerade purpose"</code>：添加一条注释，说明这个规则的用途。</li><li><code>-m set --match-set KUBE-CLUSTER-IP dst,dst</code>：使用IP集合<code>KUBE-CLUSTER-IP</code>来匹配目标IP地址和目标端口。</li><li><code>-j KUBE-MARK-MASQ</code>：如果流量匹配了前面的条件，将流量传递到名为<code>KUBE-MARK-MASQ</code>的目标。</li></ul><blockquote><p><code>iptables -j RETURN</code> 是用于iptables规则中的一个目标动作，它不是用于拒绝或接受数据包的动作，而是用于从当前规则链中返回（返回到调用链）的动作。</p><p>具体来说，当规则链中的数据包被标记为 <code>RETURN</code> 时，它们将不再受到当前链中后续规则的影响，而会立即返回到调用链，以便继续进行后续规则的处理。这通常用于某些高级设置，例如在自定义规则链中执行特定的操作后返回到主要的防火墙链。</p></blockquote><p>从代码中可以看到，对应执行 jump 的操作的链就是 <em>KUBE-MARK-MASQ</em></p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>localDetector</span><span class=p>.</span><span class=nf>IsImplemented</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// This masquerades off-cluster traffic to a service VIP.  The idea
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// is that you can establish a static route for your Service range,
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// routing to any node, and that node will bridge into the Service
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// for you.  Since that might bounce off-node, we masquerade here.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// If/when we support &#34;Local&#34; policy for VIPs, we should update this.
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=nf>writeLine</span><span class=p>(</span><span class=nx>proxier</span><span class=p>.</span><span class=nx>natRules</span><span class=p>,</span> <span class=nx>proxier</span><span class=p>.</span><span class=nx>localDetector</span><span class=p>.</span><span class=nf>JumpIfNotLocal</span><span class=p>(</span><span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=s>&#34;dst,dst&#34;</span><span class=p>),</span> <span class=nb>string</span><span class=p>(</span><span class=nx>KubeMarkMasqChain</span><span class=p>))</span><span class=o>...</span><span class=p>)</span>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// KubeMarkMasqChain is the mark-for-masquerade chain
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>KubeMarkMasqChain</span> <span class=nx>utiliptables</span><span class=p>.</span><span class=nx>Chain</span> <span class=p>=</span> <span class=s>&#34;KUBE-MARK-MASQ&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=c1>// 具体拼接的就是 -j 链名的操作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>d</span> <span class=o>*</span><span class=nx>detectLocalByCIDR</span><span class=p>)</span> <span class=nf>JumpIfNotLocal</span><span class=p>(</span><span class=nx>args</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>toChain</span> <span class=kt>string</span><span class=p>)</span> <span class=p>[]</span><span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>line</span> <span class=o>:=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>args</span><span class=p>,</span> <span class=s>&#34;!&#34;</span><span class=p>,</span> <span class=s>&#34;-s&#34;</span><span class=p>,</span> <span class=nx>d</span><span class=p>.</span><span class=nx>cidr</span><span class=p>,</span> <span class=s>&#34;-j&#34;</span><span class=p>,</span> <span class=nx>toChain</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>klog</span><span class=p>.</span><span class=nf>V</span><span class=p>(</span><span class=mi>4</span><span class=p>).</span><span class=nf>Info</span><span class=p>(</span><span class=s>&#34;[DetectLocalByCIDR (&#34;</span><span class=p>,</span> <span class=nx>d</span><span class=p>.</span><span class=nx>cidr</span><span class=p>,</span> <span class=s>&#34;)]&#34;</span><span class=p>,</span> <span class=s>&#34; Jump Not Local: &#34;</span><span class=p>,</span> <span class=nx>line</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>line</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>继续往下 <em>KUBE-POSTROUTING</em> 可以看到对应伪装是一个动态的源地址改造，而 <em>RETURN</em> 则不是被标记的请求</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>Chain</span> <span class=nx>KUBE</span><span class=o>-</span><span class=nf>POSTROUTING</span> <span class=p>(</span><span class=mi>1</span> <span class=nx>references</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>target</span>     <span class=nx>prot</span> <span class=nx>opt</span> <span class=nx>source</span>               <span class=nx>destination</span>         
</span></span><span class=line><span class=cl><span class=nx>MASQUERADE</span>  <span class=nx>all</span>  <span class=o>--</span>  <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=cm>/* Kubernetes endpoints dst ip:port, source ip for solving hairpin purpose */</span> <span class=nx>match</span><span class=o>-</span><span class=nx>set</span> <span class=nx>KUBE</span><span class=o>-</span><span class=nx>LOOP</span><span class=o>-</span><span class=nx>BACK</span> <span class=nx>dst</span><span class=p>,</span><span class=nx>dst</span><span class=p>,</span><span class=nx>src</span>
</span></span><span class=line><span class=cl><span class=nx>RETURN</span>     <span class=nx>all</span>  <span class=o>--</span>  <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=nx>mark</span> <span class=nx>match</span> <span class=p>!</span> <span class=mh>0x4000</span><span class=o>/</span><span class=mh>0x4000</span>
</span></span><span class=line><span class=cl><span class=nx>MARK</span>       <span class=nx>all</span>  <span class=o>--</span>  <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=nx>MARK</span> <span class=nx>xor</span> <span class=mh>0x4000</span>
</span></span><span class=line><span class=cl><span class=nx>MASQUERADE</span>  <span class=nx>all</span>  <span class=o>--</span>  <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=mf>0.0.0.0</span><span class=o>/</span><span class=mi>0</span>            <span class=cm>/* kubernetes service traffic requiring SNAT */</span></span></span></code></pre></td></tr></table></div></div></div></div><p>这整体就是 ClusterCIDR 在 <em>kube-proxy</em> 中的应用，换句话说还需要关注一个 LocalCIDR</p></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：kube-proxy参数ClusterCIDR做什么</p><p>文章链接：<a href=http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/ target=_blank>http://localhost:1313/2023/09/ch26-kube-proxy-clustercidr/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2023/03/ch24-kube-proxy-performance/><span>kube-proxy如何保证规则的一致性</span></a></li><li><a href=/2023/02/ch23-extend-kube-proxy/><span>深入理解Kubernetes service - 如何扩展现有的kube-proxy架构？</span></a></li><li><a href=/2023/02/ch19-kube-proxy-code/><span>深入理解Kubernetes service - kube-proxy架构分析</span></a></li><li><a href=/2023/08/ch29-volumemanager/><span>深入理解kubelet - VolumeManager源码解析</span></a></li><li><a href=/2023/02/ch18-endpointslices/><span>深入理解Kubernetes service - EndpointSlices做了什么？</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/kubernetes/>Kubernetes</a></li><li><a href=http://localhost:1313/tags/kubernetes-develop/>Kubernetes Develop</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/2023/09/05-2-bucket-policy/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>Ceph对象存储 - 桶策略 Bucket Policy</span>
</a><a class=next href=http://localhost:1313/2023/09/11-1-ceph-common-cmd/><span class=title></span>
<span>ceph常用命令&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/ch26 kube-proxy clusterCIDR","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>