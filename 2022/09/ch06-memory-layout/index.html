<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch06 内存布局 | Cylon's Collection</title>
<meta name=keywords content="C"><meta name=description content="Overview 在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 x.out 文件）这是一个可执行的链接文件( Executable and linking format)。在执行时这些不组织成几部分，包含不同的内存分段 (segments)
ELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。
可以使用 size {ELF_file} 查看被分配的每个段的大小（Linux操作系统）；
dec 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示 text 段是存储可执行命令的段 data 段包含所有初始化数据，全局与静态变量 BSS 段包含未初始化数据 bash 1 2 3 $ size 1 text data bss dec hex filename 1843 584 8 2435 983 1 Memory Layout in C [1] 在C语言中内存布局模型包含六个部分
命令行参数 (Command Line Arguments) 栈 (Stack) 堆 (Heap) 未初始化数据段 (Uninitialized Data Segment BSS) 已初始化数据段 (Initialized Data Segment) 文本/代码段 (Text/Code Segment) 这6部分结构可以再划分为两种类型："><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2022/09/ch06-memory-layout/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2022/09/ch06-memory-layout/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script defer src=https://cdn.staticfile.net/jquery/3.5.1/jquery.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css><script defer src=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js></script><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><meta property="og:title" content="ch06 内存布局"><meta property="og:description" content="Overview 在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 x.out 文件）这是一个可执行的链接文件( Executable and linking format)。在执行时这些不组织成几部分，包含不同的内存分段 (segments)
ELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。
可以使用 size {ELF_file} 查看被分配的每个段的大小（Linux操作系统）；
dec 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示 text 段是存储可执行命令的段 data 段包含所有初始化数据，全局与静态变量 BSS 段包含未初始化数据 bash 1 2 3 $ size 1 text data bss dec hex filename 1843 584 8 2435 983 1 Memory Layout in C [1] 在C语言中内存布局模型包含六个部分
命令行参数 (Command Line Arguments) 栈 (Stack) 堆 (Heap) 未初始化数据段 (Uninitialized Data Segment BSS) 已初始化数据段 (Initialized Data Segment) 文本/代码段 (Text/Code Segment) 这6部分结构可以再划分为两种类型："><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2022/09/ch06-memory-layout/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-28T00:00:00+00:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch06 内存布局"><meta name=twitter:description content="Overview 在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 x.out 文件）这是一个可执行的链接文件( Executable and linking format)。在执行时这些不组织成几部分，包含不同的内存分段 (segments)
ELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。
可以使用 size {ELF_file} 查看被分配的每个段的大小（Linux操作系统）；
dec 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示 text 段是存储可执行命令的段 data 段包含所有初始化数据，全局与静态变量 BSS 段包含未初始化数据 bash 1 2 3 $ size 1 text data bss dec hex filename 1843 584 8 2435 983 1 Memory Layout in C [1] 在C语言中内存布局模型包含六个部分
命令行参数 (Command Line Arguments) 栈 (Stack) 堆 (Heap) 未初始化数据段 (Uninitialized Data Segment BSS) 已初始化数据段 (Initialized Data Segment) 文本/代码段 (Text/Code Segment) 这6部分结构可以再划分为两种类型："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"ch06 内存布局","item":"https://www.oomkill.com/2022/09/ch06-memory-layout/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch06 内存布局","name":"ch06 内存布局","description":"Overview 在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 x.out 文件）这是一个可执行的链接文件( Executable and linking format)。在执行时这些不组织成几部分，包含不同的内存分段 (segments)\nELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。\n可以使用 size {ELF_file} 查看被分配的每个段的大小（Linux操作系统）；\ndec 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示 text 段是存储可执行命令的段 data 段包含所有初始化数据，全局与静态变量 BSS 段包含未初始化数据 bash 1 2 3 $ size 1 text data bss dec hex filename 1843 584 8 2435 983 1 Memory Layout in C [1] 在C语言中内存布局模型包含六个部分\n命令行参数 (Command Line Arguments) 栈 (Stack) 堆 (Heap) 未初始化数据段 (Uninitialized Data Segment BSS) 已初始化数据段 (Initialized Data Segment) 文本/代码段 (Text/Code Segment) 这6部分结构可以再划分为两种类型：","keywords":["C"],"articleBody":"Overview 在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 x.out 文件）这是一个可执行的链接文件( Executable and linking format)。在执行时这些不组织成几部分，包含不同的内存分段 (segments)\nELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。\n可以使用 size {ELF_file} 查看被分配的每个段的大小（Linux操作系统）；\ndec 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示 text 段是存储可执行命令的段 data 段包含所有初始化数据，全局与静态变量 BSS 段包含未初始化数据 bash 1 2 3 $ size 1 text data bss dec hex filename 1843 584 8 2435 983 1 Memory Layout in C [1] 在C语言中内存布局模型包含六个部分\n命令行参数 (Command Line Arguments) 栈 (Stack) 堆 (Heap) 未初始化数据段 (Uninitialized Data Segment BSS) 已初始化数据段 (Initialized Data Segment) 文本/代码段 (Text/Code Segment) 这6部分结构可以再划分为两种类型：\n静态内存结构 (Static Memory Layout)：包含代码段, 数据段 动态内存结构 (Dynamic Memory Layout)：包含栈, 堆 通过Overview中可以看到可以执行文件包含一些段，而缺少一些段，这部分是由运行时构建出来的。\n整个C程序的内存布局为下图所示\n图：memory layout C Source：https://hackthedeveloper.com/memory-layout-c-program/\n静态内存布局 静态内存布局中，包含代码段(Code Segment)，数据段(Data Segment)；数据段中又分为已初始化段，通常称为数据分段(DS)，未初始化分段(BSS)。\n代码段 代码段包含可执行的机器指令，这部分包含了程序的逻辑，为了防止堆, 栈的溢出，代码段在内存结构中处于布局中最下方。而且为了防止指令被修改，这部分是只读的。\n已编译二进制文件 只读段，防止程序被修改 可共享 可以通过 objdump -S 来导出代码段中存的汇编代码\n已初始化数据段 所有已初始化的静态变量和全局变量都被存储在DS中，该段具有写权限，程序可以在运行时修改该段中变量的值。\n定义一个C程序，通过size观看其data段的大小\nc 1 2 3 4 5 #include char main() { return '1'; } size输出为528\nc 1 2 3 $ size 1 text data bss dec hex filename 1358 528 8 1894 766 1 通过增加两个变量，一个全局变量一个静态变量，观看编译后可执行文件data段的大小与之前大小相比较\nc 1 2 3 4 5 6 7 8 9 #include static int a = 10; // int 类型占4byte char b = 'a'; // char 类型占1byte char main() { return '1'; } size查看data输出值为533 与之前 528 增加 5 bytes，与定义的类型相符合\nc 1 2 3 size 1 text data bss dec hex filename 1358 533 3 1894 766 1 未初始化数据段 未初始化数据段包含如下内容\n未初始化的全局和静态变量 初始化为0或空指针的变量 接着上述例子，添加两个变量，一个不初始化值，一个初始化为0\nc 1 2 3 4 5 6 7 8 #include int a; static int b=0; char main() { return '1'; } 通过 size 命令可以看出，这些都被分配到 BSS 部分\nc 1 2 3 $ size 1 text data bss dec hex filename 1358 528 16 1902 76e 1 对于初始化段与未初始化段和只读数据段 (.rodata) 都会被分配到数据段中\n动态内存布局 动态内存是指程序运行时创建的的内存\nheap 堆段是由BSS往上更高部分动态内存分配的段，heap段具有以下特点\n程序运行可以没有heap段\nheap位于在BSS之上stack之下，与stack成反方向增长和减少\n运行时分配内存\n由函数 malloc() , calloc() , free() 等函数管理\nheap段内存由进程中共享库和动态模块等共享内存\nheap对于stack来说，最大的特点就是没有自动的内存管理功能，所有内存的申请和销毁都是通过开发者自行定义的，C中的Glibc API 提供了申请和销毁heap内存的功能。\n函数 malloc() / calloc() 用户空间实现的库函数，用于申请heap内存，可用于windows/linux 函数 free() 释放由 malloc() / calloc() 申请的内存 brk() / sbrk() 是linux下的系统调用，在内核空间实现的库函数 下列代码为heap内存分配示例\nc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include #include int func() { int a = 10; int *aptr = \u0026a; int *ptr = (int *)malloc(sizeof(int)); *ptr = 20; printf(\"Heap Memory Value = %d\\n\", *ptr); printf(\"Pointing in Stack = %d\\n\", *aptr); free(ptr); } int main() { func(); return 0; } 下图为上述代码的图形化布局，通过申明一个指针变量 *ptr 指向了通过函数 malloc() 申请的 heap内存\nNotes: heap变量的存储实际存储时在物理内存上，而heap,stack.. 都是虚拟内存中某个进程的地址空间，通过MMU将其转为物理地址进行读写。[2]\n图：heap layout of C Source：https://hackthedeveloper.com/memory-layout-c-program/\nstack stack是与heap相邻的地区，并与heap以反方向增长，当遇到heap时表示可用内存耗尽。stack段具有如下特点：\n程序运行必须拥有的内存段 以先进先出 (LIFO) 的顺序添加和移除数据 包含以下内容 所有局部变量 函数参数（逆序） 函数调用的返回地址 基于指针的函数调用 stack段自动分配和销毁内存，开发者无法控制stack段内存 当函数执行完函数局部变量会从stack中弹出释放，也就是局部变量的作用域范围 例如\nc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include int sum(int a, int b) { return a + b; } float avg(int a, int b) { int s = sum(a, b); return (float)s / 2; } int main() { int a = 10; int b = 20; printf(\"Average of %d, %d = %f\\n\", a, b, avg(a, b)); return 0; } 下图是上述代码对于stack内存段执行时的说明，如图所示，整个如下：\n当main函数被执行时会被压入stack中 main函数会调用avg函数求平均值，此时avg被压入stack avg执行sum函数，sum被压入stack 此时正在执行的帧时位于最顶层的，被称为基指针 (base pointer) 栈帧指向stack段顶部，存储stack最顶部地址 s是一个指针保存着sum的位置，即sum函数的结尾，依次类推 图：stack layout of C Source：https://hackthedeveloper.com/memory-layout-c-program/\n栈异常 栈异常常见异常情况有\n栈溢出 (Stack Overflow)：栈溢出是指超出stack的大小，例如很长的函数调用，造成该错误原因如下： 递归函数调用 大数据声明 栈毁坏 (Stack Corruption)：是指stack段中的某些内存位置由于错误的编码而被无意访问，导致内存位置发生变化。由于数据毁坏位置发生在Stack段因此被称为 “Stack Corruption” [4] 例如下面代码模拟了一个 SC 异常\nc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include #include int copy(char *argv) { char name[10]; strcpy(name, argv); } int main(int argc, char **argv) { copy(argv[1]); printf(\"Exit\\n\"); return 0; } 输出结果为：可以看到当char大小大于10，会覆盖其他stack位置，使程序无法继续执行从而输出“Exit”。\nbash 1 2 3 4 5 $ gcc .\\1.c -o 1.exe $ .\\1.exe testargs Exit $ .\\1.exe testargs000000000000000000 Stack VS Heap [3] Stack与Heap都存储与RAM中 Stack自动管理内存，而Heap则需要手动申请和取消 Stack分配速度快（一段程序启动时预先分配好的连续内存），而Heap分配速度较慢（动态分配的非连续内存） Stack在使用是会出现溢出问题，而Heap可以分配大数据 Stack常见错误为内存溢出，Heap常见错误为内存泄漏 Stack 和 Heap 的一些常见问题\n默认Stack大小为多少：Linux中通过 ulimit -s 可以查看 默认的Heap大小为多少：没有默认的Heap大小，在32位操作系统中，每个进程可以看到连续的4GB空间，这个空间没有被映射到物理地址中，而是根据使用情况进行映射，在64位操作系统中，这个空间会更大 stack和heap存放在哪里？：在虚拟内存中，通过MMU进行映射到物理地址上 如何手动配置heap？：可以使用 ulimit -v 设置虚拟内存的大小 函数调用栈 函数调用与栈有不可密切的关系，在一个函数调用过程所需要的信息一般包括以下几个方面：\n函数返回地址 函数参数 变量 保存的上下文 ：包括在函数调用前后需要保持不变的寄存器。 当在调用一个函数时，控制流从调用函数转移到被调用函数。如下列代码在运行时产生了如下几项疑问：\n函数参数和用于调用函数的变量的区别 为什么具有多个相同名称但位于不同函数中的变量可以共存？ 为什么函数doing有一定的限制？ 为什么未初始化的局部变量可能包含任何值？ c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include int mogrify(int a, int b){ int tmp = a*4 - b / 3; return tmp; // (mogrify函数返回值) } double truly_half(int x){ double tmp = x / 2.0; return tmp; } int main(){ int a = 7, y = 17; int mog = mogrify(a,y); // 调用mogrify printf(\"Done with mogrify\\n\"); double x = truly_half(y); // 调用truly_half printf(\"Done with truly_half\\n\"); a = mogrify(x, mog); // 第二次调用mogrify printf(\"Results: %d %lf\\n\",mog,x); // (last_print) return 0; // (main函数返回) } 输出\nbash 1 2 3 4 5 lila [stack-demo-code]% gcc simple_calls.c lila [stack-demo-code]% ./a.out Done with mogrify Done with truly_half Results: 23 8.500000 栈行为 [4] main函数的调用\n上述代码调用stack发生的变化，程序从第一行的 main() 函数开始。 main() 有 3 个局部变量：a,y 是int，x 是double。栈的初始状态如下表（其中地址栏为虚构地址）\nMethod Line Var Value Addr Notes main() 12行开始 a ? 1024 y ? 1028 mod ? 1032 x ? 1036 表1\nmain函数的第一行被执行\n在运行 main（从第 12 行开始）时，会为所有局部变量分配了栈空间，但没有定义值（随机被初始化）在向下移动时，为局部变量a,y 定义了值。\nMethod Line Var Value Addr Notes main() 13行 a 7 1024 y 17 1028 mod ? 1032 x ? 1036 表2\nmogrify()被调用 在第13行时产生一个函数调用，main函数被暂停，至函数 mogrify 完成。函数调用使一个栈push到调用栈，如下表所示。\nMethod Line Var Value Addr Notes main() 13行 a 7 1024 y 17 1028 mod ? 1032 x ? 1036 mogrify() 4行 a 7 1044 b 17 1048 tmp ? 1052 表3\nmogrify()第一行被执行 此时从 mogrify 的第一行开始，完成后返回至 main 函数，将在第 13 行继续执行。表3中由于没有执行到tmp，所以还没被分配值。\n表4是 完成mogrify 函数执行，局部变量 tmp 被赋值。\nMethod Line Var Value Addr Notes main() 13行 a 7 1024 y 17 1028 mod ? 1032 x ? 1036 mogrify() 5行 a 7 1044 b 17 1048 tmp 23 1052 表4\nmogrify()函数返回\nmogrify函数返回在这里有两个作用：\n返回值被存储在调用函数位置：main函数 （第 13 行）变量 mog 中。 弹出栈帧，从调用堆栈中移除。 此时状态为表5\nMethod Line Var Value Addr Notes ain() | 4 | | | 024 | | | | | 7 | 028 | | | | od | 3 | 032 | | | | | | 036 | | 表5\n执行Printf()\nMethod Line Var Value Addr Notes ain() | 3行 | | | 024 | | | | | 7 | 028 | | | | od | | 032 | | | | | | 036 | | rintf() | ib call | ormat | | 044 | ointer | 表6\nprintf()也是作为函数，将另一个栈帧推入栈中，并为其参数和局部变量预留空间。 printf()是一个可变参数的函数。\n第二次函数调用\n从第 16 行起，调用了函数 truly_half 此时会将一个栈帧推入调用栈。此时状态如表5相同\n调用函数truly_half()\n当函数 truly_half() 被调用，对应的栈帧被push到main的栈帧下，表7中所示的地址（局部变量）与之前 mogrify() 函数是相同的地址，这是因为栈中的空间是可重用的。\nMethod Line Var Value Addr Notes main() | 16 | a | 7 | 024 | | | | y | 17 | 028 | | | | og | 23 | 032 | | | | x | ? | 036 | | truly_half()` | 8 | x | 17 | 044 | | | | mp | ? | 048 | | 表7\ntruly_half()被执行\n执行 truly_half 函数的第二行返回计算后的值来赋值给 main 中的局部变量 x，并从调用栈中弹出 truly_half 的栈帧，如表8所示\nMethod Line Var Value Addr Notes main() | 16 | a | 7 | 024 | | | | y | 17 | 028 | | | | og | 23 | 032 | | | | x | ? | 036 | | truly_half()` | 9 | x | 17 | 044 | | | | mp | 8.5 | 048 | | 表8\n返回main函数控制流\nmain函数中会打印这个值，此时内存结构为表8所示\nMethod Line Var Value Addr Notes main() 17 a 7 1024 y 17 1028 mog 23 1032 x 8.5 1036 表9\n再次调用函数mogrify()\n此时，main函数在第19行暂停，在 mogrify() 第一行开始。\n需要注意的一点是 mogrify() 参数类型是int，这里会强制转换 8 字节double 为一个 4 字节的int，小数点被省去。如表10所示\nMethod Line Var Value Addr Notes main() | 19 | a | 7 | 024 | | | | y | 17 | 028 | | | | og | 23 | 032 | | | | x | 8.5 | 036 | double | ogrify() | 4 | a | 8 | 044 | onvert to int | | | b | 23 | 048 | | | | mp | ? | 052 | | 表10\nmogrify()被执行后：\nMethod Line Var Value Addr Notes main() | 19 | a | 7 | 024 | | | | y | 17 | 028 | | | | og | 23 | 032 | | | | x | 8.5 | 036 | double | ogrify() | 5 | a | 8 | 044 | onvert to int | | | b | 23 | 048 | | | | mp | 25 | 052 | | 表11\nmogrify()被执行后： mogrify() 执行完成后将结果分配给 main 函数中的局部变量 a 并弹出栈帧。此时数据如表12所示\nMethod Line Var Value Addr Notes ain() | 19 | a | 25 | 024 | 的值被覆盖 | | | y | 17 | 028 | | | | og | 23 | 032 | | | | x | 8.5 | 036 | double | 表12\n至此返回最开始的部分，一个函数的过程包含四个部分 (function call stack)\n函数调用栈 动态分配内存区域 (heap) 存储全局变量的区域 程序允许的实际代码(data text) 栈帧(stack frame) 指的是：栈内存中单个函数调用（正在允许的函数）的一部分内存块，（参数和局部变量）。编译器在编译期间确定函数的栈帧大小。栈上的栈帧通常与尚未返回的函数一样多。\n栈行为：\npushing ：当函数被调用时，新的帧被推到调用堆栈的 “顶部”。 popping：当函数执行完成，会将控制权返回给调用它的函数。并将函数关联的帧从栈顶部弹出。 溢出：如果在返回之前调用了太多函数（例如递归），程序可能会耗尽栈空间。\n关于栈的总结 C语言的执行模型 C 语言是过程式编程，不支持在函数之外编写代码 C 语言的执行模型是指函数调用工作原理（函数调用栈行为分析的）及函数工作原理。 C 语言使用 ”栈“ 数据结构来实现函数与函数调用。 关于函数调用栈 函数调用栈是动态数据结构，用于参数传递、局部变量分配、保存调用的返回地址、保存寄存器以供恢复。\n栈向下增长，从较高的地址开始，向较低的地址。\nPush 将栈帧添加到栈，Pop从栈中弹出\n栈帧的增长在x86架构下是4字节：\n假设栈指位于1000，此时push一个函数，则该栈指指向996(1000 - 4) 假设此时弹出函数，那么会从996处从栈中弹出，并递增并指向地址1000 调用惯例 [6] 调用惯例 (Calling Conventions) 是指函数调用的标准化方法，当在函数调用时例如，如何将参数传递给子程序？子程序可以覆盖寄存器中的值，还是调用者希望保留寄存器内容？子程序中的局部变量应该存储在哪里？函数应该如何返回结果？\nC语言中调用惯例在很大程度上使用了基于硬件支持栈。对C中调用惯例的理解就需要对函数执行模型的理解（应确保完全理解 push、pop、call 和 ret 指令的行为）。在此调用约定中，子程序参数在stack上传递。寄存器保存在stack上，子程序使用的局部变量放在stack上的内存中。\ncdecl (c declaration)：C/C++默认调用约定，调用时按照从右向左的参数入\nc 1 2 3 4 5 push arg3 ; rightmost argument push arg2 push arg1 ; leftmost argument call f add esp, 12 ; 12 = 3 arguments each being 4 bytes fastcall：通过寄存器传递值（从右到左）\nthiscall：指针类型被存储在寄存器 ecx ，其他类型放置堆栈\nReference [1] memory layout c program\n[2] stack and heap locations in ram\n[3] what and where are the stack and heap\n[4] understanding stack corruption c\n[5] static\n[6] calling convention\n","wordCount":"1459","inLanguage":"zh","datePublished":"2022-09-28T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2022/09/ch06-memory-layout/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ch06 内存布局</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2022-09-28</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>1459 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>7 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/c/>#C</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#overview aria-label=Overview>Overview</a><li><a href=#memory-layout-in-c-supa-href11asup aria-label="Memory Layout in C [1]">Memory Layout in C <sup><a href=#1>[1]</a></sup></a><li><a href=#%e9%9d%99%e6%80%81%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80 aria-label=静态内存布局>静态内存布局</a><ul><li><a href=#%e4%bb%a3%e7%a0%81%e6%ae%b5 aria-label=代码段>代码段</a><li><a href=#%e5%b7%b2%e5%88%9d%e5%a7%8b%e5%8c%96%e6%95%b0%e6%8d%ae%e6%ae%b5 aria-label=已初始化数据段>已初始化数据段</a><li><a href=#%e6%9c%aa%e5%88%9d%e5%a7%8b%e5%8c%96%e6%95%b0%e6%8d%ae%e6%ae%b5 aria-label=未初始化数据段>未初始化数据段</a></ul><li><a href=#%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80 aria-label=动态内存布局>动态内存布局</a><ul><li><a href=#heap aria-label=heap>heap</a><li><a href=#stack aria-label=stack>stack</a><ul><li><a href=#%e6%a0%88%e5%bc%82%e5%b8%b8 aria-label=栈异常>栈异常</a></ul><li><a href=#stack-vs-heap-supa-href33asup aria-label="Stack VS Heap [3]">Stack VS Heap <sup><a href=#3>[3]</a></sup></a></ul><li><a href=#%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88 aria-label=函数调用栈>函数调用栈</a><ul><li><a href=#%e6%a0%88%e8%a1%8c%e4%b8%ba-supa-href44asup aria-label="栈行为 [4]">栈行为 <sup><a href=#4>[4]</a></sup></a><li><a href=#%e5%85%b3%e4%ba%8e%e6%a0%88%e7%9a%84%e6%80%bb%e7%bb%93 aria-label=关于栈的总结>关于栈的总结</a><ul><li><a href=#c%e8%af%ad%e8%a8%80%e7%9a%84%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b aria-label=C语言的执行模型>C语言的执行模型</a><li><a href=#%e5%85%b3%e4%ba%8e%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e6%a0%88 aria-label=关于函数调用栈>关于函数调用栈</a></ul><li><a href=#%e8%b0%83%e7%94%a8%e6%83%af%e4%be%8b-supa-href66asup aria-label="调用惯例 [6]">调用惯例 <sup><a href=#6>[6]</a></sup></a></ul><li><a href=#reference aria-label=Reference>Reference</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h2><p>在编写程序时包含任意指令如，已初始化和未初始化数据，局部变量，函数等都是用于动态分配内存的指令。当程序编译后（默认生成 <code>x.out</code> 文件）这是一个可执行的链接文件( <em><strong>Executable and linking format</strong></em>)。在执行时这些不组织成几部分，包含不同的内存分段 (<em><strong>segments</strong></em>)</p><blockquote><p>ELF：这是系统中标准二进制格式，其一些功能包含，动态链接，动态加载，对程序运行时控制。</p></blockquote><p>可以使用 <code>size {ELF_file}</code> 查看被分配的每个段的大小（Linux操作系统）；</p><ul><li><code>dec</code> 列给出的是这个程序 text + data + bss 段的总大小，用十进制表示</li><li><code>text</code> 段是存储可执行命令的段</li><li><code>data</code> 段包含所有初始化数据，全局与静态变量</li><li><code>BSS</code> 段包含未初始化数据</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ size <span class=m>1</span> 
</span></span><span class=line><span class=cl>   text    data     bss     dec     hex filename
</span></span><span class=line><span class=cl>   <span class=m>1843</span>     <span class=m>584</span>       <span class=m>8</span>    <span class=m>2435</span>     <span class=m>983</span> <span class=m>1</span></span></span></code></pre></td></tr></table></div></div></div></div><h2 id=memory-layout-in-c-supa-href11asup>Memory Layout in C <sup><a href=#1>[1]</a></sup><a hidden class=anchor aria-hidden=true href=#memory-layout-in-c-supa-href11asup>#</a></h2><p>在C语言中内存布局模型包含六个部分</p><ul><li>命令行参数 (<em><strong>Command Line Arguments</strong></em>)</li><li>栈 (<em><strong>Stack</strong></em>)</li><li>堆 (<em><strong>Heap</strong></em>)</li><li>未初始化数据段 (<em><strong>Uninitialized Data Segment BSS</strong></em>)</li><li>已初始化数据段 (<em><strong>Initialized Data Segment</strong></em>)</li><li>文本/代码段 (<em><strong>Text/Code Segment</strong></em>)</li></ul><p>这6部分结构可以再划分为两种类型：</p><ul><li>静态内存结构 (<em><strong>Static Memory Layout</strong></em>)：包含代码段, 数据段</li><li>动态内存结构 (<em><strong>Dynamic Memory Layout</strong></em>)：包含栈, 堆</li></ul><p>通过Overview中可以看到可以执行文件包含一些段，而缺少一些段，这部分是由运行时构建出来的。</p><p>整个C程序的内存布局为下图所示</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/Memory-layout.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/Memory-layout.png#center alt=C程序的内存布局 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><center>图：memory layout C</center><center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br><h2 id=静态内存布局>静态内存布局<a hidden class=anchor aria-hidden=true href=#静态内存布局>#</a></h2><p>静态内存布局中，包含代码段(<em><strong>Code Segment</strong></em>)，数据段(<em><strong>Data Segment</strong></em>)；数据段中又分为已初始化段，通常称为数据分段(<em><strong>DS</strong></em>)，未初始化分段(<em><strong>BSS</strong></em>)。</p><h3 id=代码段>代码段<a hidden class=anchor aria-hidden=true href=#代码段>#</a></h3><p>代码段包含可执行的机器指令，这部分包含了程序的逻辑，为了防止堆, 栈的溢出，代码段在内存结构中处于布局中最下方。而且为了防止指令被修改，这部分是只读的。</p><ul><li>已编译二进制文件</li><li>只读段，防止程序被修改</li><li>可共享</li></ul><p>可以通过 <code>objdump -S &lt;file></code> 来导出代码段中存的汇编代码</p><h3 id=已初始化数据段>已初始化数据段<a hidden class=anchor aria-hidden=true href=#已初始化数据段>#</a></h3><p>所有已初始化的静态变量和全局变量都被存储在DS中，该段具有写权限，程序可以在运行时修改该段中变量的值。</p><p>定义一个C程序，通过size观看其data段的大小</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>char</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sc>&#39;1&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>size输出为528</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>$</span> <span class=n>size</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=n>text</span>    <span class=n>data</span>     <span class=n>bss</span>     <span class=n>dec</span>     <span class=n>hex</span> <span class=n>filename</span>
</span></span><span class=line><span class=cl>   <span class=mi>1358</span>     <span class=mi>528</span>       <span class=mi>8</span>    <span class=mi>1894</span>     <span class=mi>766</span> <span class=mi>1</span></span></span></code></pre></td></tr></table></div></div></div></div><p>通过增加两个变量，一个全局变量一个静态变量，观看编译后可执行文件data段的大小与之前大小相比较</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>// int 类型占4byte
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span> <span class=n>b</span> <span class=o>=</span> <span class=sc>&#39;a&#39;</span><span class=p>;</span> 	  <span class=c1>// char 类型占1byte
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sc>&#39;1&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>size查看data输出值为533 与之前 528 增加 5 bytes，与定义的类型相符合</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>size</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=n>text</span>    <span class=n>data</span>     <span class=n>bss</span>     <span class=n>dec</span>     <span class=n>hex</span> <span class=n>filename</span>
</span></span><span class=line><span class=cl>   <span class=mi>1358</span>     <span class=mi>533</span>       <span class=mi>3</span>    <span class=mi>1894</span>     <span class=mi>766</span> <span class=mi>1</span></span></span></code></pre></td></tr></table></div></div></div></div><h3 id=未初始化数据段>未初始化数据段<a hidden class=anchor aria-hidden=true href=#未初始化数据段>#</a></h3><p>未初始化数据段包含如下内容</p><ul><li>未初始化的全局和静态变量</li><li>初始化为0或空指针的变量</li></ul><p>接着上述例子，添加两个变量，一个不初始化值，一个初始化为0</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=sc>&#39;1&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>通过 size 命令可以看出，这些都被分配到 BSS 部分</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=err>$</span> <span class=n>size</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>   <span class=n>text</span>    <span class=n>data</span>     <span class=n>bss</span>     <span class=n>dec</span>     <span class=n>hex</span> <span class=n>filename</span>
</span></span><span class=line><span class=cl>   <span class=mi>1358</span>     <span class=mi>528</span>      <span class=mi>16</span>    <span class=mi>1902</span>     <span class=mi>76</span><span class=n>e</span> <span class=mi>1</span></span></span></code></pre></td></tr></table></div></div></div></div><p>对于初始化段与未初始化段和只读数据段 (<em><strong>.rodata</strong></em>) 都会被分配到数据段中</p><h2 id=动态内存布局>动态内存布局<a hidden class=anchor aria-hidden=true href=#动态内存布局>#</a></h2><p>动态内存是指程序运行时创建的的内存</p><h3 id=heap>heap<a hidden class=anchor aria-hidden=true href=#heap>#</a></h3><p>堆段是由BSS往上更高部分动态内存分配的段，heap段具有以下特点</p><ul><li><p>程序运行可以没有heap段</p></li><li><p>heap位于在BSS之上stack之下，与stack成反方向增长和减少</p></li><li><p>运行时分配内存</p></li><li><p>由函数 <code>malloc()</code> , <code>calloc()</code> , <code>free()</code> 等函数管理</p></li><li><p>heap段内存由进程中共享库和动态模块等共享内存</p></li></ul><p>heap对于stack来说，最大的特点就是没有自动的内存管理功能，所有内存的申请和销毁都是通过开发者自行定义的，C中的Glibc API 提供了申请和销毁heap内存的功能。</p><ul><li>函数 <code>malloc()</code> / <code>calloc()</code> 用户空间实现的库函数，用于申请heap内存，可用于windows/linux</li><li>函数 <code>free()</code> 释放由 <code>malloc()</code> / <code>calloc()</code> 申请的内存</li><li><code>brk()</code> / <code>sbrk()</code> 是linux下的系统调用，在内核空间实现的库函数</li></ul><p>下列代码为heap内存分配示例</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt; </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>func</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>aptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Heap Memory Value = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Pointing in Stack = %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=o>*</span><span class=n>aptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>free</span><span class=p>(</span><span class=n>ptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>func</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>下图为上述代码的图形化布局，通过申明一个指针变量 *ptr 指向了通过函数 <code>malloc()</code> 申请的 heap内存</p><blockquote><p>Notes: heap变量的存储实际存储时在物理内存上，而heap,stack.. 都是虚拟内存中某个进程的地址空间，通过MMU将其转为物理地址进行读写。<sup><a href=#2>[2]</a></sup></p></blockquote><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/heap-layout.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/heap-layout.png#center alt=堆内存布局 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><center>图：heap layout of C</center><center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br><h3 id=stack>stack<a hidden class=anchor aria-hidden=true href=#stack>#</a></h3><p>stack是与heap相邻的地区，并与heap以反方向增长，当遇到heap时表示可用内存耗尽。stack段具有如下特点：</p><ul><li>程序运行必须拥有的内存段</li><li>以先进先出 (<em><strong>LIFO</strong></em>) 的顺序添加和移除数据</li><li>包含以下内容<ul><li>所有局部变量</li><li>函数参数（逆序）</li><li>函数调用的返回地址</li><li>基于指针的函数调用</li></ul></li><li>stack段自动分配和销毁内存，开发者无法控制stack段内存<ul><li>当函数执行完函数局部变量会从stack中弹出释放，也就是局部变量的作用域范围</li></ul></li></ul><p>例如</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> 
</span></span><span class=line><span class=cl><span class=cpf>int sum(int a, int b)</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=nf>avg</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=nf>sum</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=kt>float</span><span class=p>)</span><span class=n>s</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Average of %d, %d = %f</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=nf>avg</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>下图是上述代码对于stack内存段执行时的说明，如图所示，整个如下：</p><ul><li>当main函数被执行时会被压入stack中</li><li>main函数会调用avg函数求平均值，此时avg被压入stack</li><li>avg执行sum函数，sum被压入stack</li><li>此时正在执行的帧时位于最顶层的，被称为基指针 (<em><strong>base pointer</strong></em>)</li><li>栈帧指向stack段顶部，存储stack最顶部地址</li><li>s是一个指针保存着sum的位置，即sum函数的结尾，依次类推</li></ul><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/Stack-Layout.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/Stack-Layout.png#center alt=堆栈布局 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><center>图：stack layout of C</center><center><em>Source：</em>https://hackthedeveloper.com/memory-layout-c-program/</center><br><h4 id=栈异常>栈异常<a hidden class=anchor aria-hidden=true href=#栈异常>#</a></h4><p>栈异常常见异常情况有</p><ul><li>栈溢出 (<em><strong>Stack Overflow</strong></em>)：栈溢出是指超出stack的大小，例如很长的函数调用，造成该错误原因如下：<ul><li>递归函数调用</li><li>大数据声明</li></ul></li><li>栈毁坏 (<em><strong>Stack Corruption</strong></em>)：是指stack段中的某些内存位置由于错误的编码而被无意访问，导致内存位置发生变化。由于数据毁坏位置发生在Stack段因此被称为 “<em><strong>Stack Corruption</strong></em>” <sup><a href=#4>[4]</a></sup></li></ul><p>例如下面代码模拟了一个 SC 异常</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>copy</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>   
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>argv</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>copy</span><span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Exit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>输出结果为：可以看到当char大小大于10，会覆盖其他stack位置，使程序无法继续执行从而输出“Exit”。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ gcc .<span class=se>\1</span>.c -o 1.exe
</span></span><span class=line><span class=cl>$ .<span class=se>\1</span>.exe testargs
</span></span><span class=line><span class=cl>Exit
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ .<span class=se>\1</span>.exe testargs000000000000000000</span></span></code></pre></td></tr></table></div></div></div></div><h3 id=stack-vs-heap-supa-href33asup>Stack VS Heap <sup><a href=#3>[3]</a></sup><a hidden class=anchor aria-hidden=true href=#stack-vs-heap-supa-href33asup>#</a></h3><ul><li>Stack与Heap都存储与RAM中</li><li>Stack自动管理内存，而Heap则需要手动申请和取消</li><li>Stack分配速度快（一段程序启动时预先分配好的连续内存），而Heap分配速度较慢（动态分配的非连续内存）</li><li>Stack在使用是会出现溢出问题，而Heap可以分配大数据</li><li>Stack常见错误为内存溢出，Heap常见错误为内存泄漏</li></ul><p><em><strong>Stack</strong></em> 和 <em><strong>Heap</strong></em> 的一些常见问题</p><ul><li>默认Stack大小为多少：Linux中通过 <code>ulimit -s</code> 可以查看</li><li>默认的Heap大小为多少：没有默认的Heap大小，在32位操作系统中，每个进程可以看到连续的4GB空间，这个空间没有被映射到物理地址中，而是根据使用情况进行映射，在64位操作系统中，这个空间会更大</li><li><strong>stack和heap存放在哪里</strong>？：在虚拟内存中，通过MMU进行映射到物理地址上</li><li><strong>如何手动配置heap</strong>？：可以使用 <code>ulimit -v</code> 设置虚拟内存的大小</li></ul><h2 id=函数调用栈>函数调用栈<a hidden class=anchor aria-hidden=true href=#函数调用栈>#</a></h2><p>函数调用与栈有不可密切的关系，在一个函数调用过程所需要的信息一般包括以下几个方面：</p><ul><li>函数返回地址</li><li>函数参数</li><li>变量</li><li>保存的上下文 ：包括在函数调用前后需要保持不变的寄存器。</li></ul><p>当在调用一个函数时，控制流从调用函数转移到被调用函数。如下列代码在运行时产生了如下几项疑问：</p><ul><li>函数参数和用于调用函数的变量的区别</li><li>为什么具有多个相同名称但位于不同函数中的变量可以共存？</li><li>为什么函数doing有一定的限制？</li><li>为什么未初始化的局部变量可能包含任何值？</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt; </span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mogrify</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=o>*</span><span class=mi>4</span> <span class=o>-</span> <span class=n>b</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>                <span class=c1>// (mogrify函数返回值)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>truly_half</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>x</span> <span class=o>/</span> <span class=mf>2.0</span><span class=p>;</span>                   
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>7</span><span class=p>,</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>17</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mog</span> <span class=o>=</span> <span class=nf>mogrify</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>y</span><span class=p>);</span>              <span class=c1>// 调用mogrify
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Done with mogrify</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>x</span> <span class=o>=</span> <span class=nf>truly_half</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>            <span class=c1>// 调用truly_half
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Done with truly_half</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=nf>mogrify</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mog</span><span class=p>);</span>                  <span class=c1>// 第二次调用mogrify
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Results: %d %lf</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>mog</span><span class=p>,</span><span class=n>x</span><span class=p>);</span>   <span class=c1>// (last_print)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>                            <span class=c1>// (main函数返回)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>输出</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>bash</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>lila <span class=o>[</span>stack-demo-code<span class=o>]</span>% gcc simple_calls.c
</span></span><span class=line><span class=cl>lila <span class=o>[</span>stack-demo-code<span class=o>]</span>% ./a.out
</span></span><span class=line><span class=cl>Done with mogrify
</span></span><span class=line><span class=cl>Done with truly_half
</span></span><span class=line><span class=cl>Results: <span class=m>23</span> 8.500000</span></span></code></pre></td></tr></table></div></div></div></div><h3 id=栈行为-supa-href44asup>栈行为 <sup><a href=#4>[4]</a></sup><a hidden class=anchor aria-hidden=true href=#栈行为-supa-href44asup>#</a></h3><ul><li><p><strong>main函数的调用</strong></p><p>上述代码调用stack发生的变化，程序从第一行的 main() 函数开始。 main() 有 3 个局部变量：a,y 是int，x 是double。栈的初始状态如下表（其中地址栏为虚构地址）</p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>main()</td><td>12行开始</td><td>a</td><td>?</td><td>1024</td><td></td></tr><tr><td></td><td></td><td>y</td><td>?</td><td>1028</td><td></td></tr><tr><td></td><td></td><td>mod</td><td>?</td><td>1032</td><td></td></tr><tr><td></td><td></td><td>x</td><td>?</td><td>1036</td><td></td></tr></tbody></table><center>表1</center><br></li><li><p><strong>main函数的第一行被执行</strong></p><p>在运行 main（从第 12 行开始）时，会为所有局部变量分配了栈空间，但没有定义值（随机被初始化）在向下移动时，为局部变量a,y 定义了值。</p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>main()</td><td>13行</td><td>a</td><td>7</td><td>1024</td><td></td></tr><tr><td></td><td></td><td>y</td><td>17</td><td>1028</td><td></td></tr><tr><td></td><td></td><td>mod</td><td>?</td><td>1032</td><td></td></tr><tr><td></td><td></td><td>x</td><td>?</td><td>1036</td><td></td></tr></tbody></table><center>表2</center><br></li><li><p><strong>mogrify()被调用</strong>
在第13行时产生一个函数调用，main函数被暂停，至函数 mogrify 完成。函数调用使一个栈push到调用栈，如下表所示。</p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>main()</td><td>13行</td><td>a</td><td>7</td><td>1024</td><td></td></tr><tr><td></td><td></td><td>y</td><td>17</td><td>1028</td><td></td></tr><tr><td></td><td></td><td>mod</td><td>?</td><td>1032</td><td></td></tr><tr><td></td><td></td><td>x</td><td>?</td><td>1036</td><td></td></tr><tr><td>mogrify()</td><td>4行</td><td>a</td><td>7</td><td>1044</td><td></td></tr><tr><td></td><td></td><td>b</td><td>17</td><td>1048</td><td></td></tr><tr><td></td><td></td><td>tmp</td><td>?</td><td>1052</td><td></td></tr></tbody></table><center>表3</center><br></li><li><p><strong>mogrify()第一行被执行</strong>
此时从 mogrify 的第一行开始，完成后返回至 main 函数，将在第 13 行继续执行。表3中由于没有执行到tmp，所以还没被分配值。</p><p>表4是 完成mogrify 函数执行，局部变量 tmp 被赋值。</p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>main()</td><td>13行</td><td>a</td><td>7</td><td>1024</td><td></td></tr><tr><td></td><td></td><td>y</td><td>17</td><td>1028</td><td></td></tr><tr><td></td><td></td><td>mod</td><td>?</td><td>1032</td><td></td></tr><tr><td></td><td></td><td>x</td><td>?</td><td>1036</td><td></td></tr><tr><td>mogrify()</td><td>5行</td><td>a</td><td>7</td><td>1044</td><td></td></tr><tr><td></td><td></td><td>b</td><td>17</td><td>1048</td><td></td></tr><tr><td></td><td></td><td>tmp</td><td>23</td><td>1052</td><td></td></tr></tbody></table><center>表4</center><br></li><li><p><strong>mogrify()函数返回</strong></p><p>mogrify函数返回在这里有两个作用：</p><ul><li>返回值被存储在调用函数位置：main函数 （第 13 行）变量 mog 中。</li><li>弹出栈帧，从调用堆栈中移除。</li></ul><p>此时状态为表5</p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>ain() |</td><td>4 |</td><td>|</td><td>|</td><td>024 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>|</td><td>7 |</td><td>028 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>od |</td><td>3 |</td><td>032 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>|</td><td>|</td><td>036 |</td><td>|</td></tr></tbody></table><center>表5</center><br></li><li><p><strong>执行Printf()</strong></p><table><thead><tr><th>Method</th><th>Line</th><th>Var</th><th>Value</th><th>Addr</th><th>Notes</th></tr></thead><tbody><tr><td>ain() |</td><td>3行 |</td><td>|</td><td>|</td><td>024 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>|</td><td>7 |</td><td>028 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>od |</td><td>|</td><td>032 |</td><td>|</td></tr><tr><td>|</td><td>|</td><td>|</td><td>|</td><td>036 |</td><td>|</td></tr><tr><td>rintf() |</td><td>ib call |</td><td>ormat |</td><td>|</td><td>044 |</td><td>ointer |</td></tr></tbody></table><center>表6</center><br><p>printf()也是作为函数，将另一个栈帧推入栈中，并为其参数和局部变量预留空间。 printf()是一个可变参数的函数。</p></li><li><p><strong>第二次函数调用</strong></p><p>从第 16 行起，调用了函数 <code>truly_half</code> 此时会将一个栈帧推入调用栈。此时状态如表5相同</p></li><li><p><strong>调用函数truly_half()</strong></p><p>当函数 <code>truly_half()</code> 被调用，对应的栈帧被push到main的栈帧下，表7中所示的地址（局部变量）与之前 <code>mogrify()</code> 函数是相同的地址，这是因为栈中的空间是可重用的。</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>main() |</td><td style=text-align:center>16 |</td><td style=text-align:center>a |</td><td style=text-align:center>7 |</td><td style=text-align:center>024 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>y |</td><td style=text-align:center>17 |</td><td style=text-align:center>028 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>og |</td><td style=text-align:center>23 |</td><td style=text-align:center>032 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>x |</td><td style=text-align:center>? |</td><td style=text-align:center>036 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>truly_half()` |</td><td style=text-align:center>8 |</td><td style=text-align:center>x |</td><td style=text-align:center>17 |</td><td style=text-align:center>044 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>mp |</td><td style=text-align:center>? |</td><td style=text-align:center>048 |</td><td style=text-align:center>|</td></tr></tbody></table><center>表7</center><br></li><li><p><strong>truly_half()被执行</strong></p><p>执行 <code>truly_half</code> 函数的第二行返回计算后的值来赋值给 main 中的局部变量 x，并从调用栈中弹出 <code>truly_half</code> 的栈帧，如表8所示</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>main() |</td><td style=text-align:center>16 |</td><td style=text-align:center>a |</td><td style=text-align:center>7 |</td><td style=text-align:center>024 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>y |</td><td style=text-align:center>17 |</td><td style=text-align:center>028 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>og |</td><td style=text-align:center>23 |</td><td style=text-align:center>032 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>x |</td><td style=text-align:center>? |</td><td style=text-align:center>036 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>truly_half()` |</td><td style=text-align:center>9 |</td><td style=text-align:center>x |</td><td style=text-align:center>17 |</td><td style=text-align:center>044 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>mp |</td><td style=text-align:center>8.5 |</td><td style=text-align:center>048 |</td><td style=text-align:center>|</td></tr></tbody></table><center>表8</center><br></li><li><p><strong>返回main函数控制流</strong></p><p>main函数中会打印这个值，此时内存结构为表8所示</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>main()</td><td style=text-align:center>17</td><td style=text-align:center>a</td><td style=text-align:center>7</td><td style=text-align:center>1024</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>y</td><td style=text-align:center>17</td><td style=text-align:center>1028</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>mog</td><td style=text-align:center>23</td><td style=text-align:center>1032</td><td style=text-align:center></td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>x</td><td style=text-align:center>8.5</td><td style=text-align:center>1036</td><td style=text-align:center></td></tr></tbody></table><center>表9</center><br></li><li><p><strong>再次调用函数mogrify()</strong></p><p>此时，main函数在第19行暂停，在 <code>mogrify()</code> 第一行开始。</p><p>需要注意的一点是 <code>mogrify()</code> 参数类型是int，这里会强制转换 8 字节double 为一个 4 字节的int，小数点被省去。如表10所示</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>main() |</td><td style=text-align:center>19 |</td><td style=text-align:center>a |</td><td style=text-align:center>7 |</td><td style=text-align:center>024 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>y |</td><td style=text-align:center>17 |</td><td style=text-align:center>028 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>og |</td><td style=text-align:center>23 |</td><td style=text-align:center>032 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>x |</td><td style=text-align:center>8.5 |</td><td style=text-align:center>036 |</td><td style=text-align:center>double |</td></tr><tr><td style=text-align:center>ogrify() |</td><td style=text-align:center>4 |</td><td style=text-align:center>a |</td><td style=text-align:center>8 |</td><td style=text-align:center>044 |</td><td style=text-align:center>onvert to int |</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>b |</td><td style=text-align:center>23 |</td><td style=text-align:center>048 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>mp |</td><td style=text-align:center>? |</td><td style=text-align:center>052 |</td><td style=text-align:center>|</td></tr></tbody></table><center>表10</center><br></li><li><p><strong>mogrify()被执行后</strong>：</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>main() |</td><td style=text-align:center>19 |</td><td style=text-align:center>a |</td><td style=text-align:center>7 |</td><td style=text-align:center>024 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>y |</td><td style=text-align:center>17 |</td><td style=text-align:center>028 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>og |</td><td style=text-align:center>23 |</td><td style=text-align:center>032 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>x |</td><td style=text-align:center>8.5 |</td><td style=text-align:center>036 |</td><td style=text-align:center>double |</td></tr><tr><td style=text-align:center>ogrify() |</td><td style=text-align:center>5 |</td><td style=text-align:center>a |</td><td style=text-align:center>8 |</td><td style=text-align:center>044 |</td><td style=text-align:center>onvert to int |</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>b |</td><td style=text-align:center>23 |</td><td style=text-align:center>048 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>mp |</td><td style=text-align:center>25 |</td><td style=text-align:center>052 |</td><td style=text-align:center>|</td></tr></tbody></table><center>表11</center><br></li><li><p><strong>mogrify()被执行后</strong>：
<code>mogrify()</code> 执行完成后将结果分配给 main 函数中的局部变量 a 并弹出栈帧。此时数据如表12所示</p><table><thead><tr><th style=text-align:center>Method</th><th style=text-align:center>Line</th><th style=text-align:center>Var</th><th style=text-align:center>Value</th><th style=text-align:center>Addr</th><th style=text-align:center>Notes</th></tr></thead><tbody><tr><td style=text-align:center>ain() |</td><td style=text-align:center>19 |</td><td style=text-align:center>a |</td><td style=text-align:center>25 |</td><td style=text-align:center>024 |</td><td style=text-align:center>的值被覆盖 |</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>y |</td><td style=text-align:center>17 |</td><td style=text-align:center>028 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>og |</td><td style=text-align:center>23 |</td><td style=text-align:center>032 |</td><td style=text-align:center>|</td></tr><tr><td style=text-align:center>|</td><td style=text-align:center>|</td><td style=text-align:center>x |</td><td style=text-align:center>8.5 |</td><td style=text-align:center>036 |</td><td style=text-align:center>double |</td></tr></tbody></table><center>表12</center><br></li></ul><p>至此返回最开始的部分，一个函数的过程包含四个部分 (<em><strong>function call stack</strong></em>)</p><ul><li>函数调用栈</li><li>动态分配内存区域 (heap)</li><li>存储全局变量的区域</li><li>程序允许的实际代码(data text)</li></ul><p>栈帧(<em><strong>stack frame</strong></em>) 指的是：栈内存中单个函数调用（正在允许的函数）的一部分内存块，（参数和局部变量）。编译器在编译期间确定函数的栈帧大小。栈上的栈帧通常与尚未返回的函数一样多。</p><p>栈行为：</p><ul><li><strong>pushing</strong> ：当函数被调用时，新的帧被推到调用堆栈的 “顶部”。</li><li><strong>popping</strong>：当函数执行完成，会将控制权返回给调用它的函数。并将函数关联的帧从栈顶部弹出。</li></ul><p>溢出：如果在返回之前调用了太多函数（例如递归），程序可能会耗尽栈空间。</p><h3 id=关于栈的总结>关于栈的总结<a hidden class=anchor aria-hidden=true href=#关于栈的总结>#</a></h3><h4 id=c语言的执行模型>C语言的执行模型<a hidden class=anchor aria-hidden=true href=#c语言的执行模型>#</a></h4><ul><li>C 语言是过程式编程，不支持在函数之外编写代码</li><li>C 语言的执行模型是指函数调用工作原理（函数调用栈行为分析的）及函数工作原理。</li><li>C 语言使用 ”栈“ 数据结构来实现函数与函数调用。</li></ul><h4 id=关于函数调用栈>关于函数调用栈<a hidden class=anchor aria-hidden=true href=#关于函数调用栈>#</a></h4><ul><li><p>函数调用栈是动态数据结构，用于参数传递、局部变量分配、保存调用的返回地址、保存寄存器以供恢复。</p></li><li><p>栈向下增长，从较高的地址开始，向较低的地址。</p></li><li><p>Push 将栈帧添加到栈，Pop从栈中弹出</p></li><li><p>栈帧的增长在x86架构下是4字节：</p><ul><li>假设栈指位于1000，此时push一个函数，则该栈指指向996(1000 - 4)</li><li>假设此时弹出函数，那么会从996处从栈中弹出，并递增并指向地址1000</li></ul></li></ul><h3 id=调用惯例-supa-href66asup>调用惯例 <sup><a href=#6>[6]</a></sup><a hidden class=anchor aria-hidden=true href=#调用惯例-supa-href66asup>#</a></h3><p>调用惯例 (<em><strong>Calling Conventions</strong></em>) 是指函数调用的标准化方法，当在函数调用时例如，如何将参数传递给子程序？子程序可以覆盖寄存器中的值，还是调用者希望保留寄存器内容？子程序中的局部变量应该存储在哪里？函数应该如何返回结果？</p><p>C语言中调用惯例在很大程度上使用了基于硬件支持栈。对C中调用惯例的理解就需要对函数执行模型的理解（应确保完全理解 push、pop、call 和 ret 指令的行为）。在此调用约定中，子程序参数在stack上传递。寄存器保存在stack上，子程序使用的局部变量放在stack上的内存中。</p><ul><li><p>cdecl (<em><strong>c declaration</strong></em>)：C/C++默认调用约定，调用时按照从右向左的参数入</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>push</span> <span class=n>arg3</span>  <span class=p>;</span> <span class=n>rightmost</span> <span class=n>argument</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=n>arg2</span>
</span></span><span class=line><span class=cl><span class=n>push</span> <span class=n>arg1</span>  <span class=p>;</span> <span class=n>leftmost</span> <span class=n>argument</span>
</span></span><span class=line><span class=cl><span class=n>call</span> <span class=n>f</span>
</span></span><span class=line><span class=cl><span class=n>add</span> <span class=n>esp</span><span class=p>,</span> <span class=mi>12</span>  <span class=p>;</span> <span class=mi>12</span> <span class=o>=</span> <span class=mi>3</span> <span class=n>arguments</span> <span class=n>each</span> <span class=n>being</span> <span class=mi>4</span> <span class=n>bytes</span></span></span></code></pre></td></tr></table></div></div></div></div></li><li><p>fastcall：通过寄存器传递值（从右到左）</p></li><li><p>thiscall：指针类型被存储在寄存器 <code>ecx</code> ，其他类型放置堆栈</p></li></ul><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><blockquote><p><sup id=1>[1]</sup> <a href="http://webcache.googleusercontent.com/search?q=cache:Nk6EgMoO494J:https://hackthedeveloper.com/memory-layout-c-program/&amp;hl=zh-CN&amp;strip=0&amp;vwsrc=0" target=_blank rel="noopener nofollow noreferrer">memory layout c program</a></p><p><sup id=2>[2]</sup> <a href=https://stackoverflow.com/questions/32418750/stack-and-heap-locations-in-ram target=_blank rel="noopener nofollow noreferrer">stack and heap locations in ram</a></p><p><sup id=3>[3]</sup> <a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap?page=1&amp;tab=scoredesc#tab-top" target=_blank rel="noopener nofollow noreferrer">what and where are the stack and heap</a></p><p><sup id=4>[4]</sup> <a href=https://www.go4expert.com/articles/understanding-stack-corruption-c-t27207/ target=_blank rel="noopener nofollow noreferrer">understanding stack corruption c</a></p><p><sup id=5>[5]</sup> <a href=https://cs.gmu.edu/~kauffman/cs222/stack-demo.html target=_blank rel="noopener nofollow noreferrer">static</a></p><p><sup id=6>[6]</sup> <a href=https://renenyffenegger.ch/notes/development/languages/C-C-plus-plus/calling-convention target=_blank rel="noopener nofollow noreferrer">calling convention</a></p></blockquote></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：ch06 内存布局</p><p>文章链接：<a href=https://www.oomkill.com/2022/09/ch06-memory-layout/ target=_blank>https://www.oomkill.com/2022/09/ch06-memory-layout/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2022/09/ch0-ide/><span>ch0 ide</span></a></li><li><a href=/2022/09/ch01-parmeter-and-data-structrue/><span>ch01 变量和数据类型</span></a></li><li><a href=/2022/09/ch02-control-statements-and-format/><span>ch02 格式化与流程控制</span></a></li><li><a href=/2022/09/ch03-array/><span>ch03 数组</span></a></li><li><a href=/2022/09/ch04-function/><span>ch04 函数</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/c/>C</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2022/09/ch05-pointer/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>ch05 指针</span>
</a><a class=next href=https://www.oomkill.com/2022/09/ch07-composite-type/><span class=title></span>
<span>ch07 复合类型&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/ch06 memory layout","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>