<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>朴素贝叶斯算法 | Cylon's Collection</title>
<meta name=keywords content="MachineLearning,algorithm,CS"><meta name=description content="什么是naive bayes 朴素贝叶斯 naive bayes，是一种概率类的机器学习算法，主要用于解决分类问题
为什么被称为朴素贝叶斯？
为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值
贝叶斯定理 了解朴素贝叶斯之前，需要掌握一些概念才可继续
条件概率 Conditional probability：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率 联合概率 Joint Probability：计算两个或多个事件同时发生的可能性 边界概率 Marginal Probability：事件发生的概率，与另一个变量的结果无关 比例 Proportionality 贝叶斯定理 Bayes' Theorem：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率 边界概率 边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；
联合概率 联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \cap B)$
A 和 B 是两个不同的事件相同相交，$P(A \and B)$ $P(A,B)$ = A 和 B 的联合概率
概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。
如，从一副牌中抽到一张红牌的概率是 $\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。
而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\cap red) = \frac{2}{52} = \frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而6和红色是两个独立的概率，那么计算公式就为：$P(6 \cap red) = P(6) \times P(red) = \frac{4}{52} \times \frac{26}{52} = \frac{1}{26}$"><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2022/06/naive-bayes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2022/06/naive-bayes/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script defer src=https://cdn.staticfile.net/jquery/3.5.1/jquery.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css><script defer src=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js></script><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="朴素贝叶斯算法"><meta property="og:description" content="什么是naive bayes 朴素贝叶斯 naive bayes，是一种概率类的机器学习算法，主要用于解决分类问题
为什么被称为朴素贝叶斯？
为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值
贝叶斯定理 了解朴素贝叶斯之前，需要掌握一些概念才可继续
条件概率 Conditional probability：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率 联合概率 Joint Probability：计算两个或多个事件同时发生的可能性 边界概率 Marginal Probability：事件发生的概率，与另一个变量的结果无关 比例 Proportionality 贝叶斯定理 Bayes' Theorem：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率 边界概率 边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；
联合概率 联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \cap B)$
A 和 B 是两个不同的事件相同相交，$P(A \and B)$ $P(A,B)$ = A 和 B 的联合概率
概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。
如，从一副牌中抽到一张红牌的概率是 $\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。
而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\cap red) = \frac{2}{52} = \frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而6和红色是两个独立的概率，那么计算公式就为：$P(6 \cap red) = P(6) \times P(red) = \frac{4}{52} \times \frac{26}{52} = \frac{1}{26}$"><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2022/06/naive-bayes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-22T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="朴素贝叶斯算法"><meta name=twitter:description content="什么是naive bayes 朴素贝叶斯 naive bayes，是一种概率类的机器学习算法，主要用于解决分类问题
为什么被称为朴素贝叶斯？
为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值
贝叶斯定理 了解朴素贝叶斯之前，需要掌握一些概念才可继续
条件概率 Conditional probability：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率 联合概率 Joint Probability：计算两个或多个事件同时发生的可能性 边界概率 Marginal Probability：事件发生的概率，与另一个变量的结果无关 比例 Proportionality 贝叶斯定理 Bayes' Theorem：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率 边界概率 边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；
联合概率 联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \cap B)$
A 和 B 是两个不同的事件相同相交，$P(A \and B)$ $P(A,B)$ = A 和 B 的联合概率
概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。
如，从一副牌中抽到一张红牌的概率是 $\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。
而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\cap red) = \frac{2}{52} = \frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而6和红色是两个独立的概率，那么计算公式就为：$P(6 \cap red) = P(6) \times P(red) = \frac{4}{52} \times \frac{26}{52} = \frac{1}{26}$"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"朴素贝叶斯算法","item":"https://www.oomkill.com/2022/06/naive-bayes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"朴素贝叶斯算法","name":"朴素贝叶斯算法","description":"什么是naive bayes 朴素贝叶斯 naive bayes，是一种概率类的机器学习算法，主要用于解决分类问题\n为什么被称为朴素贝叶斯？\n为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值\n贝叶斯定理 了解朴素贝叶斯之前，需要掌握一些概念才可继续\n条件概率 Conditional probability：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率 联合概率 Joint Probability：计算两个或多个事件同时发生的可能性 边界概率 Marginal Probability：事件发生的概率，与另一个变量的结果无关 比例 Proportionality 贝叶斯定理 Bayes' Theorem：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率 边界概率 边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；\n联合概率 联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \\cap B)$\nA 和 B 是两个不同的事件相同相交，$P(A \\and B)$ $P(A,B)$ = A 和 B 的联合概率\n概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。\n如，从一副牌中抽到一张红牌的概率是 $\\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。\n而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\\cap red) = \\frac{2}{52} = \\frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而6和红色是两个独立的概率，那么计算公式就为：$P(6 \\cap red) = P(6) \\times P(red) = \\frac{4}{52} \\times \\frac{26}{52} = \\frac{1}{26}$","keywords":["MachineLearning","algorithm","CS"],"articleBody":"什么是naive bayes 朴素贝叶斯 naive bayes，是一种概率类的机器学习算法，主要用于解决分类问题\n为什么被称为朴素贝叶斯？\n为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值\n贝叶斯定理 了解朴素贝叶斯之前，需要掌握一些概念才可继续\n条件概率 Conditional probability：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率 联合概率 Joint Probability：计算两个或多个事件同时发生的可能性 边界概率 Marginal Probability：事件发生的概率，与另一个变量的结果无关 比例 Proportionality 贝叶斯定理 Bayes' Theorem：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率 边界概率 边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；\n联合概率 联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \\cap B)$\nA 和 B 是两个不同的事件相同相交，$P(A \\and B)$ $P(A,B)$ = A 和 B 的联合概率\n概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。\n如，从一副牌中抽到一张红牌的概率是 $\\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。\n而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\\cap red) = \\frac{2}{52} = \\frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而6和红色是两个独立的概率，那么计算公式就为：$P(6 \\cap red) = P(6) \\times P(red) = \\frac{4}{52} \\times \\frac{26}{52} = \\frac{1}{26}$\n在联合概率中 $ \\cap $ 称为交集，是事件 A 与 事件 B 发生的概率的相交点，通过图来表示为：两个圆的相交点，即6和红色牌共同的部分\n条件概率 条件概率是指事件发生的可能性，基于先有事件的结果的发生乘后续事件概率来计算的，例如，申请大学的通过率为80%，宿舍仅提供给60%学生使用，那么这个人被大学录取并提供宿舍的概率是多少？\n$P(accept\\ and\\ get\\ dorm) = P(Accept|Dorm) = P(Accept) \\times P(Dorm) = 0.8 \\times 0.6 = 0.48$\n条件概率将会考虑两个事件之间的关系，例如你被大学录取的概率， 以及为你提供宿舍的概率；条件概率中的关键点：\n另一个事件发生的情况下，这件事发生的几率 表示为，给定 B 的概率 A 发生的概率，用公式表示为：$P(A|B)$，其中 A 取决于 B 发生的概率 通过例子了解条件概率 上述大致上了解到了：条件概率取决于先前的结果，那么通过几个例子来熟悉条件概率\n例1：袋子里有红色，蓝色，绿色三颗玻璃球，每种被拿到的概率相等，那么摸到蓝色之后再摸到红色的条件概率是多少？\n这里需要先得到摸到蓝色的概率：$P(Blue) = \\frac{1}{3}$ 因为只有三种可能性 现在还剩下两颗玻璃球 红色和蓝色，那么摸到红色的概率为：$P(Red) = \\frac{1}{2}$ 因为只有两种可能性 那么已经摸到蓝色在摸到红色的概率为 $P(Red|Blue) = \\frac{1}{3} \\times \\frac{1}{2} = \\frac{1}{6}$ 例2：色子摇出5的概率为 $\\frac{1}{6}$ 那么在结果是奇数里摇出5 那么可能就是 $\\frac{1}{3}$，而这个奇数就是另外的一个条件，因为只有3个奇数，其中一个是5，那么在奇数中，抛出5的概率就是 $\\frac{1}{3}$。\n通过上述信息可知，B 作为附带条件修饰 A 发生的概率，称为给定 B ，A 发生的条件，用$P(A|B)$ 表示。那么可以的出：\n给定A，B发生的概率为，A和B的发生概率排除掉A的概率，即 $P(B|A) = \\frac{P(A \\cap B)}{P(A)} $ 联合概率和条件概率的区别 条件概率是一个事件在另一个事件发生的情况下的概率：$P(X\\ given\\ Y)$ 公式为： $P(X∣Y)$；即一个事件发生的概率取决于另一事件的发生；如：从一副牌中，假设你抽到一张红牌，那么抽到6的概率是 $\\frac{1}{13}$；因为26张红牌中仅有两张为6，用公式表示：$P(6|red) = \\frac{2}{26}$\n联合概率仅考虑两个事件发生的可能性，对比与条件概率可用于计算联合概率：$P(X \\cap Y) = P(X|Y) \\times P(Y)$\n通过合并上述例子得到，同时抽到6和红色的概率为：$\\frac{1}{26}$\n贝叶斯定理 贝叶斯定理是确定条件概率的数学公式。贝叶斯定理依赖于先验概率分布以计算后验概率。\n后验概率和先验概率 先验概率 prior probability：在收集新数据之前发送事件的概率 后验概率 posterior probability：得到新的数据来修正之前事件发生的概率；换句话说是后验概率是在事件 B 已经发生的情况下，事件 A 发生的概率。 例，从一副52 张牌中抽取一张牌，那么这张牌是K的概率是 $\\frac{4}{52}$ , 因为一副牌中有4张K；假设抽中的牌是一张人物牌，那么抽到是K的概率则是 $\\frac{4}{12}$；因为一副牌中有12张人物牌。那么贝叶斯定理的公式为：\n$P(A|B) = \\frac{P(A \\cap B)}{P(B)}$，$P(B|A) = \\frac{P(B \\cap A)}{P(A)}$ $P(A \\cap B)$，$P(B \\cap A)$ A和B同时发生和B和A同时发生时相等的 $P(B \\cap A) = P(B|A) \\times P(A)$ $P(A \\cap B) = P(A|B) \\times P(B)$ 那么根据上面的公式，已知 $P(A \\cap B) = P(B \\cap A)$ 可推导出公式： 因为 $P(B \\cap A) = P(A \\cap B)$ ，那么 $P(B|A) \\times P(A) = P(A|B) \\times P(B)$ 那么吧 $P(A)$ 放置等式右边即 $P(B|A) = \\frac{P(A|B) \\times P(B)}{P(A)}$ 那么最终 Formula for Bayes 为 $P(B|A) = \\frac{P(A|B) \\times P(B)}{P(A)}$ 其中：\n$P(A)$：A 的边界概率\n$P(B)$：B 的边界概率\n$P(A|B)$ ：条件概率，已知 B，A 的概率\n$P(B|A)$ ：条件概率，已知 A，B 的概率\n$P(B \\cap A)$：联合概率 B 与 A 同时发生的概率\n一个简单的概率问题可能会问：茅台股价下跌的概率是多少？条件概率通过询问这个问题更进一步：鉴于A股平均指数下跌，茅台股价下跌的概率是多少？ 给定 B 已经发生的条件下 A 的概率可以表示为：\n$P(Mao|AS) = \\frac{P(Mao \\cap AS)}{P(AS)}$\n$P(Mao \\cap AS)$ 是 A 和 B 同时发生的概率，与 A 发生的情况下 B 也发生的概率 乘 A 发生的概率相等表示为： $P(Mao) \\times P(AS|Mao)$；这两个表达式相等，也就是贝叶斯定理，可以表示为：\n如果， $P(Mao \\cap AS) = P(Mao) \\times P(AS|Mao)$ 那么， $P(Mao|AS) = \\frac{P(Mao) \\times P(AS|Mao)}{P(AS)}$ $P(Mao)$ 和 $P(AS)$ 分别为茅台和A股的下跌概率，彼此间没有关系\n一般情况下，都是以 x （输入） y （输出） 在函数中，假设 $x=AS$ , $y=MAO$ 那么替代到公式中就 $P(Y|X) = \\frac{P(X|Y) \\times P(Y)}{P(X)}$\n朴素贝叶斯算法 朴素贝叶斯不是一个的算法，而是一组算法，所有这些算法都基于一个共同的原则，即每一对被分类的特征必须相互独立。朴素贝叶斯是一个基本的贝叶斯称呼，包含三种算法的集合：多项式 Multinomial、 伯努利 Bernoulli、高斯 Gaussian。\n伯努利 伯努利朴素贝叶斯，又叫做二项式，只接受二进制值，简而言之，在伯努利中必须计算每个值的二进制出现特征，即一个单词是与否出现在文档中。\n通俗地来说，伯努利有两个互斥的结果：\n$$NB=\\begin{cases} P(X=1)\\ = \\ q\\\\ P(X=0)\\ = \\ 1-q\\\\ \\end{cases} $$ ，在伯努利中，可以有多个特征，但每个特征都假设为是二进制的变量，因此，需要将样本表示为二进制向量。\n那么扩展出的公式为：$P(A|B) = \\frac{P(B|A) \\times P(A)}{P(A) \\times P(B|A) + P(not A) \\times P(B|not A)}$\n例子：假设COVID-19测试并不准确，有**95%**几率在感染时测试出阳性（敏感性），这就意味着如果有人并未感染的概率是相同的（特异性）；问：如果Jeovanna检测为阳性，那么他感染COVID-19的概率是多少？\n敏感性和特异性是医学用语；敏感性，病人测出阳性的比例，特异性，非病人测试阴性的比例\n一般情况下没有更多的信息来确定Jeovanna是否感染，如驻留场所，是否发烧，丧失味觉等。就需要更多的信息来计算Jeovanna感染率，比如预估Jeovanna感染率为1%，这1%就是先验概率。\n此时有100000人的测试样本，预计1000人感染（先验1%），那么就是99000为感染，又因为测试具有 95% 的敏感性和 95% 的特异性，这代表了 1000的95% 和 99000的5% 是阳性。整理一个表格\nHas COVID-19 Do not Has COVID-19 count 阳性 950 4950 5900 阴性 50 94050 94100 那么可以看出，阳性的人并感染COVID-19的概率是，$\\frac{950}{5900} = 16%$ ；那么也就是Jeovanna有16%几率是感染 COVID-19。\n此时将先验概率设置为16%，那么爱丽丝得COVID-19的可能性为：\n$P(B|A)$ ：在95%成功率情况下又获得了阳性 $P(A)$：阳性的检测成功率 已知，$P(B|A) = 0.16$ ，$P(A) = 0.95$ $P(A|B) = \\frac{P(B|A) \\times P(A)}{P(A) \\times P(B|A) + P(not A) \\times P(B|not A)} = \\frac{0.16\\times0.95}{0.95\\times 0.16 + (1-0.95)\\times(1-0.16)}= \\frac{0.152}{0.194} = 0.7835 = 78.35%$\n那么就可以得知，在阳性情况下感染COVID-19的情况下，再去检测会有78%几率阳性\n多项式 多项式朴素贝叶斯是基于多项分布的朴素叶贝斯，用来处理文本，计算 $d$ 在 $c$ 中的概率计算如下：\n$P(c|d) \\ \\propto P(c) \\prod_{i=1}^n\\ P(t_k|c)$\n通俗来说就是二项式的一个变种，是计算多个不同的实例\n$P(t_k|c)$ 是 $t_k$ 的 条件概率，发生在数据集 $c$ 中，$P(t_k|c)$ 解释为 $t_k$ 有多少证据表明 $c$ 是正确的；$P(c)$ 是先验条件 $t1..\\ t2..\\ t3..\\ tn_d$ 中的标记 $d$，它们是我们用于分类的词汇表的一部分，$n_d$ 是 标记 $d$ 的数量。\n例如：“Peking and Taipei join the WTO”，$$ ,那么 $n_d = 4$\n那么可以简化为，\n$P(c=x|d=c_k) = P(c^1=x^1..,\\ c^2=x^2..,\\ c^n=x^n|d=c_k) = \\prod_{i=1}^n(c^i|d)x^i + (1-P(c^i|d))\t(1-x^i)$\n$\\prod_{i=1}^n$ 连乘积，即从下标起乘到上标\n朴素贝叶斯实现 首先将朴素贝叶斯为 5 个部分：\n分类 数据集汇总 按类别汇总数据 高斯密度函数 分类概率 分类 根据数据所属的类别来计算数据的概率，即所谓的基本率。\n先创建一个字典对象，其中每个键都是类值，然后添加所有记录的列表作为字典中的值。\n假设每行中的最后一列是类型。\npython 1 2 3 4 5 6 7 8 9 10 # 按类拆分数据集，返回结构是一个词典 def separate_by_class(dataset): separated = dict() for i in range(len(dataset)): vector = dataset[i] class_value = vector[-1] # dataset最后一行是类别 if (class_value not in separated): separated[class_value] = list() separated[class_value].append(vector) return separated 准备一些数据集\ntext 1 2 3 4 5 6 7 8 9 10 11 X1\tX2\tClass 3.393533211\t2.331273381\t0 3.110073483\t1.781539638\t0 7.423436942\t4.696522875\t1 1.343808831\t3.368360954\t0 3.582294042\t4.67917911\t0 9.172168622\t2.511101045\t1 7.792783481\t3.424088941\t1 2.280362439\t2.866990263\t0 5.745051997\t3.533989803\t1 7.939820817\t0.791637231\t1 测试分类函数的功能\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def separate_by_class(dataset): separated = dict() for i in range(len(dataset)): vector = dataset[i] class_value = vector[-1] if (class_value not in separated): separated[class_value] = list() separated[class_value].append(vector) return separated # 测试数据集 dataset = [ [3.393533211,2.331273381,0], [3.110073483,1.781539638,0], [1.343808831,3.368360954,0], [7.423436942,4.696522875,1], [3.582294042,4.67917911,0], [9.172168622,2.511101045,1], [7.792783481,3.424088941,1], [2.280362439,2.866990263,0], [5.745051997,3.533989803,1], [7.939820817,0.791637231,1] ] separated = separate_by_class(dataset) for label in separated: print(label) for row in separated[label]: print(row) 可以看到分类是成功的\n数据集汇总 现在需要对给出数据集的两个数据进行统计，如何对指定数据集做概率计算？需要以下几步\n计算数据集两个数据的平均值和标准差\n平均值为： $\\frac{sum(x)}{n} \\times count(x)$ ；其中 $x$ 为正在查找值的列表\nmean函数用于计算平均值\npython 1 2 def mean(numbers): return sum(numbers) / float(len(numbers)) 样本标准差的计算方式为平均值的平均差。公式可以为 sqrt((sum i to N (x_i – mean(x))^2) / N-1)\n函数用来计算\npython 1 2 3 4 5 6 7 from math import sqrt # Calculate the standard deviation of a list of numbers def stdev(numbers): avg = mean(numbers) # 平均值 variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) return sqrt(variance) 还需要对每个数据的每一列计算平均值和标准偏差统计量。通过将每列的所有值收集到一个列表中并计算该列表的平均值和标准差。计算完成后，将统计信息收集到数据汇总的列表或元组中。然后，对数据集中的每一列重复此操作并返回统计元组列表。\n下面是 数据汇总的函数 summarise_dataset()用来统计每列列表的平均值和标准差\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from math import sqrt # 计算平均数 def mean(numbers): return sum(numbers)/float(len(numbers)) # 计算标准差 def stdev(numbers): # 标准差 avg = mean(numbers) # 计算平均值 variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) # 计算所有的平方 return sqrt(variance) # 数据汇总 def summarize_dataset(dataset): summaries = [(mean(column), stdev(column), len(column)) for column in zip(*dataset)] del(summaries[-1]) # 因为分类不需要所以。删除掉分类哪行 return summaries # Test summarizing a dataset dataset = [ [3.393533211,2.331273381,0], [3.110073483,1.781539638,0], [1.343808831,3.368360954,0], [3.582294042,4.67917911,0], [2.280362439,2.866990263,0], [7.423436942,4.696522875,1], [5.745051997,3.533989803,1], [9.172168622,2.511101045,1], [7.792783481,3.424088941,1], [7.939820817,0.791637231,1]] summary = summarize_dataset(dataset) print(summary) 这里使用的是zip() 函数，将每列作为提供的参数。使用 * 作为位置函数，运将数据集传递给 zip() ，这个运算会将每一行的分割为单独列表。然后zip() 遍历每一行的每个元素，返回一列作为数字列表。\n然后计算每列中的平均数、标准差和行数。删掉不需要的列（第三列类别列的平均数，标准差和行数）\n可以看到\ntext 1 2 3 4 [ (5.178333386499999, 2.7665845055177263, 10), (2.9984683241, 1.218556343617447, 10) ] 根据类别汇总数据 separate_by_class() 是将数据分成行，现在要编写一个 summarise_dataset()；是先计算每列的统计汇总信息，然后在按照子集分类（X1，X2）\npython 1 2 3 4 5 6 7 # 按类拆分数据集 def summarize_by_class(dataset): separated = separate_by_class(dataset) summaries = dict() for class_value, rows in separated.items(): summaries[class_value] = summarize_dataset(rows) return summaries 这是完整的代码\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from math import sqrt # 计算平均数 def mean(numbers): return sum(numbers)/float(len(numbers)) # 计算标准差 def stdev(numbers): # 标准差 avg = mean(numbers) # 计算平均值 variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) # 计算所有的平方 return sqrt(variance) # 数据汇总 def summarize_dataset(dataset): summaries = [(mean(column), stdev(column), len(column)) for column in zip(*dataset)] del(summaries[-1]) # 因为分类不需要所以。删除掉分类哪行 return summaries # 按类进行数据汇总 def summarize_by_class(dataset): separated = separate_by_class(dataset) summaries = dict() for class_value, rows in separated.items(): summaries[class_value] = summarize_dataset(rows) return summaries # 测试数据集 dataset = [ [3.393533211,2.331273381,0], [3.110073483,1.781539638,0], [1.343808831,3.368360954,0], [3.582294042,4.67917911,0], [2.280362439,2.866990263,0], [7.423436942,4.696522875,1], [5.745051997,3.533989803,1], [9.172168622,2.511101045,1], [7.792783481,3.424088941,1], [7.939820817,0.791637231,1]] summary = summarize_by_class(dataset) for label in summary: print(label) for row in summary[label]: print(row) 按照分类，对每列计算平均值和标准差\n高斯分布函数 高斯分布 Gaussian distribution 可以用两个数字来概括，高斯分布是具有对称的钟形的分布，所以中心右侧是左侧的镜像，曲线下的面积代表概率，曲线总面积之和等于1。\n高斯分布中的大多数连续数据值倾向于围绕均值聚集，值离均值越远，那么它发生的可能性就越小。接近但从未完全贴合x 轴。\n高斯分布由均值和标准差两个参数决定的，任何点 (x) 都可以通过公式 $z = \\frac{x-mean}{standard\\ deviation}$ 来计算\nReference normal distribution\n通过这一点，就可以知道就可以计算出给定的概率，公式为：\n$P({x_i}|Y) = \\frac{1}{\\sqrt2\\pi\\sigma_y^2}exp(-(\\frac{(x_i-\\mu_y)^2}{2\\sigma_y^2})$\n其中，$\\sigma$ 为标准差，$\\mu$ 为平均值，那么转换为可读懂的公式为：\n$f(x) = \\frac{1}{\\sqrt{(2 \\times pi )}\\times sigma} \\times exp(-(\\frac{(x-mean)^2}{(2 \\times sigma)^2}))$\n其中，sigma是 x 的标准差，mean 是 x 的平均值，PI是 就是 $\\pi$ math.pi 的值。\n那么在转换成python中的代码为：\npython 1 f(x) = (1 / sqrt(2 * PI) * sigma) * exp(-((x-mean)^2 / (2 * sigma^2))) 那么用python实现一个函数，来实现高斯公式\npython 1 2 3 4 # 计算高斯分布的函数，需要三个参数，x 平均值，标准差 def calculate_probability(x, mean, stdev): exponent = exp(-((x-mean)**2 / (2 * stdev**2 ))) return (1 / (sqrt(2 * pi) * stdev)) * exponent 这里通过函数测试三个数据，(0,1,1)， (1,1,1)，(2,1,1)\npython 1 2 3 4 5 6 7 8 9 10 11 12 from math import sqrt from math import pi from math import exp # 计算高斯分布的函数，需要三个参数，x 平均值，标准差 def calculate_probability(x, mean, stdev): exponent = exp(-((x-mean)**2 / (2 * stdev**2 ))) return (1 / (sqrt(2 * pi) * stdev)) * exponent print(calculate_probability(1.0, 1.0, 1.0)) print(calculate_probability(2.0, 1.0, 1.0)) print(calculate_probability(0.0, 1.0, 1.0)) 这里可以看到结果，(1,1,1) 的概率最可能（三个值中趋于钟形顶部）\n分类概率 到这里，可以尝试通过测试数据来统计新数据的概率，这里每个类别的概率都是单独计算的，这里将简化概率计算公式 $P(class|data) = P(data|class) \\times P(class)$；这是一个常见的简化，这将意味着将结果为最大值的类的计算作为预测结果。因为通常对预测感兴趣，而不是概率\n对于上述例子，有两个变量，这里以 class=0 的类别来说明，公式为：\n$P(class=0|X1,X2) = P(X1|class=0) \\times P(X2|class=0) \\times P(class=0)$\n编写一个聚合函数，将上述四个步骤汇总处理，\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # Example of calculating class probabilities from math import sqrt from math import pi from math import exp # 拆分数据集 def separate_by_class(dataset): separated = dict() for i in range(len(dataset)): vector = dataset[i] class_value = vector[-1] if (class_value not in separated): separated[class_value] = list() separated[class_value].append(vector) print(separated) return separated # 计算平均数 def mean(numbers): return sum(numbers)/float(len(numbers)) # 计算标准差 def stdev(numbers): avg = mean(numbers) # 计算平均值 variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) # 标准差 return sqrt(variance) # 数据汇总 def summarize_dataset(dataset): summaries = [(mean(column), stdev(column), len(column)) for column in zip(*dataset)] del(summaries[-1]) return summaries # 按类进行数据汇总 def summarize_by_class(dataset): separated = separate_by_class(dataset) summaries = dict() for class_value, rows in separated.items(): summaries[class_value] = summarize_dataset(rows) return summaries # 计算高斯分布的函数，需要三个参数，x 平均值，标准差 def calculate_probability(x, mean, stdev): exponent = exp(-((x-mean)**2 / (2 * stdev**2 ))) return (1 / (sqrt(2 * pi) * stdev)) * exponent # 计算每个分类的概率 def converge_probabilities(summaries, row): # 计算所有分类的个数 total_rows = sum([summaries[label][0][2] for label in summaries]) probabilities = dict() for class_value, class_summaries in summaries.items(): # 计算分类的概率，如这个分类在总分类里概率多少 probabilities[class_value] = summaries[class_value][0][2]/float(total_rows) for i in range(len(class_summaries)): mean, stdev, _ = class_summaries[i] probabilities[class_value] *= calculate_probability(row[i], mean, stdev) return probabilities # 测试数据集 dataset = [ [3.393533211,2.331273381,0], [3.110073483,1.781539638,0], [1.343808831,3.368360954,0], [3.582294042,4.67917911,0], [2.280362439,2.866990263,0], [7.423436942,4.696522875,1], [5.745051997,3.533989803,1], [9.172168622,2.511101045,1], [7.792783481,3.424088941,1], [7.939820817,0.791637231,1]] summaries = summarize_by_class(dataset) probabilities = converge_probabilities(summaries, dataset[0]) print(probabilities) 由结果可以得知，dataset[0] X1 的概率（0.0503）要大于 X2 的概率（0.0001），所以可以正确的判断出 dataset[0] 属于 X1 分类\n鸢尾花(Iris)分类 鸢尾花分类，是模式识别中非常出名的一种数据库，需要先将数据下载：\n关于Iris-databases数据集的说明\niris dataset\n实现开始 实验是根据上述实验的步骤，将朴素贝叶斯算法应用在鸢尾花数据集中，鸢尾花数据集的实验也是需要相同的步骤，只不过对于数据集中的数据还需要一些其他的步骤，大致可分为以下几种操作：\n数据的预处理 从文件中读取数据 将数据类型转换为可用于上面实验的类型（float） 将真实分类转换为数字 int 分类 数据集汇总 按类别汇总数据 高斯密度函数 分类概率 python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 from csv import reader from random import seed from random import randrange from math import sqrt from math import exp from math import pi # 读取数据集 def load_csv(filename): dataset = list() with open(filename, 'r') as file: csv_reader = reader(file) for row in csv_reader: if not row: continue dataset.append(row) return dataset # 将每行的数字转换为float def str_column_to_float(dataset, column): for row in dataset: row[column] = float(row[column].strip()) # 将真实分类转换为数字，按照下标 def str_column_to_int(dataset, column): ''' :param dataset: list, 数据集 :param column: string，是为类型的列要传入 :return: None ''' # 通过循环拿到所有分类 class_values = [row[column] for row in dataset] # 对分类型去重 unique = set(class_values) lookup = dict() # 拿到分类值的key 下标 for i, value in enumerate(unique): lookup[value] = i # 已对应的下标进行替换 for row in dataset: row[column] = lookup[row[column]] return lookup # 将数据的一部分作为训练数据 def cross_validation_split(dataset, n_folds): dataset_split = list() dataset_copy = list(dataset) fold_size = int(len(dataset) / n_folds) for _ in range(n_folds): fold = list() while len(fold) \u003c fold_size: index = randrange(len(dataset_copy)) fold.append(dataset_copy.pop(index)) dataset_split.append(fold) return dataset_split # 计算准确度 def accuracy_metric(actual, predicted): correct = 0 for i in range(len(actual)): if actual[i] == predicted[i]: correct += 1 return correct / float(len(actual)) * 100.0 # 对算法数据进行评估 def evaluate_algorithm(dataset, algorithm, n_folds, *args): \"\"\" :param dataset:list, 原始数据集 :param algorithm:function，算法函数 :param n_folds:int，取多少数据作为训练集 :param args:options ，参数 :return: None \"\"\" folds = cross_validation_split(dataset, n_folds) scores = list() for fold in folds: train_set = list(folds) train_set.remove(fold) # 合并成一个数组 train_set = sum(train_set, []) test_set = list() for row in fold: row_copy = list(row) test_set.append(row_copy) row_copy[-1] = None # 将最后一个类型字段设置为None predicted = algorithm(train_set, test_set, *args) # 真实的类型 actual = [row[-1] for row in fold] # 精确的分数，即这一组数据正确率 accuracy = accuracy_metric(actual, predicted) scores.append(accuracy) print(scores) return scores # 按照分类拆分 def separate_by_class(dataset): separated = dict() for i in range(len(dataset)): vector = dataset[i] class_value = vector[-1] if (class_value not in separated): separated[class_value] = list() separated[class_value].append(vector) return separated # 计算这一系列的平均值 def mean(numbers): return sum(numbers)/float(len(numbers)) # 计算一系列数字的标准差 def stdev(numbers): avg = mean(numbers) variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) return sqrt(variance) # 计算数据集中每列的平均值 标准差 长度 def summarize_dataset(dataset): summaries = [(mean(column), stdev(column), len(column)) for column in zip(*dataset)] del(summaries[-1]) return summaries # 按照分类划分数据集 def summarize_by_class(dataset): separated = separate_by_class(dataset) summaries = dict() for class_value, rows in separated.items(): summaries[class_value] = summarize_dataset(rows) return summaries # 计算x的高斯概率 def calculate_probability(x, mean, stdev): \"\"\" :param x:float, 计算这个值的高斯概率 :param mean:float，x的平均值 :param stdev:float，x的标准差 :return: None \"\"\" exponent = exp(-((x-mean)**2 / (2 * stdev**2 ))) return (1 / (sqrt(2 * pi) * stdev)) * exponent # 计算每行的概率 def converge_probabilities(summaries, row): # 计算所有分类的个数 total_rows = sum([summaries[label][0][2] for label in summaries]) probabilities = dict() for class_value, class_summaries in summaries.items(): # 计算分类的概率，如这个分类在总分类里概率多少 # 公式中的P(class) probabilities[class_value] = summaries[class_value][0][2]/float(total_rows) # 通过公式 P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率 for i in range(len(class_summaries)): mean, stdev, _ = class_summaries[i] probabilities[class_value] *= calculate_probability(row[i], mean, stdev) return probabilities # 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值 def predict(summaries, row): probabilities = converge_probabilities(summaries, row) best_label, best_prob = None, -1 for class_value, probability in probabilities.items(): if best_label is None or probability best_prob: best_prob = probability best_label = class_value return best_label # Naive Bayes Algorithm def naive_bayes(train, test): # 训练数据按照类分类排序 summarize = summarize_by_class(train) predictions = list() for row in test: output = predict(summarize, row) predictions.append(output) print(predictions) return(predictions) # 测试 if __name__ == '__main__': seed(1) filename = 'iris.csv' dataset = load_csv(filename) # 转换数值为float for i in range(len(dataset[0])-1): str_column_to_float(dataset, i) # 将类型转换为数字 str_column_to_int(dataset, len(dataset[0])-1) # 将数据分位测试数据和训练数据，folds为多少数据为训练数据 n_folds = 5 scores = evaluate_algorithm(dataset, naive_bayes, n_folds) print('Scores: %s' % scores) print('Mean Accuracy: %.3f%%' % (sum(scores)/float(len(scores)))) 可以看到运行结果，对鸢尾花数据集的预测正确率，平均为95.333%\n现在对 main 部分进行修改，使用全部数据集作为训练，新增记录作为预测\npython 1 2 3 4 5 6 7 8 # 按照整个数据集分类 model = summarize_by_class(dataset) # 新加一行预测数据 row = [5.3,3.9,3.2,2.3] # 根据训练集进行对数据预测 label = predict(model, row) print('Data=%s, Predicted: %s' % (row, label)) 完整修改过的代码如下：\npython 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 from csv import reader from random import seed from random import randrange from math import sqrt from math import exp from math import pi # 读取数据集 def load_csv(filename): dataset = list() with open(filename, 'r') as file: csv_reader = reader(file) for row in csv_reader: if not row: continue dataset.append(row) return dataset # 将每行的数字转换为float def str_column_to_float(dataset, column): for row in dataset: row[column] = float(row[column].strip()) # 将真实分类转换为数字，按照下标 def str_column_to_int(dataset, column): ''' :param dataset: list, 数据集 :param column: string，是为类型的列要传入 :return: None ''' # 通过循环拿到所有分类 class_values = [row[column] for row in dataset] # 对分类型去重 unique = set(class_values) lookup = dict() # 拿到分类值的key 下标 for i, value in enumerate(unique): lookup[value] = i # 增加一行，来显示下标和真实名称对应的数据 print(lookup) # 已对应的下标进行替换 for row in dataset: row[column] = lookup[row[column]] return lookup # 将数据的一部分作为训练数据 def cross_validation_split(dataset, n_folds): dataset_split = list() dataset_copy = list(dataset) fold_size = int(len(dataset) / n_folds) for _ in range(n_folds): fold = list() while len(fold) \u003c fold_size: index = randrange(len(dataset_copy)) fold.append(dataset_copy.pop(index)) dataset_split.append(fold) return dataset_split # 计算准确度 def accuracy_metric(actual, predicted): correct = 0 for i in range(len(actual)): if actual[i] == predicted[i]: correct += 1 return correct / float(len(actual)) * 100.0 # 对算法数据进行评估 def evaluate_algorithm(dataset, algorithm, n_folds, *args): \"\"\" :param dataset:list, 原始数据集 :param algorithm:function，算法函数 :param n_folds:int，取多少数据作为训练集 :param args:options ，参数 :return: None \"\"\" folds = cross_validation_split(dataset, n_folds) scores = list() for fold in folds: train_set = list(folds) train_set.remove(fold) # 合并成一个数组 train_set = sum(train_set, []) test_set = list() for row in fold: row_copy = list(row) test_set.append(row_copy) row_copy[-1] = None # 将最后一个类型字段设置为None predicted = algorithm(train_set, test_set, *args) # 真实的类型 actual = [row[-1] for row in fold] # 精确的分数，即这一组数据正确率 accuracy = accuracy_metric(actual, predicted) scores.append(accuracy) print(scores) return scores # 按照分类拆分 def separate_by_class(dataset): \"\"\" :param dataset:list, 按分类好的列表 :return: dict, 每个分类的每列（属性）的平均值，标准差，个数 \"\"\" separated = dict() for i in range(len(dataset)): vector = dataset[i] class_value = vector[-1] if (class_value not in separated): separated[class_value] = list() separated[class_value].append(vector) return separated # 计算这一系列的平均值 def mean(numbers): return sum(numbers)/float(len(numbers)) # 计算一系列数字的标准差 def stdev(numbers): avg = mean(numbers) variance = sum([(x-avg)**2 for x in numbers]) / float(len(numbers)-1) return sqrt(variance) # 计算数据集中每列的平均值 标准差 长度 def summarize_dataset(dataset): summaries = [(mean(column), stdev(column), len(column)) for column in zip(*dataset)] del(summaries[-1]) return summaries # 按照分类划分数据集 def summarize_by_class(dataset): separated = separate_by_class(dataset) summaries = dict() for class_value, rows in separated.items(): summaries[class_value] = summarize_dataset(rows) return summaries # 计算x的高斯概率 def calculate_probability(x, mean, stdev): \"\"\" :param x:float, 计算这个值的高斯概率 :param mean:float，x的平均值 :param stdev:float，x的标准差 :return: None \"\"\" exponent = exp(-((x-mean)**2 / (2 * stdev**2 ))) return (1 / (sqrt(2 * pi) * stdev)) * exponent # 计算每行的概率 def converge_probabilities(summaries, row): # 计算所有分类的个数 total_rows = sum([summaries[label][0][2] for label in summaries]) probabilities = dict() for class_value, class_summaries in summaries.items(): # 计算分类的概率，如这个分类在总分类里概率多少 # 公式中的P(class) probabilities[class_value] = summaries[class_value][0][2]/float(total_rows) # 通过公式 P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率 for i in range(len(class_summaries)): mean, stdev, _ = class_summaries[i] probabilities[class_value] *= calculate_probability(row[i], mean, stdev) return probabilities # 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值 def predict(summaries, row): probabilities = converge_probabilities(summaries, row) best_label, best_prob = None, -1 for class_value, probability in probabilities.items(): if best_label is None or probability best_prob: best_prob = probability best_label = class_value return best_label # Naive Bayes Algorithm def naive_bayes(train, test): # 训练数据按照类分类排序 summarize = summarize_by_class(train) predictions = list() for row in test: output = predict(summarize, row) predictions.append(output) print(predictions) return(predictions) # 测试 if __name__ == '__main__': seed(1) filename = 'iris.csv' dataset = load_csv(filename) # 转换数值为float for i in range(len(dataset[0])-1): str_column_to_float(dataset, i) # 将类型转换为数字 str_column_to_int(dataset, len(dataset[0])-1) # 按照整个数据集分类 model = summarize_by_class(dataset) # 新加一行预测数据 row = [5.3,3.9,3.2,2.3] # 根据训练集进行对数据预测 label = predict(model, row) print('Data=%s, Predicted: %s' % (row, label)) 可以看到对数据集 [5.3,3.9,3.2,2.3] 预测为 versicolor，那将属性修改为，[2.3,0.9,0.2,1.3] 预测结果为 setosa\nReference gaussian naive bayes Naive Bayes Example caculator naive bayes [五分钟了解朴素贝叶斯](https://towardsdatascience.com/- a-mathematical-explanation-of-naive-bayes-in-5-minutes-44adebcdb5f8) Joint Probability Conditional Probability ","wordCount":"3124","inLanguage":"zh","datePublished":"2022-06-01T00:00:00Z","dateModified":"2023-03-22T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2022/06/naive-bayes/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">朴素贝叶斯算法</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2022-06-01</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>3124 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>15 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/machinelearning/>#MachineLearning</a>
<a href=https://www.oomkill.com/tags/algorithm/>#Algorithm</a>
<a href=https://www.oomkill.com/tags/cs/>#CS</a></ul>&nbsp;·&nbsp;<span id=busuanzi_container_page_pv>本文阅读量 <span id=busuanzi_value_page_pv></span> 次</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afnaive-bayes aria-label="什么是naive bayes">什么是naive bayes</a><li><a href=#%e8%b4%9d%e5%8f%b6%e6%96%af%e5%ae%9a%e7%90%86 aria-label=贝叶斯定理>贝叶斯定理</a><ul><li><a href=#%e8%be%b9%e7%95%8c%e6%a6%82%e7%8e%87 aria-label=边界概率>边界概率</a><li><a href=#%e8%81%94%e5%90%88%e6%a6%82%e7%8e%87 aria-label=联合概率>联合概率</a><li><a href=#%e6%9d%a1%e4%bb%b6%e6%a6%82%e7%8e%87 aria-label=条件概率>条件概率</a><ul><li><a href=#%e9%80%9a%e8%bf%87%e4%be%8b%e5%ad%90%e4%ba%86%e8%a7%a3%e6%9d%a1%e4%bb%b6%e6%a6%82%e7%8e%87 aria-label=通过例子了解条件概率>通过例子了解条件概率</a><li><a href=#%e8%81%94%e5%90%88%e6%a6%82%e7%8e%87%e5%92%8c%e6%9d%a1%e4%bb%b6%e6%a6%82%e7%8e%87%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=联合概率和条件概率的区别>联合概率和条件概率的区别</a></ul><li><a href=#%e8%b4%9d%e5%8f%b6%e6%96%af%e5%ae%9a%e7%90%86-1 aria-label=贝叶斯定理>贝叶斯定理</a><ul><li><a href=#%e5%90%8e%e9%aa%8c%e6%a6%82%e7%8e%87%e5%92%8c%e5%85%88%e9%aa%8c%e6%a6%82%e7%8e%87 aria-label=后验概率和先验概率>后验概率和先验概率</a></ul></ul><li><a href=#%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af%e7%ae%97%e6%b3%95 aria-label=朴素贝叶斯算法>朴素贝叶斯算法</a><ul><li><a href=#%e4%bc%af%e5%8a%aa%e5%88%a9 aria-label=伯努利>伯努利</a><li><a href=#%e5%a4%9a%e9%a1%b9%e5%bc%8f aria-label=多项式>多项式</a></ul><li><a href=#%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af%e5%ae%9e%e7%8e%b0 aria-label=朴素贝叶斯实现>朴素贝叶斯实现</a><ul><li><a href=#%e5%88%86%e7%b1%bb aria-label=分类>分类</a><li><a href=#%e6%95%b0%e6%8d%ae%e9%9b%86%e6%b1%87%e6%80%bb aria-label=数据集汇总>数据集汇总</a><li><a href=#%e6%a0%b9%e6%8d%ae%e7%b1%bb%e5%88%ab%e6%b1%87%e6%80%bb%e6%95%b0%e6%8d%ae aria-label=根据类别汇总数据>根据类别汇总数据</a><li><a href=#%e9%ab%98%e6%96%af%e5%88%86%e5%b8%83%e5%87%bd%e6%95%b0 aria-label=高斯分布函数>高斯分布函数</a><li><a href=#%e5%88%86%e7%b1%bb%e6%a6%82%e7%8e%87 aria-label=分类概率>分类概率</a></ul><li><a href=#%e9%b8%a2%e5%b0%be%e8%8a%b1iris%e5%88%86%e7%b1%bb aria-label=鸢尾花(Iris)分类>鸢尾花(Iris)分类</a><ul><li><a href=#%e5%ae%9e%e7%8e%b0%e5%bc%80%e5%a7%8b aria-label=实现开始>实现开始</a></ul><li><a href=#reference aria-label=Reference>Reference</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=什么是naive-bayes>什么是naive bayes<a hidden class=anchor aria-hidden=true href=#什么是naive-bayes>#</a></h2><p>朴素贝叶斯 <code>naive bayes</code>，是一种概率类的机器学习算法，主要用于解决分类问题</p><p><strong>为什么被称为朴素贝叶斯？</strong></p><p>为什么被称为朴素，难道仅仅是因为贝叶斯很天真吗？实际上是因为，朴素贝叶斯会假设数据属性之间具有很强的的独立性。即该模型中的所有属性彼此之间都是独立的，改变一个属性的值，不会直接影响或改变算法中其他的属性的值</p><h2 id=贝叶斯定理>贝叶斯定理<a hidden class=anchor aria-hidden=true href=#贝叶斯定理>#</a></h2><p>了解朴素贝叶斯之前，需要掌握一些概念才可继续</p><ul><li><strong>条件概率</strong> <code>Conditional probability</code>：在另一个事件已经发生的情况下，另外一个时间发生的概率。如，==在多云天气，下雨的概率是多少？== 这是一个条件概率</li><li><strong>联合概率</strong> <code>Joint Probability</code>：计算两个或多个事件同时发生的可能性</li><li><strong>边界概率</strong> <code>Marginal Probability</code>：事件发生的概率，与另一个变量的结果无关</li><li><strong>比例</strong> <code>Proportionality</code></li><li><strong>贝叶斯定理</strong> <code>Bayes' Theorem</code>：概率的公式；贝叶斯定律是指根据可能与事件的先验概率描述了事件的后验概率</li></ul><h3 id=边界概率>边界概率<a hidden class=anchor aria-hidden=true href=#边界概率>#</a></h3><p>边界概率是指事件发生的概率，可以认为是无条件概率。不以另一个事件为条件；用公式表示为 $P(X)$ 如：抽到的牌是红色的概率是 $P(red) = 0.5$ ；</p><h3 id=联合概率>联合概率<a hidden class=anchor aria-hidden=true href=#联合概率>#</a></h3><p>联合概率是指两个事件在同一时间点发生的可能性，公式可以表示为 $P(A \cap B)$</p><p><strong>A</strong> 和 <strong>B</strong> 是两个不同的事件相同相交，$P(A \and B)$ $P(A,B)$ = <strong>A</strong> 和 <strong>B</strong> 的联合概率</p><p>概率用于处理事件或现象发生的可能性。它被量化为介于 0 和 1 之间的数字，其中 0 表示不可能发生的机会，1 表示事件的一定结果。</p><p>如，从一副牌中抽到一张红牌的概率是 $\frac{1}{2}$。这意味着抽到红色和抽到黑色的概率相同；因为一副牌中有52张牌，其中 26 张是红色的，26 张是黑色的，所以抽到一张红牌与抽到一张黑牌的概率是 50%。</p><p>而联合概率是对测量同时发生的两个事件，只能应用于可能同时发生多个情况。例如，从一副52张牌扑克中，拿起一张既是红色又是6的牌的联合概率是 $P(6\cap red) = \frac{2}{52} = \frac{1}{26}$ ；这个是怎么得到的呢？因为抽到红色的概率为50%，而一副牌中有两个红色6（红桃6，方片6），而<strong>6</strong>和<strong>红色</strong>是两个独立的概率，那么计算公式就为：$P(6 \cap red) = P(6) \times P(red) = \frac{4}{52} \times \frac{26}{52} = \frac{1}{26}$</p><p>在联合概率中 $ \cap $ 称为交集，是事件 <strong>A</strong> 与 事件 <strong>B</strong> 发生的概率的相交点，通过图来表示为：两个圆的相交点，即6和红色牌共同的部分</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220501235937229.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220501235937229.png#center alt=image-20220501235937229 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=条件概率>条件概率<a hidden class=anchor aria-hidden=true href=#条件概率>#</a></h3><p>条件概率是指事件发生的可能性，基于先有事件的结果的发生乘后续事件概率来计算的，例如，申请大学的通过率为80%，宿舍仅提供给60%学生使用，那么这个人被大学录取并提供宿舍的概率是多少？</p><p>$P(accept\ and\ get\ dorm) = P(Accept|Dorm) = P(Accept) \times P(Dorm) = 0.8 \times 0.6 = 0.48$</p><p>条件概率将会考虑两个事件之间的关系，例如你被大学录取的概率， 以及为你提供宿舍的概率；<strong>条件概率中的关键点</strong>：</p><ul><li>另一个事件发生的情况下，这件事发生的几率</li><li>表示为，给定 <strong>B</strong> 的概率 <strong>A</strong> 发生的概率，用公式表示为：$P(A|B)$，其中 <strong>A</strong> 取决于 <strong>B</strong> 发生的概率</li></ul><h4 id=通过例子了解条件概率>通过例子了解条件概率<a hidden class=anchor aria-hidden=true href=#通过例子了解条件概率>#</a></h4><p>上述大致上了解到了：<strong>条件概率取决于先前的结果</strong>，那么通过几个例子来熟悉条件概率</p><p><strong>例1</strong>：袋子里有红色，蓝色，绿色三颗玻璃球，每种被拿到的概率相等，那么摸到蓝色之后再摸到红色的条件概率是多少？</p><ul><li>这里需要先得到摸到蓝色的概率：$P(Blue) = \frac{1}{3}$ 因为只有三种可能性</li><li>现在还剩下两颗玻璃球 红色和蓝色，那么摸到红色的概率为：$P(Red) = \frac{1}{2}$ 因为只有两种可能性</li><li>那么已经摸到蓝色在摸到红色的概率为 $P(Red|Blue) = \frac{1}{3} \times \frac{1}{2} = \frac{1}{6}$</li></ul><p><strong>例2</strong>：色子摇出5的概率为 $\frac{1}{6}$ 那么在结果是奇数里摇出5 那么可能就是 $\frac{1}{3}$，而这个<strong>奇数</strong>就是另外的一个条件，因为只有3个奇数，其中一个是5，那么在奇数中，抛出5的概率就是 $\frac{1}{3}$。</p><p>通过上述信息可知，<strong>B</strong> 作为附带条件修饰 <strong>A</strong> 发生的概率，称为给定 <strong>B</strong> ，<strong>A</strong> 发生的条件，用$P(A|B)$ 表示。那么可以的出：</p><ul><li>给定A，B发生的概率为，A和B的发生概率排除掉A的概率，即</li><li>$P(B|A) = \frac{P(A \cap B)}{P(A)} $</li></ul><h4 id=联合概率和条件概率的区别>联合概率和条件概率的区别<a hidden class=anchor aria-hidden=true href=#联合概率和条件概率的区别>#</a></h4><p><strong>条件概率</strong>是一个事件在另一个事件发生的情况下的概率：$P(X\ given\ Y)$ 公式为： $P(X∣Y)$；即一个事件发生的概率取决于另一事件的发生；如：从一副牌中，假设你抽到一张红牌，那么抽到6的概率是 $\frac{1}{13}$；因为26张红牌中仅有两张为6，用公式表示：$P(6|red) = \frac{2}{26}$</p><p><strong>联合概率</strong>仅考虑两个事件发生的可能性，对比与条件概率可用于计算联合概率：$P(X \cap Y) = P(X|Y) \times P(Y)$</p><p>通过合并上述例子得到，同时抽到6和红色的概率为：$\frac{1}{26}$</p><h3 id=贝叶斯定理-1>贝叶斯定理<a hidden class=anchor aria-hidden=true href=#贝叶斯定理-1>#</a></h3><p>贝叶斯定理是确定条件概率的数学公式。贝叶斯定理依赖于先验概率分布以计算后验概率。</p><h4 id=后验概率和先验概率>后验概率和先验概率<a hidden class=anchor aria-hidden=true href=#后验概率和先验概率>#</a></h4><ul><li>先验概率 <code>prior probability</code>：在收集新数据之前发送事件的概率</li><li>后验概率 <code>posterior probability</code>：得到新的数据来修正之前事件发生的概率；换句话说是<strong>后验概率是在事件 B 已经发生的情况下，事件 A 发生的概率</strong>。</li></ul><p>例，从一副52 张牌中抽取一张牌，那么这张牌是K的概率是 $\frac{4}{52}$ , 因为一副牌中有4张K；假设抽中的牌是一张人物牌，那么抽到是K的概率则是 $\frac{4}{12}$；因为一副牌中有12张人物牌。那么贝叶斯定理的公式为：</p><ul><li>$P(A|B) = \frac{P(A \cap B)}{P(B)}$，$P(B|A) = \frac{P(B \cap A)}{P(A)}$<ul><li>$P(A \cap B)$，$P(B \cap A)$ A和B同时发生和B和A同时发生时相等的</li><li>$P(B \cap A) = P(B|A) \times P(A)$</li><li>$P(A \cap B) = P(A|B) \times P(B)$</li></ul></li><li>那么根据上面的公式，已知 $P(A \cap B) = P(B \cap A)$ 可推导出公式：<ul><li>因为 $P(B \cap A) = P(A \cap B)$ ，那么 $P(B|A) \times P(A) = P(A|B) \times P(B)$</li><li>那么吧 $P(A)$ 放置等式右边即 $P(B|A) = \frac{P(A|B) \times P(B)}{P(A)}$</li></ul></li><li>那么最终 <code>Formula for Bayes</code> 为 $P(B|A) = \frac{P(A|B) \times P(B)}{P(A)}$</li></ul><p>其中：</p><ul><li><p>$P(A)$：<strong>A</strong> 的边界概率</p></li><li><p>$P(B)$：<strong>B</strong> 的边界概率</p></li><li><p>$P(A|B)$ ：条件概率，已知 <strong>B</strong>，<strong>A</strong> 的概率</p></li><li><p>$P(B|A)$ ：条件概率，已知 <strong>A</strong>，<strong>B</strong> 的概率</p></li><li><p>$P(B \cap A)$：联合概率 <strong>B</strong> 与 <strong>A</strong> 同时发生的概率</p></li></ul><p>一个简单的概率问题可能会问：茅台股价下跌的概率是多少？条件概率通过询问这个问题更进一步：鉴于A股平均指数下跌，茅台股价下跌的概率是多少？ 给定 B 已经发生的条件下 A 的概率可以表示为：</p><p>$P(Mao|AS) = \frac{P(Mao \cap AS)}{P(AS)}$</p><p>$P(Mao \cap AS)$ 是 A 和 B 同时发生的概率，与 A 发生的情况下 B 也发生的概率 乘 A 发生的概率相等表示为： $P(Mao) \times P(AS|Mao)$；这两个表达式相等，也就是贝叶斯定理，可以表示为：</p><ul><li>如果， $P(Mao \cap AS) = P(Mao) \times P(AS|Mao)$</li><li>那么， $P(Mao|AS) = \frac{P(Mao) \times P(AS|Mao)}{P(AS)}$</li></ul><p>$P(Mao)$ 和 $P(AS)$ 分别为茅台和A股的下跌概率，彼此间没有关系</p><p>一般情况下，都是以 <strong>x</strong> （输入） <strong>y</strong> （输出） 在函数中，假设 $x=AS$ , $y=MAO$ 那么替代到公式中就 $P(Y|X) = \frac{P(X|Y) \times P(Y)}{P(X)}$</p><h2 id=朴素贝叶斯算法>朴素贝叶斯算法<a hidden class=anchor aria-hidden=true href=#朴素贝叶斯算法>#</a></h2><p>朴素贝叶斯不是一个的算法，而是一组算法，所有这些算法都基于一个共同的原则，即每一对被分类的特征必须相互独立。朴素贝叶斯是一个基本的贝叶斯称呼，包含三种算法的集合：多项式 <code>Multinomial</code>、 伯努利 <code>Bernoulli</code>、高斯 <code>Gaussian</code>。</p><h3 id=伯努利>伯努利<a hidden class=anchor aria-hidden=true href=#伯努利>#</a></h3><p>伯努利朴素贝叶斯，又叫做二项式，只接受二进制值，简而言之，在伯努利中必须计算每个值的二进制出现特征，即一个单词是与否出现在文档中。</p><p>通俗地来说，伯努利有两个互斥的结果：</p>$$NB=\begin{cases}
P(X=1)\ = \ q\\
P(X=0)\ = \ 1-q\\
\end{cases}
$$<p>，在伯努利中，可以有多个特征，但每个特征都假设为是二进制的变量，因此，需要将样本表示为二进制向量。</p><p>那么扩展出的公式为：$P(A|B) = \frac{P(B|A) \times P(A)}{P(A) \times P(B|A) + P(not A) \times P(B|not A)}$</p><p><strong>例子</strong>：假设COVID-19测试并不准确，有**95%**几率在感染时测试出阳性（敏感性），这就意味着如果有人并未感染的概率是相同的（特异性）；问：如果Jeovanna检测为阳性，那么他感染COVID-19的概率是多少？</p><p>敏感性和特异性是医学用语；敏感性，病人测出阳性的比例，特异性，非病人测试阴性的比例</p><p>一般情况下没有更多的信息来确定Jeovanna是否感染，如驻留场所，是否发烧，丧失味觉等。就需要更多的信息来计算Jeovanna感染率，比如预估Jeovanna感染率为1%，这1%就是先验概率。</p><p>此时有100000人的测试样本，预计1000人感染（先验1%），那么就是99000为感染，又因为测试具有 95% 的敏感性和 95% 的特异性，这代表了 1000的95% 和 99000的5% 是阳性。整理一个表格</p><table><thead><tr><th></th><th>Has COVID-19</th><th>Do not Has COVID-19</th><th>count</th></tr></thead><tbody><tr><td>阳性</td><td>950</td><td>4950</td><td>5900</td></tr><tr><td>阴性</td><td>50</td><td>94050</td><td>94100</td></tr></tbody></table><p>那么可以看出，阳性的人并感染COVID-19的概率是，$\frac{950}{5900} = 16%$ ；那么也就是Jeovanna有16%几率是感染 COVID-19。</p><p>此时将先验概率设置为16%，那么爱丽丝得COVID-19的可能性为：</p><p>$P(B|A)$ ：在95%成功率情况下又获得了阳性
$P(A)$：阳性的检测成功率
已知，$P(B|A) = 0.16$ ，$P(A) = 0.95$
$P(A|B) = \frac{P(B|A) \times P(A)}{P(A) \times P(B|A) + P(not A) \times P(B|not A)} = \frac{0.16\times0.95}{0.95\times 0.16 + (1-0.95)\times(1-0.16)}= \frac{0.152}{0.194} = 0.7835 = 78.35%$</p><p>那么就可以得知，在阳性情况下感染COVID-19的情况下，再去检测会有78%几率阳性</p><h3 id=多项式>多项式<a hidden class=anchor aria-hidden=true href=#多项式>#</a></h3><p>多项式朴素贝叶斯是基于多项分布的朴素叶贝斯，用来处理文本，计算 $d$ 在 $c$ 中的概率计算如下：</p><p>$P(c|d) \ \propto P(c) \prod_{i=1}^n\ P(t_k|c)$</p><p>通俗来说就是二项式的一个变种，是计算多个不同的实例</p><p>$P(t_k|c)$ 是 $t_k$ 的 条件概率，发生在数据集 $c$ 中，$P(t_k|c)$ 解释为 $t_k$ 有多少证据表明 $c$ 是正确的；$P(c)$ 是先验条件 $t1..\ t2..\ t3..\ tn_d$ 中的标记 $d$，它们是我们用于分类的词汇表的一部分，$n_d$ 是 标记 $d$ 的数量。</p><p>例如：&ldquo;Peking and Taipei join the WTO&rdquo;，$&lt;Peking,\ Taipei,\ join,\ WTO>$ ,那么 $n_d = 4$</p><p>那么可以简化为，</p><p>$P(c=x|d=c_k) = P(c^1=x^1..,\ c^2=x^2..,\ c^n=x^n|d=c_k) = \prod_{i=1}^n(c^i|d)x^i + (1-P(c^i|d)) (1-x^i)$</p><p>$\prod_{i=1}^n$ 连乘积，即从下标起乘到上标</p><h2 id=朴素贝叶斯实现>朴素贝叶斯实现<a hidden class=anchor aria-hidden=true href=#朴素贝叶斯实现>#</a></h2><p>首先将朴素贝叶斯为 5 个部分：</p><ul><li>分类</li><li>数据集汇总</li><li>按类别汇总数据</li><li>高斯密度函数</li><li>分类概率</li></ul><h3 id=分类>分类<a hidden class=anchor aria-hidden=true href=#分类>#</a></h3><p>根据数据所属的类别来计算数据的概率，即所谓的基本率。</p><p>先创建一个字典对象，其中每个键都是类值，然后添加所有记录的列表作为字典中的值。</p><p>假设每行中的最后一列是类型。</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 按类拆分数据集，返回结构是一个词典</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=n>vector</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=n>class_value</span> <span class=o>=</span> <span class=n>vector</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=c1># dataset最后一行是类别</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>class_value</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>separated</span></span></span></code></pre></td></tr></table></div></div></div></div><p>准备一些数据集</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>X1				X2						Class
</span></span><span class=line><span class=cl>3.393533211		2.331273381				0
</span></span><span class=line><span class=cl>3.110073483		1.781539638				0
</span></span><span class=line><span class=cl>7.423436942		4.696522875				1
</span></span><span class=line><span class=cl>1.343808831		3.368360954				0
</span></span><span class=line><span class=cl>3.582294042		4.67917911				0
</span></span><span class=line><span class=cl>9.172168622		2.511101045				1
</span></span><span class=line><span class=cl>7.792783481		3.424088941				1
</span></span><span class=line><span class=cl>2.280362439		2.866990263				0
</span></span><span class=line><span class=cl>5.745051997		3.533989803				1
</span></span><span class=line><span class=cl>7.939820817		0.791637231				1</span></span></code></pre></td></tr></table></div></div></div></div><p>测试分类函数的功能</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=n>vector</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=n>class_value</span> <span class=o>=</span> <span class=n>vector</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>class_value</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>separated</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 测试数据集</span>
</span></span><span class=line><span class=cl><span class=n>dataset</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>3.393533211</span><span class=p>,</span><span class=mf>2.331273381</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.110073483</span><span class=p>,</span><span class=mf>1.781539638</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>1.343808831</span><span class=p>,</span><span class=mf>3.368360954</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>7.423436942</span><span class=p>,</span><span class=mf>4.696522875</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.582294042</span><span class=p>,</span><span class=mf>4.67917911</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>9.172168622</span><span class=p>,</span><span class=mf>2.511101045</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.792783481</span><span class=p>,</span><span class=mf>3.424088941</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>2.280362439</span><span class=p>,</span><span class=mf>2.866990263</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>5.745051997</span><span class=p>,</span><span class=mf>3.533989803</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.939820817</span><span class=p>,</span><span class=mf>0.791637231</span><span class=p>,</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>label</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=n>label</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>[</span><span class=n>label</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div><p>可以看到分类是成功的</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220503215102264.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220503215102264.png#center alt=image-20220503215102264 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=数据集汇总>数据集汇总<a hidden class=anchor aria-hidden=true href=#数据集汇总>#</a></h3><p>现在需要对给出数据集的两个数据进行统计，如何对指定数据集做概率计算？需要以下几步</p><p>计算数据集两个数据的平均值和标准差</p><p>平均值为： $\frac{sum(x)}{n} \times count(x)$ ；其中 $x$ 为正在查找值的列表</p><p>mean函数用于计算平均值</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div></div></div><p>样本标准差的计算方式为平均值的平均差。公式可以为 <code>sqrt((sum i to N (x_i – mean(x))^2) / N-1)</code></p><p>函数用来计算</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># Calculate the standard deviation of a list of numbers</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span> <span class=c1># 平均值</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div><p>还需要对每个数据的每一列计算平均值和标准偏差统计量。通过将每列的所有值收集到一个列表中并计算该列表的平均值和标准差。计算完成后，将统计信息收集到数据汇总的列表或元组中。然后，对数据集中的每一列重复此操作并返回统计元组列表。</p><p>下面是 数据汇总的函数 <code>summarise_dataset()</code>用来统计每列列表的平均值和标准差</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算平均数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span> <span class=c1># 标准差</span>
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span> <span class=c1># 计算平均值</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 计算所有的平方</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 数据汇总</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>summaries</span> <span class=o>=</span> <span class=p>[(</span><span class=n>mean</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=n>stdev</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>column</span><span class=p>))</span> <span class=k>for</span> <span class=n>column</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>dataset</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>del</span><span class=p>(</span><span class=n>summaries</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=c1># 因为分类不需要所以。删除掉分类哪行</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># Test summarizing a dataset</span>
</span></span><span class=line><span class=cl><span class=n>dataset</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>3.393533211</span><span class=p>,</span><span class=mf>2.331273381</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.110073483</span><span class=p>,</span><span class=mf>1.781539638</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>1.343808831</span><span class=p>,</span><span class=mf>3.368360954</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.582294042</span><span class=p>,</span><span class=mf>4.67917911</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>2.280362439</span><span class=p>,</span><span class=mf>2.866990263</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.423436942</span><span class=p>,</span><span class=mf>4.696522875</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>5.745051997</span><span class=p>,</span><span class=mf>3.533989803</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>9.172168622</span><span class=p>,</span><span class=mf>2.511101045</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.792783481</span><span class=p>,</span><span class=mf>3.424088941</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.939820817</span><span class=p>,</span><span class=mf>0.791637231</span><span class=p>,</span><span class=mi>1</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>summary</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>summary</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div><p>这里使用的是<code>zip()</code> 函数，将每列作为提供的参数。使用 * 作为位置函数，运将数据集传递给 <code>zip()</code> ，这个运算会将每一行的分割为单独列表。然后<code>zip()</code> 遍历每一行的每个元素，返回一列作为数字列表。</p><p>然后计算每列中的平均数、标准差和行数。删掉不需要的列（第三列类别列的平均数，标准差和行数）</p><p>可以看到</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>(5.178333386499999, 2.7665845055177263, 10), 
</span></span><span class=line><span class=cl>(2.9984683241, 1.218556343617447, 10)
</span></span><span class=line><span class=cl>]</span></span></code></pre></td></tr></table></div></div></div></div><h3 id=根据类别汇总数据>根据类别汇总数据<a hidden class=anchor aria-hidden=true href=#根据类别汇总数据>#</a></h3><p><code>separate_by_class()</code> 是将数据分成行，现在要编写一个 <code>summarise_dataset()</code>；是先计算每列的统计汇总信息，然后在按照子集分类（X1，X2）</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 按类拆分数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>rows</span> <span class=ow>in</span> <span class=n>separated</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span></span></span></code></pre></td></tr></table></div></div></div></div><p>这是完整的代码</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算平均数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span> <span class=c1># 标准差</span>
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span> <span class=c1># 计算平均值</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 计算所有的平方</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 数据汇总</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>summaries</span> <span class=o>=</span> <span class=p>[(</span><span class=n>mean</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=n>stdev</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>column</span><span class=p>))</span> <span class=k>for</span> <span class=n>column</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>dataset</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>    <span class=k>del</span><span class=p>(</span><span class=n>summaries</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span> <span class=c1># 因为分类不需要所以。删除掉分类哪行</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 按类进行数据汇总</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>rows</span> <span class=ow>in</span> <span class=n>separated</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 测试数据集</span>
</span></span><span class=line><span class=cl><span class=n>dataset</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>3.393533211</span><span class=p>,</span><span class=mf>2.331273381</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.110073483</span><span class=p>,</span><span class=mf>1.781539638</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>1.343808831</span><span class=p>,</span><span class=mf>3.368360954</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.582294042</span><span class=p>,</span><span class=mf>4.67917911</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>2.280362439</span><span class=p>,</span><span class=mf>2.866990263</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.423436942</span><span class=p>,</span><span class=mf>4.696522875</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>5.745051997</span><span class=p>,</span><span class=mf>3.533989803</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>9.172168622</span><span class=p>,</span><span class=mf>2.511101045</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.792783481</span><span class=p>,</span><span class=mf>3.424088941</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.939820817</span><span class=p>,</span><span class=mf>0.791637231</span><span class=p>,</span><span class=mi>1</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>summary</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>label</span> <span class=ow>in</span> <span class=n>summary</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=n>label</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>summary</span><span class=p>[</span><span class=n>label</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=n>row</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div><p>按照分类，对每列计算平均值和标准差</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220504174107364.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220504174107364.png#center alt=image-20220504174107364 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h3 id=高斯分布函数>高斯分布函数<a hidden class=anchor aria-hidden=true href=#高斯分布函数>#</a></h3><p>高斯分布 <code>Gaussian distribution</code> 可以用两个数字来概括，高斯分布是具有对称的钟形的分布，所以中心右侧是左侧的镜像，曲线下的面积代表概率，曲线总面积之和等于1。</p><p>高斯分布中的大多数连续数据值倾向于围绕均值聚集，值离均值越远，那么它发生的可能性就越小。接近但从未完全贴合x 轴。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/bell-curve.jpg><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/bell-curve.jpg#center alt onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>高斯分布由均值和标准差两个参数决定的，任何点 (x) 都可以通过公式 $z = \frac{x-mean}{standard\ deviation}$ 来计算</p><p>Reference
<a href=https://www.simplypsychology.org/normal-distribution.html target=_blank rel="noopener nofollow noreferrer">normal distribution</a></p><p>通过这一点，就可以知道就可以计算出给定的概率，公式为：</p><p>$P({x_i}|Y) = \frac{1}{\sqrt2\pi\sigma_y^2}exp(-(\frac{(x_i-\mu_y)^2}{2\sigma_y^2})$</p><p>其中，$\sigma$ 为标准差，$\mu$ 为平均值，那么转换为可读懂的公式为：</p><p>$f(x) = \frac{1}{\sqrt{(2 \times pi )}\times sigma} \times exp(-(\frac{(x-mean)^2}{(2 \times sigma)^2}))$</p><p>其中，<code>sigma</code>是 <code>x</code> 的标准差，<code>mean</code> 是 <code>x</code> 的平均值，PI是 就是 $\pi$ <code>math.pi</code> 的值。</p><p>那么在转换成python中的代码为：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>PI</span><span class=p>)</span> <span class=o>*</span> <span class=n>sigma</span><span class=p>)</span> <span class=o>*</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>^</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>sigma</span><span class=o>^</span><span class=mi>2</span><span class=p>)))</span></span></span></code></pre></td></tr></table></div></div></div></div><p>那么用python实现一个函数，来实现高斯公式</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_probability</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>exponent</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>stdev</span><span class=o>**</span><span class=mi>2</span> <span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span><span class=p>)</span> <span class=o>*</span> <span class=n>stdev</span><span class=p>))</span> <span class=o>*</span> <span class=n>exponent</span></span></span></code></pre></td></tr></table></div></div></div></div><p>这里通过函数测试三个数据，<code>(0,1,1)</code>， <code>(1,1,1)</code>，<code>(2,1,1)</code></p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>pi</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>exp</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_probability</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>exponent</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>stdev</span><span class=o>**</span><span class=mi>2</span> <span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span><span class=p>)</span> <span class=o>*</span> <span class=n>stdev</span><span class=p>))</span> <span class=o>*</span> <span class=n>exponent</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calculate_probability</span><span class=p>(</span><span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calculate_probability</span><span class=p>(</span><span class=mf>2.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>calculate_probability</span><span class=p>(</span><span class=mf>0.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>,</span> <span class=mf>1.0</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div></div></div><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220504220553349.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220504220553349.png#center alt=image-20220504220553349 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>这里可以看到结果，<code>(1,1,1)</code> 的概率最可能（三个值中趋于钟形顶部）</p><h3 id=分类概率>分类概率<a hidden class=anchor aria-hidden=true href=#分类概率>#</a></h3><p>到这里，可以尝试通过测试数据来统计新数据的概率，这里每个类别的概率都是单独计算的，这里将简化概率计算公式 $P(class|data) = P(data|class) \times P(class)$；这是一个常见的简化，这将意味着将结果为最大值的类的计算作为预测结果。因为通常对预测感兴趣，而不是概率</p><p>对于上述例子，有两个变量，这里以 <code>class=0</code> 的类别来说明，公式为：</p><p>$P(class=0|X1,X2) = P(X1|class=0) \times P(X2|class=0) \times P(class=0)$</p><p>编写一个聚合函数，将上述四个步骤汇总处理，</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Example of calculating class probabilities</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>pi</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>exp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 拆分数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>separated</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>class_value</span> <span class=o>=</span> <span class=n>vector</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>class_value</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>separated</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>separated</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算平均数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span> 
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span>  <span class=c1># 计算平均值</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=c1># 标准差</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 数据汇总</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=p>[(</span><span class=n>mean</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=n>stdev</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>column</span><span class=p>))</span> <span class=k>for</span> <span class=n>column</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>dataset</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>	<span class=k>del</span><span class=p>(</span><span class=n>summaries</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 按类进行数据汇总</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>rows</span> <span class=ow>in</span> <span class=n>separated</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算高斯分布的函数，需要三个参数，x 平均值，标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_probability</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>exponent</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>stdev</span><span class=o>**</span><span class=mi>2</span> <span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span><span class=p>)</span> <span class=o>*</span> <span class=n>stdev</span><span class=p>))</span> <span class=o>*</span> <span class=n>exponent</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 计算每个分类的概率</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 计算所有分类的个数</span>
</span></span><span class=line><span class=cl>    <span class=n>total_rows</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([</span><span class=n>summaries</span><span class=p>[</span><span class=n>label</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=k>for</span> <span class=n>label</span> <span class=ow>in</span> <span class=n>summaries</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>probabilities</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>class_summaries</span> <span class=ow>in</span> <span class=n>summaries</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class=line><span class=cl>        <span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=n>total_rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>class_summaries</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>class_summaries</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>*=</span> <span class=n>calculate_probability</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>probabilities</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 测试数据集</span>
</span></span><span class=line><span class=cl><span class=n>dataset</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=mf>3.393533211</span><span class=p>,</span><span class=mf>2.331273381</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.110073483</span><span class=p>,</span><span class=mf>1.781539638</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>1.343808831</span><span class=p>,</span><span class=mf>3.368360954</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>3.582294042</span><span class=p>,</span><span class=mf>4.67917911</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>2.280362439</span><span class=p>,</span><span class=mf>2.866990263</span><span class=p>,</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.423436942</span><span class=p>,</span><span class=mf>4.696522875</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>5.745051997</span><span class=p>,</span><span class=mf>3.533989803</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>9.172168622</span><span class=p>,</span><span class=mf>2.511101045</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.792783481</span><span class=p>,</span><span class=mf>3.424088941</span><span class=p>,</span><span class=mi>1</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=p>[</span><span class=mf>7.939820817</span><span class=p>,</span><span class=mf>0.791637231</span><span class=p>,</span><span class=mi>1</span><span class=p>]]</span>
</span></span><span class=line><span class=cl><span class=n>summaries</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>probabilities</span> <span class=o>=</span> <span class=n>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>probabilities</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div></div></div><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220505233319199.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220505233319199.png#center alt=image-20220505233319199 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>由结果可以得知，<code>dataset[0]</code> <strong>X1</strong> 的概率（0.0503）要大于 <strong>X2</strong> 的概率（0.0001），所以可以正确的判断出 <code>dataset[0]</code> 属于 <strong>X1</strong> 分类</p><h2 id=鸢尾花iris分类>鸢尾花(Iris)分类<a hidden class=anchor aria-hidden=true href=#鸢尾花iris分类>#</a></h2><p>鸢尾花分类，是模式识别中非常出名的一种数据库，需要先将数据下载：</p><ul><li><p><a href=https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.names target=_blank rel="noopener nofollow noreferrer">关于Iris-databases数据集的说明</a></p></li><li><p><a href=https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv target=_blank rel="noopener nofollow noreferrer">iris dataset</a></p></li></ul><h3 id=实现开始>实现开始<a hidden class=anchor aria-hidden=true href=#实现开始>#</a></h3><p>实验是根据上述实验的步骤，将朴素贝叶斯算法应用在鸢尾花数据集中，鸢尾花数据集的实验也是需要相同的步骤，只不过对于数据集中的数据还需要一些其他的步骤，大致可分为以下几种操作：</p><ul><li>数据的预处理<ul><li>从文件中读取数据</li><li>将数据类型转换为可用于上面实验的类型（<code>float</code>）</li><li>将真实分类转换为数字 <code>int</code></li></ul></li><li>分类</li><li>数据集汇总</li><li>按类别汇总数据</li><li>高斯密度函数</li><li>分类概率</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>csv</span> <span class=kn>import</span> <span class=n>reader</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>seed</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>randrange</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>exp</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>pi</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 读取数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>load_csv</span><span class=p>(</span><span class=n>filename</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s1>&#39;r&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>csv_reader</span> <span class=o>=</span> <span class=n>reader</span><span class=p>(</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>csv_reader</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=ow>not</span> <span class=n>row</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=n>dataset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>dataset</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将每行的数字转换为float</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>str_column_to_float</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>column</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将真实分类转换为数字，按照下标</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>str_column_to_int</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>column</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    :param dataset: list, 数据集
</span></span></span><span class=line><span class=cl><span class=s1>    :param column: string，是为类型的列要传入
</span></span></span><span class=line><span class=cl><span class=s1>    :return: None
</span></span></span><span class=line><span class=cl><span class=s1>    &#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 通过循环拿到所有分类</span>
</span></span><span class=line><span class=cl>    <span class=n>class_values</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对分类型去重</span>
</span></span><span class=line><span class=cl>    <span class=n>unique</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>class_values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>lookup</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 拿到分类值的key 下标</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>value</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>unique</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>lookup</span><span class=p>[</span><span class=n>value</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 已对应的下标进行替换</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=o>=</span> <span class=n>lookup</span><span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>lookup</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将数据的一部分作为训练数据</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cross_validation_split</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset_split</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset_copy</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>fold_size</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span> <span class=o>/</span> <span class=n>n_folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_folds</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>fold</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>fold_size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>index</span> <span class=o>=</span> <span class=n>randrange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset_copy</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=n>fold</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>dataset_copy</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>index</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=n>dataset_split</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>dataset_split</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算准确度</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>accuracy_metric</span><span class=p>(</span><span class=n>actual</span><span class=p>,</span> <span class=n>predicted</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>correct</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>actual</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>actual</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>predicted</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>			<span class=n>correct</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>correct</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>actual</span><span class=p>))</span> <span class=o>*</span> <span class=mf>100.0</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 对算法数据进行评估</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>evaluate_algorithm</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>algorithm</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    :param dataset:list, 原始数据集
</span></span></span><span class=line><span class=cl><span class=s2>    :param algorithm:function，算法函数
</span></span></span><span class=line><span class=cl><span class=s2>    :param n_folds:int，取多少数据作为训练集
</span></span></span><span class=line><span class=cl><span class=s2>    :param args:options ，参数
</span></span></span><span class=line><span class=cl><span class=s2>    :return: None
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>folds</span> <span class=o>=</span> <span class=n>cross_validation_split</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>scores</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>fold</span> <span class=ow>in</span> <span class=n>folds</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 合并成一个数组</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>train_set</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>test_set</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>fold</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>row_copy</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>test_set</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row_copy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>row_copy</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span> <span class=c1># 将最后一个类型字段设置为None</span>
</span></span><span class=line><span class=cl>        <span class=n>predicted</span> <span class=o>=</span> <span class=n>algorithm</span><span class=p>(</span><span class=n>train_set</span><span class=p>,</span> <span class=n>test_set</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 真实的类型</span>
</span></span><span class=line><span class=cl>        <span class=n>actual</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>fold</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 精确的分数，即这一组数据正确率</span>
</span></span><span class=line><span class=cl>        <span class=n>accuracy</span> <span class=o>=</span> <span class=n>accuracy_metric</span><span class=p>(</span><span class=n>actual</span><span class=p>,</span> <span class=n>predicted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>scores</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>accuracy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>scores</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>scores</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 按照分类拆分</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=n>vector</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=n>class_value</span> <span class=o>=</span> <span class=n>vector</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>class_value</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>separated</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算这一系列的平均值</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算一系列数字的标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算数据集中每列的平均值 标准差 长度</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=p>[(</span><span class=n>mean</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=n>stdev</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>column</span><span class=p>))</span> <span class=k>for</span> <span class=n>column</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>dataset</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>	<span class=k>del</span><span class=p>(</span><span class=n>summaries</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 按照分类划分数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>rows</span> <span class=ow>in</span> <span class=n>separated</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算x的高斯概率</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_probability</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    :param x:float, 计算这个值的高斯概率
</span></span></span><span class=line><span class=cl><span class=s2>    :param mean:float，x的平均值
</span></span></span><span class=line><span class=cl><span class=s2>    :param stdev:float，x的标准差
</span></span></span><span class=line><span class=cl><span class=s2>    :return: None
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>exponent</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>stdev</span><span class=o>**</span><span class=mi>2</span> <span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span><span class=p>)</span> <span class=o>*</span> <span class=n>stdev</span><span class=p>))</span> <span class=o>*</span> <span class=n>exponent</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算每行的概率</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 计算所有分类的个数</span>
</span></span><span class=line><span class=cl>	<span class=n>total_rows</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([</span><span class=n>summaries</span><span class=p>[</span><span class=n>label</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=k>for</span> <span class=n>label</span> <span class=ow>in</span> <span class=n>summaries</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=n>probabilities</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>class_summaries</span> <span class=ow>in</span> <span class=n>summaries</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class=line><span class=cl>        <span class=c1># 公式中的P(class)</span>
</span></span><span class=line><span class=cl>		<span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=n>total_rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 通过公式  P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>class_summaries</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>			<span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>class_summaries</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>*=</span> <span class=n>calculate_probability</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>probabilities</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>probabilities</span> <span class=o>=</span> <span class=n>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>best_label</span><span class=p>,</span> <span class=n>best_prob</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>probability</span> <span class=ow>in</span> <span class=n>probabilities</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>best_label</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>or</span> <span class=n>probability</span> <span class=n>best_prob</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>best_prob</span> <span class=o>=</span> <span class=n>probability</span>
</span></span><span class=line><span class=cl>			<span class=n>best_label</span> <span class=o>=</span> <span class=n>class_value</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>best_label</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># Naive Bayes Algorithm</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>naive_bayes</span><span class=p>(</span><span class=n>train</span><span class=p>,</span> <span class=n>test</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 训练数据按照类分类排序</span>
</span></span><span class=line><span class=cl>    <span class=n>summarize</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>train</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>predictions</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>test</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>predict</span><span class=p>(</span><span class=n>summarize</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>predictions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>predictions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>(</span><span class=n>predictions</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 测试</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>seed</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>filename</span> <span class=o>=</span> <span class=s1>&#39;iris.csv&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>dataset</span> <span class=o>=</span> <span class=n>load_csv</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 转换数值为float</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>str_column_to_float</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 将类型转换为数字</span>
</span></span><span class=line><span class=cl>    <span class=n>str_column_to_int</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 将数据分位测试数据和训练数据，folds为多少数据为训练数据</span>
</span></span><span class=line><span class=cl>    <span class=n>n_folds</span> <span class=o>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl>    <span class=n>scores</span> <span class=o>=</span> <span class=n>evaluate_algorithm</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>naive_bayes</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Scores: </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=n>scores</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Mean Accuracy: </span><span class=si>%.3f%%</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=nb>sum</span><span class=p>(</span><span class=n>scores</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>scores</span><span class=p>))))</span></span></span></code></pre></td></tr></table></div></div></div></div><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506190801092.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506190801092.png#center alt=image-20220506190801092 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>可以看到运行结果，对鸢尾花数据集的预测正确率，平均为95.333%</p><p>现在对 <code>main</code> 部分进行修改，使用全部数据集作为训练，新增记录作为预测</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 按照整个数据集分类</span>
</span></span><span class=line><span class=cl><span class=n>model</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 新加一行预测数据</span>
</span></span><span class=line><span class=cl><span class=n>row</span> <span class=o>=</span> <span class=p>[</span><span class=mf>5.3</span><span class=p>,</span><span class=mf>3.9</span><span class=p>,</span><span class=mf>3.2</span><span class=p>,</span><span class=mf>2.3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1># 根据训练集进行对数据预测</span>
</span></span><span class=line><span class=cl><span class=n>label</span> <span class=o>=</span> <span class=n>predict</span><span class=p>(</span><span class=n>model</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Data=</span><span class=si>%s</span><span class=s1>, Predicted: </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>label</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div></div></div><p>完整修改过的代码如下：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span><span class=lnt>194
</span><span class=lnt>195
</span><span class=lnt>196
</span><span class=lnt>197
</span><span class=lnt>198
</span><span class=lnt>199
</span><span class=lnt>200
</span><span class=lnt>201
</span><span class=lnt>202
</span><span class=lnt>203
</span><span class=lnt>204
</span><span class=lnt>205
</span><span class=lnt>206
</span><span class=lnt>207
</span><span class=lnt>208
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>csv</span> <span class=kn>import</span> <span class=n>reader</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>seed</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>random</span> <span class=kn>import</span> <span class=n>randrange</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>sqrt</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>exp</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>math</span> <span class=kn>import</span> <span class=n>pi</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 读取数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>load_csv</span><span class=p>(</span><span class=n>filename</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=s1>&#39;r&#39;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>csv_reader</span> <span class=o>=</span> <span class=n>reader</span><span class=p>(</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>csv_reader</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=ow>not</span> <span class=n>row</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>			<span class=n>dataset</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>dataset</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将每行的数字转换为float</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>str_column_to_float</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>column</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span><span class=o>.</span><span class=n>strip</span><span class=p>())</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将真实分类转换为数字，按照下标</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>str_column_to_int</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>column</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;&#39;&#39;
</span></span></span><span class=line><span class=cl><span class=s1>    :param dataset: list, 数据集
</span></span></span><span class=line><span class=cl><span class=s1>    :param column: string，是为类型的列要传入
</span></span></span><span class=line><span class=cl><span class=s1>    :return: None
</span></span></span><span class=line><span class=cl><span class=s1>    &#39;&#39;&#39;</span>
</span></span><span class=line><span class=cl>    <span class=c1># 通过循环拿到所有分类</span>
</span></span><span class=line><span class=cl>    <span class=n>class_values</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 对分类型去重</span>
</span></span><span class=line><span class=cl>    <span class=n>unique</span> <span class=o>=</span> <span class=nb>set</span><span class=p>(</span><span class=n>class_values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>lookup</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 拿到分类值的key 下标</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>value</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>unique</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>lookup</span><span class=p>[</span><span class=n>value</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 增加一行，来显示下标和真实名称对应的数据</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>lookup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 已对应的下标进行替换</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>dataset</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]</span> <span class=o>=</span> <span class=n>lookup</span><span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=n>column</span><span class=p>]]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>lookup</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 将数据的一部分作为训练数据</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>cross_validation_split</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset_split</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>dataset_copy</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>fold_size</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span> <span class=o>/</span> <span class=n>n_folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n_folds</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>fold</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>fold_size</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>index</span> <span class=o>=</span> <span class=n>randrange</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset_copy</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=n>fold</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>dataset_copy</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>index</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=n>dataset_split</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>dataset_split</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算准确度</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>accuracy_metric</span><span class=p>(</span><span class=n>actual</span><span class=p>,</span> <span class=n>predicted</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>correct</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>actual</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>actual</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>predicted</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>			<span class=n>correct</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>correct</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>actual</span><span class=p>))</span> <span class=o>*</span> <span class=mf>100.0</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 对算法数据进行评估</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>evaluate_algorithm</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>algorithm</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    :param dataset:list, 原始数据集
</span></span></span><span class=line><span class=cl><span class=s2>    :param algorithm:function，算法函数
</span></span></span><span class=line><span class=cl><span class=s2>    :param n_folds:int，取多少数据作为训练集
</span></span></span><span class=line><span class=cl><span class=s2>    :param args:options ，参数
</span></span></span><span class=line><span class=cl><span class=s2>    :return: None
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>folds</span> <span class=o>=</span> <span class=n>cross_validation_split</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>n_folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>scores</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>fold</span> <span class=ow>in</span> <span class=n>folds</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>folds</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>fold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 合并成一个数组</span>
</span></span><span class=line><span class=cl>        <span class=n>train_set</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>(</span><span class=n>train_set</span><span class=p>,</span> <span class=p>[])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>test_set</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>fold</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>row_copy</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>test_set</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>row_copy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>row_copy</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=kc>None</span> <span class=c1># 将最后一个类型字段设置为None</span>
</span></span><span class=line><span class=cl>        <span class=n>predicted</span> <span class=o>=</span> <span class=n>algorithm</span><span class=p>(</span><span class=n>train_set</span><span class=p>,</span> <span class=n>test_set</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 真实的类型</span>
</span></span><span class=line><span class=cl>        <span class=n>actual</span> <span class=o>=</span> <span class=p>[</span><span class=n>row</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>fold</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># 精确的分数，即这一组数据正确率</span>
</span></span><span class=line><span class=cl>        <span class=n>accuracy</span> <span class=o>=</span> <span class=n>accuracy_metric</span><span class=p>(</span><span class=n>actual</span><span class=p>,</span> <span class=n>predicted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>scores</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>accuracy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>scores</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>scores</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 按照分类拆分</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    :param dataset:list, 按分类好的列表
</span></span></span><span class=line><span class=cl><span class=s2>    :return: dict, 每个分类的每列（属性）的平均值，标准差，个数
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>separated</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span> <span class=o>=</span> <span class=n>dataset</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>class_value</span> <span class=o>=</span> <span class=n>vector</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>class_value</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>separated</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>separated</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>vector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>separated</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算这一系列的平均值</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>sum</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>))</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算一系列数字的标准差</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>stdev</span><span class=p>(</span><span class=n>numbers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>avg</span> <span class=o>=</span> <span class=n>mean</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>variance</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([(</span><span class=n>x</span><span class=o>-</span><span class=n>avg</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>numbers</span><span class=p>])</span> <span class=o>/</span> <span class=nb>float</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>numbers</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>sqrt</span><span class=p>(</span><span class=n>variance</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算数据集中每列的平均值 标准差 长度</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_dataset</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>summaries</span> <span class=o>=</span> <span class=p>[(</span><span class=n>mean</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=n>stdev</span><span class=p>(</span><span class=n>column</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>column</span><span class=p>))</span> <span class=k>for</span> <span class=n>column</span> <span class=ow>in</span> <span class=nb>zip</span><span class=p>(</span><span class=o>*</span><span class=n>dataset</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>	<span class=k>del</span><span class=p>(</span><span class=n>summaries</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 按照分类划分数据集</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>separated</span> <span class=o>=</span> <span class=n>separate_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>summaries</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>rows</span> <span class=ow>in</span> <span class=n>separated</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summarize_dataset</span><span class=p>(</span><span class=n>rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>summaries</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算x的高斯概率</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>calculate_probability</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    :param x:float, 计算这个值的高斯概率
</span></span></span><span class=line><span class=cl><span class=s2>    :param mean:float，x的平均值
</span></span></span><span class=line><span class=cl><span class=s2>    :param stdev:float，x的标准差
</span></span></span><span class=line><span class=cl><span class=s2>    :return: None
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>exponent</span> <span class=o>=</span> <span class=n>exp</span><span class=p>(</span><span class=o>-</span><span class=p>((</span><span class=n>x</span><span class=o>-</span><span class=n>mean</span><span class=p>)</span><span class=o>**</span><span class=mi>2</span> <span class=o>/</span> <span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>stdev</span><span class=o>**</span><span class=mi>2</span> <span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=mi>1</span> <span class=o>/</span> <span class=p>(</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>pi</span><span class=p>)</span> <span class=o>*</span> <span class=n>stdev</span><span class=p>))</span> <span class=o>*</span> <span class=n>exponent</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 计算每行的概率</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 计算所有分类的个数</span>
</span></span><span class=line><span class=cl>    <span class=n>total_rows</span> <span class=o>=</span> <span class=nb>sum</span><span class=p>([</span><span class=n>summaries</span><span class=p>[</span><span class=n>label</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span> <span class=k>for</span> <span class=n>label</span> <span class=ow>in</span> <span class=n>summaries</span><span class=p>])</span>
</span></span><span class=line><span class=cl>    <span class=n>probabilities</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>class_summaries</span> <span class=ow>in</span> <span class=n>summaries</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># 计算分类的概率，如这个分类在总分类里概率多少</span>
</span></span><span class=line><span class=cl>        <span class=c1># 公式中的P(class)</span>
</span></span><span class=line><span class=cl>        <span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>=</span> <span class=n>summaries</span><span class=p>[</span><span class=n>class_value</span><span class=p>][</span><span class=mi>0</span><span class=p>][</span><span class=mi>2</span><span class=p>]</span><span class=o>/</span><span class=nb>float</span><span class=p>(</span><span class=n>total_rows</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 通过公式  P(X1|class=0) * P(X2|class=0) * P(class=0) 计算高斯概率</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>class_summaries</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>,</span> <span class=n>_</span> <span class=o>=</span> <span class=n>class_summaries</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>probabilities</span><span class=p>[</span><span class=n>class_value</span><span class=p>]</span> <span class=o>*=</span> <span class=n>calculate_probability</span><span class=p>(</span><span class=n>row</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>mean</span><span class=p>,</span> <span class=n>stdev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>probabilities</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 通过计算出来的值，预测该花属于哪个品种，取高斯概率最大的值</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>probabilities</span> <span class=o>=</span> <span class=n>converge_probabilities</span><span class=p>(</span><span class=n>summaries</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>best_label</span><span class=p>,</span> <span class=n>best_prob</span> <span class=o>=</span> <span class=kc>None</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>class_value</span><span class=p>,</span> <span class=n>probability</span> <span class=ow>in</span> <span class=n>probabilities</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>best_label</span> <span class=ow>is</span> <span class=kc>None</span> <span class=ow>or</span> <span class=n>probability</span> <span class=n>best_prob</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>best_prob</span> <span class=o>=</span> <span class=n>probability</span>
</span></span><span class=line><span class=cl>			<span class=n>best_label</span> <span class=o>=</span> <span class=n>class_value</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>best_label</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># Naive Bayes Algorithm</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>naive_bayes</span><span class=p>(</span><span class=n>train</span><span class=p>,</span> <span class=n>test</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 训练数据按照类分类排序</span>
</span></span><span class=line><span class=cl>    <span class=n>summarize</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>train</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>predictions</span> <span class=o>=</span> <span class=nb>list</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>row</span> <span class=ow>in</span> <span class=n>test</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>output</span> <span class=o>=</span> <span class=n>predict</span><span class=p>(</span><span class=n>summarize</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>predictions</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>output</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>predictions</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>(</span><span class=n>predictions</span><span class=p>)</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl><span class=c1># 测试</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>seed</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>filename</span> <span class=o>=</span> <span class=s1>&#39;iris.csv&#39;</span>
</span></span><span class=line><span class=cl>    <span class=n>dataset</span> <span class=o>=</span> <span class=n>load_csv</span><span class=p>(</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 转换数值为float</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>-</span><span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>str_column_to_float</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 将类型转换为数字</span>
</span></span><span class=line><span class=cl>    <span class=n>str_column_to_int</span><span class=p>(</span><span class=n>dataset</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>dataset</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 按照整个数据集分类</span>
</span></span><span class=line><span class=cl>    <span class=n>model</span> <span class=o>=</span> <span class=n>summarize_by_class</span><span class=p>(</span><span class=n>dataset</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 新加一行预测数据</span>
</span></span><span class=line><span class=cl>    <span class=n>row</span> <span class=o>=</span> <span class=p>[</span><span class=mf>5.3</span><span class=p>,</span><span class=mf>3.9</span><span class=p>,</span><span class=mf>3.2</span><span class=p>,</span><span class=mf>2.3</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 根据训练集进行对数据预测</span>
</span></span><span class=line><span class=cl>    <span class=n>label</span> <span class=o>=</span> <span class=n>predict</span><span class=p>(</span><span class=n>model</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Data=</span><span class=si>%s</span><span class=s1>, Predicted: </span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>label</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div></div></div><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506193631974.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506193631974.png#center alt=image-20220506193631974 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><p>可以看到对数据集 <code>[5.3,3.9,3.2,2.3]</code> 预测为 <code>versicolor</code>，那将属性修改为，<code>[2.3,0.9,0.2,1.3]</code> 预测结果为 <code>setosa</code></p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506193805325.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220506193805325.png#center alt=image-20220506193805325 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><ul><li><a href=https://iq.opengenus.org/gaussian-naive-bayes/ target=_blank rel="noopener nofollow noreferrer">gaussian naive bayes</a></li><li><a href=https://www.varsity.co.uk/science/21149 target=_blank rel="noopener nofollow noreferrer">Naive Bayes Example</a></li><li><a href=https://www.omnicalculator.com/statistics/bayes-theorem target=_blank rel="noopener nofollow noreferrer">caculator naive bayes</a></li><li>[五分钟了解朴素贝叶斯](<a href=https://towardsdatascience.com/- target=_blank rel="noopener nofollow noreferrer">https://towardsdatascience.com/-</a> a-mathematical-explanation-of-naive-bayes-in-5-minutes-44adebcdb5f8)</li><li><a href=https://www.investopedia.com/terms/j/jointprobability.asp target=_blank rel="noopener nofollow noreferrer">Joint Probability</a></li><li><a href=https://www.investopedia.com/terms/c/conditional_probability.asp target=_blank rel="noopener nofollow noreferrer">Conditional Probability</a></li></ul></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：朴素贝叶斯算法</p><p>文章链接：<a href=https://www.oomkill.com/2022/06/naive-bayes/ target=_blank>https://www.oomkill.com/2022/06/naive-bayes/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2022/06/knn/><span>KNN算法</span></a></li><li><a href=/2022/06/decision-tree/><span>决策树</span></a></li><li><a href=/2022/06/decision-boundary/><span>决策边界算法</span></a></li><li><a href=/2022/06/logistic-regression/><span>逻辑回归</span></a></li><li><a href=/2016/09/consistent-hash/><span>一致性hash在memcache中的应用</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/machinelearning/>MachineLearning</a></li><li><a href=https://www.oomkill.com/tags/algorithm/>Algorithm</a></li><li><a href=https://www.oomkill.com/tags/cs/>CS</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2022/06/logistic-regression/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>逻辑回归</span>
</a><a class=next href=https://www.oomkill.com/2022/05/debian11-install-tutorial/><span class=title></span>
<span>安装Debian11 (bullseye) Step-by-Step&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/naive-bayes","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span><div class=busuanzi-footer style="font-family:helvetica neue,Helvetica,Arial,sans-serif;text-align:center;padding:4px 0;color:#999"><span id=busuanzi_container_site_pv style=margin-right:8px;font-size:.85em>本站总访问量<span id=busuanzi_value_site_pv style=font-weight:500>0</span>次
</span><span id=busuanzi_container_site_uv style=font-size:.85em>本站访客数<span id=busuanzi_value_site_uv style=font-weight:500>0</span>人次</span></div></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>