<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深入理解Kubernetes 4A - Authentication源码解析 | Cylon&#39;s Collection</title>
<meta name="keywords" content="ldap, kubernetes, kubernetes Authentication, k8s Authentication webhook, 4A">
<meta name="description" content="深入理解Kubernetes 4A - Authentication源码解析 - Cylon&#39;s Collection">
<meta name="author" content="cylon">
<link rel="canonical" href="https://www.oomkill.com/2022/11/ch31-authentication/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.41a8706089174fae1769fc26da4d1d354fa88083db604a95688ff58852dd9006.css" integrity="sha256-QahwYIkXT64Xafwm2k0dNU&#43;ogIPbYEqVaI/1iFLdkAY=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.oomkill.com/favicon.ico">
<link rel="apple-touch-icon" href="https://www.oomkill.com/apple-touch-icon.png">

<meta name="twitter:title" content="深入理解Kubernetes 4A - Authentication源码解析 | Cylon&#39;s Collection" />
<meta name="twitter:description" content="" />
<meta property="og:title" content="深入理解Kubernetes 4A - Authentication源码解析 | Cylon&#39;s Collection" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.oomkill.com/2022/11/ch31-authentication/" />
<meta property="article:section" content="posts" />
  <meta property="article:published_time" content="2022-11-16T00:00:00&#43;00:00" />
  <meta property="article:modified_time" content="2022-11-28T23:00:36&#43;08:00" />


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://www.oomkill.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "深入理解Kubernetes 4A - Authentication源码解析",
      "item": "https://www.oomkill.com/2022/11/ch31-authentication/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解Kubernetes 4A - Authentication源码解析 | Cylon's Collection",
  "name": "深入理解Kubernetes 4A - Authentication源码解析",
  "description": "",
  "keywords": [
    "ldap", "kubernetes", "kubernetes Authentication", "k8s Authentication webhook", "4A"
  ],
  "wordCount" : "7236",
  "inLanguage": "zh",
  "datePublished": "2022-11-16T00:00:00Z",
  "dateModified": "2022-11-28T23:00:36+08:00",
  "author":{
    "@type": "Person",
    "name": "cylon"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.oomkill.com/2022/11/ch31-authentication/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Cylon's Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.oomkill.com/favicon.ico"
    }
  }
}
</script><script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary-bg: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list-page {
                background: var(--theme);
            }

            .list-page:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list-page:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

</head>

<body class=" type-posts kind-page layout-" id="top"><script data-no-instant>
function switchTheme(theme) {
  switch (theme) {
    case 'light':
      document.body.classList.remove('dark');
      break;
    case 'dark':
      document.body.classList.add('dark');
      break;
    
    default:
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
      }
  }
}

function isDarkTheme() {
  return document.body.className.includes("dark");
}

function getPrefTheme() {
  return localStorage.getItem("pref-theme");
}

function setPrefTheme(theme) {
  switchTheme(theme)
  localStorage.setItem("pref-theme", theme);
}

const toggleThemeCallbacks = {}
toggleThemeCallbacks['main'] = (isDark) => {
  
  if (isDark) {
    setPrefTheme('light');
  } else {
    setPrefTheme('dark');
  }
}




window.addEventListener('toggle-theme', function() {
  
  const isDark = isDarkTheme()
  for (const key in toggleThemeCallbacks) {
    toggleThemeCallbacks[key](isDark)
  }
});


function toggleThemeListener() {
  
  window.dispatchEvent(new CustomEvent('toggle-theme'));
}

</script>
<script>
  
  (function() {
    const defaultTheme = 'auto';
    const prefTheme = getPrefTheme();
    const theme = prefTheme ? prefTheme : defaultTheme;

    switchTheme(theme);
  })();
</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.oomkill.com" accesskey="h" title="Cylon&#39;s Collection (Alt + H)">Cylon&#39;s Collection</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.oomkill.com/archives/" title="归档"
                >归档
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/tags/" title="标签"
                >标签
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/search/" title="搜索 (Alt &#43; /)"data-no-instant accesskey=/
                >搜索
                </a>
            </li>
            <li>
                <a href="https://www.oomkill.com/about/" title="关于"
                >关于
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main post">

<article class="post-single">
  <header class="post-header"><h1 class="post-title">深入理解Kubernetes 4A - Authentication源码解析</h1>
    <div class="post-meta"><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>2022-11-16</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select: text;"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select: text;"></rect><line x1="16" y1="2" x2="16" y2="6" style="user-select: text;"></line><line x1="8" y1="2" x2="8" y2="6" style="user-select: text;"></line><line x1="3" y1="10" x2="21" y2="10" style="user-select: text;"></line></svg>
  <span>Edited on 2022-11-28</span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon" style="user-select: text;"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z" style="user-select: text;"></path><line x1="7" y1="7" x2="7" y2="7" style="user-select: text;"></line></svg>
  <span class="post-tags"><a href="https://www.oomkill.com/tags/ldap/">ldap</a><a href="https://www.oomkill.com/tags/kubernetes/">kubernetes</a><a href="https://www.oomkill.com/tags/kubernetes-develop/">kubernetes develop</a></span></span><span class="meta-item">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><circle cx="12" cy="12" r="9"></circle><polyline points="12 7 12 12 15 15"></polyline></svg>
  <span>15 分钟</span></span>

      
      
    </div>
  </header> <div class="toc side right">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#overview" aria-label="Overview">Overview</a></li>
                <li>
                    <a href="#kubernetes-%e8%ae%a4%e8%af%81" aria-label="Kubernetes 认证">Kubernetes 认证</a></li>
                <li>
                    <a href="#%e5%90%91%e5%a4%96%e9%83%a8%e7%94%a8%e6%88%b7%e6%8e%88%e6%9d%83%e9%9b%86%e7%be%a4%e8%ae%bf%e9%97%ae%e7%9a%84%e7%a4%ba%e4%be%8b" aria-label="向外部用户授权集群访问的示例">向外部用户授权集群访问的示例</a><ul>
                        
                <li>
                    <a href="#%e5%9c%ba%e6%99%af1%e9%80%9a%e8%bf%87%e8%af%81%e4%b9%a6%e8%af%b7%e6%b1%82k8s" aria-label="场景1：通过证书请求k8s">场景1：通过证书请求k8s</a></li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af2%e9%80%9a%e8%bf%87token" aria-label="场景2：通过token">场景2：通过token</a></li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af3serviceaccount" aria-label="场景3：serviceaccount">场景3：serviceaccount</a></li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af4openid" aria-label="场景4：openid">场景4：openid</a></li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af5webhook" aria-label="场景5：webhook">场景5：webhook</a></li>
                <li>
                    <a href="#%e5%9c%ba%e6%99%af6%e4%bb%a3%e7%90%86%e8%ae%a4%e8%af%81" aria-label="场景6：代理认证">场景6：代理认证</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e5%9f%ba%e4%ba%8eldap%e7%9a%84%e8%ba%ab%e4%bb%bd%e8%ae%a4%e8%af%81" aria-label="实验：基于LDAP的身份认证">实验：基于LDAP的身份认证</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e7%8e%af%e5%a2%83" aria-label="实验环境">实验环境</a></li>
                <li>
                    <a href="#%e5%ae%9e%e9%aa%8c%e5%bc%80%e5%a7%8b" aria-label="实验开始">实验开始</a><ul>
                        
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%94%a8%e6%88%b7%e6%95%b0%e6%8d%ae" aria-label="初始化用户数据">初始化用户数据</a></li>
                <li>
                    <a href="#%e7%bc%96%e5%86%99webhook%e6%9f%a5%e8%af%a2%e7%94%a8%e6%88%b7%e9%83%a8%e5%88%86" aria-label="编写webhook查询用户部分">编写webhook查询用户部分</a></li>
                <li>
                    <a href="#%e7%bc%96%e5%86%99http%e9%83%a8%e5%88%86" aria-label="编写HTTP部分">编写HTTP部分</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%83%a8%e7%bd%b2webhook" aria-label="部署webhook">部署webhook</a></li>
                <li>
                    <a href="#%e9%aa%8c%e8%af%81%e7%bb%93%e6%9e%9c" aria-label="验证结果">验证结果</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#reference" aria-label="Reference">Reference</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content">
    





<div class="copyrightTopBlock">
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <div class="articleSuffix-bg"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
</div>
<br><h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">¶</a></h2>
<blockquote>
<p>本文是关于Kubernetes 4A解析的第一章</p>
<ul>
<li>深入理解Kubernetes 4A - Authentication源码解析</li>
<li><a href="https://cylonchau.github.io/kubernetes-authorization.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Authorization源码解析</a></li>
<li><a href="https://cylonchau.github.io/ch3.7-admission-webhook.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Admission Control源码解析</a></li>
<li><a href="https://cylonchau.github.io/kubernetes-auditing.html" target="_blank"
   rel="noopener nofollow noreferrer" >深入理解Kubernetes 4A - Audit源码解析</a></li>
</ul>
<p>所有关于Kubernetes 4A部分代码上传至仓库 github.com/cylonchau/hello-k8s-4A</p>
</blockquote>
<p>本章主要简单阐述kubernetes 认证相关原理，最后以实验来阐述kubernetes用户系统的思路</p>
<p><strong>objective</strong>：</p>
<ul>
<li>了解kubernetes 各种认证机制的原理</li>
<li>了解kubernetes 用户的概念</li>
<li>了解kubernetes authentication webhook</li>
<li>完成实验，如何将其他用户系统接入到kubernetes中的一个思路</li>
</ul>
<p>如有错别字或理解错误地方请多多担待，代码是以1.24进行整理，实验是以1.19环境进行，差别不大。</p>
<h2 id="kubernetes-认证">Kubernetes 认证<a hidden class="anchor" aria-hidden="true" href="#kubernetes-认证">¶</a></h2>
<p>在Kubernetes apiserver对于认证部分所描述的，对于所有用户访问Kubernetes API（通过任何客户端，客户端库，<code>kubectl</code> 等）时都会经历 验证 (<em><strong>Authentication</strong></em>) , 授权 (<em><strong>Authorization</strong></em>), 和准入控制 (<em><strong>Admission control</strong></em>) 三个阶段来完成对 “用户” 进行授权，整个流程正如下图所示</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/vhesGDFN3dLdzXwS7vzPdXkI3aglQYZgGhjc-Cx_boaV6URKFFoe8mFRZZUuJyGHywa_bOkeUlIkm-nJkCVMHPk9dr2dXFwNzAQJKzft2phsTcEDjdObjmugBcYtpdPLpLIYuIGzeFYvtsR2Lw.jpeg" alt="image-20221025003822017" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Kubernetes API 请求的请求处理步骤图</center>
<center><em>Source：</em>https://www.armosec.io/blog/kubernetes-admission-controller/</center><br>
<p>其中在大多数教程中，在对这三个阶段所做的工作大致上为：</p>
<ul>
<li>
<p><em><strong>Authentication</strong></em> 阶段所指用于确认请求访问Kubernetes API 用户是否为合法用户，拒绝为401</p>
</li>
<li>
<p><em><strong>Authorization</strong></em> 阶段所指的将是这个用户是否有对操作的资源的权限，拒绝为403</p>
</li>
<li>
<p><em><strong>Admission control</strong></em> 阶段所指控制对请求资源进行控制，通俗来说，就是一票否决权，即使前两个步骤完成</p>
</li>
</ul>
<p>到这里了解到了Kubernetes API实际上做的工作就是 “人类用户” 与 “kubernetes service account&quot; <sup><a href="#2">[2]</a></sup>；那么就引出了一个重要概念就是 “用户” 在Kubernetes中是什么，以及用户在认证中的也是本章节的中心。</p>
<p>在Kubernetes官方手册中给出了 ”用户“ 的概念，Kubernetes集群中存在的用户包括 ”普通用户“ 与 “service account” 但是 Kubernetes 没有普通用户的管理方式，只是将使用集群的证书CA签署的有效证书的用户都被视为合法用户 <sup><a href="#3">[3]</a></sup></p>
<p>那么对于使得Kubernetes集群有一个真正的用户系统，就可以根据上面给出的概念将Kubernetes用户分为 ”外部用户“ 与 ”内部用户“。如何理解外部与内部用户呢？实际上就是有Kubernetes管理的用户，即在kubernetes定义用户的数据模型这种为 “内部用户” ，正如 service account；反之，非Kubernetes托管的用户则为 ”外部用户“ 这中概念也更好的对kubernetes用户的阐述。</p>
<p>对于外部用户来说，实际上Kubernetes给出了多种用户概念 <sup><a href="#3">[3]</a></sup>，例如：</p>
<ul>
<li>拥有kubernetes集群证书的用户</li>
<li>拥有Kubernetes集群token的用户（<code>--token-auth-file</code> 指定的静态token）</li>
<li>用户来自外部用户系统，例如 <em>OpenID</em>，<em>LDAP</em>，<em>QQ connect</em>, <em>google identity platform</em> 等</li>
</ul>
<h2 id="向外部用户授权集群访问的示例">向外部用户授权集群访问的示例<a hidden class="anchor" aria-hidden="true" href="#向外部用户授权集群访问的示例">¶</a></h2>
<h3 id="场景1通过证书请求k8s">场景1：通过证书请求k8s<a hidden class="anchor" aria-hidden="true" href="#场景1通过证书请求k8s">¶</a></h3>
<p>该场景中kubernetes将使用证书中的cn作为用户，ou作为组，如果对应 <code>rolebinding/clusterrolebinding</code> 给予该用户权限，那么请求为合法</p>
<pre><code class="language-bash">$ curl https://hostname:6443/api/v1/pods \
	--cert ./client.pem \
	--key ./client-key.pem \
	--cacert ./ca.pem 
</code></pre>
<p>接下来浅析下在代码中做的事情</p>
<p>确认用户是 <em><strong>apiserver</strong></em> 在 <em><strong>Authentication</strong></em> 阶段 做的事情，而对应代码在 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator</a> 下，整个文件就是构建了一系列的认证器，而x.509证书指是其中一个</p>
<pre><code class="language-go">// 创建一个认证器，返回请求或一个k8s认证机制的标准错误
func (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, error) {
    
...

	// X509 methods
    // 可以看到这里就是将x509证书解析为user
	if config.ClientCAContentProvider != nil {
		certAuth := x509.NewDynamic(config.ClientCAContentProvider.VerifyOptions, x509.CommonNameUserConversion)
		authenticators = append(authenticators, certAuth)
	}
...
</code></pre>
<p>接下来看实现原理，NewDynamic函数位于代码 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/request/x509/x509.go#L126-L130" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/request/x509/x509.go</a></p>
<p>通过代码可以看出，是通过一个验证函数与用户来解析为一个 <em>Authenticator</em></p>
<pre><code class="language-go">// NewDynamic returns a request.Authenticator that verifies client certificates using the provided
// VerifyOptionFunc (which may be dynamic), and converts valid certificate chains into user.Info using the provided UserConversion
func NewDynamic(verifyOptionsFn VerifyOptionFunc, user UserConversion) *Authenticator {
	return &amp;Authenticator{verifyOptionsFn, user}
}
</code></pre>
<p>验证函数为 CAContentProvider 的方法，而x509部分实现为 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/server/dynamiccertificates/dynamic_cafile_content.go#L253-L261" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/server/dynamiccertificates/dynamic_cafile_content.go.VerifyOptions</a>；可以看出返回是一个 <code>x509.VerifyOptions</code> + 与认证的状态</p>
<pre><code class="language-go">// VerifyOptions provides verifyoptions compatible with authenticators
func (c *DynamicFileCAContent) VerifyOptions() (x509.VerifyOptions, bool) {
	uncastObj := c.caBundle.Load()
	if uncastObj == nil {
		return x509.VerifyOptions{}, false
	}

	return uncastObj.(*caBundleAndVerifier).verifyOptions, true
}
</code></pre>
<p>而用户的获取则位于  <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/request/x509/x509.go#L248-L258" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/request/x509/x509.go</a>；可以看出，用户正是拿的证书的CN，而组则是为证书的OU</p>
<pre><code class="language-go">// CommonNameUserConversion builds user info from a certificate chain using the subject's CommonName
var CommonNameUserConversion = UserConversionFunc(func(chain []*x509.Certificate) (*authenticator.Response, bool, error) {
	if len(chain[0].Subject.CommonName) == 0 {
		return nil, false, nil
	}
	return &amp;authenticator.Response{
		User: &amp;user.DefaultInfo{
			Name:   chain[0].Subject.CommonName,
			Groups: chain[0].Subject.Organization,
		},
	}, true, nil
})
</code></pre>
<p>由于授权不在本章范围内，直接忽略至入库阶段，入库阶段由 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/pkg/controlplane/instance.go#L561" target="_blank"
   rel="noopener nofollow noreferrer" >RESTStorageProvider</a> 实现 这里，每一个Provider都提供了 <code>Authenticator</code> 这里包含了已经允许的请求，将会被对应的REST客户端写入到库中</p>
<pre><code class="language-go">type RESTStorageProvider struct {
	Authenticator authenticator.Request
	APIAudiences  authenticator.Audiences
}
// RESTStorageProvider is a factory type for REST storage.
type RESTStorageProvider interface {
	GroupName() string
	NewRESTStorage(apiResourceConfigSource serverstorage.APIResourceConfigSource, restOptionsGetter generic.RESTOptionsGetter) (genericapiserver.APIGroupInfo, error)
}
</code></pre>
<h3 id="场景2通过token">场景2：通过token<a hidden class="anchor" aria-hidden="true" href="#场景2通过token">¶</a></h3>
<p>该场景中，当 <em><strong>kube-apiserver</strong></em> 开启了 <code>--enable-bootstrap-token-auth</code> 时，就可以使用 Bootstrap Token 进行认证，通常如下列命令，在请求头中增加 <code>Authorization: Bearer &lt;token&gt;</code> 标识</p>
<pre><code class="language-bash">$ curl https://hostname:6443/api/v1/pods \
  --cacert ${CACERT} \
  --header &quot;Authorization: Bearer &lt;token&gt;&quot; \
</code></pre>
<p>接下来浅析下在代码中做的事情</p>
<p>可以看到，在代码 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator.New()</a> 中当 <em><strong>kube-apiserver</strong></em> 指定了参数 <code>--token-auth-file=/etc/kubernetes/token.csv&quot;</code> 这种认证会被激活</p>
<pre><code class="language-go">if len(config.TokenAuthFile) &gt; 0 {
    tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))
}
</code></pre>
<p>此时打开 token.csv 查看下token长什么样</p>
<pre><code class="language-bash">$ cat /etc/kubernetes/token.csv
12ba4f.d82a57a4433b2359,&quot;system:bootstrapper&quot;,10001,&quot;system:bootstrappers&quot;
</code></pre>
<p>这里回到代码 <a href="https://github.com/kubernetes/kubernetes/blob/fdc77503e954d1ee641c0e350481f7528e8d068b/staging/src/k8s.io/apiserver/pkg/authentication/token/tokenfile/tokenfile.go#L45-L91" target="_blank"
   rel="noopener nofollow noreferrer" >k8s.io/apiserver/pkg/authentication/token/tokenfile/tokenfile.go.NewCSV</a> ，这里可以看出，就是读取 <code>--token-auth-file=</code> 参数指定的tokenfile，然后解析为用户，<code>record[1]</code> 作为用户名，<code>record[2]</code> 作为UID</p>
<pre><code class="language-go">// NewCSV returns a TokenAuthenticator, populated from a CSV file.
// The CSV file must contain records in the format &quot;token,username,useruid&quot;
func NewCSV(path string) (*TokenAuthenticator, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	recordNum := 0
	tokens := make(map[string]*user.DefaultInfo)
	reader := csv.NewReader(file)
	reader.FieldsPerRecord = -1
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, err
		}
		if len(record) &lt; 3 {
			return nil, fmt.Errorf(&quot;token file '%s' must have at least 3 columns (token, user name, user uid), found %d&quot;, path, len(record))
		}

		recordNum++
		if record[0] == &quot;&quot; {
			klog.Warningf(&quot;empty token has been found in token file '%s', record number '%d'&quot;, path, recordNum)
			continue
		}

		obj := &amp;user.DefaultInfo{
			Name: record[1],
			UID:  record[2],
		}
		if _, exist := tokens[record[0]]; exist {
			klog.Warningf(&quot;duplicate token has been found in token file '%s', record number '%d'&quot;, path, recordNum)
		}
		tokens[record[0]] = obj

		if len(record) &gt;= 4 {
			obj.Groups = strings.Split(record[3], &quot;,&quot;)
		}
	}

	return &amp;TokenAuthenticator{
		tokens: tokens,
	}, nil
}
</code></pre>
<p>而token file中配置的格式正是以逗号分隔的一组字符串，</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<p>这种用户最常见的方式就是 <em><strong>kubelet</strong></em> 通常会以此类用户向控制平面进行身份认证，例如下列配置</p>
<pre><code class="language-bash">KUBELET_ARGS=&quot;--v=0 \
    --logtostderr=true \
    --config=/etc/kubernetes/kubelet-config.yaml \
    --kubeconfig=/etc/kubernetes/auth/kubelet.conf \
    --network-plugin=cni \
    --pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.1 \
    --bootstrap-kubeconfig=/etc/kubernetes/auth/bootstrap.conf&quot;
</code></pre>
<p><code>/etc/kubernetes/auth/bootstrap.conf</code> 内容，这里就用到了 <em><strong>kube-apiserver</strong></em> 配置的 <code>--token-auth-file=</code> 用户名，组必须为 <code>system:bootstrappers</code></p>
<pre><code class="language-yaml">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: ......
    server: https://10.0.0.4:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: system:bootstrapper
  name: system:bootstrapper@kubernetes
current-context: system:bootstrapper@kubernetes
kind: Config
preferences: {}
users:
- name: system:bootstrapper
</code></pre>
<p>而通常在二进制部署时会出现的问题，例如下列错误</p>
<pre><code class="language-log">Unable to register node &quot;hostname&quot; with API server: nodes is forbidden: User &quot;system:anonymous&quot; cannot create resource &quot;nodes&quot; in API group &quot;&quot; at the cluster scope
</code></pre>
<p>而通常解决方法是执行下列命令，这里就是将 <em><strong>kubelet</strong></em> 与 <em><strong>kube-apiserver</strong></em> 通讯时的用户授权，因为kubernetes官方给出的条件是，用户组必须为 <code>system:bootstrappers</code>  <sup><a href="#4">[4]</a></sup></p>
<pre><code class="language-bash">$ kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --group=system:bootstrappers
</code></pre>
<p>生成的clusterrolebinding 如下</p>
<pre><code class="language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  creationTimestamp: &quot;2022-08-14T22:26:51Z&quot;
  managedFields:
  - apiVersion: rbac.authorization.k8s.io/v1
    fieldsType: FieldsV1
   ...
    time: &quot;2022-08-14T22:26:51Z&quot;
  name: kubelet-bootstrap
  resourceVersion: &quot;158&quot;
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/kubelet-bootstrap
  uid: b4d70f4f-4ae0-468f-86b7-55e9351e4719
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:node-bootstrapper
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:bootstrappers
</code></pre>
<p>上述就是 bootstrap token，翻译后就是引导token，因为其做的工作就是将节点载入Kubernetes系统过程提供认证机制的用户。</p>
<blockquote>
<p>Notes：这种用户不存在与kubernetes内，可以算属于一个外部用户，但认证机制中存在并绑定了最高权限，也可以用来做其他访问时的认证</p>
</blockquote>
<h3 id="场景3serviceaccount">场景3：serviceaccount<a hidden class="anchor" aria-hidden="true" href="#场景3serviceaccount">¶</a></h3>
<p>serviceaccount通常为API自动创建的，但在用户中，实际上认证存在两个方向，一个是 <code>--service-account-key-file</code> 这个参数可以指定多个，指定对应的证书文件公钥或私钥，用以办法sa的token</p>
<p>首先会根据指定的公钥或私钥文件生成token</p>
<pre><code class="language-go">if len(config.ServiceAccountKeyFiles) &gt; 0 {
    serviceAccountAuth, err := newLegacyServiceAccountAuthenticator(config.ServiceAccountKeyFiles, config.ServiceAccountLookup, config.APIAudiences, config.ServiceAccountTokenGetter)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
}
if len(config.ServiceAccountIssuers) &gt; 0 {
    serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountIssuers, config.ServiceAccountKeyFiles, config.APIAudiences, config.ServiceAccountTokenGetter)
    if err != nil {
        return nil, nil, err
    }
    tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
}
</code></pre>
<p>对于  <code>--service-account-key-file</code>  他生成的用户都是 “kubernetes/serviceaccount”  , 而对于 <code>--service-account-issuer</code> 只是对sa颁发者提供了一个称号标识是谁，而不是统一的 “kubernetes/serviceaccount” ，这里可以从代码中看到，两者是完全相同的，只是称号不同罢了</p>
<pre><code class="language-go">// newLegacyServiceAccountAuthenticator returns an authenticator.Token or an error
func newLegacyServiceAccountAuthenticator(keyfiles []string, lookup bool, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
	allPublicKeys := []interface{}{}
	for _, keyfile := range keyfiles {
		publicKeys, err := keyutil.PublicKeysFromFile(keyfile)
		if err != nil {
			return nil, err
		}
		allPublicKeys = append(allPublicKeys, publicKeys...)
	}
// 唯一的区别 这里使用了常量 serviceaccount.LegacyIssuer
	tokenAuthenticator := serviceaccount.JWTTokenAuthenticator([]string{serviceaccount.LegacyIssuer}, allPublicKeys, apiAudiences, serviceaccount.NewLegacyValidator(lookup, serviceAccountGetter))
	return tokenAuthenticator, nil
}

// newServiceAccountAuthenticator returns an authenticator.Token or an error
func newServiceAccountAuthenticator(issuers []string, keyfiles []string, apiAudiences authenticator.Audiences, serviceAccountGetter serviceaccount.ServiceAccountTokenGetter) (authenticator.Token, error) {
	allPublicKeys := []interface{}{}
	for _, keyfile := range keyfiles {
		publicKeys, err := keyutil.PublicKeysFromFile(keyfile)
		if err != nil {
			return nil, err
		}
		allPublicKeys = append(allPublicKeys, publicKeys...)
	}
// 唯一的区别 这里根据kube-apiserver提供的称号指定名称
	tokenAuthenticator := serviceaccount.JWTTokenAuthenticator(issuers, allPublicKeys, apiAudiences, serviceaccount.NewValidator(serviceAccountGetter))
	return tokenAuthenticator, nil
}
</code></pre>
<p>最后根据ServiceAccounts，Secrets等值签发一个token，也就是通过下列命令获取的值</p>
<pre><code class="language-go">$ kubectl get secret multus-token-v6bfg -n kube-system -o jsonpath={&quot;.data.token&quot;}
</code></pre>
<h3 id="场景4openid">场景4：openid<a hidden class="anchor" aria-hidden="true" href="#场景4openid">¶</a></h3>
<p>OpenID Connect是 OAuth2 风格，允许用户授权三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，下面是一张kubernetes 使用 OID 认证的逻辑图</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/kube-login-oidc-ad4caf57f124e622897e0781fe1e3d6e1ecb5c6099776e6677ca800c4458f1de.jpg" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：Kubernetes OID认证</center>
<center><em>Source：</em>https://developer.okta.com/blog/2021/11/08/k8s-api-server-oidc</center><br>
<h3 id="场景5webhook">场景5：webhook<a hidden class="anchor" aria-hidden="true" href="#场景5webhook">¶</a></h3>
<p>webhook是kubernetes提供自定义认证的其中一种，主要是用于认证 “<em><strong>不记名 token</strong></em>“ 的钩子，“<em><strong>不记名 token</strong></em>“ 将 由身份验证服务创建。当用户对kubernetes访问时，会触发准入控制，当对kubernetes集群注册了 authenticaion webhook时，将会使用该webhook提供的方式进行身份验证时，此时会为您生成一个 token 。</p>
<p>如代码 <a href="pkg/kubeapiserver/authenticator">pkg/kubeapiserver/authenticator.New()</a>  中所示 newWebhookTokenAuthenticator 会通过提供的config (<code>--authentication-token-webhook-config-file</code>) 来创建出一个 WebhookTokenAuthenticator</p>
<pre><code class="language-go">if len(config.WebhookTokenAuthnConfigFile) &gt; 0 {
    webhookTokenAuth, err := newWebhookTokenAuthenticator(config)
    if err != nil {
        return nil, nil, err
    }

    tokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)
}
</code></pre>
<p>下图是kubernetes 中 WebhookToken 验证的工作原理</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/25d075712ff343ce492a5db30733cd93.svg" alt="Webhook 令牌认证插件" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center>图：kubernetes WebhookToken验证原理</center>
<center><em>Source：</em>https://learnk8s.io/kubernetes-custom-authentication</center><br>
<p>最后由token中的authHandler，循环所有的Handlers在运行 <code>AuthenticateToken</code> 去进行获取用户的信息</p>
<pre><code class="language-go">func (authHandler *unionAuthTokenHandler) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {
   var errlist []error
   for _, currAuthRequestHandler := range authHandler.Handlers {
      info, ok, err := currAuthRequestHandler.AuthenticateToken(ctx, token)
      if err != nil {
         if authHandler.FailOnError {
            return info, ok, err
         }
         errlist = append(errlist, err)
         continue
      }

      if ok {
         return info, ok, err
      }
   }

   return nil, false, utilerrors.NewAggregate(errlist)
}
</code></pre>
<p>而webhook插件也实现了这个方法 <code>AuthenticateToken</code> ,这里会通过POST请求，调用注入的webhook，该请求携带一个JSON 格式的 <code>TokenReview</code> 对象，其中包含要验证的令牌</p>
<pre><code class="language-go">func (w *WebhookTokenAuthenticator) AuthenticateToken(ctx context.Context, token string) (*authenticator.Response, bool, error) {

    ....

		start := time.Now()
		result, statusCode, tokenReviewErr = w.tokenReview.Create(ctx, r, metav1.CreateOptions{})
		latency := time.Since(start)
...
}
</code></pre>
<p>webhook token认证服务要返回<a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#userinfo-v1beta1-authentication-k8s-io" target="_blank"
   rel="noopener nofollow noreferrer" >用户的身份信息</a>，就是上面token部分提到的数据结构（webhook来决定接受还是拒绝该用户）</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<h3 id="场景6代理认证">场景6：代理认证<a hidden class="anchor" aria-hidden="true" href="#场景6代理认证">¶</a></h3>
<h2 id="实验基于ldap的身份认证">实验：基于LDAP的身份认证<a hidden class="anchor" aria-hidden="true" href="#实验基于ldap的身份认证">¶</a></h2>
<p>通过上面阐述，大致了解到kubernetes认证框架中的用户的分类以及认证的策略由哪些，实验的目的也是为了阐述一个结果，就是使用OIDC/webhook 是比其他方式更好的保护，管理kubernetes集群。首先在安全上，假设网络环境是不安全的，那么任意node节点遗漏 bootstrap token文件，就意味着拥有了集群中最高权限；其次在管理上，越大的团队，人数越多，不可能每个用户都提供单独的证书或者token，要知道传统教程中讲到token在kubernetes集群中是永久有效的，除非你删除了这个secret/sa；而Kubernetes提供的插件就很好的解决了这些问题。</p>
<h3 id="实验环境">实验环境<a hidden class="anchor" aria-hidden="true" href="#实验环境">¶</a></h3>
<ul>
<li>一个kubernetes集群</li>
<li>一个openldap服务，建议可以是集群外部的，因为webhook不像SSSD有缓存机制，并且集群不可用，那么认证不可用，当认证不可用时会导致集群不可用，这样事故影响的范围可以得到控制，也叫最小化半径</li>
<li>了解ldap相关技术，并了解go ldap客户端</li>
</ul>
<p><strong>实验大致分为以下几个步骤</strong>：</p>
<ul>
<li>建立一个HTTP服务器用于返回给kubernetes Authenticaion服务</li>
<li>查询ldap该用户是否合法
<ul>
<li>查询用户是否合法</li>
<li>查询用户所属组是否拥有权限</li>
</ul>
</li>
</ul>
<h3 id="实验开始">实验开始<a hidden class="anchor" aria-hidden="true" href="#实验开始">¶</a></h3>
<h4 id="初始化用户数据">初始化用户数据<a hidden class="anchor" aria-hidden="true" href="#初始化用户数据">¶</a></h4>
<p>首先准备openldap初始化数据，创建三个 posixGroup 组，与5个用户 admin, admin1, admin11, searchUser, syncUser 密码均为111，组与用户关联使用的 <code>memberUid</code></p>
<pre><code class="language-bash">cat &lt;&lt; EOF | ldapdelete -r  -H ldap://10.0.0.3 -D &quot;cn=admin,dc=test,dc=com&quot; -w 111
dn: dc=test,dc=com
objectClass: top
objectClass: organizationalUnit
objectClass: extensibleObject
description: US Organization
ou: people

dn: ou=tvb,dc=test,dc=com
objectClass: organizationalUnit
description: Television Broadcasts Limited
ou: tvb

dn: cn=admin,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10000
cn: admin

dn: cn=conf,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10001
cn: conf

dn: cn=dir,ou=tvb,dc=test,dc=com
objectClass: posixGroup
gidNumber: 10002
cn: dir

dn: uid=syncUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: syncUser
cn: syncUser
uidNumber: 10006
gidNumber: 10002
homeDirectory: /home/syncUser
loginShell: /bin/bash
sn: syncUser
givenName: syncUser
memberOf: cn=confGroup,ou=tvb,dc=test,dc=com

dn: uid=searchUser,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: searchUser
cn: searchUser
uidNumber: 10005
gidNumber: 10001
homeDirectory: /home/searchUser
loginShell: /bin/bash
sn: searchUser
givenName: searchUser
memberOf: cn=dirGroup,ou=tvb,dc=test,dc=com

dn: uid=admin1,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: admin1
sn: admin1
cn: admin
uidNumber: 10010
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin11,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
sn: admin11
pwdAttribute: userPassword
uid: admin11
cn: admin11
uidNumber: 10011
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
givenName: admin11
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com

dn: uid=admin,ou=tvb,dc=test,dc=com
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: posixAccount
objectClass: shadowAccount
objectClass: pwdPolicy
pwdAttribute: userPassword
uid: admin
cn: admin
uidNumber: 10009
gidNumber: 10000
homeDirectory: /home/admin
loginShell: /bin/bash
sn: admin
givenName: admin
memberOf: cn=adminGroup,ou=tvb,dc=test,dc=com
EOF
</code></pre>
<p>接下来需要确定如何为认证成功的用户，上面讲到对于kubernetes中用户格式为 <code>v1.UserInfo</code> 的格式，即要获得用户，即用户组，假设需要查找的用户为，admin，那么在openldap中查询filter如下：</p>
<pre><code class="language-bash">&quot;(|(&amp;(objectClass=posixAccount)(uid=admin))(&amp;(objectClass=posixGroup)(memberUid=admin)))&quot;
</code></pre>
<p>上面语句意思是，找到 <code>objectClass=posixAccount</code> 并且 <code>uid=admin</code> 或者 <code>objectClass=posixGroup</code> 并且 <code>memberUid=admin</code> 的条目信息，这里使用 ”|“ 与 ”&amp;“ 是为了要拿到这两个结果。</p>
<h4 id="编写webhook查询用户部分">编写webhook查询用户部分<a hidden class="anchor" aria-hidden="true" href="#编写webhook查询用户部分">¶</a></h4>
<p>这里由于openldap配置密码保存格式不是明文的，如果直接使用 ”=“ 来验证是查询不到内容的，故直接多用了一次登录来验证用户是否合法</p>
<pre><code class="language-go">func ldapSearch(username, password string) (*v1.UserInfo, error) {
	ldapconn, err := ldap.DialURL(ldapURL)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}
	defer ldapconn.Close()

	// Authenticate as LDAP admin user
	err = ldapconn.Bind(&quot;uid=searchUser,ou=tvb,dc=test,dc=com&quot;, &quot;111&quot;)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	// Execute LDAP Search request
	result, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixGroup)(memberUid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	userResult, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixAccount)(uid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	if len(result.Entries) == 0 {
		klog.V(3).Info(&quot;User does not exist&quot;)
		return nil, errors.New(&quot;User does not exist&quot;)
	} else {
		// 验证用户名密码是否正确
		if err := ldapconn.Bind(userResult.Entries[0].DN, password); err != nil {
			e := fmt.Sprintf(&quot;Failed to auth. %s\n&quot;, err)
			klog.V(3).Info(e)
			return nil, errors.New(e)
		} else {
			klog.V(3).Info(fmt.Sprintf(&quot;User %s Authenticated successfuly!&quot;, username))
		}
		// 拼接为kubernetes authentication 的用户格式
		user := new(v1.UserInfo)
		for _, v := range result.Entries {
			attrubute := v.GetAttributeValue(&quot;objectClass&quot;)
			if strings.Contains(attrubute, &quot;posixGroup&quot;) {
				user.Groups = append(user.Groups, v.GetAttributeValue(&quot;cn&quot;))
			}
		}

		u := userResult.Entries[0].GetAttributeValue(&quot;uid&quot;)
		user.UID = u
		user.Username = u
		return user, nil
	}
}
</code></pre>
<h4 id="编写http部分">编写HTTP部分<a hidden class="anchor" aria-hidden="true" href="#编写http部分">¶</a></h4>
<p>这里有几个需要注意的部分，即用户或者理解为要认证的token的定义，此处使用了 ”username@password“ 格式作为用户的辨别，即登录kubernetes时需要直接输入 ”username@password“ 来作为登录的凭据。</p>
<p>第二个部分为返回值，返回给Kubernetes的格式必须为 <code>api/authentication/v1.TokenReview</code> 格式，<code>Status.Authenticated</code> 表示用户身份验证结果，如果该用户合法，则设置 <code>tokenReview.Status.Authenticated = true</code> 反之亦然。如果验证成功还需要 <code>Status.User</code> 这就是在<code>ldapSearch</code></p>
<pre><code class="language-go">func serve(w http.ResponseWriter, r *http.Request) {
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		httpError(w, err)
		return
	}
	klog.V(4).Info(&quot;Receiving: %s\n&quot;, string(b))

	var tokenReview v1.TokenReview
	err = json.Unmarshal(b, &amp;tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}

	// 提取用户名与密码
	s := strings.SplitN(tokenReview.Spec.Token, &quot;@&quot;, 2)
	if len(s) != 2 {
		klog.V(3).Info(fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		httpError(w, fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		return
	}
	username, password := s[0], s[1]
	// 查询ldap，验证用户是否合法
	userInfo, err := ldapSearch(username, password)
	if err != nil {
		// 这里不打印日志的原因是 ldapSearch 中打印过了
		return
	}

	// 设置返回的tokenReview
	if userInfo == nil {
		tokenReview.Status.Authenticated = false
	} else {
		tokenReview.Status.Authenticated = true
		tokenReview.Status.User = *userInfo
	}

	b, err = json.Marshal(tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}
	w.Write(b)
	klog.V(3).Info(&quot;Returning: &quot;, string(b))
}

func httpError(w http.ResponseWriter, err error) {
	err = fmt.Errorf(&quot;Error: %v&quot;, err)
	w.WriteHeader(http.StatusInternalServerError) // 500
	fmt.Fprintln(w, err)
	klog.V(4).Info(&quot;httpcode 500: &quot;, err)
}
</code></pre>
<p>下面是完整的代码</p>
<pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;errors&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;io/ioutil&quot;
	&quot;net/http&quot;
	&quot;strings&quot;

	&quot;github.com/go-ldap/ldap&quot;
	&quot;k8s.io/api/authentication/v1&quot;
	&quot;k8s.io/klog/v2&quot;
)

var ldapURL string

func main() {
	klog.InitFlags(nil)
	flag.Parse()
	http.HandleFunc(&quot;/authenticate&quot;, serve)
	klog.V(4).Info(&quot;Listening on port 443 waiting for requests...&quot;)
	klog.V(4).Info(http.ListenAndServe(&quot;:443&quot;, nil))
	ldapURL = &quot;ldap://10.0.0.10:389&quot;
	ldapSearch(&quot;admin&quot;, &quot;1111&quot;)
}

func serve(w http.ResponseWriter, r *http.Request) {
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		httpError(w, err)
		return
	}
	klog.V(4).Info(&quot;Receiving: %s\n&quot;, string(b))

	var tokenReview v1.TokenReview
	err = json.Unmarshal(b, &amp;tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}

	// 提取用户名与密码
	s := strings.SplitN(tokenReview.Spec.Token, &quot;@&quot;, 2)
	if len(s) != 2 {
		klog.V(3).Info(fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		httpError(w, fmt.Errorf(&quot;badly formatted token: %s&quot;, tokenReview.Spec.Token))
		return
	}
	username, password := s[0], s[1]
	// 查询ldap，验证用户是否合法
	userInfo, err := ldapSearch(username, password)
	if err != nil {
		// 这里不打印日志的原因是 ldapSearch 中打印过了
		return
	}

	// 设置返回的tokenReview
	if userInfo == nil {
		tokenReview.Status.Authenticated = false
	} else {
		tokenReview.Status.Authenticated = true
		tokenReview.Status.User = *userInfo
	}

	b, err = json.Marshal(tokenReview)
	if err != nil {
		klog.V(3).Info(&quot;Json convert err: &quot;, err)
		httpError(w, err)
		return
	}
	w.Write(b)
	klog.V(3).Info(&quot;Returning: &quot;, string(b))
}

func httpError(w http.ResponseWriter, err error) {
	err = fmt.Errorf(&quot;Error: %v&quot;, err)
	w.WriteHeader(http.StatusInternalServerError) // 500
	fmt.Fprintln(w, err)
	klog.V(4).Info(&quot;httpcode 500: &quot;, err)
}

func ldapSearch(username, password string) (*v1.UserInfo, error) {

	ldapconn, err := ldap.DialURL(ldapURL)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}
	defer ldapconn.Close()

	// Authenticate as LDAP admin user
	err = ldapconn.Bind(&quot;cn=admin,dc=test,dc=com&quot;, &quot;111&quot;)
	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	// Execute LDAP Search request
	result, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixGroup)(memberUid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	userResult, err := ldapconn.Search(ldap.NewSearchRequest(
		&quot;ou=tvb,dc=test,dc=com&quot;,
		ldap.ScopeWholeSubtree,
		ldap.NeverDerefAliases,
		0,
		0,
		false,
		fmt.Sprintf(&quot;(&amp;(objectClass=posixAccount)(uid=%s))&quot;, username), // Filter
		nil,
		nil,
	))

	if err != nil {
		klog.V(3).Info(err)
		return nil, err
	}

	if len(result.Entries) == 0 {
		klog.V(3).Info(&quot;User does not exist&quot;)
		return nil, errors.New(&quot;User does not exist&quot;)
	} else {
		// 验证用户名密码是否正确
		if err := ldapconn.Bind(userResult.Entries[0].DN, password); err != nil {
			e := fmt.Sprintf(&quot;Failed to auth. %s\n&quot;, err)
			klog.V(3).Info(e)
			return nil, errors.New(e)
		} else {
			klog.V(3).Info(fmt.Sprintf(&quot;User %s Authenticated successfuly!&quot;, username))
		}
		// 拼接为kubernetes authentication 的用户格式
		user := new(v1.UserInfo)
		for _, v := range result.Entries {
			attrubute := v.GetAttributeValue(&quot;objectClass&quot;)
			if strings.Contains(attrubute, &quot;posixGroup&quot;) {
				user.Groups = append(user.Groups, v.GetAttributeValue(&quot;cn&quot;))
			}
		}

		u := userResult.Entries[0].GetAttributeValue(&quot;uid&quot;)
		user.UID = u
		user.Username = u
		return user, nil
	}
}
</code></pre>
<h3 id="部署webhook">部署webhook<a hidden class="anchor" aria-hidden="true" href="#部署webhook">¶</a></h3>
<p>kubernetes官方手册中指出，启用webhook认证的标记是在 <em><strong>kube-apiserver</strong></em> 指定参数 <code>--authentication-token-webhook-config-file</code> 。而这个配置文件是一个 <em>kubeconfig</em> 类型的文件格式 <sup><a href="#5">[5]</a></sup></p>
<p>下列是部署在kubernetes集群外部的配置</p>
<p>创建一个给 <em>kube-apiserver</em> 使用的配置文件 <code>/etc/kubernetes/auth/authentication-webhook.conf</code></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Config
clusters:
- cluster:
    server: http://10.0.0.1:88/authenticate
  name: authenticator
users:
- name: webhook-authenticator
current-context: webhook-authenticator@authenticator
contexts:
- context:
    cluster: authenticator
    user: webhook-authenticator
  name: webhook-authenticator@authenticator
</code></pre>
<p>修改 <em>kube-apiserver</em> 参数</p>
<pre><code class="language-bash"># 指向对应的配置文件
--authentication-token-webhook-config-file=/etc/kubernetes/auth/authentication-webhook.conf
# 这个是token缓存时间，指的是用户在访问API时验证通过后在一定时间内无需在请求webhook进行认证了
--authentication-token-webhook-cache-ttl=30m
# 版本指定为API使用哪个版本？authentication.k8s.io/v1或v1beta1
--authentication-token-webhook-version=v1
</code></pre>
<p>启动服务后，创建一个 kubeconfig 中的用户用于验证结果</p>
<pre><code class="language-conf">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: 
    server: https://10.0.0.4:6443
  name: kubernetes
contexts:
- context:
    cluster: kubernetes
    user: k8s-admin
  name: k8s-admin@kubernetes
current-context: k8s-admin@kubernetes
kind: Config
preferences: {}
users:
- name: admin
  user: 
    token: admin@111
</code></pre>
<h3 id="验证结果">验证结果<a hidden class="anchor" aria-hidden="true" href="#验证结果">¶</a></h3>
<p><strong>当密码不正确时，使用用户admin请求集群</strong></p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
error: You must be logged in to the server (Unauthorized)
</code></pre>
<p><strong>当密码正确时，使用用户admin请求集群</strong></p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
Error from server (Forbidden): pods is forbidden: User &quot;admin&quot; cannot list resource &quot;pods&quot; in API group &quot;&quot; in the namespace &quot;default&quot;
</code></pre>
<p>可以看到admin用户是一个不存在与集群中的用户，并且提示没有权限操作对应资源，此时将admin用户与集群中的cluster-admin绑定，测试结果</p>
<pre><code class="language-bash">$ kubectl create clusterrolebinding admin \
	--clusterrole=cluster-admin \
	--group=admin
</code></pre>
<p>此时再尝试使用admin用户访问集群</p>
<pre><code class="language-bash">$ kubectl get pods --user=admin
NAME                      READY   STATUS    RESTARTS   AGE
netbox-85865d5556-hfg6v   1/1     Running   0          91d
netbox-85865d5556-vlgr4   1/1     Running   0          91d
</code></pre>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">¶</a></h2>
<p>kubernetes authentication 插件提供的功能可以注入一个认证系统，这样可以完美解决了kubernetes中用户的问题，而这些用户并不存在与kubernetes中，并且也无需为多个用户准备大量serviceaccount或者证书，也可以完成鉴权操作。首先返回值标准如下所示，如果kubernetes集群有对在其他用户系统中获得的 <code>Groups</code> 并建立了 <code>clusterrolebinding</code> 或 <code>rolebinding</code> 那么这个组的所有用户都将有这些权限。管理员只需要维护与公司用户系统中组同样多的 clusterrole 与 clusterrolebinding 即可</p>
<pre><code class="language-go">type DefaultInfo struct {
	Name   string
	UID    string
	Groups []string
	Extra  map[string][]string
}
</code></pre>
<p>对于如何将 kubernetes 与其他平台进行融合可以参考 <a href="https://cylonchau.github.io/kubernetes-dashborad-based.html" target="_blank"
   rel="noopener nofollow noreferrer" >文章</a></p>
<blockquote>
<p>Notes：Kubernetes原生就支持OID，完全不用自己开发webhook从而实现接入其他系统，这里展示的只是一个思路</p>
</blockquote>
<h2 id="reference">Reference<a hidden class="anchor" aria-hidden="true" href="#reference">¶</a></h2>
<blockquote>
<p><sup id="1">[1]</sup> <a href="https://learnk8s.io/kubernetes-custom-authentication" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Implementing a custom Kubernetes authentication method</strong></em></a></p>
<p><sup id="2">[2]</sup> <a href="https://kubernetes.io/docs/concepts/security/controlling-access/" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Controlling Access to the Kubernetes API</strong></em></a></p>
<p><sup id="3">[3]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#users-in-kubernetes" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Users in Kubernetes</strong></em></a></p>
<p><sup id="4">[4]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#bootstrap-tokens" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>bootstrap tokens</strong></em></a></p>
<p><sup id="5">[5]</sup> <a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication" target="_blank"
   rel="noopener nofollow noreferrer" ><em><strong>Webhook Token Authentication</strong></em></a></p>
</blockquote>


    
    


<div class="copyrightBlock" >
    <div class="articleSuffix-bg"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 147.78 155.96"> <path d="M10.5,99.81a1.9,1.9,0,0,0-.53-.09,1.66,1.66,0,0,0-1.64,1.65A1.64,1.64,0,0,0,10,103a1.57,1.57,0,0,0,.87-.25l26.76,26.82.45-1.08L11.52,101.91A1.65,1.65,0,0,0,10.5,99.81Zm-.13,2a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.58.58,0,0,1,.57-.57h0a.57.57,0,0,1,.56.58A.55.55,0,0,1,10.37,101.77Z" style="fill:#c5c9e0"></path><path d="M56.15,117.58H39.06l0-.09a1.65,1.65,0,0,0-1.36-1H37.5a1.65,1.65,0,1,0,1.56,2.19H55.7L92.92,156h41.44v-1.08h-41Zm-18.25.94a.56.56,0,0,1-.79,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h0a.58.58,0,0,1,.57.58A.54.54,0,0,1,37.9,118.52Z" style="fill:#c5c9e0"></path><path d="M23.52,50.32a1.65,1.65,0,0,0,1.55-1.11H55.28l48-48.13h31.06V0H102.85l-48,48.13H25.07a1.64,1.64,0,0,0-2.09-1,1.64,1.64,0,0,0,.54,3.2Zm0-2.21a.57.57,0,0,1,0,1.13.57.57,0,1,1,0-1.13Z" style="fill:#c5c9e0"></path><polygon points="102.86 0 102.86 0 102.86 0 102.86 0" style="fill:#c5c9e0"></polygon><path d="M107.72,12.14h26.64V11.07H107.27L57.4,61H3.09a1.66,1.66,0,0,0-1.45-.86H1.52A1.65,1.65,0,1,0,2.81,63a1.59,1.59,0,0,0,.45-.87H57.85ZM2.05,62.23a.57.57,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.56-.57h.09a.57.57,0,0,1,.32,1Z" style="fill:#c5c9e0"></path><path d="M134.36,43.22V42.14h-22.3l-9.62,9.63a1.64,1.64,0,0,0-2.19.77,1.61,1.61,0,0,0-.17.71,1.65,1.65,0,1,0,3.29,0,1.61,1.61,0,0,0-.16-.72l9.3-9.32Zm-32.64,10.6a.57.57,0,0,1,0-1.13.57.57,0,0,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M147,52.3l-9,9H111.48a1.64,1.64,0,0,0-1.61-1.33h-.14a1.65,1.65,0,1,0,1.6,2.41h27.19l9.26-9.29L147,52.3Zm-37.15,9.85a.56.56,0,0,1-.56-.57h0a.56.56,0,0,1,.56-.56h0a.57.57,0,1,1,0,1.13Z" style="fill:#c5c9e0"></path><path d="M66.79,75.35l11,11.06h56.53V85.33H78.27l-11-11.06H49.49L37.12,86.67a1.64,1.64,0,0,0-2.09,1,1.61,1.61,0,0,0-.09.54,1.65,1.65,0,0,0,3.29,0,1.68,1.68,0,0,0-.26-.89l12-12ZM36.58,88.79a.57.57,0,1,1,.57-.56A.57.57,0,0,1,36.58,88.79Z" style="fill:#c5c9e0"></path><path d="M110.61,95.55,92.8,113.4a1.62,1.62,0,1,0,.77.76l17.49-17.53h23.31V95.55ZM92.49,115.28a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,.57-.57h0a.58.58,0,0,1,.56.58A.55.55,0,0,1,92.49,115.28Z" style="fill:#c5c9e0"></path><path d="M97.89,122.3H76.62L64.2,109.85a1.65,1.65,0,0,0-.77-2.2,1.77,1.77,0,0,0-.72-.17h-.14a1.65,1.65,0,0,0,.15,3.29,1.58,1.58,0,0,0,.71-.17l12.74,12.77H98.34l17.48-17.52h18.54v-1.08h-19ZM63.12,109.53a.56.56,0,0,1-.8,0,.58.58,0,0,1-.17-.41.57.57,0,0,1,1.14,0A.54.54,0,0,1,63.12,109.53Z" style="fill:#c5c9e0"></path> </svg> </div>
    <p>本文发布于<a href="https://www.oomkill.com/about" target="_blank">Cylon的收藏册</a>，转载请著名原文链接~</p>
    <p>链接：<a href="https://www.oomkill.com/2022/11/ch31-authentication/" target="_blank">https://www.oomkill.com/2022/11/ch31-authentication/</a></p>
    <p style="margin-bottom: 0px;">版权：本作品采用<a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">「署名-非商业性使用-相同方式共享 4.0 国际」</a> 许可协议进行许可。</p>
    </div>
</div>
  </div>

  <footer class="post-footer">
    
<nav class="paginav">
  <a class="prev" href="https://www.oomkill.com/2022/11/ch32-authorization/">
    <span class="title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select: text;"><line x1="19" y1="12" x2="5" y2="12" style="user-select: text;"></line><polyline points="12 19 5 12 12 5" style="user-select: text;"></polyline>
      </polyline></svg>&nbsp; </span>
    
    <span>深入理解Kubernetes 4A - Authorization源码解析</span>
  </a>
  <a class="next" href="https://www.oomkill.com/2022/11/ch11-sssd/" >
    <span class="title"> </span>
    
    <span>理解ldap - 使用SSSD接入OpenLDAP实现身份验证&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select: text;"><line x1="5" y1="12" x2="19" y2="12" style="user-select: text;"></line><polyline points="12 5 19 12 12 19" style="user-select: text;"></polyline></svg></span>
  </a>
</nav>

  </footer>

  
  <div class="pagination__title">
    <span class="pagination__title-h"></span>
  </div>
  
  
  
  
    <div class="comments-separator"></div>
    

<h3 class="relatedContentTitle" >相关阅读</h3>
<ul class="relatedContent">
	
	<li><a href="/2022/07/ch33-admission-webhook/"><span>深入理解Kubernetes 4A - Admission Control源码解析</span></a></li>
	
	<li><a href="/2022/08/ch22-custom-scheduler/"><span>基于Prometheus的Kubernetes网络调度器</span></a></li>
	
	<li><a href="/2022/07/ch21-scheduling-algorithm/"><span>如何理解kubernetes调度框架与插件？</span></a></li>
	
	<li><a href="/2022/07/ch20-schedule-workflow/"><span>kube-scheduler的调度上下文</span></a></li>
	
	<li><a href="/2022/07/ch16-scheduler/"><span>kubernetes的决策组件 - kube-scheduler原理分析</span></a></li>
	
</ul>

  

  
    
      <div class="comments-separator"></div>
<div class="comments">
    <script>
    function loadComment() {
        let theme = localStorage.getItem('pref-theme') === 'dark' ? 'dark' : 'light';
        let s = document.createElement('script');
        s.src = 'https://giscus.app/client.js';
        s.setAttribute('data-repo', 'cylonchau\/cylonchau.github.io');
        s.setAttribute('data-repo-id', 'R_kgDOIRlNSQ');
        s.setAttribute('data-category', 'Announcements');
        s.setAttribute('data-category-id', 'DIC_kwDOIRlNSc4CXy1U');
        s.setAttribute('data-mapping', 'title');
        s.setAttribute('data-reactions-enabled', '1');
        s.setAttribute('data-emit-metadata', '1');
        s.setAttribute('data-input-position', 'top');
        s.setAttribute('data-lang', 'zh-TW');
        s.setAttribute('data-theme', theme);
        s.setAttribute('crossorigin', 'anonymous');
        s.setAttribute('async', '');
        document.querySelector('div.comments').innerHTML = '';
        document.querySelector('div.comments').appendChild(s);
    }
    loadComment();
    </script>
</div>
</article>
    </main>
    
<footer class="footer">
  <p>
  Copyright
  <span>&copy; 2024 <a href="https://www.oomkill.com">Cylon&#39;s Collection</a></span></p>
  <span style="display: inline-block; margin-left: 1em;">
    Powered by
    <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> on github-page & Theme
    <a href="https://github.com/reorx/hugo-PaperModX/" rel="noopener" target="_blank">PaperModX</a>
  </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <span class="topInner">
        <svg class="topSvg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z"/>
        </svg>
        <span id="read_progress"></span>
    </span>
</a>

<script>
  (function() {
     
    const disableThemeToggle = '' == '1';
    if (disableThemeToggle) {
      return;
    }

    let button = document.getElementById("theme-toggle")
    
    button.removeEventListener('click', toggleThemeListener)
    
    button.addEventListener('click', toggleThemeListener)
  })();
</script>

<script>
  (function () {
    let menu = document.getElementById('menu')
    if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
    }

    const disableSmoothScroll = '' == '1';
    const enableInstantClick = '1' == '1';
    
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches || disableSmoothScroll || enableInstantClick) {
      return;
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
        e.preventDefault();
        var id = this.getAttribute("href").substr(1);
        document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
          behavior: "smooth"
        });
        if (id === "top") {
          history.replaceState(null, null, " ");
        } else {
          history.pushState(null, null, `#${id}`);
        }
      });
    });
  })();
</script>

<script>
  document.addEventListener('scroll', function (e) {
      const readProgress = document.getElementById("read_progress");
      const scrollHeight = document.documentElement.scrollHeight;
      const clientHeight = document.documentElement.clientHeight;
      const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
      readProgress.innerText = ((scrollTop / (scrollHeight - clientHeight)).toFixed(2) * 100).toFixed(0);
  })
</script>

<script>
  var menu = document.getElementById('menu')
  if (menu) {
      menu.scrollLeft = localStorage.getItem("menu-scroll-position");
      menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
      }
  }

  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                  behavior: "smooth"
              });
          } else {
              document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
          }
          if (id === "top") {
              history.replaceState(null, null, " ");
          } else {
              history.pushState(null, null, `#${id}`);
          }
      });
  });
</script>
<script>
  var mybutton = document.getElementById("top-link");
  window.onscroll = function () {
      if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
      } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
      }
  };
</script>
<script>
  if (window.scrollListeners) {
    
    for (const listener of scrollListeners) {
      window.removeEventListener('scroll', listener)
    }
  }
  window.scrollListeners = []
</script>



<script src="/js/medium-zoom.min.js" data-no-instant
></script>
<script>
  document.querySelectorAll('pre > code').forEach((codeblock) => {
    const container = codeblock.parentNode.parentNode;

    const copybutton = document.createElement('button');
    copybutton.classList.add('copy-code');
    copybutton.innerText = 'copy';

    function copyingDone() {
      copybutton.innerText = 'copied';
      setTimeout(() => {
        copybutton.innerText = 'copy';
      }, 2000);
    }

    copybutton.addEventListener('click', (cb) => {
      if ('clipboard' in navigator) {
        navigator.clipboard.writeText(codeblock.textContent);
        copyingDone();
        return;
      }

      const range = document.createRange();
      range.selectNodeContents(codeblock);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      try {
        document.execCommand('copy');
        copyingDone();
      } catch (e) { };
      selection.removeRange(range);
    });

    if (container.classList.contains("highlight")) {
      container.appendChild(copybutton);
    } else if (container.parentNode.firstChild == container) {
      
    } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
      
      codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
    } else {
      
      codeblock.parentNode.appendChild(copybutton);
    }
  });
</script>




<script>
  
  
  (function() {
    const enableTocScroll = '1' == '1'
    if (!enableTocScroll) {
      return
    }
    if (!document.querySelector('.toc')) {
      console.log('no toc found, ignore toc scroll')
      return
    }
    

    
    const scrollListeners = window.scrollListeners
    const headings = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]');
    const activeClass = 'active';

    
    let activeHeading = headings[0];
    getLinkByHeading(activeHeading).classList.add(activeClass);

    const onScroll = () => {
      const passedHeadings = [];
      for (const h of headings) {
        
        if (getOffsetTop(h) < 5) {
          passedHeadings.push(h)
        } else {
          break;
        }
      }
      if (passedHeadings.length > 0) {
        newActiveHeading = passedHeadings[passedHeadings.length - 1];
      } else {
        newActiveHeading = headings[0];
      }
      if (activeHeading != newActiveHeading) {
        getLinkByHeading(activeHeading).classList.remove(activeClass);
        activeHeading = newActiveHeading;
        getLinkByHeading(activeHeading).classList.add(activeClass);
      }
    }

    let timer = null;
    const scrollListener = () => {
      if (timer !== null) {
        clearTimeout(timer)
      }
      timer = setTimeout(onScroll, 50)
    }
    window.addEventListener('scroll', scrollListener, false);
    scrollListeners.push(scrollListener)

    function getLinkByHeading(heading) {
      const id = encodeURI(heading.getAttribute('id')).toLowerCase();
      return document.querySelector(`.toc ul li a[href="#${id}"]`);
    }

    function getOffsetTop(heading) {
      if (!heading.getClientRects().length) {
        return 0;
      }
      let rect = heading.getBoundingClientRect();
      return rect.top
    }
  })();
  </script>

<script src="/js/instantclick.min.js" data-no-instant
></script>
<script data-no-instant>
  
  
  
  
  
  
  InstantClick.init();
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.6.0/mermaid.min.js" crossorigin="anonymous"></script>
<script>
    mermaid.init(undefined, '.language-mermaid');
</script>
</body>

</html>
