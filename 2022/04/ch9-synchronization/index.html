<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ch9 同步 | Cylon's Collection</title>
<meta name=keywords content="操作系统,同步"><meta name=description content="Background 多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：
独立进程 Independent Process 不和其他进程共享资源或状态 确定性，输入状态确定结果 可重现，能够重现起始条件，I/O 调度的顺序不重要 协作进程 Cooperative Process； 多进程共享资源或状态 不确定性 probabilistic 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的
Cooperation 进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。
进程需要合作的原因：
资源共享：多个进程访问相同的数据 一台电脑，多个用户 一个银行存款余额,多台ATM机 嵌入式系统（机器人手臂和收的协调） 计算加速： I/O 和 CPU计算可重叠 多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU） 模块化：复杂的任务组织成单独的子任务，让不同的进程运行 大程序分成小程序 是系统易于扩展 程序可以调用函数fork()来创建一个新的进程
操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行
如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作
多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性
先思考清楚问题，把程序的行为设计清楚 切忌给予着手编写代码，碰到问题再调试 Race Condition 竞态条件是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。
怎么样避免竞态?"><meta name=author content="cylon"><link rel=canonical href=https://www.oomkill.com/2022/04/ch9-synchronization/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.oomkill.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.oomkill.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.oomkill.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.oomkill.com/favicon.ico><link rel=mask-icon href=https://www.oomkill.com/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.oomkill.com/2022/04/ch9-synchronization/><noscript><style>#theme-toggle,#top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link crossorigin=anonymous href=/assets/css/pe.min.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/pe.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/all.min.css><link rel=stylesheet href=https://cdn.staticfile.net/font-awesome/6.5.1/css/v4-shims.min.css><script defer src=https://cdn.staticfile.net/jquery/3.5.1/jquery.min.js></script><link rel=stylesheet href=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.css><script defer src=https://cdn.staticfile.net/fancybox/3.5.7/jquery.fancybox.min.js></script><script id=MathJax-script async src=https://cdn.staticfile.net/mathjax/3.2.2/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["$$","$$"]],inlineMath:[["\\$","\\$"]]}}</script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><meta name=referrer content="no-referrer-when-downgrade"><meta property="og:title" content="ch9 同步"><meta property="og:description" content="Background 多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：
独立进程 Independent Process 不和其他进程共享资源或状态 确定性，输入状态确定结果 可重现，能够重现起始条件，I/O 调度的顺序不重要 协作进程 Cooperative Process； 多进程共享资源或状态 不确定性 probabilistic 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的
Cooperation 进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。
进程需要合作的原因：
资源共享：多个进程访问相同的数据 一台电脑，多个用户 一个银行存款余额,多台ATM机 嵌入式系统（机器人手臂和收的协调） 计算加速： I/O 和 CPU计算可重叠 多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU） 模块化：复杂的任务组织成单独的子任务，让不同的进程运行 大程序分成小程序 是系统易于扩展 程序可以调用函数fork()来创建一个新的进程
操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行
如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作
多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性
先思考清楚问题，把程序的行为设计清楚 切忌给予着手编写代码，碰到问题再调试 Race Condition 竞态条件是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。
怎么样避免竞态?"><meta property="og:type" content="article"><meta property="og:url" content="https://www.oomkill.com/2022/04/ch9-synchronization/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-30T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-22T23:00:36+08:00"><meta property="og:site_name" content="Cylon's Collection"><meta name=twitter:card content="summary"><meta name=twitter:title content="ch9 同步"><meta name=twitter:description content="Background 多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：
独立进程 Independent Process 不和其他进程共享资源或状态 确定性，输入状态确定结果 可重现，能够重现起始条件，I/O 调度的顺序不重要 协作进程 Cooperative Process； 多进程共享资源或状态 不确定性 probabilistic 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的
Cooperation 进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。
进程需要合作的原因：
资源共享：多个进程访问相同的数据 一台电脑，多个用户 一个银行存款余额,多台ATM机 嵌入式系统（机器人手臂和收的协调） 计算加速： I/O 和 CPU计算可重叠 多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU） 模块化：复杂的任务组织成单独的子任务，让不同的进程运行 大程序分成小程序 是系统易于扩展 程序可以调用函数fork()来创建一个新的进程
操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行
如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作
多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性
先思考清楚问题，把程序的行为设计清楚 切忌给予着手编写代码，碰到问题再调试 Race Condition 竞态条件是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。
怎么样避免竞态?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.oomkill.com/posts/"},{"@type":"ListItem","position":2,"name":"ch9 同步","item":"https://www.oomkill.com/2022/04/ch9-synchronization/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ch9 同步","name":"ch9 同步","description":"Background 多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：\n独立进程 Independent Process 不和其他进程共享资源或状态 确定性，输入状态确定结果 可重现，能够重现起始条件，I/O 调度的顺序不重要 协作进程 Cooperative Process； 多进程共享资源或状态 不确定性 probabilistic 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的\nCooperation 进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。\n进程需要合作的原因：\n资源共享：多个进程访问相同的数据 一台电脑，多个用户 一个银行存款余额,多台ATM机 嵌入式系统（机器人手臂和收的协调） 计算加速： I/O 和 CPU计算可重叠 多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU） 模块化：复杂的任务组织成单独的子任务，让不同的进程运行 大程序分成小程序 是系统易于扩展 程序可以调用函数fork()来创建一个新的进程\n操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行\n如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作\n多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性\n先思考清楚问题，把程序的行为设计清楚 切忌给予着手编写代码，碰到问题再调试 Race Condition 竞态条件是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。\n怎么样避免竞态?","keywords":["操作系统","同步"],"articleBody":"Background 多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：\n独立进程 Independent Process 不和其他进程共享资源或状态 确定性，输入状态确定结果 可重现，能够重现起始条件，I/O 调度的顺序不重要 协作进程 Cooperative Process； 多进程共享资源或状态 不确定性 probabilistic 不可重现 不确定性和不可重现意味着bug可能是间歇性发生的\nCooperation 进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。\n进程需要合作的原因：\n资源共享：多个进程访问相同的数据 一台电脑，多个用户 一个银行存款余额,多台ATM机 嵌入式系统（机器人手臂和收的协调） 计算加速： I/O 和 CPU计算可重叠 多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU） 模块化：复杂的任务组织成单独的子任务，让不同的进程运行 大程序分成小程序 是系统易于扩展 程序可以调用函数fork()来创建一个新的进程\n操作系统需要分配一个新的并且唯一的进程ID 因此在内核中,这个系统调用会运行 new_pid = next_pid++; 翻译成机器指令: Load next_pid Reg1 STORE Reg1 new_pid INC Reg1 STORE Reg1 next_pid 假设两个进程并发执行\n如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102 可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101 无论多个线程的指令序列怎样交替执行,程序都必须正常工作\n多线程程序具有不确定性和不可重现的特点 不经过专门设计,调试难度很高 不确定性要求并行程序的正确性\n先思考清楚问题，把程序的行为设计清楚 切忌给予着手编写代码，碰到问题再调试 Race Condition 竞态条件是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。\n怎么样避免竞态?\nAtomic Operator(原子操作)\n原子操作是指一次不存在任何终端或者失败的执行\n该执行成功结束 或者根本没有执行 并且不应发生任何部分执行的状态 假设设计一个程序，A和B两个进程互相竞争，一个进程使counter+1，另外一个进程使counter-1\nc 1 2 3 4 5 6 7 8 while (true) { /* produce an item in next produced */ while (counter == BUFFER_SIZE) ; /* do nothing */ buffer[in] = next_produced; in = (in + 1) % BUFFER_SIZE; counter++; } c 1 2 3 4 5 6 7 8 while (true) { while (counter == 0) ; /* do nothing */ next_consumed = buffer[out]; out = (out + 1) % BUFFER_SIZE; counter--; /* consume the item in next consumed */ } P1和P2指令的执行顺序不同，产生的结果也不同。可能存在P1执行完或P2先执行完，也可能永远执行不完\n临界区：程序中试图访问共享资源并可能导致竞态条件的区域称为临界区 Critical Section 互斥 Mutual Exclusion：如果一个进程在临界区并访问共享资源，则不允许临界区有其他进程处于临界区并访问共享资源。 死锁 Deadlock：两个或两个以上进程，互相等待完成特定任务，而最终没法将自身任务进行下去 有界等待 Bounded Waiting：在一个进程发出进入其临界区的请求后，在该进程的请求被批准之前，有多少个进程可以进入临界区是有限制的。因此，达到限制后，必须有授予权限的进程才能进入其临界区。此条件的目的是确保每个进程都有机会进入其临界区，从而没有进程永远饥饿。 饥饿 Starvation：一个可执行的进程，长期被调度器忽略，以至于虽然处于可执行状态却不被执行。 无忙等待 忙等待 busy-waiting：忙等待是指，进程在继续执行之前等待并不断的检查要满足的条件，例如说循环、锁；一般情况下忙等待分为两种\n消耗处理器的同时不断检查要满足的条件 不消耗处理器，当满足条件时，会被唤醒 在一些操作系统中，忙等待很低效，循环会浪费CPU资源。但通常情况下，解决忙等待的方法就是延迟；例如\ntext 1 2 3 while z is still in use do sleep(900) end 另外一种方式就是信号量的阻塞进程，即处于忙碌等待状态的进程被阻塞并放置在不消耗资源的等待队列中。一旦满足条件，该过程将重新启动并放置在就绪队列中。\nReference synchronization\nrace condition\nbusy waiting\n禁用硬件中断 如何保障临界区操作是原子的，只要不发生上下文切换，那么操作就是原子的，即禁用硬件中断 disable interupt instruction DI instruction\n进入临界区禁用中断 操作临界区代码 离开临界区启用中断 text 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Lock { int value = FREE; } Lock::Acquire() { Disable interrupts; # 禁用中断 while (value != FREE) { # 等待锁 Enable interrupts; Disable interrupts; } value = BUSY; Enable interrupts; } Lock::Release() { Disable interrupts; value = FREE; # 解锁 Enable interrupts; # 启用中断 } 缺点：\n一旦中断被禁用，线程就无法被停止\n整个系统都会为你停下来 可能导致其他线程处于饥饿状态 要是临界区可以任意长怎么办？\n无法限制响应中断所需的时间(可能存在硬件影响) 要小心使用，适合于较小的操作\n软件解决方案 屏蔽硬件中断简单有效，但受制于临界区执行时间，影响整个系统的效率。\nPeterson 一个满足两个进程进程Pi 和 Pj 之间互斥的经典的基于软件的解决方法(1981年)，Peterson算法；Peterson 算法是基于双进程的互斥访问，需要两个锁：\n一个使用 flag，是一个布尔数组 另外一个使用 turn 的int锁 而这两个锁都有可能出现死锁的情况：如\ntext 1 2 3 4 5 6 7 8 9 int turn = 0 turn = j do { while( turn != i); Critical Section turn = j; remainder section\t} while(1) 另外一个进程\ntext 1 2 3 4 5 6 7 8 9 int turn = 0 turn = i do { while( turn != j); Critical Section turn = i; remainder section\t} while(1) 满足了互斥，没满足progress（想进入临界区的进程），最终只有一个进程可以进入，无法进行流转。\nPeterson 算法基于两个锁的临界区问题的解决方案：\n一个使用 flag，是一个布尔数组；boolean flag[i] 初始化为false，即没有进程有兴趣进入临界区 另外一个使用 turn 的int锁；进入临界区的进程 c 1 2 3 4 5 6 7 8 9 10 int trun; boolean flag[]; do{ flag[i] = true; // 此时i想进入临界区 turn = j // 但是当前是i while(flag[j] \u0026\u0026 turn ==j); critical section flag[i] = false; remander section } while(true); Peterson 算法可以解决上述单锁的问题：\n互斥是有保证：任何时候仅有一个进程可以访问临界区 进程有保证：不会阻止临界区外其他进程进入临界区 Peterson 算法的缺点：\n忙等待 仅限于两个进程 Dekker Dekker是另外一种临界区解决方法，Dekker从第五版才完整满足了所有的条件；dekker算法类似于Peterson 算法；下面是算法的实现：\ngo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 package main import ( \"fmt\" \"math/rand\" \"time\" ) var thread1wantstoenter = false // 进程是否在执行 var thread2wantstoenter = false // 进程是否在执行 var favouredthread int // 进入临界区的进程 var cs = 0 func main() { go thread1() go thread2() time.Sleep(time.Second * 20) } func thread1() { fmt.Printf(\"thread %d Start execute\\n\", 1) for { fmt.Printf(\"get a lock, %d \\n\", cs) thread1wantstoenter = true for thread2wantstoenter == true { fmt.Printf(\"1 get a lock, thread %d also executing.\\n\", 2) if favouredthread == 2 { fmt.Printf(\"current cs thread is %d also executing.\\n\", favouredthread) thread1wantstoenter = false for favouredthread == 2 { // 忙等待，一直等到当前临界区进程不为对方 } thread1wantstoenter = true } } fmt.Printf(\"not get lock, begin update cs1.\\n\") cs = 1 time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) favouredthread = 2 thread1wantstoenter = false fmt.Printf(\"thread %d has completed\\n\", favouredthread) fmt.Printf(\"cs value with update %d \\n\", cs) } } func thread2() { fmt.Printf(\"thread %d Start execute\\n\", 2) for { fmt.Printf(\"get a lock, %d \\n\", cs) thread2wantstoenter = true for thread1wantstoenter == true { fmt.Printf(\"2 get a lock, thread %d also executing.\\n\", 1) if favouredthread == 1 { fmt.Printf(\"current cs thread is %d also executing.\\n\", favouredthread) thread2wantstoenter = false for favouredthread == 1 { // 忙等待，一直等到当前临界区进程不为对方 } thread2wantstoenter = true } } fmt.Printf(\"not get lock, begin update cs2.\\n\") cs = 2 favouredthread = 1 time.Sleep(time.Millisecond * time.Duration(rand.Intn(1000))) // 退出，标记着线程2已完成， thread2wantstoenter = false fmt.Printf(\"thread %d has completed\\n\", favouredthread) fmt.Printf(\"cs value with update %d \\n\", cs) } } 整个for部分是一个锁，如果其他进程没有占用临界区，则可以进入临界区；这样第一个 for保证了互斥，在两个进程都没有被标记时，至少有一个进程可以进入，这样保证了progess。\n再假设，thread1永远卡在thread2wantstoenter == true；最终thread2会退出favouredthread = 1；这样的话不存在死锁，最终会脱离循环，脱离后会将自己设置为true thread1wantstoenter = true；这样的话，只要对方（thread2）为false了，即结束临界区访问；那么下一次循环将退出锁部分，并且可已访问临界区\n如果不对 favouredthread == counterpart 进行判断，那么就会出现饥饿现象。\nReference\ndekker algorithm\nwikipedia\nbakery bakery算法是针对N个进程互斥提出的解决方法之一；\n每当有进程进入临界区时，会被分配一个数 拥有最小数的进程会被选入临界区； 如果进程Pi 和 Pj 被分配相同的数，并且 $i","wordCount":"1426","inLanguage":"zh","datePublished":"2022-04-30T00:00:00Z","dateModified":"2023-03-22T23:00:36+08:00","author":{"@type":"Person","name":"cylon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.oomkill.com/2022/04/ch9-synchronization/"},"publisher":{"@type":"Organization","name":"Cylon's Collection","logo":{"@type":"ImageObject","url":"https://www.oomkill.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.oomkill.com/><img src=https://www.oomkill.com/favicon.ico alt aria-label=logo height=20>Cylon's Collection</a><div class=logo-switches><button id=theme-toggle><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.oomkill.com/archives><span>归档</span></a></li><li><a href=https://www.oomkill.com/tags><span>标签</span></a></li><li><a href=https://www.oomkill.com/search><span>搜索</span></a></li><li><a href=https://www.oomkill.com/about accesskey=/><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ch9 同步</h1><div class=post-meta><span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>2022-04-30</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg><span>1426 字</span></span>&nbsp;·&nbsp;<span class=pe-post-meta-item><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><span>7 分钟</span></span>
<span class=pe-post-meta-item>&nbsp;·&nbsp;<svg t="1714036239378" fill="currentcolor" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="6659" width="256" height="256"><path d="M690 78.2c-18.6-18.8-49-19-67.8-.4s-19 49-.4 67.8l255.4 258.6c67.8 68.6 67.8 178.8.0 247.4L653.4 878.2c-18.6 18.8-18.4 49.2.4 67.8s49.2 18.4 67.8-.4l224-226.4c104.8-106 104.8-276.4.0-382.4L690 78.2zM485.4 101.4c-24-24-56.6-37.4-90.6-37.4H96C43 64 0 107 0 160v299c0 34 13.4 66.6 37.4 90.6l336 336c50 50 131 50 181 0l267-267c50-50 50-131 0-181l-336-336zM96 160h299c8.4.0 16.6 3.4 22.6 9.4l336 336c12.4 12.4 12.4 32.8.0 45.2l-267 267c-12.4 12.4-32.8 12.4-45.2.0l-336-336c-6-6-9.4-14.2-9.4-22.6V160zm192 128a64 64 0 10-128 0 64 64 0 10128 0z" p-id="6660"/></svg></span><ul class=pe-post-meta-item><a href=https://www.oomkill.com/tags/os/>#OS</a></ul>&nbsp;·&nbsp;<span id=busuanzi_container_page_pv>本文阅读量 <span id=busuanzi_value_page_pv></span> 次</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary><span class=details>目录</span></summary><div class=inner><ul><li><a href=#background aria-label=Background>Background</a><ul><li><a href=#cooperation aria-label=Cooperation>Cooperation</a></ul><li><a href=#race-condition aria-label="Race Condition">Race Condition</a><ul><li><a href=#%e5%bf%99%e7%ad%89%e5%be%85 aria-label=忙等待>忙等待</a></ul><li><a href=#%e7%a6%81%e7%94%a8%e7%a1%ac%e4%bb%b6%e4%b8%ad%e6%96%ad aria-label=禁用硬件中断>禁用硬件中断</a><li><a href=#%e8%bd%af%e4%bb%b6%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=软件解决方案>软件解决方案</a><ul><li><a href=#peterson aria-label=Peterson>Peterson</a><li><a href=#dekker aria-label=Dekker>Dekker</a><li><a href=#bakery aria-label=bakery>bakery</a></ul><li><a href=#%e6%9b%b4%e9%ab%98%e7%ba%a7%e6%8a%bd%e8%b1%a1 aria-label=更高级抽象>更高级抽象</a></li></div></details></div></aside><script src=/js/pe-toc.min.445eb1bfc5e85dd13b9519fcc2a806522e9629b6224a2974052789ba00ab78af.js integrity="sha256-RF6xv8XoXdE7lRn8wqgGUi6WKbYiSil0BSeJugCreK8="></script><div class=post-content><h2 id=background>Background<a hidden class=anchor aria-hidden=true href=#background>#</a></h2><p>多进程作为现代操作系统的重要特性，交互则会引起同时对共享资源的访问，当这些资源访问不正确会出现冲突或产生不适当的输出（冲突、死锁、饥饿）；而在同步的基础上，进程被分为以下两种类型：</p><ul><li>独立进程 <strong>Independent Process</strong><ul><li>不和其他进程共享资源或状态</li><li>确定性，输入状态确定结果</li><li>可重现，能够重现起始条件，I/O</li><li>调度的顺序不重要</li></ul></li><li>协作进程 <strong>Cooperative Process</strong>；<ul><li>多进程共享资源或状态</li><li>不确定性 <code>probabilistic</code></li><li>不可重现</li></ul></li></ul><p>不确定性和不可重现意味着bug可能是间歇性发生的</p><h3 id=cooperation>Cooperation<a hidden class=anchor aria-hidden=true href=#cooperation>#</a></h3><p>进程的互相影响，即进程间的合作（相互或破坏）；最简单的例子就是两个进程使用同一个文件，一个进程读，一个进程写。读进程的结果会被写进程所影响。</p><p>进程需要合作的原因：</p><ul><li>资源共享：多个进程访问相同的数据<ul><li>一台电脑，多个用户</li><li>一个银行存款余额,多台ATM机</li><li>嵌入式系统（机器人手臂和收的协调）</li></ul></li><li>计算加速：<ul><li>I/O 和 CPU计算可重叠</li><li>多处理器 - 将任务分解为子任务并分布在不同的进程中，它通常可以更快地运行（也需要多个可共享的 CPU）</li></ul></li><li>模块化：复杂的任务组织成单独的子任务，让不同的进程运行<ul><li>大程序分成小程序</li><li>是系统易于扩展</li></ul></li></ul><p>程序可以调用函数fork()来创建一个新的进程</p><ul><li>操作系统需要分配一个新的并且唯一的进程ID</li><li>因此在内核中,这个系统调用会运行 <code>new_pid = next_pid++</code>;</li><li>翻译成机器指令:<ul><li><code>Load next_pid Reg1</code></li><li><code>STORE Reg1 new_pid</code></li><li><code>INC Reg1</code></li><li><code>STORE Reg1 next_pid</code></li></ul></li></ul><p>假设两个进程并发执行</p><ul><li>如果next_pid等于100, 那么其中一个进程得到的ID应该是100, 另一个进程的ID应该是101, next_pid应该增加到102</li><li>可能在INC前进行了上下文切换, 最终导致两个进程的pid都是100,而next_pid也是101</li></ul><p>无论多个线程的指令序列怎样交替执行,程序都必须正常工作</p><ul><li>多线程程序具有不确定性和不可重现的特点</li><li>不经过专门设计,调试难度很高</li></ul><p>不确定性要求并行程序的正确性</p><ul><li>先思考清楚问题，把程序的行为设计清楚</li><li>切忌给予着手编写代码，碰到问题再调试</li></ul><h2 id=race-condition>Race Condition<a hidden class=anchor aria-hidden=true href=#race-condition>#</a></h2><p><strong>竞态条件</strong>是由操作系统软件中的同步错误。出现在进程试图同时执行两个或多个操作时，这是一种不希望出现的情况。</p><p>怎么样避免竞态?</p><p>Atomic Operator(原子操作)</p><p>原子操作是指一次不存在任何终端或者失败的执行</p><ul><li>该执行成功结束</li><li>或者根本没有执行</li><li>并且不应发生任何部分执行的状态</li></ul><p>假设设计一个程序，A和B两个进程互相竞争，一个进程使counter+1，另外一个进程使counter-1</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* produce an item in next produced */</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>counter</span> <span class=o>==</span> <span class=n>BUFFER_SIZE</span><span class=p>)</span> <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* do nothing */</span>
</span></span><span class=line><span class=cl>    <span class=n>buffer</span><span class=p>[</span><span class=n>in</span><span class=p>]</span> <span class=o>=</span> <span class=n>next_produced</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>in</span> <span class=o>=</span> <span class=p>(</span><span class=n>in</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div></div></div><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>counter</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>;</span> <span class=cm>/* do nothing */</span>
</span></span><span class=line><span class=cl>    <span class=n>next_consumed</span> <span class=o>=</span> <span class=n>buffer</span><span class=p>[</span><span class=n>out</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>out</span> <span class=o>=</span> <span class=p>(</span><span class=n>out</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>BUFFER_SIZE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>counter</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* consume the item in next consumed */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> 
</span></span></code></pre></td></tr></table></div></div></div></div><p>P1和P2指令的执行顺序不同，产生的结果也不同。可能存在P1执行完或P2先执行完，也可能永远执行不完</p><ul><li>临界区：程序中试图访问共享资源并可能导致竞态条件的区域称为临界区 <code>Critical Section</code></li><li>互斥 <strong>Mutual Exclusion</strong>：如果一个进程在临界区并访问共享资源，则不允许临界区有其他进程处于临界区并访问共享资源。</li><li>死锁 <strong>Deadlock</strong>：两个或两个以上进程，互相等待完成特定任务，而最终没法将自身任务进行下去</li><li>有界等待 <strong>Bounded Waiting</strong>：在一个进程发出进入其临界区的请求后，在该进程的请求被批准之前，有多少个进程可以进入临界区是有限制的。因此，达到限制后，必须有授予权限的进程才能进入其临界区。此条件的目的是确保每个进程都有机会进入其临界区，从而没有进程永远饥饿。</li><li>饥饿 <strong>Starvation</strong>：一个可执行的进程，长期被调度器忽略，以至于虽然处于可执行状态却不被执行。</li><li>无忙等待</li></ul><h3 id=忙等待>忙等待<a hidden class=anchor aria-hidden=true href=#忙等待>#</a></h3><p><code>busy-waiting</code>：忙等待是指，进程在继续执行之前等待并不断的检查要满足的条件，例如说循环、锁；一般情况下忙等待分为两种</p><ul><li>消耗处理器的同时不断检查要满足的条件</li><li>不消耗处理器，当满足条件时，会被唤醒</li></ul><p>在一些操作系统中，忙等待很低效，循环会浪费CPU资源。但通常情况下，解决忙等待的方法就是延迟；例如</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>while z is still in use do
</span></span><span class=line><span class=cl>	sleep(900)
</span></span><span class=line><span class=cl>end</span></span></code></pre></td></tr></table></div></div></div></div><p>另外一种方式就是信号量的阻塞进程，即处于忙碌等待状态的进程被阻塞并放置在不消耗资源的等待队列中。一旦满足条件，该过程将重新启动并放置在就绪队列中。</p><blockquote><p>Reference
<a href=https://cps.cse.uconn.edu/wp-content/uploads/sites/2687/2019/10/ch5.pdf target=_blank rel="noopener nofollow noreferrer">synchronization</a></p><p><a href=https://www.gatevidyalay.com/process-synchronization-race-condition-in-os/ target=_blank rel="noopener nofollow noreferrer">race condition</a></p><p><a href=https://www.baeldung.com/cs/os-busy-waiting target=_blank rel="noopener nofollow noreferrer">busy waiting</a></p></blockquote><h2 id=禁用硬件中断>禁用硬件中断<a hidden class=anchor aria-hidden=true href=#禁用硬件中断>#</a></h2><p>如何保障临界区操作是原子的，只要不发生上下文切换，那么操作就是原子的，即禁用硬件中断 <code>disable interupt instruction</code> DI instruction</p><ol><li>进入临界区禁用中断</li><li>操作临界区代码</li><li>离开临界区启用中断</li></ol><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>class Lock { int value = FREE; }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Lock::Acquire() {
</span></span><span class=line><span class=cl>    Disable interrupts; # 禁用中断
</span></span><span class=line><span class=cl>    while (value != FREE) { # 等待锁
</span></span><span class=line><span class=cl>        Enable interrupts;  
</span></span><span class=line><span class=cl>        Disable interrupts;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    value = BUSY; 
</span></span><span class=line><span class=cl>    Enable interrupts; 
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Lock::Release() {
</span></span><span class=line><span class=cl>    Disable interrupts;
</span></span><span class=line><span class=cl>    value = FREE; # 解锁
</span></span><span class=line><span class=cl>    Enable interrupts; # 启用中断
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div></div></div><p><strong>缺点</strong>：</p><ul><li><p>一旦中断被禁用，线程就无法被停止</p><ul><li>整个系统都会为你停下来</li><li>可能导致其他线程处于饥饿状态</li></ul></li><li><p>要是临界区可以任意长怎么办？</p><ul><li>无法限制响应中断所需的时间(可能存在硬件影响)</li></ul></li><li><p>要小心使用，适合于较小的操作</p></li></ul><h2 id=软件解决方案>软件解决方案<a hidden class=anchor aria-hidden=true href=#软件解决方案>#</a></h2><p>屏蔽硬件中断简单有效，但受制于临界区执行时间，影响整个系统的效率。</p><h3 id=peterson>Peterson<a hidden class=anchor aria-hidden=true href=#peterson>#</a></h3><p>一个满足两个进程进程P<sub>i</sub> 和 P<sub>j</sub> 之间互斥的经典的基于软件的解决方法(1981年)，Peterson算法；Peterson 算法是基于双进程的互斥访问，需要两个锁：</p><ul><li>一个使用 flag，是一个布尔数组</li><li>另外一个使用 turn 的int锁</li></ul><p>而这两个锁都有可能出现死锁的情况：如</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>int turn = 0
</span></span><span class=line><span class=cl>turn = j
</span></span><span class=line><span class=cl>do {
</span></span><span class=line><span class=cl>	while( turn != i);
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    Critical Section
</span></span><span class=line><span class=cl>    turn = j;
</span></span><span class=line><span class=cl>    remainder section	
</span></span><span class=line><span class=cl>} while(1)</span></span></code></pre></td></tr></table></div></div></div></div><p>另外一个进程</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>int turn = 0
</span></span><span class=line><span class=cl>turn = i
</span></span><span class=line><span class=cl>do {
</span></span><span class=line><span class=cl>	while( turn != j);
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    Critical Section
</span></span><span class=line><span class=cl>    turn = i;
</span></span><span class=line><span class=cl>    remainder section	
</span></span><span class=line><span class=cl>} while(1)</span></span></code></pre></td></tr></table></div></div></div></div><p>满足了互斥，没满足progress（想进入临界区的进程），最终只有一个进程可以进入，无法进行流转。</p><p>Peterson 算法基于两个锁的临界区问题的解决方案：</p><ul><li>一个使用 flag，是一个布尔数组；<code>boolean flag[i]</code> 初始化为false，即没有进程有兴趣进入临界区</li><li>另外一个使用 turn 的int锁；进入临界区的进程</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>c</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>trun</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>boolean</span> <span class=n>flag</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=k>do</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>flag</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// 此时i想进入临界区
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>turn</span>  <span class=o>=</span> <span class=n>j</span>  <span class=c1>// 但是当前是i
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>flag</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>turn</span>  <span class=o>==</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    	<span class=n>critical</span> <span class=n>section</span>
</span></span><span class=line><span class=cl>    <span class=n>flag</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=n>remander</span> <span class=n>section</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>while</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div></div></div><p>Peterson 算法可以解决上述单锁的问题：</p><ul><li>互斥是有保证：任何时候仅有一个进程可以访问临界区</li><li>进程有保证：不会阻止临界区外其他进程进入临界区</li></ul><p>Peterson 算法的缺点：</p><ul><li>忙等待</li><li>仅限于两个进程</li></ul><h3 id=dekker>Dekker<a hidden class=anchor aria-hidden=true href=#dekker>#</a></h3><p>Dekker是另外一种临界区解决方法，Dekker从第五版才完整满足了所有的条件；dekker算法类似于Peterson 算法；下面是算法的实现：</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>thread1wantstoenter</span> <span class=p>=</span> <span class=kc>false</span> <span class=c1>// 进程是否在执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>thread2wantstoenter</span> <span class=p>=</span> <span class=kc>false</span> <span class=c1>// 进程是否在执行
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>favouredthread</span> <span class=kt>int</span> <span class=c1>// 进入临界区的进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>cs</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>thread1</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>thread2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>20</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d Start execute\n&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;get a lock, %d \n&#34;</span><span class=p>,</span> <span class=nx>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>thread1wantstoenter</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>thread2wantstoenter</span> <span class=o>==</span> <span class=kc>true</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;1 get a lock, thread %d also executing.\n&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>favouredthread</span> <span class=o>==</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;current cs thread is %d also executing.\n&#34;</span><span class=p>,</span> <span class=nx>favouredthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>thread1wantstoenter</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=nx>favouredthread</span> <span class=o>==</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 忙等待，一直等到当前临界区进程不为对方
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>thread1wantstoenter</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;not get lock, begin update cs1.\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>cs</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>1000</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=nx>favouredthread</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>		<span class=nx>thread1wantstoenter</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d has completed\n&#34;</span><span class=p>,</span> <span class=nx>favouredthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;cs value with update %d \n&#34;</span><span class=p>,</span> <span class=nx>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d Start execute\n&#34;</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;get a lock, %d \n&#34;</span><span class=p>,</span> <span class=nx>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>thread2wantstoenter</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>thread1wantstoenter</span> <span class=o>==</span> <span class=kc>true</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;2 get a lock, thread %d also executing.\n&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=nx>favouredthread</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;current cs thread is %d also executing.\n&#34;</span><span class=p>,</span> <span class=nx>favouredthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=nx>thread2wantstoenter</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=nx>favouredthread</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// 忙等待，一直等到当前临界区进程不为对方
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=nx>thread2wantstoenter</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;not get lock, begin update cs2.\n&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>cs</span> <span class=p>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nx>favouredthread</span> <span class=p>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>1000</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=c1>// 退出，标记着线程2已完成，
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>thread2wantstoenter</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d has completed\n&#34;</span><span class=p>,</span> <span class=nx>favouredthread</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;cs value with update %d \n&#34;</span><span class=p>,</span> <span class=nx>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>整个for部分是一个锁，如果其他进程没有占用临界区，则可以进入临界区；这样第一个 for保证了<strong>互斥</strong>，在两个进程都没有被标记时，至少有一个进程可以进入，这样保证了<strong>progess</strong>。</p><p>再假设，<strong>thread1</strong>永远卡在<code>thread2wantstoenter == true</code>；最终thread2会退出<code>favouredthread = 1</code>；这样的话不存在死锁，最终会脱离循环，脱离后会将自己设置为true <code>thread1wantstoenter = true</code>；这样的话，只要对方（<strong>thread2</strong>）为false了，即结束临界区访问；那么下一次循环将退出锁部分，并且可已访问临界区</p><p>如果不对 <code>favouredthread == counterpart</code> 进行判断，那么就会出现饥饿现象。</p><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220412232216377.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220412232216377.png#center alt=image-20220412232216377 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><blockquote><p>Reference</p><p><a href=https://www.tutorialspoint.com/dekker-s-algorithm-in-operating-system target=_blank rel="noopener nofollow noreferrer">dekker algorithm</a></p><p><a href=https://en.wikipedia.org/wiki/Dekker%27s_algorithm target=_blank rel="noopener nofollow noreferrer">wikipedia</a></p></blockquote><h3 id=bakery>bakery<a hidden class=anchor aria-hidden=true href=#bakery>#</a></h3><p>bakery算法是针对N个进程互斥提出的解决方法之一；</p><ul><li>每当有进程进入临界区时，会被分配一个数</li><li>拥有最小数的进程会被选入临界区；</li><li>如果进程P<sub>i</sub> 和 P<sub>j</sub> 被分配相同的数，并且 $i&lt;j$，那么进程P<sub>i</sub> 首先进入临界区，进程编号 i j不会重复<ul><li>定义操作符号 &lt;<ul><li>判断 $(a,b) &lt; (c,d)$；当 $a&lt;c$即 $(a,b)&lt;(c,d)$; 如果 $a=c$，那么则判断b和d</li><li>定义操作函数 <code>max()</code></li><li>$max(a_0,\ &mldr;,\ a_{n-1})$，是整个序列 $(a_0,\ &mldr;,\ a_{n-1})$ 中的一个数 <code>k</code>，使 $k > a_i$；</li><li><code>for i=0,... n-1</code></li></ul></li><li>定义共享数据<ul><li><code>boolean choosing[n]</code></li><li><code>int number[n]</code></li><li>初始值分别为false和0</li></ul></li></ul></li><li>数的分配以递增顺序产生 1 2 3 4 5&mldr;.</li></ul><p>需要满足的条件，当一个线程想要进入临界区时，它必须确保它具有最小的数字，但是还需：</p><ul><li>线程状态不为真，即已经完成选号，在进程数组中，并且状态为false</li><li>如果线程编号相同，那么最小id的可以进入，即 id和index比谁小 id是当前的id，index是列表中其他的线程</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>go</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>choosing</span> <span class=p>[]</span><span class=kt>bool</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>number</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>cs</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>thread</span><span class=p>(</span><span class=nx>id</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>maximum</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>500</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 19-25 线程i开始选择号码，为maximum+1
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>choosing</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=nx>maximum</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>number</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>maximum</span> <span class=p>=</span> <span class=nb>int</span><span class=p>(</span><span class=nx>math</span><span class=p>.</span><span class=nf>Max</span><span class=p>(</span><span class=nb>float64</span><span class=p>(</span><span class=nx>maximum</span><span class=p>),</span> <span class=nb>float64</span><span class=p>(</span><span class=nx>i</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>number</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=nx>maximum</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nx>choosing</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>number</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nx>i</span> <span class=o>!=</span> <span class=nx>id</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 此时进程j进入临界区但没有选号完成则i进行忙等待等待选号完成
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=nx>choosing</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 忙等待
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d busy-waiting 1. \n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=c1>// 当一个线程想要进入临界区时，必须确保它具有最小的数字（优先级最高）
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 当前线程 必须为最小，即number[id] &gt; number[i]需要忙等待
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>// 如果线程获得相同编号 ，id低的可以抢先 即 (number[id] == number[i] &amp;&amp; id &gt; i) 需要阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>for</span> <span class=nx>number</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=nx>number</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>&gt;</span> <span class=nx>number</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>||</span> <span class=p>(</span><span class=nx>number</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=o>==</span> <span class=nx>number</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=nx>id</span> <span class=p>&gt;</span> <span class=nx>i</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// 忙等待
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;thread %d busy-waiting 2.\n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 即所有的id全部等于0就是没有其他进程抢占。就可以进入临界区
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 临界区
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;critical section used by thread %d \n&#34;</span><span class=p>,</span> <span class=nx>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>cs</span> <span class=p>=</span> <span class=nx>id</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;critical section has been modified to %d \n&#34;</span><span class=p>,</span> <span class=nx>cs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 退出临界区
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Millisecond</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>100</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>	<span class=nx>number</span><span class=p>[</span><span class=nx>id</span><span class=p>]</span> <span class=p>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>number</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>choosing</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>bool</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>n</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>n</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>number</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=nx>n</span>
</span></span><span class=line><span class=cl>		<span class=nx>choosing</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=nf>thread</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span> <span class=o>*</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div></div></div><p>python的实现</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>python</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>threading</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BakeryAlgorithm</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1>#  declaration and initial values of global variables</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># ticket for threads in line, n - number of threads</span>
</span></span><span class=line><span class=cl>    <span class=n>tickets</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># True when thread entering in line</span>
</span></span><span class=line><span class=cl>    <span class=n>entering</span> <span class=o>=</span> <span class=p>[</span><span class=kc>False</span><span class=p>]</span><span class=o>*</span><span class=mi>5</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>lock</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span><span class=o>*</span><span class=n>args</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>entering</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>True</span>
</span></span><span class=line><span class=cl>        <span class=n>maximum</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>ticket</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>maximum</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>maximum</span><span class=p>,</span> <span class=n>ticket</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=n>maximum</span><span class=o>+</span><span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>entering</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait until thread j receives its number:</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>entering</span><span class=p>[</span><span class=n>i</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;waiting </span><span class=si>%d</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1># Wait until all threads with smaller numbers or with the samenumber, but with higher priority, finish their work:</span>
</span></span><span class=line><span class=cl>                <span class=k>while</span> <span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=ow>or</span> <span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span><span class=o>==</span><span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=ow>and</span> <span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span><span class=o>&gt;</span><span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;waiting </span><span class=si>%d</span><span class=s2> 2&#34;</span> <span class=o>%</span> <span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># The critical section goes here...</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;critical section used by process</span><span class=si>{</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>#exit section</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>tickets</span><span class=p>[</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]]</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Running all the 5 processes using thread module and  passing process index as args since Thread supports args and kwargs argument only</span>
</span></span><span class=line><span class=cl>        <span class=n>t1</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>,</span> <span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=mi>0</span><span class=p>,))</span> 
</span></span><span class=line><span class=cl>        <span class=n>t2</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>,</span> <span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=p>,))</span> 
</span></span><span class=line><span class=cl>        <span class=n>t3</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>,</span> <span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=mi>2</span><span class=p>,))</span> 
</span></span><span class=line><span class=cl>        <span class=n>t4</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>,</span> <span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=mi>3</span><span class=p>,))</span> 
</span></span><span class=line><span class=cl>        <span class=n>t5</span> <span class=o>=</span> <span class=n>threading</span><span class=o>.</span><span class=n>Thread</span><span class=p>(</span><span class=n>target</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>lock</span><span class=p>,</span> <span class=n>args</span> <span class=o>=</span> <span class=p>(</span><span class=mi>4</span><span class=p>,))</span> 
</span></span><span class=line><span class=cl>        <span class=n>t1</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t2</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t3</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t4</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>t5</span><span class=o>.</span><span class=n>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>BakeryAlgorithm</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>.</span><span class=n>main</span><span class=p>()</span></span></span></code></pre></td></tr></table></div></div></div></div><p><div class=pe-fancybox><a data-fancybox=gallery href=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220413171749388.png><img src=https://cdn.jsdelivr.net/gh/cylonchau/blogs@img/img/image-20220413171749388.png#center alt=image-20220413171749388 onerror='this.onerror=null,this.src="/placeholder.svg",this.className="pe-image-placeholder"'></a></div></p><ul><li>互斥：有没有可能2个以上进程同时进临界区<ul><li>最小的id才可进入临界区</li><li>如果多个id拿到同样最小号，那么他们的进程id也不一样，进程id最小的可以进入临界区</li><li>上述保证了互斥</li></ul></li><li>有界等待：等待的进程不超过$n-1$；可以保证每个进程都能进入临界区</li><li>progress：想进入临界区的进程，不想进入的number=0也会被驱逐</li></ul><blockquote><p>Reference</p><p><a href=https://cppsecrets.com/users/120612197115104981111171149751485164103109971051084699111109/Python-Implementation-of-Bakery-Algorithm.php target=_blank rel="noopener nofollow noreferrer">Python Implementation of Bakery Algorithm</a></p><p><a href=https://www.geeksforgeeks.org/bakery-algorithm-in-process-synchronization/ target=_blank rel="noopener nofollow noreferrer">bakery algorithm</a></p></blockquote><h2 id=更高级抽象>更高级抽象<a hidden class=anchor aria-hidden=true href=#更高级抽象>#</a></h2><p>硬件提供了一些原语</p><ul><li>像中断禁用, 原子操作指令等</li><li>大多数现代体系结构都这样</li></ul><p>操作系统提供更高级的编程抽象来简化并行编程</p><ul><li>例如，锁，信号量</li><li>从硬件原语中构建</li></ul><p>锁是一个抽象的数据结构</p><ul><li>一个二进制状态(锁定,解锁),两种方法</li><li><code>Lock::Acquire()</code> 锁被释放前一直等待,然后得到锁</li><li><code>Lock::Release()</code> 锁释放,唤醒任何等待的进程</li></ul><p>使用锁来编写临界区</p><ul><li><p>前面的例子变得简单起来:</p><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>lock_next_pid-&gt;Acquire();
</span></span><span class=line><span class=cl>new_pid = next_pid++;
</span></span><span class=line><span class=cl>lock_next_pid-&gt;Release();</span></span></code></pre></td></tr></table></div></div></div></div></li></ul><p>大多数现代体系结构都提供特殊的原子操作指令</p><ul><li>通过特殊的内存访问电路</li><li>针对单处理器和多处理器</li></ul><p>Test-and-Set 测试和置位</p><ul><li>从内存中读取值</li><li>测试该值是否为1(然后返回真或假)</li><li>内存值设置为1</li></ul><p>交换</p><ul><li>交换内存中的两个值</li></ul><div class="pe-code-block-wrap pe-code-details open scrollable"><div class="pe-code-block-header pe-code-details-summary"><div class=pe-code-block-header-left><i class="arrow fas fa-chevron-right fa-fw pe-code-details-icon" aria-hidden=true></i>
<span>text</span></div><div class=pe-code-block-header-center><span></span></div><div class=pe-code-block-header-right><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i>
<button class=pe-code-copy-button><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24" class="pe-icon"><path fill="currentcolor" fill-rule="evenodd" d="M7 5a3 3 0 013-3h9a3 3 0 013 3v9a3 3 0 01-3 3h-2v2a3 3 0 01-3 3H5a3 3 0 01-3-3v-9a3 3 0 013-3h2zm2 2h5a3 3 0 013 3v5h2a1 1 0 001-1V5a1 1 0 00-1-1h-9A1 1 0 009 5zM5 9a1 1 0 00-1 1v9a1 1 0 001 1h9a1 1 0 001-1v-9a1 1 0 00-1-1z" clip-rule="evenodd"/></svg></button></div></div><div class="pe-code-details-content scrollable"><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>bool TestandSet(bool *target){
</span></span><span class=line><span class=cl>		bool rv = *target;
</span></span><span class=line><span class=cl>		*target = true;
</span></span><span class=line><span class=cl>		return rv;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void Exchange(bool *a, bool *b){
</span></span><span class=line><span class=cl>		bool tmp = *a;
</span></span><span class=line><span class=cl>		*a = *b;
</span></span><span class=line><span class=cl>		*b = tmp;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div></div></div><ul><li><p>总结</p><p>锁是更高等级的编程抽象</p><ul><li>互斥可以使用锁来实现</li><li>通常需要一定等级的硬件支持</li></ul><p>常用的三种实现方法</p><ul><li>禁用中断(仅限于单处理器)</li><li>软件方法(复杂)</li><li>原子操作指令(单处理器或多处理器均可)</li></ul><p>可选的实现内容:</p><ul><li>有忙等待</li><li>无忙等待</li></ul></li></ul></div><div class=pe-copyright><hr><blockquote><p>本文为原创内容，版权归作者所有。如需转载，请在文章中声明本文标题及链接。</p><p>文章标题：ch9 同步</p><p>文章链接：<a href=https://www.oomkill.com/2022/04/ch9-synchronization/ target=_blank>https://www.oomkill.com/2022/04/ch9-synchronization/</a></p><p>许可协议：<a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></p></blockquote></div><div class=comments-separator></div><h3 class=relatedContentTitle>相关阅读</h3><ul class=relatedContent><li><a href=/2022/04/ch8-cpu-scheduling-algorithms/><span>ch8 CPU调度算法</span></a></li><li><a href=/2022/04/ch7-process-management/><span>ch7 进程管理</span></a></li><li><a href=/2022/04/ch6-page-replacement-algorithms/><span>ch6 页面置换算法</span></a></li><li><a href=/2022/04/ch5-virtual-memory/><span>ch5 虚拟内存</span></a></li><li><a href=/2022/04/ch4-non-contiguous-memory-allocation/><span>ch4 操作内存管理 - 非连续内存分配</span></a></li></ul><div class=comments-separator></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.oomkill.com/tags/os/>OS</a></li></ul><nav class=paginav><a class=prev href=https://www.oomkill.com/2022/04/ch8-cpu-scheduling-algorithms/><span class=title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-left" style="user-select:text"><line x1="19" y1="12" x2="5" y2="12" style="user-select:text"/><polyline points="12 19 5 12 12 5" style="user-select:text"/></polyline></svg>&nbsp;</span>
<span>ch8 CPU调度算法</span>
</a><a class=next href=https://www.oomkill.com/2022/04/ch7-process-management/><span class=title></span>
<span>ch7 进程管理&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right" style="user-select:text"><line x1="5" y1="12" x2="19" y2="12" style="user-select:text"/><polyline points="12 5 19 12 12 19" style="user-select:text"/></svg></span></a></nav></footer><div class=pe-comments-decoration><p class=pe-comments-title></p><p class=pe-comments-subtitle></p></div><div id=pe-comments></div><script src=/js/pe-go-comment.min.86a214102576ba5f9b7bdc29eed8d58dd56e34aef80b3c65c73ea9cc88443696.js integrity="sha256-hqIUECV2ul+be9wp7tjVjdVuNK74Czxlxz6pzIhENpY="></script><script>const getStoredTheme=()=>localStorage.getItem("pref-theme")==="dark"?"dark":"light",setGiscusTheme=()=>{const e=e=>{const t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")};e({setConfig:{theme:getStoredTheme()}})};document.addEventListener("DOMContentLoaded",()=>{const s={src:"https://giscus.app/client.js","data-repo":"cylonchau/cylonchau.github.io","data-repo-id":"R_kgDOIRlNSQ","data-category":"Announcements","data-category-id":"DIC_kwDOIRlNSc4CXy1U","data-mapping":"pathname","data-term":"posts/ch9 Synchronization","data-strict":"0","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"top","data-theme":getStoredTheme(),"data-lang":"zh-TW","data-loading":"lazy",crossorigin:"anonymous",async:""},e=document.createElement("script");Object.entries(s).forEach(([t,n])=>e.setAttribute(t,n)),document.querySelector("#pe-comments").appendChild(e);const t=document.querySelector("#theme-toggle");t&&t.addEventListener("click",setGiscusTheme);const n=document.querySelector("#theme-toggle-float");n&&n.addEventListener("click",setGiscusTheme)})</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.oomkill.com/>Cylon's Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> on
<a href=https://pages.github.com/ rel=noopener target=_blank>GitHub Pages</a> & Theme
        <a href=https://github.com/tofuwine/PaperMod-PE rel=noopener target=_blank>PaperMod-PE</a></span><div class=busuanzi-footer style="font-family:helvetica neue,Helvetica,Arial,sans-serif;text-align:center;padding:4px 0;color:#999"><span id=busuanzi_container_site_pv style=margin-right:8px;font-size:.85em>本站总访问量<span id=busuanzi_value_site_pv style=font-weight:500>0</span>次
</span><span id=busuanzi_container_site_uv style=font-size:.85em>本站访客数<span id=busuanzi_value_site_uv style=font-weight:500>0</span>人次</span></div></footer><div class=pe-right-sidebar><a href=javascript:void(0); id=theme-toggle-float class=pe-float-btn><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</a><a href=#top class=pe-float-btn id=top-link><span id=pe-read-progress></span></a></div><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>