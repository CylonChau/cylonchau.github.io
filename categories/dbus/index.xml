<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dbus on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/categories/dbus/</link>
    <description>Recent content in dbus on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 22 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/categories/dbus/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux Dbus中的ACL策略</title>
      <link>https://www.oomkill.com/2023/03/dbus-security-policy/</link>
      <pubDate>Wed, 22 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2023/03/dbus-security-policy/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>D-Bus 是 Linux 系统中的一种通信机制，用于在进程之间进行通信。D-Bus 配置文件则是一种用于配置 D-Bus 的文件，其中包含有关系统总线 (<em><strong>system bus</strong></em>)，会话总线 (<em><strong>session bus</strong></em>) 和各种系统服务的详细信息。</p>
<p>本文将解析 D-Bus 配置文件，侧重点则为权限的配置</p>
<h2 id="配置文件的基本结构">配置文件的基本结构</h2>
<p>D-Bus 配置文件使用 XML 格式进行编写，具有以下基本结构：</p>
<pre><code class="language-xml">&lt;!DOCTYPE busconfig PUBLIC &quot;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN&quot;
        &quot;http://www.freedesktop.org/standards/D-Bus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
  &lt;policy group=&quot;wheel&quot;&gt;
    &lt;!-- policy rules go here --&gt;
  &lt;/policy&gt;
  &lt;policy context=&quot;default&quot;&gt;
    &lt;!-- policy rules go here --&gt;
  &lt;/policy&gt;
  &lt;include filename=&quot;other-config.xml&quot;/&gt;
  &lt;listen&gt;unix:path=/var/run/D-Bus/system_bus_socket&lt;/listen&gt;
&lt;/busconfig&gt;
</code></pre>
<h2 id="什么是d-bus-policy">什么是D-Bus Policy？</h2>
<p>D-Bus Policy是D-Bus配置文件中最重要的字段之一，用于定义D-Bus服务的访问控制策略。D-Bus Policy包含了一组规则，用于限制D-Bus服务的使用者对D-Bus服务的访问，确保D-Bus服务的安全性。</p>
<p>这些规则可以限制对D-Bus的连接，以及对D-Bus服务的读写访问、接收和发送消息等操作，以助于保护D-Bus服务免受未经授权的访问和攻击。</p>
<p>D-Bus Policy 是由 dbus-daemon 进程执行的，dbus-daemon 进程是DBus 消息总线系统的核心组件。D-Bus Policy 则在系统启动时加载并编译 dbus-policy 文件。此文件定义了系统中所有服务和对象的访问控制。</p>
<h2 id="配置d-bus-policy">配置D-Bus Policy</h2>
<p>&lt;policy&gt; 元素定义了要应用于总线连接的特定一组安全策略，也就是这里的核心配置，  &lt;policy&gt; 段的主要的子配置包含两个 allow 与 deny</p>
<p>例如，下面是一个D-Bus Policy配置文件的示例：</p>
<pre><code class="language-xml">&lt;!DOCTYPE busconfig PUBLIC
  &quot;-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN&quot;
  &quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;
&lt;busconfig&gt;
    &lt;policy&gt;
      &lt;allow own=&quot;org.example.myapp&quot;/&gt;
      &lt;allow own=&quot;org.example.myapp.service&quot;/&gt;
      &lt;allow send_destination=&quot;org.example.myapp.service&quot;/&gt;
    &lt;/policy&gt;
&lt;/busconfig&gt;
</code></pre>
<p>其中 own 用于允许其他DBus进程注册特定的DBus服务名称。own则是DBus服务的名称，它指明了DBus服务注册的名称，而这两条 own 允许了 <code>org.example.myapp</code> 和 <code>org.example.myapp.service</code> 的名字被注册。</p>
<p>对于 own 存在四个回复标记</p>
<ul>
<li><code>RequestNameReplyPrimaryOwner</code>: 表示名称请求成功，您已成为主要所有者。</li>
<li><code>RequestNameReplyInQueue</code>: 表示名称请求被放置在名称队列中等待获取，因为另一个所有者正在使用该名称。请求没有立即成功，但您可以等待并在所有者释放名称所有权后获取名称所有权。</li>
<li><code>RequestNameReplyExists</code>: 表示名称请求失败，因为该名称已被另一个所有者占用，不能再次被分配给您。</li>
<li><code>RequestNameReplyAlreadyOwner</code>: 表示名称请求被拒绝，因为您已经是该名称的所有者。无需再次请求。</li>
</ul>
<p><code>send_destination</code> 指DBus进程发送消息的目的地DBus进程的名称，它指明了DBus进程消息通信的目标进程；而这条配置则表示 允许向 <code>org.example.myapp.service</code> 发送消息。这里 <code>org.example.myapp.service</code> 可以理解为是一个服务</p>
<h3 id="policy的优先级">policy的优先级</h3>
<p>在dbus policy 不同的上下文属性具有不同的优先级，优先级从高到低为：</p>
<ol>
<li>“at_console” 属性的优先级最高，表示进程是否在控制台上运行。如果该属性为1，则表示进程在控制台上运行，否则表示不在控制台上。</li>
<li>其次是 “user” 属性，它用于指定DBus进程所属的用户账户。</li>
<li>最后是 “group” 属性，它用于指定DBus进程所属的用户组。</li>
</ol>
<h3 id="默认策略">默认策略</h3>
<p>系统总线 ( <em><strong>system bus</strong></em> ) 对于发送方法调用拥有的总 bus 默认策略为拒绝，对于接收消息、发送信号 (<em><strong>signal</strong></em>) 和为每个 没有 NO_REPLY 标志的方法调用发送单个成功或错误回复具有默认允许策略。不允许发送多个预期数量的回复。</p>
<p>&lt;policy&gt; 包含四个属性，通常user, group 只系统的 id 可以看到的用户</p>
<ul>
<li>context：(default|mandatory)</li>
<li>at_console：&quot;(true|false)&quot;</li>
<li>user：&ldquo;username or userid&rdquo;</li>
<li>group：&ldquo;group name or gid&rdquo;</li>
</ul>
<h3 id="权限配置">权限配置</h3>
<p>&lt;deny&gt; 配置需要出现在  &lt;policy&gt; 最上方，表示禁止某些操作，&lt;allow&gt; 是对上面的 &lt;deny&gt; 语句进行修饰。</p>
<p>&lt;deny&gt; 确定是否拒绝与特定条件匹配的请求。如果匹配，则拒绝该操作（如果下面的 &lt;allow&gt; 允许，则允许），例如下列的配置</p>
<pre><code class="language-xml">&lt;policy context=&quot;default&quot;&gt;
    &lt;deny receive_path=&quot;/org/fedoraproject/FirewallD1&quot; /&gt;
    &lt;allow user=&quot;root&quot; /&gt;
    &lt;allow own=&quot;com.github.cylonchau.Uranus&quot; /&gt;
    &lt;allow receive_sender=&quot;com.github.cylonchau.Uranus&quot; receive_path=&quot;/org/fedoraproject/FirewallD1&quot; /&gt;
&lt;/policy&gt;
</code></pre>
<p>例如拒绝所有请求 <code>/org/fedoraproject/FirewallD1</code> 的请求，只允许服务 <code>com.github.cylonchau.Uranus</code> 发送请求 <code>/org/fedoraproject/FirewallD1</code> 的请求</p>
<p>具有一个或多个 <code>send_*</code> 系列属性的规则在连接尝试发送消息时按顺序检查。最后匹配消息的规则确定是否可以发送它。</p>
<p>而通常，已知的会话总线允许发送任何消息。通常，已知的系统总线允许发送任何信号，选择性地向dbus-daemon发送方法调用，并恰好回答先前已发送的每个方法调用（成功或错误）。</p>
<p>具有一个或多个 <code>receive_*</code> 系列属性或仅带有 <code>eavesdrop</code> 属性且没有其他属性的规则将为每个消息的 receiver 进行检查（如果消息是广播或连接正在窃听，则可能有多个接收者）。最后一个匹配消息的规则确定是否可以接收它。</p>
<p><code>send_destination</code> 和 <code>receive_sender</code> 规则表示消息不能被发送到或从给定名称的 “所有者” （服务）接收，而不是不能向该名称发送。即，如果连接拥有服务A、B、C，并且向A发送被拒绝，则向B或C发送也将无法工作。作为特例，<code>send_destination=&quot;*&quot;</code> 匹配任何消息（无论是否指定了目标），而 <code>receive_sender=&quot;*&quot;</code> 匹配任何消息。</p>
<h2 id="reference">Reference</h2>
<p><a href="https://dbus.freedesktop.org/doc/dbus-daemon.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-daemon</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux高级IPC - DBus</title>
      <link>https://www.oomkill.com/2021/11/what-is-dbus/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/11/what-is-dbus/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="what-is-ipc">What is IPC</h2>
<p>IPC [<em>Inter-Process Communication</em>]  <strong>进程间通信</strong>，指至少两个进程或线程间传送数据或信号的一些技术或方法。在Linux/Unix中，提供了许多IPC。Unix七大IPC：</p>
<ul>
<li><strong>Pipe</strong>：无名管道，最基本的IPC，单向通信，仅在父/子进程之间，也就是将一个程序的输出直接交给另一个程序的输入。常见使用为 <code>ps -ef|grep xxx</code></li>
<li><strong>FIFO [<code>(First in, First out)</code>] 或  有名管道（<code>named pipe</code>）</strong>:与Pipe不同，<strong>FIFO</strong>可以让两个不相关的进程可以使用FIFO。单向。</li>
<li><strong>Socket 和 Unix Domain Socket</strong>：socket和Unix套接字，双向。适用于网络通信，但也可以在本地使用。适用于不同的协议。</li>
<li><strong>消息队列 <code>Message Queue</code></strong>:  SysV 消息队列、POSIX 消息队列。</li>
<li><strong>Signal</strong>: 信号，是发送到正在运行的进程通知以触发其事件的特定行为，是IPC的一种有限形式。</li>
<li><strong>Semaphore</strong>：信号量，通常用于IPC或同一进程内的线程间通信。他们之间使用队列进行消息传递、控制或内容的传递。（常见SysV 信号量、POSIX 信号量）</li>
<li><strong>Shared memory</strong>：（常见SysV 共享内存、POSIX 共享内存）。共享内存，是在进程（程序）之间传递数据的有效方式，目的是在其之间提供通信。</li>
</ul>
<p>每种IPC都有不通的特点，每种方式对资源的使用及性能都是不通的</p>
<ul>
<li>管道 I/O是最快的，但为单向通信，需要工作在 父/子 进程关系之间。</li>
<li>UNIX 套接字可以在本地连接不同的进程，并且具有更高的带宽，并且没有固有的消息边界。</li>
<li>TCP/IP套接字可以连接任何进程。并且可以通过网络连接，但是对资源会有更多的开销，同样的没有固定的消息边界。</li>
</ul>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://stackoverflow.com/questions/404604/comparing-unix-linux-ipc" target="_blank"
   rel="noopener nofollow noreferrer" >comparsion Unix/Linux IPC</a></p>
</blockquote>
<h2 id="what-is-d-bus">What is D-Bus</h2>
<p>提到，D-Bus就不能不提一下freedesktop，而  D-Bus 仅仅作为<code>freedesktop.org</code>的一部分。</p>
<p>D-Bus 桌面总线 (<code>Desktop Bus</code>)，的简写，也是Linux- IPC机制，不同于Unix 7大基础IPC的是，D-Bus是在这些IPC类型之上实现的中间件IPC，D-Bus使用了基础IPC中一种过多种，其设计的目的是在Linux桌面环境，提供服务的标准化。但目前并没有合入主线内核中。</p>
<p>作为中间件IPC，D-Bus的性能较低与其他IPC模式，因为在通信过程中会进行很多上下文切换，如果通过Dbus来发送消息，会先将其发送到内核，然后将其送回D-Bus。<code>AF_BUS </code> 补丁是新的套接字类型，用来减少D-Bus上下文的切换。</p>
<p>更多可参考：https://en.wikipedia.org/wiki/D-Bus</p>
<h3 id="d-bus组成">D-Bus组成</h3>
<p>D-Bus是 一个IPC的实现方式，在架构上分位三层。</p>
<ul>
<li><strong>Layer 1 libdbus</strong>：freedesktop机构提供的一个免费开源的一个由C语言编写的 <code>low-level API</code> 。是提供dbus功能的库。是高级API绑定的低级API。</li>
<li><strong>Layer 2 dbus daemon</strong>：dbus实现的IPC守护进行，随Linux启动，通过不通进程对其的连接，实现了多进程间消息的路由（包含内核、网络、桌面等）</li>
<li><strong>Layer 3 Wapper libraries （high-level API）</strong>： 对  <code>low-level API</code> <em>libdbus</em>的封装 ，例如<code> libdbus-qt</code> <code> libdbus-python</code> <code>github.com/godbus/dbus</code>，这些不同编程语言实现的Wapper是不同开发者应该使用的lib，其简化了D-Bus的开发难度。</li>
</ul>
<p><img loading="lazy" src="https://www.softprayog.in/images/interprocess-communication-using-dbus.png" alt="使用 D-Bus 进行进程间通信" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>Reference</p>
<p><a href="https://dbus.freedesktop.org/doc/dbus-tutorial.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-tutorial</a></p>
</blockquote>
<h2 id="dbus-基本概念">dbus 基本概念</h2>
<h3 id="总线">总线</h3>
<p>在 D-Bus 中，bus是一个核心概念。它是应用程序可以进行方法调用、发送信号和侦听信号的通道。有两种预定义的bus：<em>会话总线</em>和<em>系统总线</em>。</p>
<ul>
<li>
<p><strong>会话总线（Session Bus）</strong>：普通进程创建，可同时存在多条。会话总线属于某个进程私有，它用于进程间传递消息。</p>
</li>
<li>
<p><strong>系统总线（System Bus）</strong>：在引导时就会启动，它由操作系统和后台进程使用，安全性非常好，以使得任意的应用程序不能欺骗系统事件。当然，如果一个应用程序需要接受来自系统总线的消息，他也可以直接连接到系统总线中，但是他能发送的消息是受限的。系统总线最常见的用途是在系统范围事件发生时发送系统范围的通知。添加新的存储设备、网络连接更改事件和关闭相关事件都是系统总线何时更适合通信总线的示例。</p>
</li>
</ul>
<p>通常情况下只存在一个<code>System Bus</code>，但可以存在多个<code>Session Bus</code>（每个桌面会话一个）。</p>
<p>总线以dbus-daemon的形式存在与系统中，该进程专门将消息从一个进程传递到另一个进程。该守护进程还将向总线上的所有应用程序转发通知。</p>
<h3 id="bus-name">bus name</h3>
<p>总线名称 Bus Name，不能单单以字面意思 <em>总线名称</em> 来理解，官方对其解释为**：<em>Connections have one or more bus names associated with them. A connection has exactly one bus name that is a unique connection name.</em>**，可以出bus name其实是用来连接名称。主要是用来标识一个应用和消息总线的连接。总线名称主要分为两类：唯一名称与公共名称。</p>
<ul>
<li>唯一连接名称 <code>unique connection names</code> ：以冒号（&rsquo;：&rsquo;）字符开头的 bus name是唯一的连接名称。例如 <code>:1.0</code>。每个连接都有一个唯一名。在一个 消息总线的生命期内，不会有两个连接有相同的唯一名。</li>
<li>公共连接名称 <code>well-known bus names</code>：公共名称是以反向DNS域名（小写）例如：<code>org.fedoraproject.FirewallD1</code>。
<ul>
<li>如果DNS 域名包含连字符/减号，则应将其替换为下划线，如果包含数字，则应通过添加下划线进行转义。例如： 7-zip.org的bus name应该定义为 <code>org._7_zip.Archiver</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Reference</p>
<p><a href="https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus" target="_blank"
   rel="noopener nofollow noreferrer" >bus name</a></p>
</blockquote>
<h3 id="对象路径">对象路径</h3>
<p>对象路径(<code>Object Paths</code>) 是用于引用对象实例的名称（类似于 C++ 或 Java 对象）。从概念上来说，D-Bus在消息交换中每个参与者都有任意个对象实例，如文件系统一样，Dbus中的参与者中的对象实例也会形成一个层次树。如，在CentOS7中 firewalld开发的D-Bus API 使用了<code>/org/fedoraproject/FirewallD1</code>的层次结构。</p>
<p>在定义一个对象路径时，需要注意以下：</p>
<ul>
<li>路径可以是任意长度</li>
<li>路径必须以 ASCII  &lsquo;/&rsquo;（整数 47）字符开头，并且必须由以斜杠字符分隔的元素组成。</li>
<li>每个元素只能包含 ASCII 字符 <code>[AZ][az][0-9]_</code></li>
<li>不允许出现 空字符串</li>
<li>多个 <code>/</code> 字符不能依次出现。 除非路径是根路径（单个<code>/</code>字符），否则不允许尾随 <code>/</code>字符。</li>
</ul>
<h3 id="接口名称">接口名称</h3>
<p><code>interface</code>，在每个 <code>Object Path</code>都包含多个接口，一般情况下接口名称应以==反向 DNS 域名开头==（小写），（同 Java 中的接口名称）。在命名规则上，与bus name相同。</p>
<p>例如：CentOS7中 firewalld开发的D-Bus API 定义的管理zone的接口 <code> org.fedoraproject.FirewallD1.config.zone</code>。如果DNS名称中包含<code>-</code>，则应将其替换为下划线 <code>_</code>。如果DNS 域名包含紧跟在  <code>.</code> 之后的数字，则接口名称应在数字之前添加一个下划线。例如，如果 <code>7-zip.org</code> 插件定义了一个接口，应该被命名为<code>org._7_zip.Plugin</code>.</p>
<h3 id="成员方法名称">成员方法名称</h3>
<p>成员方法名称，<code>Member names</code> ,对于定义了接口后，需要实现其接口的放法，如需要获得firewalld的zone时，就可以调用 <code>org.fedoraproject.FirewallD1.getDefaultZone</code> 。在D-Bus中<code>Member names</code>通常由“驼峰式”（<code>camel-case</code>）命名 。</p>
<h3 id="dbus">dbus</h3>
<p>在Linux中，如CentOS dbus包括 dbus daemon及一些cli commad。这些包dbuslib</p>
<h3 id="d-bus的消息">D-Bus的消息</h3>
<p>最基本的D-Bus协议是一对一的通信协议。与直接使用socket不同，D-Bus是面向消息的协议。 D-Bus的所有功能都是通过在连接上流动的消息完成的。</p>
<p>而在D-Bus中有四种类型的消息</p>
<ul>
<li>METHOD_CALL  方法调用</li>
<li>METHOD_RETURN  方法返回</li>
<li>ERROR 错误</li>
<li>SIGNAL 信号：与方法调用不同，信号发射没有响应。信号发射只是一个类型为 <code>SIGNAL</code> 的消息。它必须具有三个标头字段：<code>PATH</code>给出发出信号的对象，加上<code>INTERFACE</code>并<code>MEMBER</code>给出信号的完全限定名称。</li>
</ul>
<p>消息返回的类型</p>
<table>
<thead>
<tr>
<th>Conventional name</th>
<th>十进制值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>INVALID</code></td>
<td>0</td>
<td>这是个无效类型</td>
</tr>
<tr>
<td><code>METHOD_CALL</code></td>
<td>1</td>
<td>方法调用，该方法会有提示</td>
</tr>
<tr>
<td><code>METHOD_RETURN</code></td>
<td>2</td>
<td>方法返回的数据</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>3</td>
<td>错误返回，第一个是其错误的信息</td>
</tr>
<tr>
<td><code>SIGNAL</code></td>
<td>4</td>
<td>信号的发射</td>
</tr>
</tbody>
</table>
<h2 id="centos的dbus服务管理">CentOS的dbus服务管理</h2>
<p>在CentOS7中，作为systemd的一部分D-BUS会从Systemd获取套接字文件描述符，并使用D-Bus交换当前进程生成的socket信息。而PID 1 不使用 PolicyKit 来控制对特权操作的访问，而是完全依赖于 low-level API  D-Bus 。（这样做是为了避免 PolicyKit 和 systemd/PID 1 之间的循环依赖。）而有些特权进程（例如关机/重启/挂起/登陆）可以通过logind进行管理的。</p>
<p>由此，可以知道在CentOS中，dbus相关的服务大概有 <code>dbus</code>,与 <code>logind</code>。</p>
<p>dbus包含：</p>
<ul>
<li>
<p><a href="https://dbus.freedesktop.org/doc/dbus-daemon.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-daemon</a>：dbus架构中 layer 2的 dbus-damon</p>
</li>
<li>
<p><a href="https://dbus.freedesktop.org/doc/dbus-send.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-send</a>: dbus提供的命令行工具，可以用dbus-send来发送消息。</p>
</li>
<li>
<p><a href="https://dbus.freedesktop.org/doc/dbus-monitor.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-monitor</a>: dbus提供的命令行工具，用于监视总线上流动的消息。</p>
</li>
<li>
<p><a href="https://dbus.freedesktop.org/doc/dbus-launch.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-launch</a>： shell脚本启动消息总线的命令行工具</p>
</li>
</ul>
<h3 id="dbus配置文件说明">dbus配置文件说明</h3>
<p>dbus-daemon守护进程，有两个配置文件，一个为 session bus，另外一个为 system bus。</p>
<p>标准的system bus文件 <code>/usr/local/share/dbus-1/system.conf</code> session bus配置 <code>/usr/local/share/dbus-1/session.conf</code>中配置。在一般情况下，不会操作这两个文件，因其会引入 <code>/etc/dbus-1</code> 中的<code>system.conf</code>  或 <code>session.conf</code>。</p>
<p>配置文件包含的标签：</p>
<p>更多的注释可以参考：<a href="https://dbus.freedesktop.org/doc/dbus-daemon.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-daemon</a></p>
<pre><code class="language-xml"># 根元素
&lt;busconfig&gt;

  &lt;!-- 根据指定的 -system或 -session 来选择的配置文件 --&gt;
  &lt;type&gt;system&lt;/type&gt;

  &lt;!-- dbus-daemon运行的用户 --&gt;
  &lt;user&gt;dbus&lt;/user&gt;

  &lt;!-- Fork into daemon mode --&gt;
  &lt;fork/&gt;

  &lt;!-- We use system service launching using a helper --&gt;
  &lt;standard_system_servicedirs/&gt;

  &lt;!-- This is a setuid helper that is used to launch system services --&gt;
  &lt;servicehelper&gt;//usr/libexec/dbus-1/dbus-daemon-launch-helper&lt;/servicehelper&gt;

  &lt;!-- Write a pid file --&gt;
  &lt;pidfile&gt;/run/dbus/messagebus.pid&lt;/pidfile&gt;

  &lt;!-- Enable logging to syslog --&gt;
  &lt;syslog/&gt;

  &lt;!-- 指定授权机制。如果不存在，所有的机制都被允许。 --&gt;
  &lt;auth&gt;EXTERNAL&lt;/auth&gt;

  &lt;!-- 总线监听的地址，支持unix socket，tcp，system等
		--&gt;
  &lt;listen&gt;unix:path=/run/dbus/system_bus_socket&lt;/listen&gt;
  &lt;listen&gt;unix:path=/tmp/foo&lt;/listen&gt;
  &lt;listen&gt;tcp:host=localhost,port=1234&lt;/listen&gt;  
    
    
  &lt;policy context=&quot;default&quot;&gt;
    &lt;!-- All users can connect to system bus --&gt;
    &lt;allow user=&quot;*&quot;/&gt;

    &lt;!-- Holes must be punched in service configuration files for
         name ownership and sending method calls --&gt;
    &lt;deny own=&quot;*&quot;/&gt;
    &lt;deny send_type=&quot;method_call&quot;/&gt;

    &lt;!-- Signals and reply messages (method returns, errors) are allowed
         by efault --&gt;
    &lt;allow send_type=&quot;signal&quot;/&gt;
    &lt;allow send_requested_reply=&quot;true&quot; send_type=&quot;method_return&quot;/&gt;
    &lt;allow send_requested_reply=&quot;true&quot; send_type=&quot;error&quot;/&gt;

    &lt;!-- All messages may be received by default --&gt;
    &lt;allow receive_type=&quot;method_call&quot;/&gt;
    &lt;allow receive_type=&quot;method_return&quot;/&gt;
    &lt;allow receive_type=&quot;error&quot;/&gt;
    &lt;allow receive_type=&quot;signal&quot;/&gt;

    &lt;!-- Allow anyone to talk to the message bus --&gt;
    &lt;allow send_destination=&quot;org.freedesktop.DBus&quot;
           send_interface=&quot;org.freedesktop.DBus&quot; /&gt;
    &lt;allow send_destination=&quot;org.fedoraproject.FirewallD1&quot; 
	send_interface=&quot;org.fedorapproject.FirewallD1&quot; /&gt;
    &lt;allow send_destination=&quot;org.freedesktop.DBus&quot;
           send_interface=&quot;org.freedesktop.DBus.Introspectable&quot;/&gt;
    &lt;!-- But disallow some specific bus services --&gt;
    &lt;deny send_destination=&quot;org.freedesktop.DBus&quot;
          send_interface=&quot;org.freedesktop.DBus&quot;
          send_member=&quot;UpdateActivationEnvironment&quot;/&gt;
    &lt;deny send_destination=&quot;org.freedesktop.DBus&quot;
          send_interface=&quot;org.freedesktop.DBus.Debug.Stats&quot;/&gt;
    &lt;deny send_destination=&quot;org.freedesktop.DBus&quot;
          send_interface=&quot;org.freedesktop.systemd1.Activator&quot;/&gt;
  &lt;/policy&gt;

  &lt;!-- Only systemd, which runs as root, may report activation failures. --&gt;
  &lt;policy user=&quot;root&quot;&gt;
    &lt;allow send_destination=&quot;org.freedesktop.DBus&quot;
           send_interface=&quot;org.freedesktop.systemd1.Activator&quot;/&gt;
  &lt;/policy&gt;

  &lt;!-- root may monitor the system bus. --&gt;
  &lt;policy user=&quot;root&quot;&gt;
    &lt;allow send_destination=&quot;org.freedesktop.DBus&quot;
           send_interface=&quot;org.freedesktop.DBus.Monitoring&quot;/&gt;
  &lt;/policy&gt;

  &lt;!-- If the Stats interface was enabled at compile-time, root may use it.
       Copy this into system.local.conf or system.d/*.conf if you want to
       enable other privileged users to view statistics and debug info --&gt;
  &lt;policy user=&quot;root&quot;&gt;
    &lt;allow send_destination=&quot;org.freedesktop.DBus&quot;
           send_interface=&quot;org.freedesktop.DBus.Debug.Stats&quot;/&gt;
  &lt;/policy&gt;

  &lt;!-- Include legacy configuration location --&gt;
  &lt;include ignore_missing=&quot;yes&quot;&gt;/etc/dbus-1/system.conf&lt;/include&gt;

  &lt;!-- 包含的子配置文件. --&gt;
  &lt;includedir&gt;system.d&lt;/includedir&gt;

  &lt;includedir&gt;/etc/dbus-1/system.d&lt;/includedir&gt;

  &lt;!-- This is included last so local configuration can override what's 
       in this standard file --&gt;
  &lt;include ignore_missing=&quot;yes&quot;&gt;/etc/dbus-1/system-local.conf&lt;/include&gt;

  &lt;include if_selinux_enabled=&quot;yes&quot; selinux_root_relative=&quot;yes&quot;&gt;contexts/dbus_contexts&lt;/include&gt;

&lt;/busconfig&gt;
</code></pre>
<h3 id="通过命令行发送dbus消息">通过命令行发送dbus消息</h3>
<p>dbus支持通过命令发送一个dbus消息，如获取可用的dbus 服务。</p>
<pre><code class="language-bash">dbus-send --session \
--dest=org.freedesktop.DBus \
--type=method_call \
--print-reply \
/org/freedesktop/DBus \
org.freedesktop.DBus.ListNames

method return time=1631452206.288425 sender=org.freedesktop.DBus -&gt; destination=:1.29 serial=3 reply_serial=2
   array [
      string &quot;org.freedesktop.DBus&quot;
      string &quot;org.freedesktop.login1&quot;
      string &quot;org.freedesktop.systemd1&quot;
      string &quot;org.fedoraproject.FirewallD1&quot;
      string &quot;org.freedesktop.PolicyKit1&quot;
      string &quot;:1.17&quot;
      string &quot;:1.0&quot;
      string &quot;:1.29&quot;
      string &quot;:1.18&quot;
      string &quot;:1.1&quot;
   ]
</code></pre>
<p>返回org.freedesktop.DBus service</p>
<pre><code class="language-bash">dbus-send --session \
--dest=org.freedesktop.DBus \
--type=method_call \
--print-reply \
/org/freedesktop/DBus \
org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<h2 id="使用dbus-api操作linux防火墙">使用dbus api操作linux防火墙</h2>
<p>Firewalld是一个基于动态区域的防火墙守护进程，自 2009 年左右开始开发，目前为Fedora 18 以及随后的 RHEL7 和 CentOS 7 中的默认防火墙机制。</p>
<p><em>Firewalld</em>被配置为<em>systemd</em> D-Bus 服务。请注意下面的“Type=dbus”指令。</p>
<pre><code class="language-bash">$ cat /usr/lib/systemd/system/firewalld.service 
[Unit]
Description=firewalld - dynamic firewall daemon
Before=network.target
Before=libvirtd.service
Before=NetworkManager.service
Conflicts=iptables.service ip6tables.service ebtables.service

[Service]
EnvironmentFile=-/etc/sysconfig/firewalld
ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS
ExecReload=/bin/kill -HUP $MAINPID
# supress to log debug and error output also to /var/log/messages
StandardOutput=null
StandardError=null
Type=dbus
BusName=org.fedoraproject.FirewallD1

[Install]
WantedBy=basic.target
Alias=dbus-org.fedoraproject.FirewallD1.service
</code></pre>
<p>知道了<em>firewalld</em>服务是基于D-Bus的，就可以通过D-Bus来操作防火墙。</p>
<p>查看dbus注册的服务是否包含firewalld，这里需要注意的是，firewalld依赖dbus服务，每次启动firewalld时注册到dbus总线内。所以需要先启动<code>dbus-daemon</code>与 <code>firewalld </code> 服务。</p>
<pre><code class="language-bash">dbus-send --system --dest=org.freedesktop.DBus --type=method_call --print-reply \
/org/freedesktop/DBus org.freedesktop.DBus.ListNames | grep FirewallD
</code></pre>
<p>查看得知 <code>org.fedoraproject.FirewallD1</code> 为firewalld接口</p>
<p>查看接口所拥有的方法、属性、信号等信息</p>
<pre><code class="language-bash">dbus-send --system --dest=org.fedoraproject.FirewallD1 --print-reply \
/org/fedoraproject/FirewallD1 org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<p>获得zone</p>
<pre><code>firewall-cmd --get-zones

dbus-send --system \
--dest=org.fedoraproject.FirewallD1 \
--print-reply \
--type=method_call /org/fedoraproject/FirewallD1 \
org.fedoraproject.FirewallD1.zone.getZones
</code></pre>
<p>查看zone内的条目信息</p>
<pre><code class="language-bash">$ firewall-cmd --zone=public --list-all

dbus-send --system --dest=org.fedoraproject.FirewallD1 --print-reply --type=method_call \
/org/fedoraproject/FirewallD1 org.fedoraproject.FirewallD1.getZoneSettings string:&quot;public&quot;
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>使用firewalld dbus接口配置iptables</title>
      <link>https://www.oomkill.com/2021/11/firewalld-dbus-interface/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/11/firewalld-dbus-interface/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>firewalld，一个基于动态区的iptables/nftables守护程序，自2009年左右开始开发，CentOS7基于 <code>firewalld-0.6.3</code> ， 发布于2018年10月11日。主要的开发人员是托马斯·沃纳，他目前为红帽公司工作。这是因为为Federal 18 的默认防火墙机制， 随后在 Rhel7 和 Centos 7 中使用。</p>
<p>firewalld比旧的 iptable 机制有许多优势。值得注意的是，它解决了 iptable 要求每次更改时重新启动防火墙的问题，从而中断了任何状态连接。它还提供了丰富的 D-Bus 方法、信号和属性。</p>
<p>这里并不是从firewalld操作使用方式来介绍firewalld的改名，想反，是介绍firewalld D-Bus API来检索信息或更改设置。</p>
<p>firewalld被配置为系统 D-Bus 服务，注意看 systemd file中的&quot; <code>Type=dbus</code> &ldquo;参数。</p>
<pre><code>$ cat /usr/lib/systemd/system/firewalld.service
[Unit]
Description=firewalld - dynamic firewall daemon
Before=network-pre.target
Wants=network-pre.target
After=dbus.service
After=polkit.service
Conflicts=iptables.service ip6tables.service ebtables.service ipset.service
Documentation=man:firewalld(1)

[Service]
EnvironmentFile=-/etc/sysconfig/firewalld
ExecStart=/usr/sbin/firewalld --nofork --nopid $FIREWALLD_ARGS
ExecReload=/bin/kill -HUP $MAINPID
# supress to log debug and error output also to /var/log/messages
StandardOutput=null
StandardError=null
Type=dbus
BusName=org.fedoraproject.FirewallD1
KillMode=mixed

[Install]
WantedBy=multi-user.target
Alias=dbus-org.fedoraproject.FirewallD1.service
</code></pre>
<p>实际上，手动运行 <code>/usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid --debug</code> 效果是一样的，这里的注册是通过dbus 高级API操作的。</p>
<p>此时由于已经了解到了，firewalld 服务 是基于D-Bus接口的，所以需要找到对应的 dbus interface</p>
<pre><code>dbus-send --system --dest=org.freedesktop.DBus \
	--type=method_call --print-reply \
	/org/freedesktop/DBus org.freedesktop.DBus.ListNames | grep FirewallD
</code></pre>
<p><code>org.fedoraproject.FirewallD1</code> 这个就是firewalld注册的dbus interface了。</p>
<p><code>dbus-send</code> 命令可以向 D-Bus消息总线发送消息并显示该消息的返回结果。有两个众所周知的消息总线：system bus（<code>Option -System</code>） 和每个用户session bus（ <code>-session</code>）。使用 <code>firewall-cmd</code> 也是通过 dbus interface 进行交互的。在使用<code>dbus-send</code> 时，必须指定其对应的消息接口 <code> -dest</code>，该参数是连接到对应总线上的接口名称，以将消息发送到对应的dbus firewalld-server进行对应iptables规则的翻译。</p>
<p>现在有了dbus接口，需要了解改接口支持的方法 <code>methods</code>，属性 <code>properties </code>，信号<code>signals </code> 等信息。</p>
<pre><code>dbus-send --system --dest=org.fedoraproject.FirewallD1 --print-reply \
	/org/fedoraproject/FirewallD1 \
	org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<p>通过上述输出列出了通过防火墙 D-Bus 接口提供的所有方法、单一和属性。这是基于D-Bus DTD 的输出格式。所有 dbus服务都需要实现 <code>org.freedesktop.DBus.Introspectable.Introspect </code> 方法。</p>
<p>知道了 方法 属性 信号，就可以直接对firewalld进行一个操作了。现在开始第一个例子。获取默认zone。</p>
<pre><code>$ firewall-cmd --get-default-zone

dbus-send --system --dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \ 
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.getDefaultZone
</code></pre>
<p><strong>通过dbus接口来检索区域列表</strong></p>
<pre><code>$ firewall-cmd --get-zones

dbus-send --system \
	--dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \ 
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.zone.getZones
</code></pre>
<p><strong>最常用的命令：查看当前zone所有策略</strong></p>
<pre><code>$ firewall-cmd --zone=public --list-all

dbus-send --system \
	--dest=org.fedoraproject.FirewallD1 \
	--print-reply --type=method_call \
	/org/fedoraproject/FirewallD1 \
	org.fedoraproject.FirewallD1.getZoneSettings string:&quot;public&quot;
</code></pre>
<p><strong>获得inerface的properties</strong></p>
<p>其实这里在命令行根本用不到，但是在封装时却会可以用到。</p>
<pre><code>dbus-send --system \
	--print-reply --dest=org.fedoraproject.FirewallD1 \
	/org/fedoraproject/FirewallD1 \
	org.freedesktop.DBus.Properties.GetAll string:&quot;org.fedoraproject.FirewallD1&quot;
</code></pre>
<p>还可以通过其他的接口来查看对应的属性值</p>
<pre><code>dbus-send --system --print-reply 
--dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;version&quot;


$ dbus-send --system --print-reply \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;interface_version&quot;


$ dbus-send --system --print-reply \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;state&quot;

$ dbus-send --system --print-reply=literal \
   --dest=org.fedoraproject.FirewallD1 \
   /org/fedoraproject/FirewallD1 \
   org.freedesktop.DBus.Properties.Get \
   string:&quot;org.fedoraproject.FirewallD1&quot; \
   string:&quot;state&quot;
</code></pre>
<h3 id="查询规则">查询规则</h3>
<p><strong>查询接口</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1 \
    --print-reply \
    --type=method_call \
    /org/fedoraproject/FirewallD1 \
    org.fedoraproject.FirewallD1.zone.getZoneOfInterface \
    string:&quot;eth0&quot;
</code></pre>
<p><strong>创建一个新zone</strong></p>
<pre><code>dbus-send --session \
    --dest=org.freedesktop.DBus \
    --type=method_call \
    --print-reply /org/freedesktop/DBus  \
    org.fedoraproject.FirewallD1.config.addZone \
    string:&quot;testapi&quot;
</code></pre>
<p><strong>获得一个zone的所有规则（<code>zonesettings</code>）</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1  \
    --type=method_call \
    --print-reply /org/fedoraproject/FirewallD1  \
    org.fedoraproject.FirewallD1.getZoneSettings \
    string:&quot;public&quot;
</code></pre>
<p><strong>添加一个port</strong></p>
<pre><code>dbus-send --system \
    --dest=org.fedoraproject.FirewallD1 \
    --print-reply --type=method_call \
    /org/fedoraproject/FirewallD1 \
    org.fedoraproject.FirewallD1.zone.addPort \
    string:&quot;public&quot; \
    string:&quot;81&quot; \
    string:&quot;tcp&quot; \
    uint64:300 
</code></pre>
<p>对应设置firewalld 面板所有属性的命令</p>
<pre><code>firewall-cmd --zone=public --change-interface=eth0

firewall-cmd --zone=public --add-masquerade
firewall-cmd --zone=public --add-forward-port=port=1122:proto=tcp:toport=22:toaddr=192.168.100.3
firewall-cmd --zone=public --add-forward-port=port=1122:proto=tcp:toport=22:toaddr=10.0.0.3

firewall-cmd --add-protocol=tcp
firewall-cmd --add-protocol=udp

firewall-cmd --add-icmp-blocks=icmp
firewall-cmd --set-target=DROP

firewall-cmd --add-icmp-block=redirect
firewall-cmd --add-icmp-block=network-unknown

firewall-cmd --add-source-port=80/tcp
firewall-cmd --add-source-port=100/tcp

firewall-cmd --add-source=10.0.0.1
firewall-cmd --add-source=10.0.0.2

firewall-cmd --add-rich-rule='rule family=ipv4 source address=192.168.1.101/32 service name=telnet limit value=1/m accept'

firewall-cmd --add-icmp-block-inversion

firewall-cmd --new-zone=123 --permanen
</code></pre>
<h3 id="执行远程命令">执行远程命令</h3>
<p>dbus接口支持远程命令的，通过dbus-send发送时，根据配置dbus的监听来完成远程的操作</p>
<pre><code>DBUS_SESSION_BUS_ADDRESS=tcp:host=10.0.0.3,port=55557 
</code></pre>
<p>根据上述，参考加上官方文档，了解如何通过D-Bus接口操作FirewallD，虽然此处是使用了 <code>dbus-send</code>，但是也可以通过 qt 或者 其他的来管理 基于 dbus api的应用了。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>通俗易懂的dbus数据结构</title>
      <link>https://www.oomkill.com/2021/11/dbus-data-structure/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/11/dbus-data-structure/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>DBus中也是类似于静态语言，使用了“强类型”数据格式。在DBus上传递的所有数据都需要声明其对应的类型，下面整理了下，DBus中的数据类型，以及在DBus中声明的数据类型是什么意思。</p>
<table>
<thead>
<tr>
<th>dbus类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s</td>
<td>string 字符串类型，可以声明 s:</td>
</tr>
<tr>
<td>a</td>
<td>array 数组，可以声明为 a:</td>
</tr>
<tr>
<td>v</td>
<td>variant，variant:<type>:<value></td>
</tr>
<tr>
<td>()</td>
<td>结构体，声明时为双括号中间的为类型，可以是多个，例如(ss) 即这个结构体内包含两个字符串属性</td>
</tr>
<tr>
<td>b</td>
<td>布尔值</td>
</tr>
<tr>
<td>SIGNATURE</td>
<td>signature类型</td>
</tr>
<tr>
<td>y</td>
<td>BYTE</td>
</tr>
<tr>
<td>d</td>
<td>DOUBLE</td>
</tr>
<tr>
<td>t</td>
<td>UINT64</td>
</tr>
<tr>
<td>x</td>
<td>INT64</td>
</tr>
<tr>
<td>u</td>
<td>UINT32</td>
</tr>
<tr>
<td>i</td>
<td>INT32</td>
</tr>
<tr>
<td>q</td>
<td>uint16</td>
</tr>
<tr>
<td>n</td>
<td>INT16</td>
</tr>
<tr>
<td>{}</td>
<td>词典，这里声明为两个括号，中间为其对应的 key value，例如 {sv} 即 key是字符串类型，value是variant类型。</td>
</tr>
<tr>
<td>o</td>
<td>OBJECT_PATH 对象路径</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>a{sv}</code> :  是一个数组，为 一个键值对的词典，里面仅有一个</p>
</li>
<li>
<p><code>(ssssa{ss}as）</code> 为一个结构体， 里面属性有7个 两个词典（数组），五个字符串类型</p>
</li>
<li>
<p><code>(sssbsasa(ss)asba(ssss)asasasasa(ss)b)</code> 这个类型拆开为下：共16个属性</p>
<pre><code>(
 s string
 s string
 s string
 b bool
 s string
 as array only one string
 a(ss) two string type in the array
 as array only one string
 b bool
 a(ssss) four string type in the array
 as array only one string
 as array only one string
 as array only one string
 as array only one string
 a(ss)  two string type in the array
 b bool
 )
</code></pre>
<p>对上述类型，python中就可以很灵活的声明</p>
<pre><code>[&quot;&quot;, &quot;&quot;, &quot;&quot;, False, DEFAULT_ZONE_TARGET, [], [],
                         [], False, [], [], [], [], [], [], False]
</code></pre>
<p>go 中就需要按照对应类型声明为不通的结构体，属性名称可以不为主，顺序需要一致。</p>
<p><strong>其dbus收到的报文内容为</strong></p>
<pre><code>   struct {
      string &quot;&quot;
      string &quot;Public&quot; 
      string &quot;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&quot;
      boolean false
      string &quot;default&quot;
      array [
         string &quot;ssh&quot;
         string &quot;dhcpv6-client&quot;
      ]
      array [
         struct {
            string &quot;55555-55557&quot;
            string &quot;tcp&quot;
         }
      ]
      array [
         string &quot;redirect&quot;
         string &quot;network-unknown&quot;
      ]
      boolean true
      array [
         struct {
            string &quot;1122&quot;
            string &quot;tcp&quot;
            string &quot;22&quot;
            string &quot;10.0.0.3&quot;
         }
      ]
      array [
         string &quot;eth0&quot;
      ]
      array [
         string &quot;10.0.0.1&quot;
         string &quot;10.0.0.2&quot;
      ]
      array [
         string &quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.101/32&quot; service name=&quot;telnet&quot; accept limit value=&quot;1/m&quot;&quot;
      ]
      array [
         string &quot;tcp&quot;
         string &quot;udp&quot;
      ]
      array [
         struct {
            string &quot;80&quot;
            string &quot;tcp&quot;
         }
         struct {
            string &quot;100&quot;
            string &quot;tcp&quot;
         }
      ]
      boolean false
   }
</code></pre>
</li>
<li>
<p><code>ao</code>:  array，里面元素仅为一个<code>object_path</code></p>
</li>
</ul>
<h2 id="golang-中声明一个-variant">golang 中声明一个 Variant</h2>
<p>在go中看到variant类型如下</p>
<pre><code>type Variant struct {
	sig   Signature
	value interface{}
}
</code></pre>
<p>可以通过 <code>SignatureOf(&quot;short&quot;)</code>声明一个 <code>Signature</code></p>
<p>然后在通过：<code>MakeVariantWithSignature(v interface{}, s Signature) Variant</code> 声明 对应的 Variant</p>
<hr>
<p>注：其他数据类型与golang自己的数据类型一致，数组可以使用slice（类似php，python直接用数组替代即可更灵活）</p>
<hr>
<h2 id="more-reference"><strong>More Reference</strong></h2>
<ul>
<li>
<p><a href="http://www.fmddlmyy.cn/text54.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus data type</a></p>
</li>
<li>
<p><a href="http://www.fmddlmyy.cn/text54.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus data type conparision perl</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux dbus命令行套件</title>
      <link>https://www.oomkill.com/2021/10/dbus-client-tutorial/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2021/10/dbus-client-tutorial/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>D-Bus是Linux使用的进程间通信机制，允许各个进程互相访问，而不需要为每个其他组件实现自定义代码。即使对于系统管理员来说，这也是一个相当深奥的主题，但它确实有助于解释linux的另一部分是如何工作的。</p>
<p>这里主要介绍 <code>dbus-send</code> 与 <code>GDbus</code> cli工具，其他的还有<code>QtDbus</code> , <code>d-feet</code>&hellip;</p>
<p>命令行工具<code>dbus-send</code> ，是freedesktoop提供的dbus包配套的命令客户端工具，可用于发送dbus消息。</p>
<p><code>GDbus</code> GLib实现的dbus工具。较与 <code>dbus-send</code>，拥有更完整的功能。</p>
<p><code>d-feet</code>: 可以处理所有D-Bus服务的GUI应用程序。</p>
<h2 id="dbus-send">dbus-send</h2>
<p>dbus有两种消息总线 （<code>message bus</code>）：<code>system bus</code> 和 <code>session bus</code>，通过使用 <code>--system</code>和 <code>--session</code> 选项来通过<code>dbus-send</code> 向系统总线或会话总线发送消息。如果两者都未指定，默认为**session bus*.</p>
<p>借此，顺道聊下 <code>system bus</code> 和 <code>session bus</code>：</p>
<ul>
<li>
<p><code>System Bus</code>:</p>
<ul>
<li>在桌面上，为所有用户提供一条总线.</li>
<li>专用于系统服务。</li>
<li>有关于低级时间，例如 网络连接，USB设备。</li>
<li>在嵌入式Linux系统中，system bus是唯一D-Bus类型。</li>
<li></li>
</ul>
</li>
<li>
<p><code>Session Bus</code>:</p>
<ul>
<li>每个用户会话一个实例</li>
<li>为用户应用提供那个桌面服务。</li>
<li>连接到 <code>X-session</code></li>
</ul>
</li>
</ul>
<h3 id="参数选项">参数选项</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>--dest=NAME</code></td>
<td>这个是必选的参数，指定要接收消息的接口名称。例如 <code>org.freedesktop.ExampleName</code></td>
</tr>
<tr>
<td><code>--print-reply</code></td>
<td>打印回复消息</td>
</tr>
<tr>
<td><code>--print-reply=literal</code></td>
<td>如选项一样，打印回复正文。如有特殊字符，如对象或 object 则按字面打印，没有标点符号、转义字符等。</td>
</tr>
<tr>
<td><code>--reply-timeout=</code></td>
<td>可选参数，等待回复的超时时长，单位为 毫秒。</td>
</tr>
<tr>
<td><code>--system</code></td>
<td><code>--session</code></td>
</tr>
<tr>
<td><code>--type=method_call</code></td>
<td><code>signal </code></td>
</tr>
</tbody>
</table>
<p>必须始终指定要发送的消息的对象路径和名称。以下参数（如果有）是消息内容（消息参数）。这些值作为类型指定的值给出，可能包括如下所述的容器（数组、dict和变体）。</p>
<h3 id="支持参数">支持参数</h3>
<p><code>dbus-send</code> 发送的消息，在调用方法需要传参数时，必须将这些值给出。<code>dbus-send</code> 支持传入的参数的类型，并不为D-Bus支持的所有的数据类型，仅为一些简单的类型：如</p>
<ul>
<li>Type: 这里<code>type</code> 仅仅为简单的数据类型，即 <code>type:content</code>  ,支持的内容如下： <code>string | int16 | uint16 | int32 | uint32 | int64 | uint64 | double | byte | boolean | objpath</code>。</li>
<li>数组：<code>array = array:&lt;type&gt;:&lt;value&gt;[,&lt;value&gt;...]</code></li>
<li>词典: <code>dict = dict:&lt;type&gt;:&lt;type&gt;:&lt;key&gt;,&lt;value&gt;[,&lt;key&gt;,&lt;value&gt;...]</code>。</li>
<li>变体：<code>variant = variant:&lt;type&gt;:&lt;value&gt;</code>。</li>
</ul>
<p>根据官网的解析出来后如上述集中数据类型，更详细的描述可以根据官方 <a href="https://dbus.freedesktop.org/doc/dbus-send.1.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-send</a> 进行参考。</p>
<p><strong>可以通过一张图来理解 <code>dbus-send</code> 发送一个消息所需的几个必须参数</strong></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20211011223436036-907208415.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>通过简单的命令，来了解一个 <code>dbus-send</code> 命令如何传入参数</strong></p>
<pre><code class="language-bash"> dbus-send --dest=org.freedesktop.ExampleName \  # service
   /org/freedesktop/sample/object/name \  # object
   org.freedesktop.ExampleInterface.ExampleMethod \ # interface.method
   int32:47 string:'hello world' double:65.32	\ # param int
   array:string:&quot;1st item&quot;,&quot;next item&quot;,&quot;last item&quot; \ # param array
   dict:string:int32:&quot;one&quot;,1,&quot;two&quot;,2,&quot;three&quot;,3 \ # param dict
   variant:int32:-8 \ # param variant
   objpath:/org/freedesktop/sample/object/name # param object_path
</code></pre>
<h3 id="使用案例">使用案例</h3>
<p>如列出所有总线接口</p>
<pre><code class="language-shell">dbus-send --session \
  --dest=org.freedesktop.DBus \
  --type=method_call \
  --print-reply \
  /org/freedesktop/DBus \
  org.freedesktop.DBus.ListNames
</code></pre>
<p>查看对方总线所支持的对象接口，<code>org.freedesktop.DBus.Introspectable</code> 、<code>org.freedesktop.DBus.Properties</code> 和 <code>org.freedesktop.PowerManagement</code>。每个接口实现一些方法和信号。这些是你可以与之互动的东西。</p>
<pre><code class="language-bash">dbus-send --session \
	--type=method_call \
	--print-reply \
	--dest=org.freedesktop.DBus \ 
	/ \
	org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<p><code>dbus-send</code>，也支持调用远程总线接口，通过默认通过 <code>DBUS_SESSION_BUS_ADDRESS</code> 或 <code>DBUS_SYSTEM_BUS_ADDRESS</code>，来指定远程的总线。</p>
<pre><code>DBUS_SESSION_BUS_ADDRESS=&quot;&quot;
dbus-send --session \
	--type=method_call \
	--print-reply \
	--dest=org.freedesktop.DBus \ 
	/ \
	org.freedesktop.DBus.Introspectable.Introspect
</code></pre>
<h2 id="dbus-monitor">dbus-monitor</h2>
<p><code>dbus-monitor</code> 是一个可以监控 D-Bus 消息的命令行工具，。它可以调试和分析 D-Bus 通信间的数据包。</p>
<ol>
<li>监视所有消息</li>
</ol>
<p>要在控制台上监视所有 D-Bus 消息，可以使用以下命令：</p>
<pre><code class="language-bash">dbus-monitor
</code></pre>
<ol start="2">
<li>监视某个特定接口</li>
</ol>
<pre><code class="language-go">dbus-monitor interface=&quot;org.freedesktop.NetworkManager&quot;
</code></pre>
<ol start="3">
<li>监视某个特定路径下的对象</li>
</ol>
<pre><code class="language-bash">dbus-monitor path=&quot;/org/freedesktop/NetworkManager&quot;
</code></pre>
<ol start="4">
<li>监视某个特定接口和路径下的对象</li>
</ol>
<pre><code class="language-bash">dbus-monitor interface=&quot;org.freedesktop.NetworkManager&quot; \ 
	path=&quot;/org/freedesktop/NetworkManager&quot;
</code></pre>
<ol start="5">
<li>抓包输出到 Wireshark</li>
</ol>
<pre><code>dbus-monitor --pcap &gt; 1.pcap
</code></pre>
<p>​</p>
<h2 id="gdbus">gdbus</h2>
<p>gdbus是 GLib实现的dbus工具。较与 <code>dbus-send</code>，拥有更完整的功能。</p>
<p><code>introspect</code> : 可以打印出对象的接口和属性值。对应对象的所有者需要实现<code>org.freedesktop.DBus.Introspectable</code> 的接口。使用 <code>--xml</code>选项，将打印返回的<code>xml </code> 格式。<code>--recurse</code> 选项可将其子级等打印，<code>--only</code> 选项仅打印具有属性的接口。</p>
<p><code>monitor</code>: 类似于 <code>dbus-monitor</code></p>
<p><code>call</code>: 调用一个方法，传入的必须为 <code>GVariant</code> ,而相应的也为<code>GVariant</code>。</p>
<p><code>emit</code>: 发出信号。信号中包含的每个参数除字符串外都必须序列化为GVariant。</p>
<p>使用案例</p>
<pre><code>gdbus introspect --system \
	--dest org.freedesktop.UPower \
	--object-path \
	/ \
	--recurse  \
	--only-properties 
</code></pre>
<p>通过call 来向一个dbus service发送信息</p>
<pre><code>gdbus call --session \
             --dest org.freedesktop.Notifications \
             --object-path /org/freedesktop/Notifications \
             --method org.freedesktop.Notifications.Notify \
             my_app_name \
             42 \
             gtk-dialog-info \
             &quot;The Summary&quot; \
             &quot;Here's the body of the notification&quot; \
             [] \
             {} \
             5000
(uint32 12,)
</code></pre>
<p>监听一个服务的对象</p>
<pre><code>gdbus monitor \
	--system \
	--dest org.freedesktop.NetworkManager \
	--object-path /org/freedesktop/NetworkManager/AccessPoint/4141
</code></pre>
<p>发送信号</p>
<pre><code>gdbus emit --session \
	--object-path /foo \
	--signal org.bar.Foo &quot;['foo', 'bar', 'baz']&quot;
</code></pre>
<p>想特定进程发送信号，`&ndash;dest 为指定进程。</p>
<pre><code> gdbus emit \
 	--session \
 	--object-path /bar \
 	--signal org.bar.Bar someString \
 	--dest :1.42
</code></pre>
<h2 id="检查配置文件语法">检查配置文件语法</h2>
<p>CentOS 7 (dbus 1.10)，命令会启动一个dbus来验证配置文件的正确与否</p>
<pre><code class="language-bash">dbus-launch --sh-syntax --config-file=/path/to/config &gt; output.txt
</code></pre>
<p>higher</p>
<pre><code class="language-bash">dbus-daemon --config-file=/path/to/config --print-syntax
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Centos7 dbus问题总结</title>
      <link>https://www.oomkill.com/2020/09/centos7-dbus-troubleshooting/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/09/centos7-dbus-troubleshooting/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="authorization-not-available-check-if-polkit">Authorization not available. Check if polkit</h2>
<pre><code>Authorization not available. Check if polkit service is running or see debug message for more information.

dbus.socket failed to listen on sockets: Address family not supported by protocol
Failed to listen on D-Bus System Message Bus Socket.
</code></pre>
<p>这个问题是因为dbus.socket状态异常，所有依赖dbus的启动都会去通过systemcall连接 dbus，当服务不可用时，所有服务无法以systemd方式正常启动/关闭。需要检查dbus.socket是否正常。本地使用需保证unix套接字的监听时启动的</p>
<h2 id="did-not-receive-a-reply">Did not receive a reply</h2>
<pre><code>Failed to open connection to &quot;system&quot; message bus: Did not receive a reply. Possible causes include: the remote application did not send a reply, the message bus security policy blocked the reply, the reply timeout expired, or the network connection was broken.
</code></pre>
<p>这是因为你的配置不对，客户端无法连接上</p>
<h2 id="d-bus-重启后登陆慢">D-Bus 重启后登陆慢</h2>
<pre><code>systemd-logind: Failed to connect to system bus: Connection refused
systemd-logind: Failed to fully start up daemon: Connection refused
systemd: systemd-logind.service: main process exited, code=exited, status=1/FAILURE
systemd: Unit systemd-logind.service entered failed state.
systemd: systemd-logind.service failed.
systemd: systemd-logind.service has no holdoff time, scheduling restart.
systemd: start request repeated too quickly for systemd-logind.service
systemd: Unit systemd-logind.service entered failed state.
systemd: systemd-logind.service failed.

dbus[7782]: [system] Failed to activate service 'org.freedesktop.login1': timed out
dbus-daemon: dbus[7782]: [system] Failed to activate service 'org.freedesktop.login1':   timed out
</code></pre>
<p>参考：<a href="https://serverfault.com/questions/707377/slow-ssh-login-activation-of-org-freedesktop-login1-timed-out" target="_blank"
   rel="noopener nofollow noreferrer" >ssh登陆缓慢</a></p>
<p>systemd-logind主要功能是为每一个登陆session创建一个systemd角度的cgroup管理对象，更方便对session使用cgroup，在dbus服务异常时，systemd-logind会导致登陆缓慢，并不影响正常登陆和ssh登陆。重启dbus.socket后需要也重启systemd-logind</p>
<h2 id="d-bus-开启远程连接">D-Bus 开启远程连接</h2>
<p>编辑 <code>/usr/share/dbus-1/system.conf</code> 或 <code>/etc/dbus-1/session.conf</code></p>
<p>通常情况下生效的是 <code>/etc/dbus-1/system.conf</code> ,需要根据dbus应用是system bus 还是 session bus进行选择配置</p>
<pre><code>&lt;listen&gt;tcp:host=&lt;ip&gt;,bind=*,port=&lt;port&gt;,family=ipv4&lt;/listen&gt;
&lt;listen&gt;unix:path=/run/user/&lt;username&gt;/dbus/user_bus_socket&lt;/listen&gt;
&lt;listen&gt;unix:tmpdir=/tmp&lt;/listen&gt;

&lt;auth&gt;ANONYMOUS&lt;/auth&gt;
&lt;allow_anonymous/&gt;
</code></pre>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://blog.fpmurphy.com/2018/10/using-the-d-bus-interface-to-firewalld.html" target="_blank"
   rel="noopener nofollow noreferrer" >dbus-send使用</a></li>
<li><a href="https://stackoverflow.com/questions/61327052/linux-dbus-remote-tcp-connection-with-systemd-fails" target="_blank"
   rel="noopener nofollow noreferrer" >Linux DBus远程TCP连接失败</a></li>
</ul>
<h2 id="dbus-faq">dbus faq</h2>
<ul>
<li><a href="https://dbus.freedesktop.org/doc/" target="_blank"
   rel="noopener nofollow noreferrer" >faq</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
