<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>encryption on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/categories/encryption/</link>
    <description>Recent content in encryption on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 04 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/categories/encryption/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>常用加密算法学习总结之散列函数(hash function)</title>
      <link>https://www.oomkill.com/2020/11/hash-function/</link>
      <pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/hash-function/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>散列函数（Hash function）又称散列算法、哈希函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values）的指纹。这种转化是一种压缩映射，也就是散列值的空间通常远小于输入值的空间，不同的输入可能会散列成相同的输出，二不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要函数</strong>。</p>
<h2 id="散列函数性质">散列函数性质</h2>
<p>通过使用单向散列函数，即便是确认几百MB大小的文件的完整性，也只要对比很短的散列值就可以了。那么，单向散列函数必须具备怎样的性质呢？我们来整理一下。</p>
<ul>
<li>
<p><strong>根据任意长度的消息计算出固定长度的散列值</strong></p>
</li>
<li>
<p><strong>能够快速计算出散列值</strong></p>
</li>
</ul>
<p>计算散列值所花费的时间短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。</p>
<ul>
<li>
<p><strong>消息不同散列值也不同</strong></p>
</li>
<li>
<p><strong>难以发现碰撞的性质称为抗碰撞性（collisionresistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。在这里，散列值可以是任意值。密码技术中的单向散列函数必须具备强抗碰撞性。</p>
</li>
<li>
<p><strong>具备单向性</strong></p>
</li>
</ul>
<p>单向散列函数必须具备单向性（one-way）。单向性指的是无法通过散列值反算出消息的性质。根据消息计算散列值可以很容易，但这条单行路是无法反过来走的。</p>
<h2 id="散列函数的应用">散列函数的应用</h2>
<p>散列函数应用具有多样性</p>
<blockquote>
<p>安全加密：</p>
</blockquote>
<ul>
<li>保护资料，散列值可用于唯一地识别机密信息。这需要散列函数是抗碰撞(collision-resistant)的，意味着很难找到产生相同散列值的资料。如数字签名、消息认证码。</li>
</ul>
<blockquote>
<p>数据校验：</p>
</blockquote>
<ul>
<li>确保传递真实的信息：消息或数据的接受者确认消息是否被篡改的性质叫数据的真实性，也称为完整性。</li>
<li>错误校正：使用一个散列函数可以很直观的检测出数据在传输时发生的错误。</li>
</ul>
<blockquote>
<p>负载均衡：</p>
</blockquote>
<ul>
<li>通过hash算法，对客户端IP进行计算hash值，将取到值与服务器数量进行取模运算。</li>
</ul>
<blockquote>
<p>分布式存储：如一致性hash。</p>
</blockquote>
<h2 id="常用单项散列函数">常用单项散列函数</h2>
<h3 id="md4-md5">MD4 MD5</h3>
<p>MD5在1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p>
<h3 id="sha-1-sha-2">SHA-1 SHA-2</h3>
<p>SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS、GnuPG、SSH、S/MIME和IPsec，是MD5的后继者。但SHA-1的安全性在2010年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1。</p>
<p>SHA-2：2001年发布，包括<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>、<code>SHA-512</code>、<code>SHA-512/224</code>、<code>SHA-512/256</code>。<strong>SHA-2目前没有出现明显的弱点</strong>。虽然至今尚未出现对SHA-2有效的攻击，但它的算法跟SHA-1基本上仍然相似。 比特币使用的sha-256进行的数字签名</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法和变体</th>
<th style="text-align:center">输出散列值长度 （bits）</th>
<th style="text-align:center">中继散列值长度 （bits）</th>
<th style="text-align:center">资料区块长度 （bits）</th>
<th style="text-align:center">最大输入消息长度 （bits）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MD5</td>
<td style="text-align:center">128</td>
<td style="text-align:center">128 (4 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">无限</td>
</tr>
<tr>
<td style="text-align:center">SHA-0</td>
<td style="text-align:center">160</td>
<td style="text-align:center">160 (5 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">264 − 1</td>
</tr>
<tr>
<td style="text-align:center">SHA-1</td>
<td style="text-align:center">160</td>
<td style="text-align:center">160 (5 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">264 − 1</td>
</tr>
<tr>
<td style="text-align:center">SHA-2</td>
<td style="text-align:center"><em>SHA-224</em> <em>SHA-256</em></td>
<td style="text-align:center">224 256</td>
<td style="text-align:center">256 (8 × 32)</td>
<td style="text-align:center">512</td>
</tr>
<tr>
<td style="text-align:center"><em>SHA-384</em> <em>SHA-512</em> <em>SHA-512/224</em> <em>SHA-512/256</em></td>
<td style="text-align:center">384 512 224  256</td>
<td style="text-align:center">512 (8 × 64)</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">2128 − 1</td>
</tr>
</tbody>
</table>
<h2 id="go语言中使用散列函数">Go语言中使用散列函数</h2>
<h3 id="go语言使用md5">Go语言使用MD5</h3>
<p>方式一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">md5</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>方式2:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">getMD5_2</span><span class="p">(</span><span class="nx">str</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 1. 创建一个使用MD5校验的Hash对象`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">myHash</span> <span class="o">:=</span> <span class="nx">md5</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 2. 通过io操作将数据写入hash对象中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">io</span><span class="p">.</span><span class="nf">WriteString</span><span class="p">(</span><span class="nx">myHash</span><span class="p">,</span> <span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//io.WriteString(myHash, &#34;, world&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">myHash</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;, world&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 3. 计算结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">myHash</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 4. 将结果转换为16进制格式字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// --- 这是另外一种格式化切片的方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">res</span> <span class="p">=</span> <span class="nx">hex</span><span class="p">.</span><span class="nf">EncodeToString</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="go语言sha-1sha-2的使用">Go语言SHA-1、SHA-2的使用</h3>
<p>方法一：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">sha512</span><span class="p">.</span><span class="nf">Sum512</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">sha256</span><span class="p">.</span><span class="nf">Sum256</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>方法二与md5的使用类似</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之数字签名</title>
      <link>https://www.oomkill.com/2020/11/digital-signature/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/digital-signature/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>数字签名（Digital Signature），通俗来讲是基于非对称加密算法，用秘钥对内容进行散列值签名，在对内容与签名一起发送。</p>
<p><a href="http://www.youdzone.com/signature.html">更详细的解说</a>
<a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html">更详细的解说 - 中文</a></p>
<h2 id="数字签名的生成个验证">数字签名的生成个验证</h2>
<blockquote>
<p><strong>签名</strong></p>
<p>⑴ 对数据进行散列值运算。
⑵ 签名：使用签名者的私钥对数据的散列值进行加密。
⑶ 数字签名数据：签名与原始数据。</p>
</blockquote>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/how-do-digital-signatures-and-digital-certificates-work-together-in-ssl.png" alt="how do digital signatures and digital certificates work together in ssl"  /></p>
<center class="podsc">图：数字签名</center>
<center><em>Source：</em>https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/</center>
<blockquote>
<p><strong>验证</strong>
⑴ 接收数据：原始数据&amp;数字签名。
⑵ 使用公钥进行解密得到散列值。
⑶ 将原始数据的散列值与解密后的散列值进行对比。</p>
</blockquote>
<h2 id="go语言中使用rsa进行数字签名">Go语言中使用RSA进行数字签名</h2>
<blockquote>
<p>⑴ pem解码：使用pem对私钥进行解码, 得到pem.Block结构体
⑵ 获得私钥：使用GO x509接口<code>pem.Block</code>据解析成私钥结构体
⑶ 计算hash值：对明文进行散列值计算
⑷ 使用秘钥对散列值签名</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/rand&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/rsa&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/sha256&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;crypto/x509&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;encoding/pem&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">private</span> <span class="p">=</span> <span class="s">`-----BEGIN 私钥-----
</span></span></span><span class="line"><span class="cl"><span class="s">MIICXQIBAAKBgQDc73afIxqYOHg80puDIMYrqUAiTi8EiTVDEiO9YE3+VxRvN0sa
</span></span></span><span class="line"><span class="cl"><span class="s">pe3zx1UdhgIn3iCPUzyI2vwNADId3LjuIjkdCcdB2fHrBTbcy6u0545HnY42F9aQ
</span></span></span><span class="line"><span class="cl"><span class="s">7cAr168bHcqhQoKcna9i9nukO+w7So1J9C6Wr8J4e4923q7+T7z7bZeXywIDAQAB
</span></span></span><span class="line"><span class="cl"><span class="s">AoGBAItX5KLdywoyo3MJCdgcNaCX8MEyOmlL+HHC4ROxx78gQN0cLJw0Bu33zHEA
</span></span></span><span class="line"><span class="cl"><span class="s">ch+e8z4yKz3Nj6bLdtBqw6A9qXLBCfWfD/p9YKDZNFP/6+u9teUirOgiBSq7kXWy
</span></span></span><span class="line"><span class="cl"><span class="s">mtBm0I3pz33EomCuSJzLj/Mj/fkKs+425jPFcZboJdZpCyBhAkEA8mtGUGYuAZwV
</span></span></span><span class="line"><span class="cl"><span class="s">RKBDkf1bz5EyPBGV+9CyXa6pd6md61APY0j+qhb1w9ADfHKkAzfoilhpucznRhaz
</span></span></span><span class="line"><span class="cl"><span class="s">kAheqMPAMwJBAOlQEx2Ytc8TxfFqhF8RPTODe2N0jBBvsvJ85k7vNiQ+hnmaAray
</span></span></span><span class="line"><span class="cl"><span class="s">XS6pCbZdvmGHYKlz3MVGeis/UJKDdSzE0gkCQQCoZijkNPcEmz6S+5m00oFywXRa
</span></span></span><span class="line"><span class="cl"><span class="s">EgVUdndRaMHEpIlVK7pkyBJQab60Fc42JxUUP0RExoI7VcHbCG4YQhgvuDvNAkBQ
</span></span></span><span class="line"><span class="cl"><span class="s">CUolcwebe/sBcDrsqetGyqn/WjHaSZcnnDUdiu4VzOUwveaEafeRVCeiydHPfzNn
</span></span></span><span class="line"><span class="cl"><span class="s">rflkK2MphtTLDhGaRAKRAkASKlhV8aTBzTty/V3XMQfFVIAdHCyEIGMdjDDSzPly
</span></span></span><span class="line"><span class="cl"><span class="s">shZCn66IyIze8j5Q4ZLcRz6GPglHdrkBnyt4QFuGurpl
</span></span></span><span class="line"><span class="cl"><span class="s">-----END 私钥-----`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">public</span> <span class="p">=</span> <span class="s">`-----BEGIN 公钥-----
</span></span></span><span class="line"><span class="cl"><span class="s">MIGJAoGBANzvdp8jGpg4eDzSm4MgxiupQCJOLwSJNUMSI71gTf5XFG83Sxql7fPH
</span></span></span><span class="line"><span class="cl"><span class="s">VR2GAifeII9TPIja/A0AMh3cuO4iOR0Jx0HZ8esFNtzLq7TnjkedjjYX1pDtwCvX
</span></span></span><span class="line"><span class="cl"><span class="s">rxsdyqFCgpydr2L2e6Q77DtKjUn0Lpavwnh7j3berv5PvPttl5fLAgMBAAE=
</span></span></span><span class="line"><span class="cl"><span class="s">-----END 公钥-----`</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">digitalSign</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">,</span> <span class="nx">plainText</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">signText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pemBlock</span><span class="p">,</span> <span class="nx">_</span>   <span class="p">=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">privateStream</span> <span class="o">*</span><span class="nx">rsa</span><span class="p">.</span><span class="nx">PrivateKey</span>
</span></span><span class="line"><span class="cl">		<span class="nx">plainHash</span>     <span class="p">=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nf">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">plainText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">privateStream</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS1PrivateKey</span><span class="p">(</span><span class="nx">pemBlock</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">signText</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rsa</span><span class="p">.</span><span class="nf">SignPKCS1v15</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">privateStream</span><span class="p">,</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">SHA256</span><span class="p">,</span> <span class="nx">plainHash</span><span class="p">[:]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">digitalVerify</span><span class="p">(</span><span class="nx">publicKeyByte</span><span class="p">,</span> <span class="nx">plainText</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">signText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">ok</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pemBlock</span><span class="p">,</span> <span class="nx">_</span>  <span class="p">=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">publicKeyByte</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">publicStream</span> <span class="o">*</span><span class="nx">rsa</span><span class="p">.</span><span class="nx">PublicKey</span>
</span></span><span class="line"><span class="cl">		<span class="nx">plainHash</span>    <span class="p">=</span> <span class="nx">sha256</span><span class="p">.</span><span class="nf">Sum256</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">plainText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">publicStream</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS1PublicKey</span><span class="p">(</span><span class="nx">pemBlock</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rsa</span><span class="p">.</span><span class="nf">VerifyPKCS1v15</span><span class="p">(</span><span class="nx">publicStream</span><span class="p">,</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">SHA256</span><span class="p">,</span> <span class="nx">plainHash</span><span class="p">[:],</span> <span class="nx">signText</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">text</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">digitalSign</span><span class="p">(</span><span class="nx">private</span><span class="p">,</span> <span class="s">&#34;张三李四王五赵柳&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ok</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">digitalVerify</span><span class="p">(</span><span class="nx">public</span><span class="p">,</span> <span class="s">&#34;张三李四王五赵柳&#34;</span><span class="p">,</span> <span class="nx">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>总结
在Go语言API中公钥私钥的注释头尾也需要加上</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之非对称加密</title>
      <link>https://www.oomkill.com/2020/11/asymmetric/</link>
      <pubDate>Mon, 02 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/asymmetric/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种演算法。常用的非对称加密算法有 <code>RSA</code> <code>DSA</code> <code>ECC</code> 等。<a href="https://zh.wikipedia.org/zh-hans/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开密钥加密</a></p>
<p>非对称加密算法使用<strong>公钥</strong>、<strong>私钥</strong>来加解密。</p>
<ul>
<li>公钥与私钥是成对出现的。</li>
<li>多个用户（终端等）使用的密钥交公钥，只有一个用户（终端等）使用的秘钥叫私钥。</li>
<li>使用公钥加密的数据只有对应的私钥可以解密；使用私钥加密的数据只有对应的公钥可以解密。</li>
</ul>
<h2 id="非对称加密通信过程">非对称加密通信过程</h2>
<p>下面我们来看一看使用公钥密码的通信流程。假设Alice要给Bob发送一条消息，Alice是发送者，Bob是接收者，而这一次窃听者Eve依然能够窃所到他们之间的通信内容。 <a href="https://zh.wikipedia.org/zh-hans/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">参考自维基百科</a></p>
<blockquote>
<p>⑴ Alice与bob事先互不认识，也没有可靠安全的沟通渠道，但Alice现在却要透过不安全的互联网向bob发送信息。
⑵ Alice撰写好原文，原文在未加密的状态下称之为明文 <code>plainText</code>。
⑶ bob使用密码学安全伪随机数生成器产生一对密钥，其中一个作为公钥 <code>publicKey</code>，另一个作为私钥 <code>privateKey</code>。
⑷ bob可以用任何方法传送公钥<code>publicKey</code> 给Alice，即使在中间被窃听到也没问题。
⑸ Alice用公钥<code>publicKey</code>把明文<code>plainText</code>进行加密，得到密文 <code>cipherText</code>
⑹ Alice可以用任何方法传输密文给bob，即使中间被窃听到密文也没问题。
⑺ bob收到密文，用私钥对密文进行解密，得到明文 <code>plainText</code>。
由于其他人没有私钥，所以无法得知明文；如果Alice，在没有得到bob私钥的情况下，她将重新得到原文。</p>
</blockquote>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102205804406-1240772965.png" alt=""  />

  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102204939055-1888285763.png" alt=""  /></p>
<h2 id="rsa">RSA</h2>
<p>RSA是一种非对称加密算法，是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出，并以三人姓氏开头字母拼在一起组成的。</p>
<blockquote>
<p>RSA公钥和密钥的获取：随机选择两个大的素数，<code>p</code> <code>q</code>  $N = p*q$
RSA加密过程：$cipherText = plainText ^ E  mod  N$，$(N,e)$为公钥，$(N,d)$为私钥。
RSA解密过程：$plainText = cipherText^ D  mod     N$</p>
</blockquote>
<h2 id="go语言中rsa的应用">Go语言中RSA的应用</h2>
<h3 id="在go语言中生成公钥与私钥">在Go语言中生成公钥与私钥</h3>
<h4 id="生成秘钥流程">生成秘钥流程</h4>
<blockquote>
<p>⑴ 使用<code>crypto/rsa</code>中的<code>GenerateKey(random io.Reader, bits int)</code>方法生成私钥（结构体）
⑵ 因为X509证书采用了<a href="https://wuziqingwzq.github.io/ca/2017/12/26/x509-knowledge-asn1.html">ASN1</a>描述结构，需要通过Go语言API将的到的私钥（结构体），转换为<code>BER</code>编码规则的字符串。
⑶ 需要将ASN1 BER 规则转回为PEM数据编码。<code>pem.Encode(out io.Writer, b *Block)</code>
⑷ 将返回的数据保存</p>
</blockquote>
<h4 id="生成私钥">生成私钥</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GeneratePrivateKey</span><span class="p">(</span><span class="nx">keySize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">privateKey</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 生成私钥
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="nx">privateKeyStruct</span> <span class="o">*</span><span class="nx">rsa</span><span class="p">.</span><span class="nx">PrivateKey</span>
</span></span><span class="line"><span class="cl">		<span class="nx">privateStream</span>    <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">privateKeyStruct</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rsa</span><span class="p">.</span><span class="nf">GenerateKey</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">keySize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">privateStream</span> <span class="p">=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">MarshalPKCS1PrivateKey</span><span class="p">(</span><span class="nx">privateKeyStruct</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">privateBlock</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nx">Block</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="s">&#34;私钥&#34;</span><span class="p">,</span> <span class="nx">Bytes</span><span class="p">:</span> <span class="nx">privateStream</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">privateKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">privateBlock</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="通过私钥获取公钥">通过私钥获取公钥</h4>
<p>通过私钥获取公钥需要将私钥生成的步骤翻转</p>
<blockquote>
<p>⑴ 私钥[]byte解码为一个pemBlock <code>pem.Decode()</code>
⑵ pemBlock.Bytes是<code>BER</code>编码规则的字符串。将其转换为结构体 <code>x509.ParsePKCS1PrivateKey()</code>
⑶ 转换为的结构体的属性<code>PublicKey</code>为公钥结构体，需将其转换为<code>BER</code>编码规则的字符串。<code>x509.MarshalPKCS1PublicKey(&amp;PublicKey)</code>
⑷ 拼接公钥pemBlock，并需要将ASN1 BER规则字符串转回为PEM数据编码。<code>pem.Encode(out io.Writer, b *Block)</code></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">GetPublicKey</span><span class="p">(</span><span class="nx">privateKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">publicKey</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pemBlock</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">privateStream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS1PrivateKey</span><span class="p">(</span><span class="nx">pemBlock</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">publicStream</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">MarshalPKCS1PublicKey</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">privateStream</span><span class="p">.</span><span class="nx">PublicKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">privateBlock</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nx">Block</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="s">&#34;公钥&#34;</span><span class="p">,</span> <span class="nx">Bytes</span><span class="p">:</span> <span class="nx">publicStream</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">publicKey</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">privateBlock</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102235640888-2142103656.png" alt=""  /></p>
<h3 id="使用rsa密钥进行加解密">使用RSA密钥进行加解密</h3>
<p>RSA加/解密步骤</p>
<blockquote>
<p>⑴ 因为在生成公钥与私钥时，进行了pem编码，需要先对其（一般情况下加密都使用公钥）进行解码为pemBlock。<code>pem.Decode()</code>
⑵ pemBlock.Bytes是<code>BER</code>编码规则的字符串。将其转换为结构体 <code>x509.ParsePKCS1PublicKey(pemBlock.Bytes)</code>
⑶ 使用 <code>rsa.DecryptPKCS1v15</code> 或 <code>rsa.EncryptPKCS1v15</code> 进行加解密，如：<code>rsa.DecryptPKCS1v15(rand.Reader, public|private stream, []byte plain|cipher)</code>，返回值即为加/解密好的数据。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">RSAEncrypt</span><span class="p">(</span><span class="nx">publicKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">plainText</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">cipherText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pemBlock</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">publicKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">publicStream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS1PublicKey</span><span class="p">(</span><span class="nx">pemBlock</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">cipherText</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rsa</span><span class="p">.</span><span class="nf">EncryptPKCS1v15</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">publicStream</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">plainText</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">RSADecrypt</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">,</span> <span class="nx">cipherText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">plainText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pemBlock</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">pem</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">privateKey</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">privateStream</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">x509</span><span class="p">.</span><span class="nf">ParsePKCS1PrivateKey</span><span class="p">(</span><span class="nx">pemBlock</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">plainText</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rsa</span><span class="p">.</span><span class="nf">DecryptPKCS1v15</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">privateStream</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201103160438176-867986897.png" alt=""  /></p>
<blockquote>
<p>总结</p>
<ul>
<li>Go语言接口中，明文内容的长度不能大于秘钥本身。</li>
<li>RSA算法加解密速度慢，不推荐对较大数据加密。</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之对称加密</title>
      <link>https://www.oomkill.com/2020/10/symmetric/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/10/symmetric/</guid>
      <description></description>
      <content:encoded><![CDATA[<p><strong>对称加密</strong>，又称为 <strong>共享密钥加密算法</strong>，是指加密和解密方使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031172028652-1698637107.png" alt=""  /></p>
<h3 id="des">DES</h3>
<p>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS）</p>
<h4 id="des的加密和解密">DES的加密和解密</h4>
<p>DES是一种将64bit（8Byte）的明文加密成64bit的密文的对称密码算法，==它的密钥长度是56比特==。<font color="red">从规格上来说，DES的密钥长度是64bit，但由于每隔7bit会设置一个用于==错误检查==的比特，因此实质上其密钥长度是56bit</font>。</p>
<p><font color="red">DES是以64bit的明文（比特序列）为一个单位来进行加密的</font>，<strong>这个64bit的单位称为分组</strong>。一般来说，以分组为单位进行处理的密码算法称为<strong>分组密码（blockcipher）</strong>，DES就是分组密码的一种。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031173939221-127508220.png" alt=""  /></p>
<p>DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。</p>
<h3 id="3des">3DES</h3>
<p>3DES（Triple DES）：是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p>3DES是基于计算机的运算能力的增强，基于DES算法，增强秘钥进行多绪加密，而不是一种块密码算法。</p>
<h3 id="aes">AES</h3>
<p>AES（Advanced Encryption Standard）：高级加密标准，是美国联邦政府采用的一种区块加密标准。</p>
<h3 id="分组密码模式">分组密码模式</h3>
<p>**分组密码（<code>blockcipher</code>）**是每次只能处理特定长度的一块数据的一类密码算法，这里的一块&quot;就称为分组（block）。此外，一个分组的比特数就称为分组长度（<code>blocklength</code>）。</p>
<p>例如，<strong>DES和3DES的分组长度都是64比特</strong>。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。</p>
<p><strong>AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。</strong></p>
<p><strong>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）</strong>。</p>
<p>分组密码的模式有很多种类，分组密码的主要模式有以下5种：</p>
<h4 id="明文与密文分组">明文与密文分组</h4>
<ul>
<li>**明文分组: **是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</li>
<li>**密文分组: **是指使用分组密码算法将明文分组加密之后所生成的密文。</li>
</ul>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180750458-1657314183.png" alt=""  /></p>
<h4 id="ecb模式electronic-code-book-mode电子密码本模式">ECB模式：Electronic Code Book mode（电子密码本模式）</h4>
<p>ECB是最简单的加密模式，<font color="red">明文消息被分成固定大小的块（分组），并且每个块被单独加密。</font>  每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<font color="red">安全性比较差。  适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</font></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180917418-1828892139.png" alt=""  />

  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180907816-1922224853.png" alt=""  /></p>
<blockquote>
<p>使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，因此ECB模式也称为电子密码本模式<strong>当最后一个明文分组的内容小于分组长度时（如一个分组8bit），需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度</strong>。</p>
</blockquote>
<blockquote>
<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>
</blockquote>
<h4 id="cbc模式cipher-block-chaining-mode密码分组链接密码块-模式">CBC模式：Cipher Block Chaining mode（密码分组链接/密码块 模式）</h4>
<p>1976年，IBM发明了密码分组链接CBC。CBC<font color="red">模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密</font>。 这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，<font color="red">在<strong>第一个块</strong>进行加密之前需要用初始化向量 <code>IV</code> 进行异或操作</font>。  <font color="blue">CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。</font></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031194830815-323142789.png" alt=""  /></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031194838945-4927688.png" alt=""  /></p>
<p>**当加密第一个明文分组时，由于不存在 “前一个密文分组&quot;，因此<font color="red">需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组</font>&quot;，这个比特序列称为初始化向量（initialization vector）**通常缩写为 <code>IV</code>。一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。</p>
<h4 id="cfb模式cipher-feedback-mode密文反馈模式">CFB模式：Cipher FeedBack mode（密文反馈模式）</h4>
<p>密文反馈模式 CFB；在CFB模式中，<font color="red">前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</font>。所谓反馈，这里指的就是返回输入端的意思，即前一个密文分组会被送回到密码算法的输入端。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031200320644-9430185.png" alt=""  />

  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031200333802-435217010.png" alt=""  /></p>
<p>在ECB和CBC中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组和密文分组之间并没有经过&quot;加密&quot;这一步骤，明文分和密文分组之间只有一个XOR。</p>
<h4 id="ofb模式output-feedback-mode输出反馈模式">OFB模式：Output FeedBack mode（输出反馈模式）</h4>
<p>输出反馈模式, OFB。在OFB模式中，上一个分组密码算法的输出是当前分组密码算法的输入（下图）</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031201815366-1110323402.png" alt=""  /></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031201835300-606590872.png" alt=""  /></p>
<h4 id="ctr模式counter-mode计数器模式"><strong>CTR模式</strong>：CounTeR mode（计数器模式）</h4>
<p><font color="red">CTR是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码</font>；即每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202045165-1475648471.png" alt=""  /></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202056336-731754020.png" alt=""  /></p>
<p><strong>CTR模式的特点</strong></p>
<blockquote>
<p>CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。
CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器&quot;的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。
CTR模式能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。</p>
</blockquote>
<p>总结</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202458031-1831855010.png" alt=""  /></p>
<blockquote>
<p>初始化向量 - IV</p>
<ul>
<li>ecb, ctr模式不需要初始化向量</li>
<li>cbc, ofc, cfb需要初始化向量</li>
</ul>
</blockquote>
<blockquote>
<p>最后一个明文分组的填充</p>
<ul>
<li>使用cbc, ecb需要填充
<ul>
<li>明文分组中进行了填充, 然后加密</li>
<li>解密密文得到明文, 需要把填充的字节删除</li>
</ul>
</li>
<li>使用 ofb, cfb, ctr不需要填充</li>
</ul>
</blockquote>
<h2 id="对称加密在go语言中的实现方式">对称加密在Go语言中的实现方式</h2>
<h3 id="cbc分组模式">CBC分组模式</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @brief DES加密函数，
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @param1 加密的明文
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @param2 秘钥
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @return，得到的密文
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">DesEncrypt</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建一个des加密的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">des</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 分组加密 需要对最后进行填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">padText</span>    <span class="p">=</span> <span class="nf">LastPadding</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">plainText</span><span class="p">),</span> <span class="nx">block</span><span class="p">.</span><span class="nf">BlockSize</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="nx">cipherText</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">padText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建使用cbc分组模式加密接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nf">NewCBCEncrypter</span><span class="p">(</span><span class="nx">block</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;12345678&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 加密
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span><span class="p">.</span><span class="nf">CryptBlocks</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">,</span> <span class="nx">padText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cipherText</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @brief DES解密函数，
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @param1 加密的明文
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @param2 秘钥
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  @return，得到的密文
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">DesDecrypt</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建一个des加密的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">des</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建使用cbc分组模式解密接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">mode</span>           <span class="p">=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nf">NewCBCDecrypter</span><span class="p">(</span><span class="nx">block</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;12345678&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">byteCipherText</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 明文存储变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">plainText</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">byteCipherText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解密，无返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span><span class="p">.</span><span class="nf">CryptBlocks</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">byteCipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将填充的内容删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nf">LastUnPadding</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">des</span><span class="p">.</span><span class="nx">BlockSize</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201101190422825-4035893.png" alt=""  /></p>
<blockquote>
<p>总结</p>
<ul>
<li>DES使用64bit钥对数据块进行加密</li>
<li>在Go语言中<code>iv</code>的长须需要与密钥对长度一致。</li>
<li>CBC使用的流密码算法</li>
<li>CBC需要对最后明文分组填充</li>
</ul>
</blockquote>
<h3 id="ofb分组模式">OFB分组模式</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">OFBEncrypt</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建一个des加密的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">des</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 分组加密 需要对最后进行填充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nx">cipherText</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">plainText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建使用cbc分组模式加密接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nf">NewOFB</span><span class="p">(</span><span class="nx">block</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;12345678&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//mode := cipher.NewCBCEncrypter(block, []byte(&#34;12345678&#34;))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 加密
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span><span class="p">.</span><span class="nf">XORKeyStream</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">plainText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">cipherText</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">OFBDecrypt</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建一个des加密的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">des</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建使用cbc分组模式解密接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">mode</span>           <span class="p">=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nf">NewOFB</span><span class="p">(</span><span class="nx">block</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;12345678&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">byteCipherText</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 明文存储变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">plainText</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">byteCipherText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 解密，无返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span><span class="p">.</span><span class="nf">XORKeyStream</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">byteCipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将填充的内容删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nf">LastUnPadding</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">des</span><span class="p">.</span><span class="nx">BlockSize</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201101214408337-854797848.png" alt=""  /></p>
<h3 id="填充方式">填充方式</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  填充函数，如果最后一个分组字节数不够则填充，填充的字节数为缺少的字节数
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  如果最后一个字节数正好的话，则新建一个分组
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LastPadding</span><span class="p">(</span><span class="nx">plainText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">blockSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获得明文的长度，以判断时候需要补充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">paddingLength</span> <span class="p">=</span> <span class="nx">blockSize</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nx">plainText</span><span class="p">)</span><span class="o">%</span><span class="nx">blockSize</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 初始化填充的内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">padText</span> <span class="p">=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Repeat</span><span class="p">([]</span><span class="kt">byte</span><span class="p">{</span><span class="nb">byte</span><span class="p">(</span><span class="nx">paddingLength</span><span class="p">)},</span> <span class="nx">paddingLength</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//将填充的内容追加到明文后
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nb">append</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">padText</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  删除填充函数，如果最后一个分组字节数不够则填充，填充的字节数为缺少的字节数
</span></span></span><span class="line"><span class="cl"><span class="cm"> *  如果最后一个字节数正好的话，则新建一个分组
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">LastUnPadding</span><span class="p">(</span><span class="nx">plainText</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">blockSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获得明文的长度，以判断时候需要补充
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">paddingLength</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">plainText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 获得尾部填充的字节数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">lastChar</span> <span class="p">=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">plainText</span><span class="p">[</span><span class="nx">paddingLength</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">TrimFunc</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">r</span> <span class="kt">rune</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">r</span> <span class="o">==</span> <span class="nb">rune</span><span class="p">(</span><span class="nx">lastChar</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>总结</p>
<ul>
<li>ofb不需要最后为明文分组填充</li>
<li>加密算法Go语言API已经提供，但算法的分组业务流程需要自己实现</li>
</ul>
</blockquote>
<h3 id="aes-1">AES</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">AESEncrypt</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 创建一个AES加密的接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">block</span><span class="p">,</span> <span class="nx">err</span>     <span class="p">=</span> <span class="nx">aes</span><span class="p">.</span><span class="nf">NewCipher</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">byteCipherText</span> <span class="p">=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">cipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 明文存储变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">plainText</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">byteCipherText</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 创建使用cbc分组模式解密接口
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span> <span class="o">:=</span> <span class="nx">cipher</span><span class="p">.</span><span class="nf">NewOFB</span><span class="p">(</span><span class="nx">block</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;1234567812345678&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 解密，无返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mode</span><span class="p">.</span><span class="nf">XORKeyStream</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">byteCipherText</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 将填充的内容删除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">return</span> <span class="nf">LastUnPadding</span><span class="p">(</span><span class="nx">plainText</span><span class="p">,</span> <span class="nx">aes</span><span class="p">.</span><span class="nx">BlockSize</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102002205863-975724083.png" alt=""  /></p>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li>AES秘钥为 16,24,32 Byte 即 128,196,256 bit</li>
<li>在无需明文填充的分组模式下，<code>ofb</code> <code>cfb</code>  <code>ctr</code>，加密解密的业务逻辑处理是一样的。</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法之数字证书与TLS/SSL</title>
      <link>https://www.oomkill.com/2020/08/openssl-x509/</link>
      <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/08/openssl-x509/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="数字证书">数字证书</h2>
<p>互联网上任意双方之间实现通信时，证书的目的有两种，</p>
<ul>
<li>主机证书，主要实现主机与主机之间进程间通信的。</li>
<li>个人证书，主要用作个人通信的，主要用作加密的数据的发送。</li>
</ul>
<p>主机类证书所拥有的标识主要为<code>主机名</code>，主机证书名称一定要与互联网之上访问名称一致，否则此证书为不可信证书。</p>
<p>对于一个安全的通信，应该有以下特征：</p>
<ul>
<li>完整性：消息在传输过程中未被篡改</li>
<li>身份验证：确认消息发送者的身份</li>
<li>不可否认：消息的发送者无法否认自己发送了信息</li>
</ul>
<p>显然，数字签名和消息认证码是不符合要求的，这里就需要数字证书来解决其弊端。</p>
<p>数字证书（digital certificate）又称公开密钥认证 PKC（英语：Public key certificate）。是在互联网通信中，方式数字签名的秘钥被篡改，是用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>数字证书认证机构 CA (Certificate Authority)：是负责发放和管理数字证书的权威机构。</p>
<h3 id="公钥证书的格式标准">公钥证书的格式标准</h3>
<p><code>X.509</code>是密码学中公钥明证PKC的格式标准，所有的证书都符合ITU-T X.509国际标准。X.509证书的结构是用<code>ASN1</code> (Abstract Syntax Notation One)进行描述数据结构，并使用<code>ASN.1</code>语法进行编码。</p>
<h3 id="证书规范">证书规范</h3>
<p>X.509指的是ITU和ISO联合制定的（RFC5280）里定义的的 <code>X.509 v3</code></p>
<p>前使用最广泛的标准为X.509的 v3版本规范 (RFC5280）, 一般遵从<code>X.509</code>格式规范的证书，会有以下的内容：</p>
<p>证书组成结构</p>
<table>
<thead>
<tr>
<th><strong>结构</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>版本  </strong></td>
<td>现行通用版本是 V3，</td>
</tr>
<tr>
<td><strong>序号</strong></td>
<td>用来识别每一张证书，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节；由CA来维护</td>
</tr>
<tr>
<td><strong>主体</strong></td>
<td>拥有此证书的法人或自然人身份或机器，包括：<br><strong>国家</strong>（C，Country） <br/><strong>州/省</strong>（S，State）** <br/><strong>地域/城市</strong>（L，Location） <br/><strong>组织/单位</strong>（O，Organization） <br/><strong>通用名称</strong>（CN，Common Name）：在TLS应用上，此字段一般是域名</td>
</tr>
<tr>
<td><strong>发行者</strong></td>
<td>以数字签名形式签署此证书的数字证书认证机构</td>
</tr>
<tr>
<td><strong>有效期(Validity) </strong></td>
<td>此证书的有效开始时间，在此前该证书并未生效；此证书的有效结束时间，在此后该证书作废。</td>
</tr>
<tr>
<td><strong>公开密钥用途</strong></td>
<td>指定证书上公钥的用途，例如数字签名、服务器验证、客户端验证等</td>
</tr>
<tr>
<td><strong>公开密钥</strong></td>
<td></td>
</tr>
<tr>
<td><strong>公开密钥指纹</strong></td>
<td></td>
</tr>
<tr>
<td><strong>数字签名</strong></td>
<td>使用信任的CA对内容进行</td>
</tr>
<tr>
<td>主体别名</td>
<td>例如一个网站可能会有多个域名（www.jd.com <a href="https://www.360buy.com">www.360buy.com</a>..）<br>一个组织可能会有多个网站（*.baidu.com tieba.baidu.com），<br/>不同的网域可以一并使用同一张证书，方便实现应用及管理。</td>
</tr>
</tbody>
</table>
<p>互联网上任意双方之间实现通信时，证书的目的有两种，</p>
<ul>
<li>主机证书，主要实现主机与主机之间进程间通信的。</li>
<li>个人证书，主要用作个人通信的，主要用作加密的数据的发送。</li>
</ul>
<p>主机类证书所拥有的标识主要为<code>主机名</code>，主机证书名称一定要与互联网之上访问名称一致，否则此证书为不可信证书。</p>
<h3 id="数字证书文件格式">数字证书文件格式</h3>
<p><code>X.509</code>一般推荐使用<code>PEM</code> (Privacy Enhanced Mail）格式来存储证书相关的文件。</p>
<p><code>.crt</code> &amp; <code>.cer</code>：证书文件后缀名
<code>.key</code>: 私钥后缀名
<code>.csr</code>：证书请求文件后缀名</p>
<h3 id="公钥基础设施pki">公钥基础设施（PKI）</h3>
<p>公钥基础设施 PKI（Public-Key infrastructure）是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
<h4 id="pki的组成要素">PKI的组成要素</h4>
<ul>
<li>用户：使用PKI的人
<ul>
<li>注册公钥用户。</li>
<li>使用已注册公钥用户。</li>
</ul>
</li>
<li>认证机构：
<ul>
<li>签证机构：CA Certificate Authority</li>
<li>注册机构：RA</li>
</ul>
</li>
<li>仓库
<ul>
<li>证书吊销列表：CRL；</li>
<li>证书存取库，从签发机构中获得其签发的证书，需要有存取库来提供这些证书。</li>
</ul>
</li>
</ul>
<h2 id="ssltls">SSL/TLS</h2>
<p>传输层安全协议，TLS，（Transport Layer Security），其前身为<strong>安全套接层</strong> SSL（Secure Sockets Layer）。SSL3.0为SSL最高版本，3.1 即TLS 1.0</p>
<p>SSL/TLS是世界上应用最广泛的密码通信方法。比如说，当在网上商城中输人信用卡号时，我们的Web浏览器就会使用SSL/TLS进行密码通信。使用SSL/TLS可以对通信对象进行认证，还可以确保通信内容的机密性。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>时间</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL 1.0</td>
<td>未公布</td>
<td>未公布</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995年</td>
<td>已于2011年弃用</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996年</td>
<td>已于2015年弃用</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018年</td>
<td></td>
</tr>
</tbody>
</table>
<p>http协议本身为文本格式，数据发送做文本编码；https协议实现的是二进制格式，数据发送做文本编码。由于ssl的存在，双方在实现通讯时，除了tcp协议三次 握手之外，双方还需做ssl握手会话的过程（认证密钥证书、数据交换等）。ssl会话的建立只能基于IP地址，无法基于主机名识别每一个通信方。一个IP地址在某个应用协议上只能建立一个ssl会话。</p>
<p>TLS采用了分层设计，虽然在TCP/IP协议栈上，SSL增加的半层，其内部实现为多层</p>
<ul>
<li>最底层，基础算法原语的实现，aes，rsa，md5</li>
<li>向上一层，选定参数后，符合密码学标准分类的算法的实现
<ul>
<li>aes-128-abc-pkcs7 abc内部块的串联方式 pkcs7 对称加密公钥格式。</li>
</ul>
</li>
<li>再向上一层：组合算法实现的半成品。</li>
<li>用各种组件拼装而成的种种成品密码学协议/软件  tls ssh。 openssh是利用openssl工具实现的软件程序。</li>
</ul>
<h2 id="openssl">OpenSSL</h2>
<p>OpenSSL是一个开放源代码的软件库，并实现了SSL与TLS协议。OpenSSL可以运行在，MS Windows、Linux、MacOS。OpenSSL已经成为linux基础公共组件，主要由三个开源组件组成：</p>
<ul>
<li><code>openssl</code>：多用途的命令行工具，能实现对称加密、非对称加密、单项加密等。各功能分别使用单独子命令来实现。</li>
<li><code>libcrypto</code>：公共加密库，实现了多种加密算法。</li>
<li><code>libssl</code>：实现了SSL及TLS的功能库</li>
</ul>
<h3 id="openssl命令">OpenSSL命令</h3>
<p>OpenSSL命令分为 标准命令<code>Standard commands</code>、消息摘要命令<code>Message Digest commands</code>、密码命令<code>Cipher commands</code>三部分组成。</p>
<blockquote>
<ul>
<li>标准命令。完成某些功能时使用的，如生成随机数、扮演CA签发证书。
<ul>
<li>enc 对称加密</li>
<li>crl 证书吊销列表</li>
<li>ca 证书签发机构</li>
<li>dgst 消息摘要算法（单项散列函数）</li>
<li>dh 密钥交换算法</li>
<li>req 请求证书生成器</li>
</ul>
</li>
<li>消息摘要命令算法，常用散列函数。</li>
<li>加密命令，所支持的加密算法。</li>
</ul>
</blockquote>
<h3 id="openssl-命令使用">OpenSSL 命令使用</h3>
<h4 id="对称加密">对称加密</h4>
<p>加密</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl enc -e -des3 -a -salt -in /etc/passwd -out ./passwd
</span></span></code></pre></td></tr></table>
</div>
</div><p>解密</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl enc -d -des3 -a -salt -in passwd
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>-d</code> 解密</li>
<li><code>-e</code> 加密</li>
<li><code>-a</code> base64编码处理数据</li>
</ul>
<h4 id="单项加密">单项加密</h4>
<p>openssl中，单项加密即数字签名计算message的摘要信息，为 <code>openssl dgst...</code></p>
<p>单项散列函数通常应用于数字签名于消息认证码（MAC： Message Authentication Code 消息认证码，单项加密的一种延申应用，用于实现再网络通信中保证所传输的数据的完整性。）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl dgst -md5 /var/log/messages
</span></span><span class="line"><span class="cl">MD5(/var/log/messages)= 4515fae68552c00646ee7e07aac25d1d
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以简写为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl md5 /var/log/messages
</span></span><span class="line"><span class="cl">MD5(/var/log/messages)= 24483320e6af7ed2cee401aa00c260e6
</span></span></code></pre></td></tr></table>
</div>
</div><p>openssl也可以生成用户密码 sslpasswd</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">$ openssl passwd -1 -salt 123456
</span></span><span class="line"><span class="cl">Password: 
</span></span><span class="line"><span class="cl">$1$123456$wWKtx7yY/RnLiPN.KaX.z.
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>$1$123456$wWKtx7yY/RnLiPN.KaX.z.</code>  这是扩展Unix风格的<code>crypt(3)</code> 密码哈希语法。格式为 <code>$id$salt$encrypted</code> 前<code>$id$</code>符表示加密算法 1标识md5 6标识<code>SHA-512</code>，123456是指定的salt,salt为id后的最多16位的对密码加盐。</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://man7.org/linux/man-pages/man3/crypt.3.html">crypt</a>
<a href="https://unix.stackexchange.com/questions/510990/why-is-the-output-of-openssl-passwd-different-each-time">unix style encrypted</a></p>
</blockquote>
<h4 id="使用openssl生成随机数">使用openssl生成随机数</h4>
<p>hex基于16进制编码格式  每个字节4位，4指的是4个字节，一个字节是8位二进制数。4位二进制可以用一个16进制字节标识（一个十六进制对应四个二进制 $4<em>4=16$） 出现字符 num</em>2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ openssl rand -hex <span class="m">16</span>
</span></span><span class="line"><span class="cl">8cd7c7a85e22b4548f6942468028fde4
</span></span><span class="line"><span class="cl">$ openssl rand -base64 <span class="m">6</span>
</span></span><span class="line"><span class="cl">c0jDwKIG
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="使用openssl生成自签数字证书">使用OpenSSL生成自签数字证书</h4>
<p>获取证书两种方法：</p>
<ul>
<li>使用证书授权机构
<ul>
<li>生成签名请求（csr）</li>
<li>将csr发送给CA</li>
<li>从CA处接收签名</li>
</ul>
</li>
<li>自签名的证书：自已签发自己的公钥</li>
</ul>
<h5 id="1-建立rootca"><strong>1. 建立RootCA</strong></h5>
<p><strong>生成私钥</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-new</td>
<td style="text-align:left">表示生成一个新证书签署请求</td>
</tr>
<tr>
<td style="text-align:center">-x509</td>
<td style="text-align:left">专用于CA生成自签证书，如果不是自签证书则不需要此项</td>
</tr>
<tr>
<td style="text-align:center">-key</td>
<td style="text-align:left">生成请求时用到的私钥文件</td>
</tr>
<tr>
<td style="text-align:center">-out</td>
<td style="text-align:left">证书的保存路径</td>
</tr>
<tr>
<td style="text-align:center">-days</td>
<td style="text-align:left">证书的有效期限，单位是day（天），默认是365天</td>
</tr>
</tbody>
</table>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> /etc/pki/tls/
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">openssl genrsa -out private/cakey.pem <span class="m">2048</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 路径和名称必须为openssl配置文件中路径的名称</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="2-自签名证书">2 自签名证书</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">openssl req -new <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-x509 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-key private/cakey.pem <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-out cacert.pem <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-days <span class="m">3650</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-subj <span class="s2">&#34;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=CHINA MOBILE&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>自签名证书是base64编码的，查看证书内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">openssl x509 -in cacert.pem -noout -text
</span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>x509</td>
<td>格式</td>
</tr>
<tr>
<td>-noout</td>
<td>输出时不生成新文件，只显示内容</td>
</tr>
<tr>
<td>-text</td>
<td>以文本格式输出</td>
</tr>
</tbody>
</table>
<p><strong>数字证书中主题(Subject)中字段的含义</strong></p>
<ul>
<li>一般的数字证书产品的主题通常含有如下字段：</li>
</ul>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公用名称 <font color="#f8070d" size=3>CN</font> (Common Name)</td>
<td>对于 SSL 证书，<font color="#f8070d" size=2>一般为网站域名</font>；而对于代码签名证书则为申请单位名称；而对于客户端证书则为证书申请者的姓名；</td>
</tr>
<tr>
<td>单位名称 <font color="#f8070d" size=3>O</font>  (Organization Name)</td>
<td>对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端单位证书则为证书申请者所在单位名称；</td>
</tr>
<tr>
<td>OU</td>
<td>可以理解为公司部门名称</td>
</tr>
<tr>
<td>所在城市 <font color="#f8070d" size=3>L</font> (Locality)</td>
<td></td>
</tr>
<tr>
<td>所在省份 <font color="#f8070d" size=3>ST</font>(State/Provice)</td>
<td></td>
</tr>
<tr>
<td>所在国家 <font color="#f8070d" size=3>C</font> (Country）</td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看到生成了一个Chinamobile的自签的RootCA</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105220215285-526813628.png" alt=""  /></p>
<h5 id="用户或组织向ca申请公钥证书">用户或组织向CA申请公钥（证书）</h5>
<ol>
<li>生成私钥</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> mkdir child
</span></span><span class="line"><span class="cl"> openssl genrsa -out child/child.pem <span class="m">2048</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>生成证书申请文件 <code>child.csr</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">openssl req -new <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>-key child/child.pem <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>-out child/child.csr <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>-subj <span class="s2">&#34;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=*.10086.com&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>将证书申请文件发送给CA</li>
</ol>
<p>可以通过任意方式发送申请文件给CA</p>
<h5 id="ca颁发证书">CA颁发证书</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">touch /etc/pki/CA/index.txt
</span></span><span class="line"><span class="cl">touch /etc/pki/CA/serial # 下一个要颁发的编号 16进制
</span></span><span class="line"><span class="cl">touch /etc/pki/CA/crlnumber
</span></span><span class="line"><span class="cl">echo 01 &gt; /etc/pki/CA/serial
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl ca -in child/child.csr \ # 签发请求
</span></span><span class="line"><span class="cl">	-cert cacert.pem \ # CA证书
</span></span><span class="line"><span class="cl">	-keyfile private/cakey.pem \  # CA私钥
</span></span><span class="line"><span class="cl">	-out child/a.crt -days 30
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="证书发送给客户端">证书发送给客户端</h5>
<p>在应用软件中使用证书</p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105221806859-170479134.png" alt=""  /></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105221815048-923869731.png" alt=""  /></p>
<h4 id="openssl配置文件注释">OpenSSL配置文件注释</h4>
<p><code>/etc/pki/tls/openssl.cnf </code> 定义了管理CA的相关信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 语法
</span></span><span class="line"><span class="cl"># 变量 = 值
</span></span><span class="line"><span class="cl"># 1. 字符串值最好使用双引号界定，并且其中可以使用&#34;\n&#34;,&#34;\r&#34;,&#34;\t&#34;,&#34;\\&#34;这些转义序列。
</span></span><span class="line"><span class="cl"># 2. 可以使用 ${变量名} 的形式引用同一字段中的变量，使用 ${字段名::变量名} 的形式引用其它字段中的变量。
</span></span><span class="line"><span class="cl"># 3. 可以使用 ${ENV::环境变量} 的形式引用操作系统中定义的环境变量，若变量不存在则会导致错误。
</span></span><span class="line"><span class="cl"># 4. 可以在默认字段定义与操作系统环境变量同名的变量作为默认值来避免环境变量不存在导致的错误。
</span></span><span class="line"><span class="cl"># 5. 如果在同一字段内有多个相同名称的变量，那么后面的值将覆盖前面的值。
</span></span><span class="line"><span class="cl"># 6. 可以通过 &#34;.include = 绝对路径&#34; 语法或 OPENSSL_CONF_INCLUDE 环境变量引入其他配置文件(*.cnf)。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 定义 HOME 的默认值，防止操作系统中不存在 HOME 环境变量。
</span></span><span class="line"><span class="cl">HOME			= .
</span></span><span class="line"><span class="cl"># 默认的随机数种子文件，对应 -rand 命令行选项。
</span></span><span class="line"><span class="cl">RANDFILE		= $ENV::HOME/.rnd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 扩展对象定义
</span></span><span class="line"><span class="cl"># 如果没有在 OpenSSL 命令行中定义X.509证书的扩展项，那么就会从下面对扩展对象的定义中获取。
</span></span><span class="line"><span class="cl"># 定义方法有两种，第一种(反对使用)是存储在外部文件中，也就是这里&#34;oid_file&#34;变量定义的文件。
</span></span><span class="line"><span class="cl">#oid_file		= $ENV::HOME/.oid
</span></span><span class="line"><span class="cl"># 第二种是存储在配置文件的一个字段中，也就是这里&#34;oid_section&#34;变量值所指定的字段。
</span></span><span class="line"><span class="cl">oid_section		= new_oids
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 要将此配置文件用于 &#34;openssl x509&#34; 命令的 &#34;-extfile&#34; 选项，
</span></span><span class="line"><span class="cl"># 请在此指定包含 X.509v3 扩展的小节名称
</span></span><span class="line"><span class="cl">#extensions =
</span></span><span class="line"><span class="cl"># 或者使用一个默认字段中仅包含 X.509v3 扩展的配置文件
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ new_oids ]
</span></span><span class="line"><span class="cl"># 添加可以被 &#39;ca&#39;, &#39;req&#39;, &#39;ts&#39; 命令使用的扩展对象。格式如下：
</span></span><span class="line"><span class="cl"># 对象简称 = 对象数字ID
</span></span><span class="line"><span class="cl"># 下面是一些增强型密钥用法(extendedKeyUsage)的例子
</span></span><span class="line"><span class="cl"># We can add new OIDs in here for use by &#39;ca&#39;, &#39;req&#39; and &#39;ts&#39;.
</span></span><span class="line"><span class="cl"># Add a simple OID like this:
</span></span><span class="line"><span class="cl"># testoid1=1.2.3.4
</span></span><span class="line"><span class="cl"># Or use config file substitution like this:
</span></span><span class="line"><span class="cl"># testoid2=${testoid1}.5.6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Policies used by the TSA examples.
</span></span><span class="line"><span class="cl">tsa_policy1 = 1.2.3.4.1
</span></span><span class="line"><span class="cl">tsa_policy2 = 1.2.3.4.5.6
</span></span><span class="line"><span class="cl">tsa_policy3 = 1.2.3.4.5.7
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">###################################  证书签发配置  ######################################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># openssl 的 ca 命令实现了证书签发的功能，其相关选项的默认值就来自于这里的设置。
</span></span><span class="line"><span class="cl"># 这个字段只是通过唯一的 default_ca 变量来指定默认CA主配置字段的入口(-name 命令行选项的默认值)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">######################## 默认CA主配置字段，(★)标记表示必需项 #############################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">[ ca ]  #
</span></span><span class="line"><span class="cl">default_ca	= CA_default		# The default ca section # 默认CA
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">######################### 默认CA主配置字段，(★)标记表示必需项 ############################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">[ CA_default ] 
</span></span><span class="line"><span class="cl"># 保存所有信息的文件夹，这个变量只是为了给后面的变量使用
</span></span><span class="line"><span class="cl">dir			= /etc/pki/CA
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># (★)存放新签发证书的默认目录，证书名就是该证书的系列号，后缀是.pem 。对应 -outdir 命令行选项。
</span></span><span class="line"><span class="cl">certs		= $dir/certs
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 存放证书吊销列表的
</span></span><span class="line"><span class="cl">crl_dir		= $dir/crl
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 数据库，颁发了那些证书，以及证书状态、编号。 数据索引。默认不存在的
</span></span><span class="line"><span class="cl">database	= $dir/index.txt
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#unique_subject	= no
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#(★)存放新签发证书的默认目录，证书名就是该证书的系列号，后缀是.pem 。对应 -outdir 命令行选项。
</span></span><span class="line"><span class="cl">new_certs_dir	= $dir/newcerts		# default place for new certs. # 新证书目录
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#(★)存放CA自身证书的文件名。对应 -cert 命令行选项。
</span></span><span class="line"><span class="cl">certificate	= $dir/cacert.pem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#(★)签发证书时使用的序列号文本文件，里面必须包含下一个可用的16进制数字。。需手工创建 
</span></span><span class="line"><span class="cl">serial		= $dir/serial
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 存放当前(下一个吊销证书编号)CRL编号的文件，需手工创建
</span></span><span class="line"><span class="cl">crlnumber	= $dir/crlnumber
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 证书吊销列表
</span></span><span class="line"><span class="cl">crl		= $dir/crl.pem 		
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#(★)存放CA自身私钥的文件名。对应 -keyfile 命令行选项。
</span></span><span class="line"><span class="cl">private_key	= $dir/private/cakey.pem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 私钥文件路径
</span></span><span class="line"><span class="cl">RANDFILE	= $dir/private/.rand
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 定义X.509证书扩展项的字段。对应 -extensions 命令行选项。
</span></span><span class="line"><span class="cl">x509_extensions	= usr_cert
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 当用户需要确认签发证书时可读证书DN域的显示格式。可用值与 x509 指令的 -nameopt 选项相同。
</span></span><span class="line"><span class="cl">name_opt 	= ca_default		# Subject Name options
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 可用值与 x509 指令的 -certopt 选项相同，不过 no_signame 和 no_sigdump 总被默认设置。
</span></span><span class="line"><span class="cl">cert_opt 	= ca_default		# Certificate field options
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 是否将证书请求中的扩展项信息加入到证书扩展项中去。取值范围以及解释：
</span></span><span class="line"><span class="cl">## none: 忽略所有证书请求中的扩展项
</span></span><span class="line"><span class="cl">## copy: 将证书扩展项中没有的项目复制到证书中
</span></span><span class="line"><span class="cl">## copyall: 将所有证书请求中的扩展项都复制过去，并且覆盖证书扩展项中原来已经存在的值。
</span></span><span class="line"><span class="cl">## 此选项的主要用途是允许证书请求提供例如 subjectAltName 之类扩展的值。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># copy_extensions = copy
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 定义生成CRL时需要加入的扩展项字段。对应 -crlexts 命令行选项。
</span></span><span class="line"><span class="cl"># crl_extensions	= crl_ext
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 新签发的证书默认有效期，以天为单位。依次对应 -days , -startdate , -enddate 命令行选项。
</span></span><span class="line"><span class="cl">default_days	= 365	# 颁发证书默认有效期
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># crl的有效期 30天
</span></span><span class="line"><span class="cl">default_crl_days= 30
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 默认hash算法
</span></span><span class="line"><span class="cl">default_md	= sha256
</span></span><span class="line"><span class="cl">preserve	= no	    # keep passed DN ordering
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#(★)定义用于证书请求DN域匹配策略的字段，用于决定CA要求和处理证书请求提供的DN域的各个参数值的规则。
</span></span><span class="line"><span class="cl"># 策略匹配 ，客户端与ca之间区申请证书信息是否必须匹配，对应 -policy 命令行选项。
</span></span><span class="line"><span class="cl">policy		= policy_match 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">################################ 为签发的证书设置扩展项 ##################################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 变量名称是DN域对象的名称，变量值可以是：
</span></span><span class="line"><span class="cl"># match: 该变量在证书请求中的值必须与CA证书相应的变量值完全相同，否则拒签。
</span></span><span class="line"><span class="cl"># supplied: 该变量在证书请求中必须提供(值可以不同)，否则拒签。
</span></span><span class="line"><span class="cl"># optional: 该变量在证书请求中可以存在也可以不存在(相当于没有要求)。
</span></span><span class="line"><span class="cl"># 除非preserve=yes或者在ca命令中使用了-preserveDN，否则在签发证书时将删除匹配策略中未提及的对象。
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ policy_match ]
</span></span><span class="line"><span class="cl">countryName		= match
</span></span><span class="line"><span class="cl">stateOrProvinceName	= match
</span></span><span class="line"><span class="cl">organizationName	= match
</span></span><span class="line"><span class="cl">organizationalUnitName	= optional
</span></span><span class="line"><span class="cl">commonName		= supplied
</span></span><span class="line"><span class="cl">emailAddress		= optional
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">############## &#34;特征名称&#34;字段包含了用户的标识信息，对应 -subj 命令行选项 ###################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ req_distinguished_name ]
</span></span><span class="line"><span class="cl">countryName = CN  # 必须是两字母国家代码
</span></span><span class="line"><span class="cl">stateOrProvinceName = # 省份或直辖市
</span></span><span class="line"><span class="cl">localityName = # 城市
</span></span><span class="line"><span class="cl">organizationName = # 组织名或公司名
</span></span><span class="line"><span class="cl">organizationalUnitName = # 部门名称
</span></span><span class="line"><span class="cl">commonName = # 全限定域名或个人姓名
</span></span><span class="line"><span class="cl">emailAddress = # Email地址
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">################################# 为签发的证书设置扩展项 #################################
</span></span><span class="line"><span class="cl">########################################################################################
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">[ extendtsion_name ]
</span></span><span class="line"><span class="cl"># 基本约束(该证书是否为CA证书)。&#34;CA:FALSE&#34;表示非CA证书(不能签发其他证书的&#34;叶子证书&#34;)。
</span></span><span class="line"><span class="cl">basicConstraints = CA:FALSE
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 颁发机构密钥标识符(&#34;always&#34;表示始终包含)
</span></span><span class="line"><span class="cl">authorityKeyIdentifier = keyid:always,issuer
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># PKIX工作组推荐将使用者与颁发机构的密钥标识符包含在证书中
</span></span><span class="line"><span class="cl">subjectKeyIdentifier=hash
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 证书用途，如省略，則可以用于签名外的任何。
</span></span><span class="line"><span class="cl"># server SSL服务器
</span></span><span class="line"><span class="cl"># objsign 签名证书
</span></span><span class="line"><span class="cl"># client 客户端
</span></span><span class="line"><span class="cl"># email 电子邮件
</span></span><span class="line"><span class="cl">nsCertType = client
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Netscape Comment（nsComment）是包含注释的字符串扩展名，当在某些浏览器中查看证书时，该注释将显示。
</span></span><span class="line"><span class="cl">nsComment = &#34;OpenSSL Generated Client Certificate&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 密钥用法：防否认(nonRepudiation)、数字签名(digitalSignature)、密钥加密(keyEncipherment)。
</span></span><span class="line"><span class="cl"># 密钥协商(keyAgreement)、数据加密(dataEncipherment)、仅加密(encipherOnly)、仅解密(decipherOnly)
</span></span><span class="line"><span class="cl">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 增强型密钥用法(参见&#34;new_oids&#34;字段)：服务器身份验证、客户端身份验证、时间戳。
</span></span><span class="line"><span class="cl">extendedKeyUsage = critical,serverAuth, clientAuth, timeStamping
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 使用者备用名称(email, URI, DNS, RID, IP, dirName)
</span></span><span class="line"><span class="cl"># 例如，DNS常用于实现泛域名证书、IP常用于绑定特定的IP地址、&#34;copy&#34;表示直接复制
</span></span><span class="line"><span class="cl">subjectAltName = DNS:www.example.com, DNS:*.example.net, IP:192.168.7.1, IP:13::17
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="openssl扩展密钥用法生成多域名证书">OpenSSL扩展密钥用法：生成多域名证书</h3>
<p>SAN(Subject Alternative Name) 是 <code>SSL/TLS</code> 标准 <code>x.509</code> 中定义的一个扩展。使用了SAN字段的 SSL 证书，可以扩展此证书支持的域名，使一个证书可支持多个不同域名的解析。<a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">RFC 5280 4.2.1.6</a></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112203256164-952424212.png" alt=""  /></p>
<p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112203458757-2086651260.png" alt=""  /></p>
<p>可以看到面子书与京东的证书的 <code>Subject Alternative Name</code> 段中列了大量的域名，使用这种类型的证书能够极大的简化网站证书的管理</p>
<h4 id="使用openssl生成根ca">使用OpenSSL生成根CA</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> /etc/pki/tls/
</span></span><span class="line"><span class="cl">openssl genrsa -out private/cakey.pem <span class="m">2048</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">openssl req -new <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-x509 <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-key private/cakey.pem <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-out cacert.pem <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-days <span class="m">3650</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>	-subj <span class="s2">&#34;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=CHINA MOBILE&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="准备openssl配置文件">准备openssl配置文件</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[ v3_req ]
</span></span><span class="line"><span class="cl">basicConstraints = CA:FALSE
</span></span><span class="line"><span class="cl">keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</span></span><span class="line"><span class="cl">subjectKeyIdentifier=hash
</span></span><span class="line"><span class="cl">authorityKeyIdentifier = keyid:always,issuer
</span></span><span class="line"><span class="cl">nsComment = &#34;OpenSSL Generated Client Certificate&#34;
</span></span><span class="line"><span class="cl">subjectAltName = DNS:etcd, DNS:hk-etcd, IP:10.0.0.1
</span></span><span class="line"><span class="cl">nsCertType = client, server
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到此证书请求文件中会包含 <code>Subject Alternative Names</code> 字段，并包含之前在配置文件中填写的域名。</p>
<h4 id="使用-openssl-签署带有-san-扩展的证书请求csr">使用 openssl 签署带有 SAN 扩展的证书请求csr</h4>
<ol>
<li>生成私钥</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkdir child
</span></span><span class="line"><span class="cl">openssl genrsa -out child/child.pem 2048
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>生成证书申请文件 <code>child.csr</code></li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl req -new \
</span></span><span class="line"><span class="cl">	-key child/child.pem \
</span></span><span class="line"><span class="cl">	-out child/child.csr \
</span></span><span class="line"><span class="cl">	-subj &#34;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=hketcd&#34; \
</span></span><span class="line"><span class="cl">	-config ./openssl.cnf
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>单条命令实现方式</strong></p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl req -new \
</span></span><span class="line"><span class="cl">	-key child/child.pem \
</span></span><span class="line"><span class="cl">	-subj &#34;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=hketcd&#34; \
</span></span><span class="line"><span class="cl">	-reqexts req_v3 \
</span></span><span class="line"><span class="cl">	-config &lt;(cat /etc/pki/tls/openssl.cnf \
</span></span><span class="line"><span class="cl"> 			&lt;(printf &#34;[aa]\nsubjectAltName=DNS:etcd, DNS:hk-etcd, IP:10.0.0.1&#34;)) \
</span></span><span class="line"><span class="cl">	-out child/child.csr
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>CA颁发证书</li>
</ol>
<p>单条命令实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">openssl ca \
</span></span><span class="line"><span class="cl">	-in child/child.csr \
</span></span><span class="line"><span class="cl">	-cert cacert.pem \
</span></span><span class="line"><span class="cl">	-keyfile private/cakey.pem \
</span></span><span class="line"><span class="cl">	-out child/child.crt \
</span></span><span class="line"><span class="cl">	-days 30 \
</span></span><span class="line"><span class="cl">	-extensions aa \
</span></span><span class="line"><span class="cl">	-extfile &lt;(cat /etc/pki/tls/openssl.cnf \
</span></span><span class="line"><span class="cl">             &lt;(printf &#34;[aa]\nsubjectAltName=DNS:etcd, DNS:hk-etcd, IP:10.0.0.1&#34;))
</span></span></code></pre></td></tr></table>
</div>
</div><p>
  <img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112210753782-1479864379.png" alt="img"  /></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
