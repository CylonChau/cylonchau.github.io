<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>encryption on Cylon&#39;s Collection</title>
    <link>https://www.oomkill.com/categories/encryption/</link>
    <description>Recent content in encryption on Cylon&#39;s Collection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 23 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://www.oomkill.com/categories/encryption/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>openssl.cnf详解</title>
      <link>https://www.oomkill.com/2024/11/openssl-cnf/</link>
      <pubDate>Sat, 23 Nov 2024 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2024/11/openssl-cnf/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>下面是一个完整 openssl.cnf 配置文件</p>
<pre><code class="language-ini">BASE_DOMAIN=
CLUSTER_NAME=
CERT_DIR=
APISERVER_CLUSTER_IP=
MASTER_NAME=

[ ca ]
# man ca
default_ca = CA_default

[ CA_default ]
# Directory and file locations.
dir               = \${ENV::CERT_DIR}
certs             = \$dir
crl_dir           = \$dir/crl
new_certs_dir     = \$dir
database          = \$dir/index.txt
serial            = \$dir/serial
# certificate revocation lists.
crlnumber         = \$dir/crlnumber
crl               = \$dir/crl/intermediate-ca.crl
crl_extensions    = crl_ext
default_crl_days  = 30
default_md        = sha256

name_opt          = ca_default
cert_opt          = ca_default
default_days      = 375
preserve          = no
policy            = policy_loose

[ policy_loose ]
# Allow the CA to sign a range of certificates.
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional

[ req ]
# man req
default_bits        = 4096
distinguished_name  = req_distinguished_name
string_mask         = utf8only
default_md          = sha256

[ req_distinguished_name ]
countryName                    = Country Name (2 letter code)
stateOrProvinceName            = State or Province Name
localityName                   = Locality Name
0.organizationName             = Organization Name
organizationalUnitName         = Organizational Unit Name
commonName                     = Common Name

# Certificate extensions (man x509v3_config)

[ v3_ca ]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid:always,issuer
basicConstraints = critical, CA:true, pathlen:0
keyUsage = critical, digitalSignature, cRLSign, keyCertSign

[ client_cert ]
basicConstraints = CA:FALSE
nsCertType = client
nsComment = &quot;OpenSSL Generated Client Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth, serverAuth
subjectAltName = @etcd_client

[ server_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth

[ identity_server_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = DNS.1:tectonic-identity-api.tectonic-system.svc.cluster.local

[ etcd_server_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @etcd_server_and_peer_dns

[ etcd_peer_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @etcd_server_and_peer_dns

[ apiserver_cert ]
basicConstraints = CA:FALSE
nsCertType = server
nsComment = &quot;OpenSSL Generated Server Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @apiserver_names

[ master_component_client_cert ]
basicConstraints = CA:FALSE
nsCertType = client
nsComment = &quot;OpenSSL Generated Client Certificate&quot;
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = clientAuth
subjectAltName = @master_component_names


[etcd_server_and_peer_dns]
DNS.1 = \${ENV::BASE_DOMAIN}
DNS.2 = localhost
IP.1 = 10.0.0.5
IP.2 = 127.0.0.1
IP.3 = 127.0.0.5

[apiserver_names]
DNS.1 = \${ENV::CLUSTER_NAME}-\${ENV::BASE_DOMAIN}
DNS.2 = \${ENV::BASE_DOMAIN}
DNS.3 = kubernetes
DNS.4 = kubernetes.default
DNS.5 = kubernetes.default.svc
DNS.6 = kubernetes.default.svc.cluster.local
IP.1 = \${ENV::APISERVER_CLUSTER_IP}
IP.2 = 10.0.0.5
IP.3 = 10.0.0.4


[ master_component_names ]
DNS.1 = \${ENV::MASTER_NAME}.\${ENV::BASE_DOMAIN}
DNS.2 = \${ENV::BASE_DOMAIN}
IP.1 = 10.0.0.5
IP.2 = 10.0.0.4

# used for etcd_client
[ etcd_client ]
DNS.1 = localhost
IP.1 = 10.0.0.5
IP.2 = 10.0.0.4
IP.3 = 10.0.0.6
IP.4 = 127.0.0.1
</code></pre>
<p>环境变量部分，用于定义配置文件内的配置会读取这个环境变量来替换</p>
<pre><code class="language-ini">BASE_DOMAIN=                  # 基础域名，通常用于 Kubernetes 集群或 API 服务器的域名配置
CLUSTER_NAME=                 # 集群名称，通常作为集群的标识符
CERT_DIR=                     # 证书文件存放的目录
APISERVER_CLUSTER_IP=         # API 服务器的集群内部 IP 地址
MASTER_NAME=                  # Kubernetes 主节点的名称
</code></pre>
<h4 id="ca-配置部分">CA 配置部分</h4>
<p>指定默认的 CA 配置部分，即下面的 [CA_default] 部分</p>
<pre><code class="language-conf">[ ca ]
default_ca = CA_default
</code></pre>
<h4 id="ca_default-部分">[CA_default] 部分</h4>
<p>该部分定义了 CA (证书颁发机构) 的各种配置参数。</p>
<pre><code class="language-ini"># Directory and file locations.
dir               = \${ENV::CERT_DIR}    # 证书存放的根目录
certs             = \$dir                 # 证书文件夹
crl_dir           = \$dir/crl             # CRL（证书吊销列表）文件夹
new_certs_dir     = \$dir                 # 新证书文件夹
database          = \$dir/index.txt       # 用于存储证书请求、签发等信息的数据库文件
serial            = \$dir/serial          # 用于跟踪签发证书的序列号文件
crlnumber         = \$dir/crlnumber       # CRL 证书吊销序列号
crl               = \$dir/crl/intermediate-ca.crl  # 吊销列表文件
crl_extensions    = crl_ext               # CRL 扩展配置
default_crl_days  = 30                    # 默认 CRL 有效期为 30 天
default_md        = sha256                # 默认使用 sha256 哈希算法
name_opt          = ca_default            # 证书的名称选项
cert_opt          = ca_default            # 证书的选项
default_days      = 375                   # 证书默认有效期为 375 天
preserve          = no                    # 是否保留 CA 对已签发证书的审计日志
policy            = policy_loose          # 使用 'policy_loose' 签发证书
</code></pre>
<h4 id="policy_loose-部分">[policy_loose] 部分</h4>
<p>该部分定义了证书签发策略，允许一些字段为 <code>optional</code>，即证书可以包含这些字段，但不要求必须存在。</p>
<pre><code class="language-ini">countryName             = optional       # 国家名称可选
stateOrProvinceName     = optional       # 省/州名称可选
localityName            = optional       # 地市名称可选
organizationName        = optional       # 组织名称可选
organizationalUnitName  = optional       # 组织单位名称可选
commonName              = supplied       # 公共名称是必须提供的（通常是域名或主机名）
emailAddress            = optional       # 邮件地址可选
</code></pre>
<h4 id="req-和-req_distinguished_name-部分">[req] 和 [req_distinguished_name] 部分</h4>
<p>distinguished执意为，显著的，杰出的。用于生成证书请求（CSR）。配置了默认的密钥长度、签名算法等信息。</p>
<pre><code class="language-ini">[ req ]
default_bits        = 4096           # 默认的密钥位数为 4096 位
distinguished_name  = req_distinguished_name  # 引用 'req_distinguished_name' 部分来定义 DN（区分名称）
string_mask         = utf8only       # 使用 UTF-8 字符编码
default_md          = sha256         # 默认使用 sha256 作为散列算法

[ req_distinguished_name ]
countryName                    = Country Name (2 letter code)  # 国家（2个字母的国家代码）
stateOrProvinceName            = State or Province Name      # 省/州名称
localityName                   = Locality Name               # 城市/地区名称
0.organizationName             = Organization Name           # 组织名称
organizationalUnitName         = Organizational Unit Name    # 组织单位名称
commonName                     = Common Name                 # 通用名称（通常是域名或主机名）
</code></pre>
<h3 id="证书扩展部分">证书扩展部分</h3>
<p>这些扩展是用于指定证书的用途和其它属性的配置，通常包括证书的使用场景（例如，客户端、服务器认证等）。</p>
<p>扩展部分的名字，例如<code>[v3_ca]</code> 并不是一个固定的格式，只是一个 OpenSSL 配置文件中的命名部分，通常用于定义颁发 CA（证书颁发机构）证书时所需要的扩展（extensions）。你可以根据需要自定义该部分的内容，但它通常包含一些通用的证书扩展，尤其是 <strong>基本约束</strong> (<code>basicConstraints</code>)、<strong>密钥用法</strong> (<code>keyUsage</code>) 和 <strong>证书签发权限</strong>。</p>
<h4 id="v3_ca-部分">[v3_ca] 部分</h4>
<p>该部分用于设置根证书（CA）的扩展，包括证书签发权限、密钥使用等。</p>
<pre><code class="language-bash">subjectKeyIdentifier = hash                     # 用于标识证书的主题密钥标识符
authorityKeyIdentifier = keyid:always,issuer    # 用于标识证书的颁发者密钥标识符
# 基本约束，标明该证书为 CA 证书，且路径长度为 0（不能作为其他证书的颁发机构）
# CA:true 表示这个为ca
basicConstraints = critical, CA:true, pathlen:0  
keyUsage = critical, digitalSignature, cRLSign, keyCertSign  # 证书使用场景：数字签名、证书吊销列表签名、证书签发
</code></pre>
<h4 id="客户端服务器证书扩展部分">客户端、服务器证书扩展部分</h4>
<p>这些部分定义了不同类型证书（如客户端证书、服务器证书）的扩展选项：</p>
<ul>
<li><strong>[client_cert]</strong> 和 <strong>[server_cert]</strong> 定义了客户端和服务器证书的基本约束和使用场景。</li>
<li><strong>[identity_server_cert]</strong> 和 <strong>[etcd_server_cert]</strong> 定义了特定的服务器证书，通常用于指定 API 服务、etcd 服务等。</li>
</ul>
<p>这些扩展中的 <code>subjectAltName</code> 字段用于指定证书的备用名称（例如，DNS 或 IP 地址），这是证书有效性的一个重要部分。</p>
<pre><code class="language-ini">[ client_cert ]
# 不允许作为 CA 证书使用
basicConstraints = CA:FALSE
# 客户端证书使用场景
keyUsage = critical, nonRepudiation, digitalSignature, keyEncipherment
# 扩展用途：客户端身份验证、服务器身份验证
extendedKeyUsage = clientAuth, serverAuth
# 使用 'etcd_client' 部分中定义内容用作的 SAN 配置
subjectAltName = @etcd_client


[ server_cert ]
# 不允许作为 CA 证书使用
basicConstraints = CA:FALSE
# 服务器证书使用场景
keyUsage = critical, digitalSignature, keyEncipherment
# 扩展用途：服务器身份验证、客户端身份验证
extendedKeyUsage = serverAuth, clientAuth
# 使用 'etcd_server_and_peer_dns' 配置
subjectAltName = @etcd_server_and_peer_dns
</code></pre>
<ul>
<li><strong>keyUsage</strong>：通常包括 <code>digitalSignature</code> 和 <code>keyEncipherment</code>，表明证书可以用于签名和加密。</li>
<li><strong>extendedKeyUsage</strong>：指定该证书可用于 <code>serverAuth</code>（服务器认证）和 <code>clientAuth</code>（客户端认证）。</li>
<li><strong>subjectAltName</strong>：通常会列出服务器的 DNS 名称或 IP 地址，用于验证服务器身份。</li>
</ul>
<p>当 <code>extendedKeyUsage = serverAuth, clientAuth</code> 同时设定时，表示该证书可以同时用于服务器身份验证和客户端身份验证。这意味着该证书可以被用于 <strong>服务器端</strong> 来验证客户端的请求，也可以被用作 <strong>客户端</strong> 来向服务器进行身份验证。例如 Mutual TLS，mTLS。</p>
<p>单独配置：<code>extendedKeyUsage = serverAuth</code> 或 <code>extendedKeyUsage = clientAuth</code> 时：</p>
<ul>
<li><strong><code>extendedKeyUsage = serverAuth</code></strong>：表示证书的用途是 <strong>服务器身份验证</strong>，即浏览器可以用它来验证服务器的真实性，确保用户正在访问的是正确的、合法的服务器。此配置通常用于大多数网站的 <strong>SSL/TLS 服务器证书</strong>。</li>
<li><strong><code>extendedKeyUsage = clientAuth</code></strong>：表示证书仅用于客户端身份验证，例如用于 SSL/TLS 客户端证书。</li>
</ul>
<h3 id="subject-alternative-name-san-部分">Subject Alternative Name (SAN) 部分</h3>
<p>SAN 是证书中的一个字段，允许将多个 DNS 名称、IP 地址或 URI 作为证书的有效域名或 IP 地址。它可以包含多个 DNS 名称和 IP 地址。</p>
<pre><code class="language-ini">[ etcd_server_and_peer_dns ]
DNS.1 = \${ENV::BASE_DOMAIN}             # 基础域名
DNS.2 = localhost                        # 本地主机名
IP.1 = 10.0.0.5                          # IP 地址
IP.2 = 127.0.0.1                         # 本地回环地址
IP.3 = 127.0.0.5                         # 另一个本地回环地址

[ apiserver_names ]
# 使用集群名称和基础域名组成的 DNS 名称
# 使用上面的变量
DNS.1 = \${ENV::CLUSTER_NAME}-\${ENV::BASE_DOMAIN}
# 基础域名
DNS.2 = \${ENV::BASE_DOMAIN}
# API 服务器的 IP 地址
IP.1 = \${ENV::APISERVER_CLUSTER_IP}
# 备用 IP 地址
IP.2 = 10.0.0.5
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之散列函数(hash function)</title>
      <link>https://www.oomkill.com/2020/11/hash-function/</link>
      <pubDate>Wed, 04 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/hash-function/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>散列函数（Hash function）又称散列算法、哈希函数，散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values）的指纹。这种转化是一种压缩映射，也就是散列值的空间通常远小于输入值的空间，不同的输入可能会散列成相同的输出，二不可能从散列值来唯一的确定输入值。<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要函数</strong>。</p>
<h2 id="散列函数性质">散列函数性质</h2>
<p>通过使用单向散列函数，即便是确认几百MB大小的文件的完整性，也只要对比很短的散列值就可以了。那么，单向散列函数必须具备怎样的性质呢？我们来整理一下。</p>
<ul>
<li>
<p><strong>根据任意长度的消息计算出固定长度的散列值</strong></p>
</li>
<li>
<p><strong>能够快速计算出散列值</strong></p>
</li>
</ul>
<p>计算散列值所花费的时间短。尽管消息越长，计算散列值的时间也会越长，但如果不能在现实的时间内完成计算就没有意义了。</p>
<ul>
<li>
<p><strong>消息不同散列值也不同</strong></p>
</li>
<li>
<p><strong>难以发现碰撞的性质称为抗碰撞性（collisionresistance）</strong>。密码技术中所使用的单向散列函数，都需要具备抗碰撞性。强抗碰撞性，是指要找到散列值相同的两条不同的消息是非常困难的这一性质。在这里，散列值可以是任意值。密码技术中的单向散列函数必须具备强抗碰撞性。</p>
</li>
<li>
<p><strong>具备单向性</strong></p>
</li>
</ul>
<p>单向散列函数必须具备单向性（one-way）。单向性指的是无法通过散列值反算出消息的性质。根据消息计算散列值可以很容易，但这条单行路是无法反过来走的。</p>
<h2 id="散列函数的应用">散列函数的应用</h2>
<p>散列函数应用具有多样性</p>
<blockquote>
<p>安全加密：</p>
</blockquote>
<ul>
<li>保护资料，散列值可用于唯一地识别机密信息。这需要散列函数是抗碰撞(collision-resistant)的，意味着很难找到产生相同散列值的资料。如数字签名、消息认证码。</li>
</ul>
<blockquote>
<p>数据校验：</p>
</blockquote>
<ul>
<li>确保传递真实的信息：消息或数据的接受者确认消息是否被篡改的性质叫数据的真实性，也称为完整性。</li>
<li>错误校正：使用一个散列函数可以很直观的检测出数据在传输时发生的错误。</li>
</ul>
<blockquote>
<p>负载均衡：</p>
</blockquote>
<ul>
<li>通过hash算法，对客户端IP进行计算hash值，将取到值与服务器数量进行取模运算。</li>
</ul>
<blockquote>
<p>分布式存储：如一致性hash。</p>
</blockquote>
<h2 id="常用单项散列函数">常用单项散列函数</h2>
<h3 id="md4-md5">MD4 MD5</h3>
<p>MD5在1996年后被证实存在弱点，可以被加以破解，对于需要高度安全性的资料，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞攻击，因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。</p>
<h3 id="sha-1-sha-2">SHA-1 SHA-2</h3>
<p>SHA-1：1995年发布，SHA-1在许多安全协议中广为使用，包括TLS、GnuPG、SSH、S/MIME和IPsec，是MD5的后继者。但SHA-1的安全性在2010年以后已经不被大多数的加密场景所接受。2017年荷兰密码学研究小组CWI和Google正式宣布攻破了SHA-1。</p>
<p>SHA-2：2001年发布，包括<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>、<code>SHA-512</code>、<code>SHA-512/224</code>、<code>SHA-512/256</code>。<strong>SHA-2目前没有出现明显的弱点</strong>。虽然至今尚未出现对SHA-2有效的攻击，但它的算法跟SHA-1基本上仍然相似。 比特币使用的sha-256进行的数字签名</p>
<table>
<thead>
<tr>
<th style="text-align:center">算法和变体</th>
<th style="text-align:center">输出散列值长度 （bits）</th>
<th style="text-align:center">中继散列值长度 （bits）</th>
<th style="text-align:center">资料区块长度 （bits）</th>
<th style="text-align:center">最大输入消息长度 （bits）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">MD5</td>
<td style="text-align:center">128</td>
<td style="text-align:center">128 (4 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">无限</td>
</tr>
<tr>
<td style="text-align:center">SHA-0</td>
<td style="text-align:center">160</td>
<td style="text-align:center">160 (5 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">264 − 1</td>
</tr>
<tr>
<td style="text-align:center">SHA-1</td>
<td style="text-align:center">160</td>
<td style="text-align:center">160 (5 × 32)</td>
<td style="text-align:center">512</td>
<td style="text-align:center">264 − 1</td>
</tr>
<tr>
<td style="text-align:center">SHA-2</td>
<td style="text-align:center"><em>SHA-224</em> <em>SHA-256</em></td>
<td style="text-align:center">224 256</td>
<td style="text-align:center">256 (8 × 32)</td>
<td style="text-align:center">512</td>
</tr>
<tr>
<td style="text-align:center"><em>SHA-384</em> <em>SHA-512</em> <em>SHA-512/224</em> <em>SHA-512/256</em></td>
<td style="text-align:center">384 512 224  256</td>
<td style="text-align:center">512 (8 × 64)</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">2128 − 1</td>
</tr>
</tbody>
</table>
<h2 id="go语言中使用散列函数">Go语言中使用散列函数</h2>
<h3 id="go语言使用md5">Go语言使用MD5</h3>
<p>方式一：</p>
<pre><code class="language-go">md5.Sum(&quot;123&quot;)
</code></pre>
<p>方式2:</p>
<pre><code class="language-go">func getMD5_2(str []byte) string {
	// 1. 创建一个使用MD5校验的Hash对象`
	myHash := md5.New()
	// 2. 通过io操作将数据写入hash对象中
	io.WriteString(myHash, &quot;hello&quot;)
	//io.WriteString(myHash, &quot;, world&quot;)
	myHash.Write([]byte(&quot;, world&quot;))
	// 3. 计算结果
	result := myHash.Sum(nil)
	fmt.Println(result)
	// 4. 将结果转换为16进制格式字符串
	res := fmt.Sprintf(&quot;%x&quot;, result)
	fmt.Println(res)
	// --- 这是另外一种格式化切片的方式
	res = hex.EncodeToString(result)
	fmt.Println(res)

	return res
}
</code></pre>
<h3 id="go语言sha-1sha-2的使用">Go语言SHA-1、SHA-2的使用</h3>
<p>方法一：</p>
<pre><code class="language-go">sha512.Sum512()
sha256.Sum256()
</code></pre>
<p>方法二与md5的使用类似</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之数字签名</title>
      <link>https://www.oomkill.com/2020/11/digital-signature/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/digital-signature/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>数字签名（Digital Signature），通俗来讲是基于非对称加密算法，用秘钥对内容进行散列值签名，在对内容与签名一起发送。</p>
<p><a href="http://www.youdzone.com/signature.html" target="_blank"
   rel="noopener nofollow noreferrer" >更详细的解说</a>
<a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank"
   rel="noopener nofollow noreferrer" >更详细的解说 - 中文</a></p>
<h2 id="数字签名的生成个验证">数字签名的生成个验证</h2>
<blockquote>
<p><strong>签名</strong></p>
<p>⑴ 对数据进行散列值运算。
⑵ 签名：使用签名者的私钥对数据的散列值进行加密。
⑶ 数字签名数据：签名与原始数据。</p>
</blockquote>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/how-do-digital-signatures-and-digital-certificates-work-together-in-ssl.png" alt="how do digital signatures and digital certificates work together in ssl" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<center class="podsc">图：数字签名</center>
<center><em>Source：</em>https://cheapsslsecurity.com/blog/digital-signature-vs-digital-certificate-the-difference-explained/</center>
<blockquote>
<p><strong>验证</strong>
⑴ 接收数据：原始数据&amp;数字签名。
⑵ 使用公钥进行解密得到散列值。
⑶ 将原始数据的散列值与解密后的散列值进行对比。</p>
</blockquote>
<h2 id="go语言中使用rsa进行数字签名">Go语言中使用RSA进行数字签名</h2>
<blockquote>
<p>⑴ pem解码：使用pem对私钥进行解码, 得到pem.Block结构体
⑵ 获得私钥：使用GO x509接口<code>pem.Block</code>据解析成私钥结构体
⑶ 计算hash值：对明文进行散列值计算
⑷ 使用秘钥对散列值签名</p>
</blockquote>
<pre><code class="language-go">package main

import (
	&quot;crypto&quot;
	&quot;crypto/rand&quot;
	&quot;crypto/rsa&quot;
	&quot;crypto/sha256&quot;
	&quot;crypto/x509&quot;
	&quot;encoding/pem&quot;
	&quot;fmt&quot;
)

var (
	private = `-----BEGIN 私钥-----
MIICXQIBAAKBgQDc73afIxqYOHg80puDIMYrqUAiTi8EiTVDEiO9YE3+VxRvN0sa
pe3zx1UdhgIn3iCPUzyI2vwNADId3LjuIjkdCcdB2fHrBTbcy6u0545HnY42F9aQ
7cAr168bHcqhQoKcna9i9nukO+w7So1J9C6Wr8J4e4923q7+T7z7bZeXywIDAQAB
AoGBAItX5KLdywoyo3MJCdgcNaCX8MEyOmlL+HHC4ROxx78gQN0cLJw0Bu33zHEA
ch+e8z4yKz3Nj6bLdtBqw6A9qXLBCfWfD/p9YKDZNFP/6+u9teUirOgiBSq7kXWy
mtBm0I3pz33EomCuSJzLj/Mj/fkKs+425jPFcZboJdZpCyBhAkEA8mtGUGYuAZwV
RKBDkf1bz5EyPBGV+9CyXa6pd6md61APY0j+qhb1w9ADfHKkAzfoilhpucznRhaz
kAheqMPAMwJBAOlQEx2Ytc8TxfFqhF8RPTODe2N0jBBvsvJ85k7vNiQ+hnmaAray
XS6pCbZdvmGHYKlz3MVGeis/UJKDdSzE0gkCQQCoZijkNPcEmz6S+5m00oFywXRa
EgVUdndRaMHEpIlVK7pkyBJQab60Fc42JxUUP0RExoI7VcHbCG4YQhgvuDvNAkBQ
CUolcwebe/sBcDrsqetGyqn/WjHaSZcnnDUdiu4VzOUwveaEafeRVCeiydHPfzNn
rflkK2MphtTLDhGaRAKRAkASKlhV8aTBzTty/V3XMQfFVIAdHCyEIGMdjDDSzPly
shZCn66IyIze8j5Q4ZLcRz6GPglHdrkBnyt4QFuGurpl
-----END 私钥-----`

	public = `-----BEGIN 公钥-----
MIGJAoGBANzvdp8jGpg4eDzSm4MgxiupQCJOLwSJNUMSI71gTf5XFG83Sxql7fPH
VR2GAifeII9TPIja/A0AMh3cuO4iOR0Jx0HZ8esFNtzLq7TnjkedjjYX1pDtwCvX
rxsdyqFCgpydr2L2e6Q77DtKjUn0Lpavwnh7j3berv5PvPttl5fLAgMBAAE=
-----END 公钥-----`
)

func digitalSign(privateKey, plainText string) (signText []byte, err error) {
	var (
		pemBlock, _   = pem.Decode([]byte(privateKey))
		privateStream *rsa.PrivateKey
		plainHash     = sha256.Sum256([]byte(plainText))
	)

	if privateStream, err = x509.ParsePKCS1PrivateKey(pemBlock.Bytes); err != nil {
		return
	}
	if signText, err = rsa.SignPKCS1v15(rand.Reader, privateStream, crypto.SHA256, plainHash[:]); err != nil {
		return
	}
	return
}

func digitalVerify(publicKeyByte, plainText string, signText []byte) (ok bool, err error) {
	var (
		pemBlock, _  = pem.Decode([]byte(publicKeyByte))
		publicStream *rsa.PublicKey
		plainHash    = sha256.Sum256([]byte(plainText))
	)

	if publicStream, err = x509.ParsePKCS1PublicKey(pemBlock.Bytes); err != nil {
		return
	}

	if err = rsa.VerifyPKCS1v15(publicStream, crypto.SHA256, plainHash[:], signText); err != nil {
		return
	}
	return true, nil
}

func main() {
	text, err := digitalSign(private, &quot;张三李四王五赵柳&quot;)
	ok, err := digitalVerify(public, &quot;张三李四王五赵柳&quot;, text)
	fmt.Println(ok)
	fmt.Println(err)
}
</code></pre>
<blockquote>
<p>总结
在Go语言API中公钥私钥的注释头尾也需要加上</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之非对称加密</title>
      <link>https://www.oomkill.com/2020/11/asymmetric/</link>
      <pubDate>Mon, 02 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/11/asymmetric/</guid>
      <description></description>
      <content:encoded><![CDATA[<p>公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种演算法。常用的非对称加密算法有 <code>RSA</code> <code>DSA</code> <code>ECC</code> 等。<a href="https://zh.wikipedia.org/zh-hans/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank"
   rel="noopener nofollow noreferrer" >公开密钥加密</a></p>
<p>非对称加密算法使用<strong>公钥</strong>、<strong>私钥</strong>来加解密。</p>
<ul>
<li>公钥与私钥是成对出现的。</li>
<li>多个用户（终端等）使用的密钥交公钥，只有一个用户（终端等）使用的秘钥叫私钥。</li>
<li>使用公钥加密的数据只有对应的私钥可以解密；使用私钥加密的数据只有对应的公钥可以解密。</li>
</ul>
<h2 id="非对称加密通信过程">非对称加密通信过程</h2>
<p>下面我们来看一看使用公钥密码的通信流程。假设Alice要给Bob发送一条消息，Alice是发送者，Bob是接收者，而这一次窃听者Eve依然能够窃所到他们之间的通信内容。 <a href="https://zh.wikipedia.org/zh-hans/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" target="_blank"
   rel="noopener nofollow noreferrer" >参考自维基百科</a></p>
<blockquote>
<p>⑴ Alice与bob事先互不认识，也没有可靠安全的沟通渠道，但Alice现在却要透过不安全的互联网向bob发送信息。
⑵ Alice撰写好原文，原文在未加密的状态下称之为明文 <code>plainText</code>。
⑶ bob使用密码学安全伪随机数生成器产生一对密钥，其中一个作为公钥 <code>publicKey</code>，另一个作为私钥 <code>privateKey</code>。
⑷ bob可以用任何方法传送公钥<code>publicKey</code> 给Alice，即使在中间被窃听到也没问题。
⑸ Alice用公钥<code>publicKey</code>把明文<code>plainText</code>进行加密，得到密文 <code>cipherText</code>
⑹ Alice可以用任何方法传输密文给bob，即使中间被窃听到密文也没问题。
⑺ bob收到密文，用私钥对密文进行解密，得到明文 <code>plainText</code>。
由于其他人没有私钥，所以无法得知明文；如果Alice，在没有得到bob私钥的情况下，她将重新得到原文。</p>
</blockquote>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102205804406-1240772965.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" />
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102204939055-1888285763.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h2 id="rsa">RSA</h2>
<p>RSA是一种非对称加密算法，是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出，并以三人姓氏开头字母拼在一起组成的。</p>
<blockquote>
<p>RSA公钥和密钥的获取：随机选择两个大的素数，<code>p</code> <code>q</code>  $N = p*q$
RSA加密过程：$cipherText = plainText ^ E  mod  N$，$(N,e)$为公钥，$(N,d)$为私钥。
RSA解密过程：$plainText = cipherText^ D  mod     N$</p>
</blockquote>
<h2 id="go语言中rsa的应用">Go语言中RSA的应用</h2>
<h3 id="在go语言中生成公钥与私钥">在Go语言中生成公钥与私钥</h3>
<h4 id="生成秘钥流程">生成秘钥流程</h4>
<blockquote>
<p>⑴ 使用<code>crypto/rsa</code>中的<code>GenerateKey(random io.Reader, bits int)</code>方法生成私钥（结构体）
⑵ 因为X509证书采用了<a href="https://wuziqingwzq.github.io/ca/2017/12/26/x509-knowledge-asn1.html" target="_blank"
   rel="noopener nofollow noreferrer" >ASN1</a>描述结构，需要通过Go语言API将的到的私钥（结构体），转换为<code>BER</code>编码规则的字符串。
⑶ 需要将ASN1 BER 规则转回为PEM数据编码。<code>pem.Encode(out io.Writer, b *Block)</code>
⑷ 将返回的数据保存</p>
</blockquote>
<h4 id="生成私钥">生成私钥</h4>
<pre><code class="language-go">func GeneratePrivateKey(keySize int) (privateKey bytes.Buffer, err error) {
	// 生成私钥
	var (
		privateKeyStruct *rsa.PrivateKey
		privateStream    []byte
	)
	privateKeyStruct, err = rsa.GenerateKey(rand.Reader, keySize)

	if err != nil {
		return
	}

	privateStream = x509.MarshalPKCS1PrivateKey(privateKeyStruct)

	privateBlock := pem.Block{Type: &quot;私钥&quot;, Bytes: privateStream}

	if err = pem.Encode(&amp;privateKey, &amp;privateBlock); err != nil {
		return
	}
	return
}
</code></pre>
<h4 id="通过私钥获取公钥">通过私钥获取公钥</h4>
<p>通过私钥获取公钥需要将私钥生成的步骤翻转</p>
<blockquote>
<p>⑴ 私钥[]byte解码为一个pemBlock <code>pem.Decode()</code>
⑵ pemBlock.Bytes是<code>BER</code>编码规则的字符串。将其转换为结构体 <code>x509.ParsePKCS1PrivateKey()</code>
⑶ 转换为的结构体的属性<code>PublicKey</code>为公钥结构体，需将其转换为<code>BER</code>编码规则的字符串。<code>x509.MarshalPKCS1PublicKey(&amp;PublicKey)</code>
⑷ 拼接公钥pemBlock，并需要将ASN1 BER规则字符串转回为PEM数据编码。<code>pem.Encode(out io.Writer, b *Block)</code></p>
</blockquote>
<pre><code class="language-go">func GetPublicKey(privateKey []byte) (publicKey bytes.Buffer, err error) {
	pemBlock, _ := pem.Decode(privateKey)

	privateStream, err := x509.ParsePKCS1PrivateKey(pemBlock.Bytes)
	if err != nil {
		return
	}
	publicStream := x509.MarshalPKCS1PublicKey(&amp;privateStream.PublicKey)
	privateBlock := pem.Block{Type: &quot;公钥&quot;, Bytes: publicStream}

	if err = pem.Encode(&amp;publicKey, &amp;privateBlock); err != nil {
		return
	}
	return
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102235640888-2142103656.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="使用rsa密钥进行加解密">使用RSA密钥进行加解密</h3>
<p>RSA加/解密步骤</p>
<blockquote>
<p>⑴ 因为在生成公钥与私钥时，进行了pem编码，需要先对其（一般情况下加密都使用公钥）进行解码为pemBlock。<code>pem.Decode()</code>
⑵ pemBlock.Bytes是<code>BER</code>编码规则的字符串。将其转换为结构体 <code>x509.ParsePKCS1PublicKey(pemBlock.Bytes)</code>
⑶ 使用 <code>rsa.DecryptPKCS1v15</code> 或 <code>rsa.EncryptPKCS1v15</code> 进行加解密，如：<code>rsa.DecryptPKCS1v15(rand.Reader, public|private stream, []byte plain|cipher)</code>，返回值即为加/解密好的数据。</p>
</blockquote>
<pre><code class="language-go">func RSAEncrypt(publicKey []byte, plainText string) (cipherText []byte, err error) {
	pemBlock, _ := pem.Decode(publicKey)
	publicStream, err := x509.ParsePKCS1PublicKey(pemBlock.Bytes)
	if err != nil {
		return
	}

	if cipherText, err = rsa.EncryptPKCS1v15(rand.Reader, publicStream, []byte(plainText)); err != nil {
		return
	}
	return
}

func RSADecrypt(privateKey, cipherText []byte) (plainText []byte, err error) {
	pemBlock, _ := pem.Decode(privateKey)
	privateStream, err := x509.ParsePKCS1PrivateKey(pemBlock.Bytes)
	if err != nil {
		return
	}

	if plainText, err = rsa.DecryptPKCS1v15(rand.Reader, privateStream, []byte(cipherText)); err != nil {
		return
	}
	return
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201103160438176-867986897.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>总结</p>
<ul>
<li>Go语言接口中，明文内容的长度不能大于秘钥本身。</li>
<li>RSA算法加解密速度慢，不推荐对较大数据加密。</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法学习总结之对称加密</title>
      <link>https://www.oomkill.com/2020/10/symmetric/</link>
      <pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/10/symmetric/</guid>
      <description></description>
      <content:encoded><![CDATA[<p><strong>对称加密</strong>，又称为 <strong>共享密钥加密算法</strong>，是指加密和解密方使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031172028652-1698637107.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="des">DES</h3>
<p>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS）</p>
<h4 id="des的加密和解密">DES的加密和解密</h4>
<p>DES是一种将64bit（8Byte）的明文加密成64bit的密文的对称密码算法，==它的密钥长度是56比特==。<font color="red">从规格上来说，DES的密钥长度是64bit，但由于每隔7bit会设置一个用于==错误检查==的比特，因此实质上其密钥长度是56bit</font>。</p>
<p><font color="red">DES是以64bit的明文（比特序列）为一个单位来进行加密的</font>，<strong>这个64bit的单位称为分组</strong>。一般来说，以分组为单位进行处理的密码算法称为<strong>分组密码（blockcipher）</strong>，DES就是分组密码的一种。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031173939221-127508220.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>DES每次只能加密64比特的数据，如果要加密的明文比较长，就需要对DES加密进行迭代（反复），而迭代的具体方式就称为模式（mode）。</p>
<h3 id="3des">3DES</h3>
<p>3DES（Triple DES）：是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p>3DES是基于计算机的运算能力的增强，基于DES算法，增强秘钥进行多绪加密，而不是一种块密码算法。</p>
<h3 id="aes">AES</h3>
<p>AES（Advanced Encryption Standard）：高级加密标准，是美国联邦政府采用的一种区块加密标准。</p>
<h3 id="分组密码模式">分组密码模式</h3>
<p>**分组密码（<code>blockcipher</code>）**是每次只能处理特定长度的一块数据的一类密码算法，这里的一块&quot;就称为分组（block）。此外，一个分组的比特数就称为分组长度（<code>blocklength</code>）。</p>
<p>例如，<strong>DES和3DES的分组长度都是64比特</strong>。这些密码算法一次只能加密64比特的明文．并生成64比特的密文。</p>
<p><strong>AES的分组长度可以从128比特、192比特和256比特中进行选择。当选择128比特的分组长度时，AES一次可加密128比特的明文，并生成128比特的密文。</strong></p>
<p><strong>分组密码算法只能加密固定长度的分组，但是我们需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式（mode）</strong>。</p>
<p>分组密码的模式有很多种类，分组密码的主要模式有以下5种：</p>
<h4 id="明文与密文分组">明文与密文分组</h4>
<ul>
<li>**明文分组: **是指分组密码算法中作为加密对象的明文。明文分组的长度与分组密码算法的分组长度是相等的。</li>
<li>**密文分组: **是指使用分组密码算法将明文分组加密之后所生成的密文。</li>
</ul>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180750458-1657314183.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="ecb模式electronic-code-book-mode电子密码本模式">ECB模式：Electronic Code Book mode（电子密码本模式）</h4>
<p>ECB是最简单的加密模式，<font color="red">明文消息被分成固定大小的块（分组），并且每个块被单独加密。</font>  每个块的加密和解密都是独立的，且使用相同的方法进行加密，所以可以进行并行计算，但是这种方法一旦有一个块被破解，使用相同的方法可以解密所有的明文数据，<font color="red">安全性比较差。  适用于数据较少的情形，加密前需要把明文数据填充到块大小的整倍数。</font></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180917418-1828892139.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" />
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031180907816-1922224853.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>使用ECB模式加密时，相同的明文分组会被转换为相同的密文分组，因此ECB模式也称为电子密码本模式<strong>当最后一个明文分组的内容小于分组长度时（如一个分组8bit），需要用一特定的数据进行填充（padding），让值一个分组长度等于分组长度</strong>。</p>
</blockquote>
<blockquote>
<p>ECB模式是所有模式中最简单的一种。ECB模式中，明文分组与密文分组是一一对应的关系，因此，如果明文中存在多个相同的明文分组，则这些明文分组最终都将被转换为相同的密文分组。这样一来，只要观察一下密文，就可以知道明文中存在怎样的重复组合，并可以以此为线索来破译密码，因此ECB模式是存在一定风险的。</p>
</blockquote>
<h4 id="cbc模式cipher-block-chaining-mode密码分组链接密码块-模式">CBC模式：Cipher Block Chaining mode（密码分组链接/密码块 模式）</h4>
<p>1976年，IBM发明了密码分组链接CBC。CBC<font color="red">模式中每一个分组要先和前一个分组加密后的数据进行XOR异或操作，然后再进行加密</font>。 这样每个密文块依赖该块之前的所有明文块，为了保持每条消息都具有唯一性，<font color="red">在<strong>第一个块</strong>进行加密之前需要用初始化向量 <code>IV</code> 进行异或操作</font>。  <font color="blue">CBC模式是一种最常用的加密模式，它主要缺点是加密是连续的，不能并行处理，并且与ECB一样消息块必须填充到块大小的整倍数。</font></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031194830815-323142789.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031194838945-4927688.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>**当加密第一个明文分组时，由于不存在 “前一个密文分组&quot;，因此<font color="red">需要事先准备一个长度为一个分组的比特序列来代替“前一个密文分组</font>&quot;，这个比特序列称为初始化向量（initialization vector）**通常缩写为 <code>IV</code>。一般来说，每次加密时都会随机产生一个不同的比特序列来作为初始化向量。</p>
<h4 id="cfb模式cipher-feedback-mode密文反馈模式">CFB模式：Cipher FeedBack mode（密文反馈模式）</h4>
<p>密文反馈模式 CFB；在CFB模式中，<font color="red">前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文</font>。所谓反馈，这里指的就是返回输入端的意思，即前一个密文分组会被送回到密码算法的输入端。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031200320644-9430185.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" />
<img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031200333802-435217010.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>在ECB和CBC中，明文分组都是通过密码算法进行加密的，然而，在CFB模式中，明文分组和密文分组之间并没有经过&quot;加密&quot;这一步骤，明文分和密文分组之间只有一个XOR。</p>
<h4 id="ofb模式output-feedback-mode输出反馈模式">OFB模式：Output FeedBack mode（输出反馈模式）</h4>
<p>输出反馈模式, OFB。在OFB模式中，上一个分组密码算法的输出是当前分组密码算法的输入（下图）</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031201815366-1110323402.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031201835300-606590872.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="ctr模式counter-mode计数器模式"><strong>CTR模式</strong>：CounTeR mode（计数器模式）</h4>
<p><font color="red">CTR是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码</font>；即每个分组对应一个逐次累加的计数器，并通过对计数器进行加密来生成密钥流。也就是说，最终的密文分组是通过将计数器加密得到的比特序列，与明文分组进行XOR而得到的。</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202045165-1475648471.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202056336-731754020.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><strong>CTR模式的特点</strong></p>
<blockquote>
<p>CTR模式的加密和解密使用了完全相同的结构，因此在程序实现上比较容易。这一特点和同为流密码的OFB模式是一样的。
CTR模式中可以以任意顺序对分组进行加密和解密，因此在加密和解密时需要用到的“计数器&quot;的值可以由nonce和分组序号直接计算出来。这一性质是OFB模式所不具备的。
CTR模式能够以任意顺序处理分组，就意味着能够实现并行计算。在支持并行计算的系统中，CTR模式的速度是非常快的。</p>
</blockquote>
<p>总结</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201031202458031-1831855010.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>初始化向量 - IV</p>
<ul>
<li>ecb, ctr模式不需要初始化向量</li>
<li>cbc, ofc, cfb需要初始化向量</li>
</ul>
</blockquote>
<blockquote>
<p>最后一个明文分组的填充</p>
<ul>
<li>使用cbc, ecb需要填充
<ul>
<li>明文分组中进行了填充, 然后加密</li>
<li>解密密文得到明文, 需要把填充的字节删除</li>
</ul>
</li>
<li>使用 ofb, cfb, ctr不需要填充</li>
</ul>
</blockquote>
<h2 id="对称加密在go语言中的实现方式">对称加密在Go语言中的实现方式</h2>
<h3 id="cbc分组模式">CBC分组模式</h3>
<pre><code class="language-go">/*
 *  @brief DES加密函数，
 *  @param1 加密的明文
 *  @param2 秘钥
 *  @return，得到的密文
 */

func DesEncrypt(plainText, key string) ([]byte, error) {

	var (
		// 创建一个des加密的接口
		block, err = des.NewCipher([]byte(key))
		// 分组加密 需要对最后进行填充
		padText    = LastPadding([]byte(plainText), block.BlockSize())
		cipherText = make([]byte, len(padText))
	)

	if err != nil {
		return nil, err
	}
	// 创建使用cbc分组模式加密接口
	mode := cipher.NewCBCEncrypter(block, []byte(&quot;12345678&quot;))
	// 加密
	mode.CryptBlocks(cipherText, padText)
	return cipherText, nil
}

/*
 *  @brief DES解密函数，
 *  @param1 加密的明文
 *  @param2 秘钥
 *  @return，得到的密文
 */

func DesDecrypt(cipherText, key string) ([]byte, error) {

	var (
		// 创建一个des加密的接口
		block, err = des.NewCipher([]byte(key))
		// 创建使用cbc分组模式解密接口
		mode           = cipher.NewCBCDecrypter(block, []byte(&quot;12345678&quot;))
		byteCipherText = []byte(cipherText)
		// 明文存储变量
		plainText = make([]byte, len(byteCipherText))
	)

	if err != nil {
		return nil, err
	}
	// 解密，无返回值
	mode.CryptBlocks(plainText, byteCipherText)
	// 将填充的内容删除
	return LastUnPadding(plainText, des.BlockSize), nil
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201101190422825-4035893.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p>总结</p>
<ul>
<li>DES使用64bit钥对数据块进行加密</li>
<li>在Go语言中<code>iv</code>的长须需要与密钥对长度一致。</li>
<li>CBC使用的流密码算法</li>
<li>CBC需要对最后明文分组填充</li>
</ul>
</blockquote>
<h3 id="ofb分组模式">OFB分组模式</h3>
<pre><code class="language-go">func OFBEncrypt(plainText, key string) ([]byte, error) {
	var (
		// 创建一个des加密的接口

		block, err = des.NewCipher([]byte(key))
		// 分组加密 需要对最后进行填充

		cipherText = make([]byte, len(plainText))
	)

	if err != nil {
		return nil, err
	}
	// 创建使用cbc分组模式加密接口
	mode := cipher.NewOFB(block, []byte(&quot;12345678&quot;))
	//mode := cipher.NewCBCEncrypter(block, []byte(&quot;12345678&quot;))
	// 加密
	mode.XORKeyStream(cipherText, []byte(plainText))
	return cipherText, nil
}

func OFBDecrypt(cipherText, key string) ([]byte, error) {

	var (
		// 创建一个des加密的接口
		block, err = des.NewCipher([]byte(key))
		// 创建使用cbc分组模式解密接口
		mode           = cipher.NewOFB(block, []byte(&quot;12345678&quot;))
		byteCipherText = []byte(cipherText)
		// 明文存储变量
		plainText = make([]byte, len(byteCipherText))
	)

	if err != nil {
		return nil, err
	}
	// 解密，无返回值
	mode.XORKeyStream(plainText, byteCipherText)
	// 将填充的内容删除
	return LastUnPadding(plainText, des.BlockSize), nil
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201101214408337-854797848.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h3 id="填充方式">填充方式</h3>
<pre><code class="language-go">/*
 *  填充函数，如果最后一个分组字节数不够则填充，填充的字节数为缺少的字节数
 *  如果最后一个字节数正好的话，则新建一个分组
 */
func LastPadding(plainText []byte, blockSize int) []byte {

	var (
		// 获得明文的长度，以判断时候需要补充
		paddingLength = blockSize - len(plainText)%blockSize
		// 初始化填充的内容
		padText = bytes.Repeat([]byte{byte(paddingLength)}, paddingLength)
	)
	//将填充的内容追加到明文后
	return append(plainText, padText...)
}

/*
 *  删除填充函数，如果最后一个分组字节数不够则填充，填充的字节数为缺少的字节数
 *  如果最后一个字节数正好的话，则新建一个分组
 */
func LastUnPadding(plainText []byte, blockSize int) []byte {

	var (
		// 获得明文的长度，以判断时候需要补充
		paddingLength = len(plainText)
		// 获得尾部填充的字节数量
		lastChar = int(plainText[paddingLength-1])
	)
	return bytes.TrimFunc(plainText, func(r rune) bool {
		return r == rune(lastChar)
	})

}
</code></pre>
<blockquote>
<p>总结</p>
<ul>
<li>ofb不需要最后为明文分组填充</li>
<li>加密算法Go语言API已经提供，但算法的分组业务流程需要自己实现</li>
</ul>
</blockquote>
<h3 id="aes-1">AES</h3>
<pre><code class="language-go">func AESEncrypt(cipherText, key string) ([]byte, error) {

	var (
		// 创建一个AES加密的接口
		block, err     = aes.NewCipher([]byte(key))
		byteCipherText = []byte(cipherText)
		// 明文存储变量
		plainText = make([]byte, len(byteCipherText))
	)

	if err != nil {
		return nil, err
	}

	// 创建使用cbc分组模式解密接口
	mode := cipher.NewOFB(block, []byte(&quot;1234567812345678&quot;))

	// 解密，无返回值
	mode.XORKeyStream(plainText, byteCipherText)
	// 将填充的内容删除
	return LastUnPadding(plainText, aes.BlockSize), nil
}
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201102002205863-975724083.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<blockquote>
<p><strong>总结</strong></p>
<ul>
<li>AES秘钥为 16,24,32 Byte 即 128,196,256 bit</li>
<li>在无需明文填充的分组模式下，<code>ofb</code> <code>cfb</code>  <code>ctr</code>，加密解密的业务逻辑处理是一样的。</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>常用加密算法之数字证书与TLS/SSL</title>
      <link>https://www.oomkill.com/2020/08/openssl-x509/</link>
      <pubDate>Sun, 02 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.oomkill.com/2020/08/openssl-x509/</guid>
      <description></description>
      <content:encoded><![CDATA[<h2 id="数字证书">数字证书</h2>
<p>互联网上任意双方之间实现通信时，证书的目的有两种，</p>
<ul>
<li>主机证书，主要实现主机与主机之间进程间通信的。</li>
<li>个人证书，主要用作个人通信的，主要用作加密的数据的发送。</li>
</ul>
<p>主机类证书所拥有的标识主要为<code>主机名</code>，主机证书名称一定要与互联网之上访问名称一致，否则此证书为不可信证书。</p>
<p>对于一个安全的通信，应该有以下特征：</p>
<ul>
<li>完整性：消息在传输过程中未被篡改</li>
<li>身份验证：确认消息发送者的身份</li>
<li>不可否认：消息的发送者无法否认自己发送了信息</li>
</ul>
<p>显然，数字签名和消息认证码是不符合要求的，这里就需要数字证书来解决其弊端。</p>
<p>数字证书（digital certificate）又称公开密钥认证 PKC（英语：Public key certificate）。是在互联网通信中，方式数字签名的秘钥被篡改，是用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。</p>
<p>数字证书认证机构 CA (Certificate Authority)：是负责发放和管理数字证书的权威机构。</p>
<h3 id="公钥证书的格式标准">公钥证书的格式标准</h3>
<p><code>X.509</code>是密码学中公钥明证PKC的格式标准，所有的证书都符合ITU-T X.509国际标准。X.509证书的结构是用<code>ASN1</code> (Abstract Syntax Notation One)进行描述数据结构，并使用<code>ASN.1</code>语法进行编码。</p>
<h3 id="证书规范">证书规范</h3>
<p>X.509指的是ITU和ISO联合制定的（RFC5280）里定义的的 <code>X.509 v3</code></p>
<p>前使用最广泛的标准为X.509的 v3版本规范 (RFC5280）, 一般遵从<code>X.509</code>格式规范的证书，会有以下的内容：</p>
<p>证书组成结构</p>
<table>
<thead>
<tr>
<th><strong>结构</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>版本  </strong></td>
<td>现行通用版本是 V3，</td>
</tr>
<tr>
<td><strong>序号</strong></td>
<td>用来识别每一张证书，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书，最大不能过20个字节；由CA来维护</td>
</tr>
<tr>
<td><strong>主体</strong></td>
<td>拥有此证书的法人或自然人身份或机器，包括：<br><strong>国家</strong>（C，Country） <br/><strong>州/省</strong>（S，State）** <br/><strong>地域/城市</strong>（L，Location） <br/><strong>组织/单位</strong>（O，Organization） <br/><strong>通用名称</strong>（CN，Common Name）：在TLS应用上，此字段一般是域名</td>
</tr>
<tr>
<td><strong>发行者</strong></td>
<td>以数字签名形式签署此证书的数字证书认证机构</td>
</tr>
<tr>
<td><strong>有效期(Validity) </strong></td>
<td>此证书的有效开始时间，在此前该证书并未生效；此证书的有效结束时间，在此后该证书作废。</td>
</tr>
<tr>
<td><strong>公开密钥用途</strong></td>
<td>指定证书上公钥的用途，例如数字签名、服务器验证、客户端验证等</td>
</tr>
<tr>
<td><strong>公开密钥</strong></td>
<td></td>
</tr>
<tr>
<td><strong>公开密钥指纹</strong></td>
<td></td>
</tr>
<tr>
<td><strong>数字签名</strong></td>
<td>使用信任的CA对内容进行</td>
</tr>
<tr>
<td>主体别名</td>
<td>例如一个网站可能会有多个域名（www.jd.com <a href="https://www.360buy.com" target="_blank"
   rel="noopener nofollow noreferrer" >www.360buy.com</a>..）<br>一个组织可能会有多个网站（*.baidu.com tieba.baidu.com），<br/>不同的网域可以一并使用同一张证书，方便实现应用及管理。</td>
</tr>
</tbody>
</table>
<p>互联网上任意双方之间实现通信时，证书的目的有两种，</p>
<ul>
<li>主机证书，主要实现主机与主机之间进程间通信的。</li>
<li>个人证书，主要用作个人通信的，主要用作加密的数据的发送。</li>
</ul>
<p>主机类证书所拥有的标识主要为<code>主机名</code>，主机证书名称一定要与互联网之上访问名称一致，否则此证书为不可信证书。</p>
<h3 id="数字证书文件格式">数字证书文件格式</h3>
<p><code>X.509</code>一般推荐使用<code>PEM</code> (Privacy Enhanced Mail）格式来存储证书相关的文件。</p>
<p><code>.crt</code> &amp; <code>.cer</code>：证书文件后缀名
<code>.key</code>: 私钥后缀名
<code>.csr</code>：证书请求文件后缀名</p>
<h3 id="公钥基础设施pki">公钥基础设施（PKI）</h3>
<p>公钥基础设施 PKI（Public-Key infrastructure）是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。</p>
<h4 id="pki的组成要素">PKI的组成要素</h4>
<ul>
<li>用户：使用PKI的人
<ul>
<li>注册公钥用户。</li>
<li>使用已注册公钥用户。</li>
</ul>
</li>
<li>认证机构：
<ul>
<li>签证机构：CA Certificate Authority</li>
<li>注册机构：RA</li>
</ul>
</li>
<li>仓库
<ul>
<li>证书吊销列表：CRL；</li>
<li>证书存取库，从签发机构中获得其签发的证书，需要有存取库来提供这些证书。</li>
</ul>
</li>
</ul>
<h2 id="ssltls">SSL/TLS</h2>
<p>传输层安全协议，TLS，（Transport Layer Security），其前身为<strong>安全套接层</strong> SSL（Secure Sockets Layer）。SSL3.0为SSL最高版本，3.1 即TLS 1.0</p>
<p>SSL/TLS是世界上应用最广泛的密码通信方法。比如说，当在网上商城中输人信用卡号时，我们的Web浏览器就会使用SSL/TLS进行密码通信。使用SSL/TLS可以对通信对象进行认证，还可以确保通信内容的机密性。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>时间</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL 1.0</td>
<td>未公布</td>
<td>未公布</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995年</td>
<td>已于2011年弃用</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996年</td>
<td>已于2015年弃用</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018年</td>
<td></td>
</tr>
</tbody>
</table>
<p>http协议本身为文本格式，数据发送做文本编码；https协议实现的是二进制格式，数据发送做文本编码。由于ssl的存在，双方在实现通讯时，除了tcp协议三次 握手之外，双方还需做ssl握手会话的过程（认证密钥证书、数据交换等）。ssl会话的建立只能基于IP地址，无法基于主机名识别每一个通信方。一个IP地址在某个应用协议上只能建立一个ssl会话。</p>
<p>TLS采用了分层设计，虽然在TCP/IP协议栈上，SSL增加的半层，其内部实现为多层</p>
<ul>
<li>最底层，基础算法原语的实现，aes，rsa，md5</li>
<li>向上一层，选定参数后，符合密码学标准分类的算法的实现
<ul>
<li>aes-128-abc-pkcs7 abc内部块的串联方式 pkcs7 对称加密公钥格式。</li>
</ul>
</li>
<li>再向上一层：组合算法实现的半成品。</li>
<li>用各种组件拼装而成的种种成品密码学协议/软件  tls ssh。 openssh是利用openssl工具实现的软件程序。</li>
</ul>
<h2 id="openssl">OpenSSL</h2>
<p>OpenSSL是一个开放源代码的软件库，并实现了SSL与TLS协议。OpenSSL可以运行在，MS Windows、Linux、MacOS。OpenSSL已经成为linux基础公共组件，主要由三个开源组件组成：</p>
<ul>
<li><code>openssl</code>：多用途的命令行工具，能实现对称加密、非对称加密、单项加密等。各功能分别使用单独子命令来实现。</li>
<li><code>libcrypto</code>：公共加密库，实现了多种加密算法。</li>
<li><code>libssl</code>：实现了SSL及TLS的功能库</li>
</ul>
<h3 id="openssl命令">OpenSSL命令</h3>
<p>OpenSSL命令分为 标准命令<code>Standard commands</code>、消息摘要命令<code>Message Digest commands</code>、密码命令<code>Cipher commands</code>三部分组成。</p>
<blockquote>
<ul>
<li>标准命令。完成某些功能时使用的，如生成随机数、扮演CA签发证书。
<ul>
<li>enc 对称加密</li>
<li>crl 证书吊销列表</li>
<li>ca 证书签发机构</li>
<li>dgst 消息摘要算法（单项散列函数）</li>
<li>dh 密钥交换算法</li>
<li>req 请求证书生成器</li>
</ul>
</li>
<li>消息摘要命令算法，常用散列函数。</li>
<li>加密命令，所支持的加密算法。</li>
</ul>
</blockquote>
<h3 id="openssl-命令使用">OpenSSL 命令使用</h3>
<h4 id="对称加密">对称加密</h4>
<p>加密</p>
<pre><code>openssl enc -e -des3 -a -salt -in /etc/passwd -out ./passwd
</code></pre>
<p>解密</p>
<pre><code>openssl enc -d -des3 -a -salt -in passwd
</code></pre>
<ul>
<li><code>-d</code> 解密</li>
<li><code>-e</code> 加密</li>
<li><code>-a</code> base64编码处理数据</li>
</ul>
<h4 id="单项加密">单项加密</h4>
<p>openssl中，单项加密即数字签名计算message的摘要信息，为 <code>openssl dgst...</code></p>
<p>单项散列函数通常应用于数字签名于消息认证码（MAC： Message Authentication Code 消息认证码，单项加密的一种延申应用，用于实现再网络通信中保证所传输的数据的完整性。）</p>
<pre><code>$ openssl dgst -md5 /var/log/messages
MD5(/var/log/messages)= 4515fae68552c00646ee7e07aac25d1d
</code></pre>
<p>也可以简写为</p>
<pre><code>$ openssl md5 /var/log/messages
MD5(/var/log/messages)= 24483320e6af7ed2cee401aa00c260e6
</code></pre>
<p>openssl也可以生成用户密码 sslpasswd</p>
<pre><code>$ openssl passwd -1 -salt 123456
Password: 
$1$123456$wWKtx7yY/RnLiPN.KaX.z.
</code></pre>
<p><code>$1$123456$wWKtx7yY/RnLiPN.KaX.z.</code>  这是扩展Unix风格的<code>crypt(3)</code> 密码哈希语法。格式为 <code>$id$salt$encrypted</code> 前<code>$id$</code>符表示加密算法 1标识md5 6标识<code>SHA-512</code>，123456是指定的salt,salt为id后的最多16位的对密码加盐。</p>
<h2 id="reference">Reference</h2>
<blockquote>
<p><a href="https://man7.org/linux/man-pages/man3/crypt.3.html" target="_blank"
   rel="noopener nofollow noreferrer" >crypt</a>
<a href="https://unix.stackexchange.com/questions/510990/why-is-the-output-of-openssl-passwd-different-each-time" target="_blank"
   rel="noopener nofollow noreferrer" >unix style encrypted</a></p>
</blockquote>
<h4 id="使用openssl生成随机数">使用openssl生成随机数</h4>
<p>hex基于16进制编码格式  每个字节4位，4指的是4个字节，一个字节是8位二进制数。4位二进制可以用一个16进制字节标识（一个十六进制对应四个二进制 $4<em>4=16$） 出现字符 num</em>2</p>
<pre><code class="language-bash">$ openssl rand -hex 16
8cd7c7a85e22b4548f6942468028fde4
$ openssl rand -base64 6
c0jDwKIG
</code></pre>
<h4 id="使用openssl生成自签数字证书">使用OpenSSL生成自签数字证书</h4>
<p>获取证书两种方法：</p>
<ul>
<li>使用证书授权机构
<ul>
<li>生成签名请求（csr）</li>
<li>将csr发送给CA</li>
<li>从CA处接收签名</li>
</ul>
</li>
<li>自签名的证书：自已签发自己的公钥</li>
</ul>
<h5 id="1-建立rootca"><strong>1. 建立RootCA</strong></h5>
<p><strong>生成私钥</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-new</td>
<td style="text-align:left">表示生成一个新证书签署请求</td>
</tr>
<tr>
<td style="text-align:center">-x509</td>
<td style="text-align:left">专用于CA生成自签证书，如果不是自签证书则不需要此项</td>
</tr>
<tr>
<td style="text-align:center">-key</td>
<td style="text-align:left">生成请求时用到的私钥文件</td>
</tr>
<tr>
<td style="text-align:center">-out</td>
<td style="text-align:left">证书的保存路径</td>
</tr>
<tr>
<td style="text-align:center">-days</td>
<td style="text-align:left">证书的有效期限，单位是day（天），默认是365天</td>
</tr>
</tbody>
</table>
<pre><code class="language-bash">cd /etc/pki/tls/
	
openssl genrsa -out private/cakey.pem 2048
# 路径和名称必须为openssl配置文件中路径的名称
</code></pre>
<h5 id="2-自签名证书">2 自签名证书</h5>
<pre><code class="language-bash">openssl req -new \
	-x509 \
	-key private/cakey.pem \
	-out cacert.pem \
	-days 3650 \
	-subj &quot;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=CHINA MOBILE&quot;
</code></pre>
<p>自签名证书是base64编码的，查看证书内容</p>
<pre><code class="language-bash">openssl x509 -in cacert.pem -noout -text
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>x509</td>
<td>格式</td>
</tr>
<tr>
<td>-noout</td>
<td>输出时不生成新文件，只显示内容</td>
</tr>
<tr>
<td>-text</td>
<td>以文本格式输出</td>
</tr>
</tbody>
</table>
<p><strong>数字证书中主题(Subject)中字段的含义</strong></p>
<ul>
<li>一般的数字证书产品的主题通常含有如下字段：</li>
</ul>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>公用名称 <font color="#f8070d" size=3>CN</font> (Common Name)</td>
<td>对于 SSL 证书，<font color="#f8070d" size=2>一般为网站域名</font>；而对于代码签名证书则为申请单位名称；而对于客户端证书则为证书申请者的姓名；</td>
</tr>
<tr>
<td>单位名称 <font color="#f8070d" size=3>O</font>  (Organization Name)</td>
<td>对于 SSL 证书，一般为网站域名；而对于代码签名证书则为申请单位名称；而对于客户端单位证书则为证书申请者所在单位名称；</td>
</tr>
<tr>
<td>OU</td>
<td>可以理解为公司部门名称</td>
</tr>
<tr>
<td>所在城市 <font color="#f8070d" size=3>L</font> (Locality)</td>
<td></td>
</tr>
<tr>
<td>所在省份 <font color="#f8070d" size=3>ST</font>(State/Provice)</td>
<td></td>
</tr>
<tr>
<td>所在国家 <font color="#f8070d" size=3>C</font> (Country）</td>
<td></td>
</tr>
</tbody>
</table>
<p>可以看到生成了一个Chinamobile的自签的RootCA</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105220215285-526813628.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h5 id="用户或组织向ca申请公钥证书">用户或组织向CA申请公钥（证书）</h5>
<ol>
<li>生成私钥</li>
</ol>
<pre><code class="language-bash"> mkdir child
 openssl genrsa -out child/child.pem 2048
</code></pre>
<ol start="2">
<li>生成证书申请文件 <code>child.csr</code></li>
</ol>
<pre><code class="language-bash">openssl req -new \
-key child/child.pem \
-out child/child.csr \
-subj &quot;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=*.10086.com&quot;
</code></pre>
<ol start="3">
<li>将证书申请文件发送给CA</li>
</ol>
<p>可以通过任意方式发送申请文件给CA</p>
<h5 id="ca颁发证书">CA颁发证书</h5>
<pre><code>touch /etc/pki/CA/index.txt
touch /etc/pki/CA/serial # 下一个要颁发的编号 16进制
touch /etc/pki/CA/crlnumber
echo 01 &gt; /etc/pki/CA/serial
</code></pre>
<pre><code>openssl ca -in child/child.csr \ # 签发请求
	-cert cacert.pem \ # CA证书
	-keyfile private/cakey.pem \  # CA私钥
	-out child/a.crt -days 30
</code></pre>
<h5 id="证书发送给客户端">证书发送给客户端</h5>
<p>在应用软件中使用证书</p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105221806859-170479134.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201105221815048-923869731.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<h4 id="openssl配置文件注释">OpenSSL配置文件注释</h4>
<p><code>/etc/pki/tls/openssl.cnf </code> 定义了管理CA的相关信息。</p>
<pre><code class="language-cnf"># 语法
# 变量 = 值
# 1. 字符串值最好使用双引号界定，并且其中可以使用&quot;\n&quot;,&quot;\r&quot;,&quot;\t&quot;,&quot;\\&quot;这些转义序列。
# 2. 可以使用 ${变量名} 的形式引用同一字段中的变量，使用 ${字段名::变量名} 的形式引用其它字段中的变量。
# 3. 可以使用 ${ENV::环境变量} 的形式引用操作系统中定义的环境变量，若变量不存在则会导致错误。
# 4. 可以在默认字段定义与操作系统环境变量同名的变量作为默认值来避免环境变量不存在导致的错误。
# 5. 如果在同一字段内有多个相同名称的变量，那么后面的值将覆盖前面的值。
# 6. 可以通过 &quot;.include = 绝对路径&quot; 语法或 OPENSSL_CONF_INCLUDE 环境变量引入其他配置文件(*.cnf)。


# 定义 HOME 的默认值，防止操作系统中不存在 HOME 环境变量。
HOME			= .
# 默认的随机数种子文件，对应 -rand 命令行选项。
RANDFILE		= $ENV::HOME/.rnd

# 扩展对象定义
# 如果没有在 OpenSSL 命令行中定义X.509证书的扩展项，那么就会从下面对扩展对象的定义中获取。
# 定义方法有两种，第一种(反对使用)是存储在外部文件中，也就是这里&quot;oid_file&quot;变量定义的文件。
#oid_file		= $ENV::HOME/.oid
# 第二种是存储在配置文件的一个字段中，也就是这里&quot;oid_section&quot;变量值所指定的字段。
oid_section		= new_oids

# 要将此配置文件用于 &quot;openssl x509&quot; 命令的 &quot;-extfile&quot; 选项，
# 请在此指定包含 X.509v3 扩展的小节名称
#extensions =
# 或者使用一个默认字段中仅包含 X.509v3 扩展的配置文件



[ new_oids ]
# 添加可以被 'ca', 'req', 'ts' 命令使用的扩展对象。格式如下：
# 对象简称 = 对象数字ID
# 下面是一些增强型密钥用法(extendedKeyUsage)的例子
# We can add new OIDs in here for use by 'ca', 'req' and 'ts'.
# Add a simple OID like this:
# testoid1=1.2.3.4
# Or use config file substitution like this:
# testoid2=${testoid1}.5.6

# Policies used by the TSA examples.
tsa_policy1 = 1.2.3.4.1
tsa_policy2 = 1.2.3.4.5.6
tsa_policy3 = 1.2.3.4.5.7

########################################################################################
###################################  证书签发配置  ######################################
########################################################################################

# openssl 的 ca 命令实现了证书签发的功能，其相关选项的默认值就来自于这里的设置。
# 这个字段只是通过唯一的 default_ca 变量来指定默认CA主配置字段的入口(-name 命令行选项的默认值)


########################################################################################
######################## 默认CA主配置字段，(★)标记表示必需项 #############################
########################################################################################
[ ca ]  #
default_ca	= CA_default		# The default ca section # 默认CA

########################################################################################
######################### 默认CA主配置字段，(★)标记表示必需项 ############################
########################################################################################
[ CA_default ] 
# 保存所有信息的文件夹，这个变量只是为了给后面的变量使用
dir			= /etc/pki/CA

# (★)存放新签发证书的默认目录，证书名就是该证书的系列号，后缀是.pem 。对应 -outdir 命令行选项。
certs		= $dir/certs

# 存放证书吊销列表的
crl_dir		= $dir/crl

# 数据库，颁发了那些证书，以及证书状态、编号。 数据索引。默认不存在的
database	= $dir/index.txt

#unique_subject	= no

#(★)存放新签发证书的默认目录，证书名就是该证书的系列号，后缀是.pem 。对应 -outdir 命令行选项。
new_certs_dir	= $dir/newcerts		# default place for new certs. # 新证书目录

#(★)存放CA自身证书的文件名。对应 -cert 命令行选项。
certificate	= $dir/cacert.pem

#(★)签发证书时使用的序列号文本文件，里面必须包含下一个可用的16进制数字。。需手工创建 
serial		= $dir/serial

# 存放当前(下一个吊销证书编号)CRL编号的文件，需手工创建
crlnumber	= $dir/crlnumber

# 证书吊销列表
crl		= $dir/crl.pem 		

#(★)存放CA自身私钥的文件名。对应 -keyfile 命令行选项。
private_key	= $dir/private/cakey.pem

# 私钥文件路径
RANDFILE	= $dir/private/.rand

# 定义X.509证书扩展项的字段。对应 -extensions 命令行选项。
x509_extensions	= usr_cert


# 当用户需要确认签发证书时可读证书DN域的显示格式。可用值与 x509 指令的 -nameopt 选项相同。
name_opt 	= ca_default		# Subject Name options

# 可用值与 x509 指令的 -certopt 选项相同，不过 no_signame 和 no_sigdump 总被默认设置。
cert_opt 	= ca_default		# Certificate field options

# 是否将证书请求中的扩展项信息加入到证书扩展项中去。取值范围以及解释：
## none: 忽略所有证书请求中的扩展项
## copy: 将证书扩展项中没有的项目复制到证书中
## copyall: 将所有证书请求中的扩展项都复制过去，并且覆盖证书扩展项中原来已经存在的值。
## 此选项的主要用途是允许证书请求提供例如 subjectAltName 之类扩展的值。

# copy_extensions = copy

# 定义生成CRL时需要加入的扩展项字段。对应 -crlexts 命令行选项。
# crl_extensions	= crl_ext

# 新签发的证书默认有效期，以天为单位。依次对应 -days , -startdate , -enddate 命令行选项。
default_days	= 365	# 颁发证书默认有效期

# crl的有效期 30天
default_crl_days= 30

# 默认hash算法
default_md	= sha256
preserve	= no	    # keep passed DN ordering


#(★)定义用于证书请求DN域匹配策略的字段，用于决定CA要求和处理证书请求提供的DN域的各个参数值的规则。
# 策略匹配 ，客户端与ca之间区申请证书信息是否必须匹配，对应 -policy 命令行选项。
policy		= policy_match 

########################################################################################
################################ 为签发的证书设置扩展项 ##################################
########################################################################################

# 变量名称是DN域对象的名称，变量值可以是：
# match: 该变量在证书请求中的值必须与CA证书相应的变量值完全相同，否则拒签。
# supplied: 该变量在证书请求中必须提供(值可以不同)，否则拒签。
# optional: 该变量在证书请求中可以存在也可以不存在(相当于没有要求)。
# 除非preserve=yes或者在ca命令中使用了-preserveDN，否则在签发证书时将删除匹配策略中未提及的对象。

[ policy_match ]
countryName		= match
stateOrProvinceName	= match
organizationName	= match
organizationalUnitName	= optional
commonName		= supplied
emailAddress		= optional

########################################################################################
############## &quot;特征名称&quot;字段包含了用户的标识信息，对应 -subj 命令行选项 ###################
########################################################################################

[ req_distinguished_name ]
countryName = CN  # 必须是两字母国家代码
stateOrProvinceName = # 省份或直辖市
localityName = # 城市
organizationName = # 组织名或公司名
organizationalUnitName = # 部门名称
commonName = # 全限定域名或个人姓名
emailAddress = # Email地址

########################################################################################
################################# 为签发的证书设置扩展项 #################################
########################################################################################

[ extendtsion_name ]
# 基本约束(该证书是否为CA证书)。&quot;CA:FALSE&quot;表示非CA证书(不能签发其他证书的&quot;叶子证书&quot;)。
basicConstraints = CA:FALSE

# 颁发机构密钥标识符(&quot;always&quot;表示始终包含)
authorityKeyIdentifier = keyid:always,issuer

# PKIX工作组推荐将使用者与颁发机构的密钥标识符包含在证书中
subjectKeyIdentifier=hash

# 证书用途，如省略，則可以用于签名外的任何。
# server SSL服务器
# objsign 签名证书
# client 客户端
# email 电子邮件
nsCertType = client

# Netscape Comment（nsComment）是包含注释的字符串扩展名，当在某些浏览器中查看证书时，该注释将显示。
nsComment = &quot;OpenSSL Generated Client Certificate&quot;

# 密钥用法：防否认(nonRepudiation)、数字签名(digitalSignature)、密钥加密(keyEncipherment)。
# 密钥协商(keyAgreement)、数据加密(dataEncipherment)、仅加密(encipherOnly)、仅解密(decipherOnly)
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

# 增强型密钥用法(参见&quot;new_oids&quot;字段)：服务器身份验证、客户端身份验证、时间戳。
extendedKeyUsage = critical,serverAuth, clientAuth, timeStamping

# 使用者备用名称(email, URI, DNS, RID, IP, dirName)
# 例如，DNS常用于实现泛域名证书、IP常用于绑定特定的IP地址、&quot;copy&quot;表示直接复制
subjectAltName = DNS:www.example.com, DNS:*.example.net, IP:192.168.7.1, IP:13::17
</code></pre>
<h3 id="openssl扩展密钥用法生成多域名证书">OpenSSL扩展密钥用法：生成多域名证书</h3>
<p>SAN(Subject Alternative Name) 是 <code>SSL/TLS</code> 标准 <code>x.509</code> 中定义的一个扩展。使用了SAN字段的 SSL 证书，可以扩展此证书支持的域名，使一个证书可支持多个不同域名的解析。<a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6" target="_blank"
   rel="noopener nofollow noreferrer" >RFC 5280 4.2.1.6</a></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112203256164-952424212.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112203458757-2086651260.png" alt="" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
<p>可以看到面子书与京东的证书的 <code>Subject Alternative Name</code> 段中列了大量的域名，使用这种类型的证书能够极大的简化网站证书的管理</p>
<h4 id="使用openssl生成根ca">使用OpenSSL生成根CA</h4>
<pre><code class="language-bash">cd /etc/pki/tls/
openssl genrsa -out private/cakey.pem 2048

openssl req -new \
	-x509 \
	-key private/cakey.pem \
	-out cacert.pem \
	-days 3650 \
	-subj &quot;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=CHINA MOBILE&quot;
</code></pre>
<h4 id="准备openssl配置文件">准备openssl配置文件</h4>
<pre><code class="language-conf">[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectKeyIdentifier=hash
authorityKeyIdentifier = keyid:always,issuer
nsComment = &quot;OpenSSL Generated Client Certificate&quot;
subjectAltName = DNS:etcd, DNS:hk-etcd, IP:10.0.0.1
nsCertType = client, server
</code></pre>
<p>可以看到此证书请求文件中会包含 <code>Subject Alternative Names</code> 字段，并包含之前在配置文件中填写的域名。</p>
<h4 id="使用-openssl-签署带有-san-扩展的证书请求csr">使用 openssl 签署带有 SAN 扩展的证书请求csr</h4>
<ol>
<li>生成私钥</li>
</ol>
<pre><code>mkdir child
openssl genrsa -out child/child.pem 2048
</code></pre>
<ol start="2">
<li>生成证书申请文件 <code>child.csr</code></li>
</ol>
<pre><code>openssl req -new \
	-key child/child.pem \
	-out child/child.csr \
	-subj &quot;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=hketcd&quot; \
	-config ./openssl.cnf
</code></pre>
<blockquote>
<p><strong>单条命令实现方式</strong></p>
</blockquote>
<pre><code>openssl req -new \
	-key child/child.pem \
	-subj &quot;/C=HK/ST=HK/L=HK/O=chinamobile/OU=SY/CN=hketcd&quot; \
	-reqexts req_v3 \
	-config &lt;(cat /etc/pki/tls/openssl.cnf \
 			&lt;(printf &quot;[aa]\nsubjectAltName=DNS:etcd, DNS:hk-etcd, IP:10.0.0.1&quot;)) \
	-out child/child.csr
</code></pre>
<ol start="3">
<li>CA颁发证书</li>
</ol>
<p>单条命令实现</p>
<pre><code>openssl ca \
	-in child/child.csr \
	-cert cacert.pem \
	-keyfile private/cakey.pem \
	-out child/child.crt \
	-days 30 \
	-extensions aa \
	-extfile &lt;(cat /etc/pki/tls/openssl.cnf \
             &lt;(printf &quot;[aa]\nsubjectAltName=DNS:etcd, DNS:hk-etcd, IP:10.0.0.1&quot;))
</code></pre>
<p><img loading="lazy" src="https://cdn.jsdelivr.net/gh/CylonChau/imgbed/img/1380340-20201112210753782-1479864379.png" alt="img" onerror="this.onerror=null;this.src='/placeholder.svg';this.className='pe-image-placeholder'" /></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
